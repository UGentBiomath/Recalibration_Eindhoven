# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl"
 















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\generic.msl" 1
 


















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\generic.base.msl" 1
 







 TYPE Generic "builtin: type variable";

 TYPE Integer "builtin: positive and negative Natural Numbers";

 TYPE Real "builtin: Real numbers";

 TYPE Char "builtin: ASCII character";

 TYPE String 
  "builtin: Char* (implemented as atomic type for efficiency reasons)";

 TYPE Bottom "builtin: bottom type" = ENUM {null};

 TYPE Boolean "builtin: Logic type" = ENUM {True, False};

 
 
 

 TYPE TypeDeclarationType
 "builtin: type of TYPE declaration statement";
 TYPE ClassDeclarationType
 "builtin: type of CLASS declaration statement";

 TYPE ObjectDeclarationType
 "builtin: type of OBJ declaration statement";

 TYPE DeclarationType
 "type of a declaration (TYPE, CLASS, or OBJ) statement"
 = UNION {TypeDeclarationType, ClassDeclarationType, ObjectDeclarationType};

 TYPE ExpressionType
 "builtin: type of expressions";

 TYPE EquationType
 "builtin: type of equations";

 TYPE GenericIntervalType
 "Generic Interval"
 
 
 
 = RECORD 
   {
    lowerBound: Generic;   
    upperBound: Generic;   
    lowerIncluded: Boolean;
    upperIncluded: Boolean;
   };

 TYPE RealIntervalType "Interval of real numbers"
 SUBSUMES GenericIntervalType =
 RECORD 
 {
  lowerBound: Real;  
  upperBound: Real;  
  lowerIncluded: Boolean;
  upperIncluded: Boolean;
 };

 
 
 

 TYPE UnitType 
 "The type of physical units. For the time being, a string"
 = String;

 TYPE QuantityType
 "The different physical quantities. For the time being, string"
 = String;

 TYPE CausalityType
 " Causality of entities"
 
 
 
 
 = ENUM {CIN, COUT, CINOUT};

 TYPE PhysicalNatureType
 "The nature of physical variables FIELD is used (in the physicalDAE context) to denote parameters and constants"
 = ENUM {ACROSS, THROUGH, FIELD};

 TYPE PhysicalQuantityType 
 "The type of any physical quantity" 
 =
 RECORD
 {
  quantity   : QuantityType;
  unit       : UnitType;
  interval   : RealIntervalType;
  value      : Real;
  causality  : CausalityType;
  nature     : PhysicalNatureType;
 };

  
  
  

 TYPE InterfaceDeclarationType
 "declarations within an interface" = DeclarationType;

 TYPE ParameterDeclarationType
 "declarations within parameter section" = DeclarationType;

 TYPE ModelDeclarationType
 "declarations within sub_models section" = DeclarationType;

 TYPE CouplingStatementType
 "parameter coupling and connect() statements" = EquationType;

 TYPE GenericModelType 
 "The signature of the generic part of any (whatever the formalism) model"
 = 
 RECORD
 { 
  comments   : String;
  interface  : SET_OF (InterfaceDeclarationType); 
    
  parameters : SET_OF (ParameterDeclarationType); 
    
 };

 TYPE DAEModelType 
 "The signature of a Differential Algebraic Equation (DAE) model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };
 
 TYPE PhysicalDAEModelType
 "The signature of a physicalDAEModelType model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };

 TYPE CoupledModelType "The signature of a coupled (network) model"
 EXTENDS GenericModelType WITH
 RECORD
 {
  sub_models : SET_OF (ModelDeclarationType);
  coupling   : SET_OF (CouplingStatementType);
 };
  

# 20 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\generic.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\generic.quantity.msl" 1
 















 




 

 
OBJ Comp_Index "Temporary iteration variable, index of the component" : Integer;
OBJ Reaction_Index "Temporary iteration variable, index of the reaction" : Integer;
OBJ Layer_Index "Temporary iteration variable, index of the layer" : Integer;

 


CLASS Fraction "Fraction"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "Fraction";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1:};
:};

CLASS CorrectionFactor "Correction factor"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};

CLASS Rate "A class for rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Rate";
  unit      <- "dUnit/dt";
:};

CLASS Ratio "A class for ratio"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Ratio";
  unit      <- "dUnit/dUnit";
 :};


 

CLASS Time "A class for time"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Time";
  unit      <- "d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS Length "A class for Length"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Length";
  unit      <- "m";
 interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
:};

CLASS Area "A class for Area"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Area";
  unit      <- "m2";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
:};

 CLASS Volume "Volume"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity  <- "Volume";
  unit      <- "m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};
   
 CLASS SpecificVolume "Specific volume ((density)^-1)"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity  <- "SpecificVolume";
  unit      <- "m3/g";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};

CLASS Density "A class for density"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Density";
  unit      <- "g/m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS SurfaceDensity "A class for areal density"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Areal Density";
  unit      <- "g/m2";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS Concentration "A class for concentration"
SPECIALISES PhysicalQuantityType :=
{:
  nature <- "ACROSS";
  quantity <- "Concentration";
  unit <- "g/m3";
  interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS AmountOfSubstance "A class for AmountOfSubstance"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "AmountOfSubstance";
  unit      <- "mol";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS MolConcentration "Concentration in Mol per m3"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "MolConcentration";
  unit      <- "mol.m-3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:}; 

CLASS MolFlowRate "Gas flow rate in Mol per day"
SPECIALISES PhysicalQuantityType :=
{: 
quantity  <- "MolFlowRate";
unit      <- "mol.d-1";
interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS Molality "Concentration in Mol per kg"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Molality";
  unit      <- "mol.kg-1";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:}; 

CLASS MolarMass "A class for Molar mass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "MolarMass";
  unit      <- "g/mol";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS FlowRate "Flow rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "FlowRate";
  unit     <- "m3/d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};
   
 CLASS Mass "A class for Mass"
 SPECIALISES PhysicalQuantityType := 
 {:
  quantity  <- "Mass";
  unit      <- "g";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};
   
CLASS CelsiusTemperature "A class for CelsiusTemperature"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "CelsiusTemperature";
  unit      <- "degC";
  interval  <- {: lowerBound <- -273.15; upperBound <- PLUS_INF; :};
:};

CLASS KelvinTemperature "A class for KelvinTemperature"
SPECIALISES PhysicalQuantityType :=
{:
  quantity    <- "KelvinTemperature";
  unit        <- "K";
  interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS Pressure "A class for Pressure"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "Pressure";
  unit      <- "Pa";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS pH "A class for pH"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "pH";
  interval  <- {: lowerBound <- 0; upperBound <- 14 :};
:};

CLASS Velocity "A class for velocity"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Velocity";
  unit      <- "m/d";
:};

CLASS Acceleration "A class for Acceleration"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Acceleration";
  unit      <- "m/d2";
:};

CLASS Frequency "The type of frequency"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Frequency";
  unit      <- "Hz";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS Diffusivity "A class for diffusivity"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Diffusivity";
  unit      <- "m2/d";
:};

CLASS DynamicViscosity "A class for dynamic viscosity"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "DynamicViscosity";
  unit      <- "Pa*d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS KinematicViscosity "A class for KinematicViscosity"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "KinematicViscosity";
  unit      <- "m2/d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS Power "A class for Power"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "Power";
  unit      <- "W";
:};

CLASS ElectricalEnergy "A class for electrical energy"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Electrical energy";
  unit      <- "kWh";
:};

CLASS EnergyForPumping "Energy per unit flow"
SPECIALISES PhysicalQuantityType:=
{:
  quantity <- "EnergyForPumping";
  unit     <- "kWh/m3";
  interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
:};

CLASS EnergyForMixing "Energy per volume tank"
SPECIALISES PhysicalQuantityType:=
{:
  quantity <- "EnergyForMixing";
  unit     <- "kWh/m3/d";
  interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
:};

CLASS EnergyIndex "Aeration and Pumping energy"
SPECIALISES PhysicalQuantityType:=
{:
  quantity <- "EnergyIndex";
  unit     <- "kWh/d";
  interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
:};

CLASS TransferRateEnergy "A class for transfer rate per unit of energy"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Transfer rate per energy";
  unit      <- "g/kWh";
:};
  
CLASS DensityOfHeatFlowRate "A class for DensityOfHeatFlowRate"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "DensityOfHeatFlowRate";
  unit      <- "W/m2";
:};

 

 CLASS MassFlux "Mass per time unit"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity  <- "MassFlux";
  unit      <- "g/d";
  interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF :};
  nature <- "THROUGH";
 :};

CLASS ArealFlux "Mass per unit of surface and per unit of time"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "ArealFlux";
  unit     <- "g/(m2*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS SpecificAreaVolume "Mass per time unit"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "specific area per volume";
  unit      <- "1/m";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS OxygenTransferCoefficient "Oxygen Transfer Coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Kla";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 5000 :};
 :};

CLASS SaturationCoefficient "Saturation coefficient"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "K";
  unit     <- "g/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 100:};
:};

CLASS AmmoniumUptakeRate "Ammonium Uptake Rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "AUR";
  unit     <- "g/(m3.d)";
:};
 
CLASS PhosphateUptakeRate "Phosphate Uptake Rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "PUR";
  unit     <- "g/(m3.d)";
:};  

CLASS DissolvedOxygen "A class for the ammount of dissolved oxygen"
SPECIALISES PhysicalQuantityType :=
{:
  quantity    <- "DO";
  unit        <- "gO2/m3";
  displayunit <- "gO2/m3";
  interval    <- {: lowerBound <- 0; upperBound <- 15 :};
:};

CLASS OxygenUptakeRate "Oxygen Uptake Rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "OUR";
  unit     <- "g/(m3.d)";
:};

CLASS NitrateUptakeRate "Nitrate Uptake Rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "NUR";
  unit     <- "g/(m3.d)";
:};

CLASS NitrateProductionRate "Nitrate Production Rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "NPR";
  unit     <- "g/(m3.d)";
:};

 
 
 

CLASS AmmonHalfSatCoeffForAutotr "Ammonium half saturation coeff for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_NH";
  unit      <- "gNH3-N/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};
:};

CLASS NitrateHalfSatCoeffForDenitrifHetero "Nitrate half-saturation coeff for denitrifying heterotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_NO";
  unit      <- "gNO3-N/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 2 :};
:};    

 
CLASS NitriteHalfSatCoeffForDenitrifHetero "Nitrite half-saturation coeff for denitrifying heterotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_NO";
  unit      <- "gNO2-N/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 2 :};
:};    

CLASS NitrogenHalfSatCoeff "Nitrogen half-saturation coeff"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_N";
  unit      <- "g N/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};  
:};

CLASS PhosphateHalfSatCoeff "Phosphate half saturation coeff"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_HPO4";
  unit      <- "gHPO4-P/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};
:};
 

CLASS HalfSatCoeffForHetero "Half-saturation coefficient for heterotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_S";
  unit      <- "gCOD/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 100 :};
:};    

CLASS OxygenHalfSatCoeffForHetero "Oxygen half-saturation coeff for heterotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_OH";
  unit      <- "gO2/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};
:};    

CLASS OxygenHalfSatCoeffForAutotr "Oxygen half-saturation coeff for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_OA";
  unit      <- "gO2/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};
:};    

CLASS HalfSatCoeffForHydrolysis "Half saturation constant for hydrolysis"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_X";
  unit      <- "gCOD/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- 100 :};
:};

CLASS YieldForAutotrophicBiomass "A class for YieldForAutotrophicBiomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Y_A";
  unit      <- "gCOD/gN";
  interval  <- {: lowerBound <- 0; upperBound <- 4.57 :};
:};

CLASS YieldForHeterotrophicBiomass "A class for YieldForHeterotrophicBiomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Y_H";
  unit      <- "gCOD/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};    

CLASS DecayCoeffHeterotr "Decay coefficient for heterotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "B_H";
  unit      <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 25 :};
:};    

CLASS DecayCoeffAutotr "Decay coefficient for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "B_A";
  unit      <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 25 :};
:};    

CLASS FractOfBiomassLeadingToPartProd "Fraction of biomass leading to particulate products"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "F_P";
  unit      <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};    

CLASS MassOfNitrogenPerMassOfCODInBiomass "Mass of N per mass of COD in biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "I_XB";
  unit      <- "gN/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
:};    

CLASS MassOfNitrogenPerMassOfCODInProdFromBiomass "Mass of N per mass of COD in products from biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "I_XP";
  unit      <- "gN/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
:};    

CLASS AmmonificationRate "Ammonification rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_a";
  unit      <- "m3/(gCOD*d)";
  interval  <- {: lowerBound <- 0; upperBound <- 0.25 :};
:};    

CLASS MaxSpecificHydrolysisRate "Maximum specific hydrolysis rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_h";
  unit      <- "gCOD/(gCOD*d)";
  interval  <- {: lowerBound <- 0; upperBound <- 25 :};
:};    

CLASS MaxSpecifGrowthRateHetero "Maximum specific growth rate for heterotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Mu_H";
  unit      <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20 :};
:};    

CLASS MaxSpecifGrowthRateAutotr "Maximum specific growth rate for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Mu_A";
  unit      <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 5 :};
:};    

CLASS MonodTerm "A class for Monod-like terms"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "S / ( K + S)";
  unit      <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1:};
:};

CLASS InhibitionTerm "A class for inhibtion terms of the ASM-models"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K / ( K + S)";
  unit      <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1:};
:};    

CLASS RateConstant "Rate constant"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Q_or_B_or_K";
  unit      <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20 :};
:};    

CLASS Yield "A class for Yield"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "Yield";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
:};

CLASS DecayCoefficient "Decay coefficient"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "B";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
:};

CLASS ConversionFactor "A class for typical conversion factors for continuity equations"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "I";
  unit      <- "g/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};

CLASS MaxGrowthRate "Maximum growth rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Mu";
  unit      <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 100 :};
:};    

CLASS ReductionFactor "Reduction factor"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};

CLASS HalfSatCoeff "Half-saturation coefficient"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_";
  unit      <- "gCOD/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 1000000 :};
:};    

CLASS GrowthRate "Growth rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "GrowthRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
:};

CLASS ProcessRate "GrowthRate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "ProcessRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
:}; 

CLASS PhosphorusConversionFactor "A class for typical conversion factors of Phosphorus for continuity equations"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "I";
  unit      <- "gP/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};
:};

CLASS MolecularDiffusivity "A class for Diffusivity"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Diffusivity";
  unit      <- "m2/s";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS HenryCoefficient "A class for the Henry coefficient in atm"
SPECIALISES PhysicalQuantityType :=
{:
  quantity    <- "HenryCoefficient";
  unit        <- "atm.m3.Mol-1";
  interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS FreeAmmoniaSatCoeffForAutotr "Free ammonium half saturation coeff for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_FA";
  unit      <- "gN/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};
:};

CLASS AmmonHalfSatCoeffForAutotrForMampaeyA "Ammonium half saturation coeff for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_NH";
  unit      <- "gNH3-N/m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS FreeNitrousAcidSatCoeffForAutotr "Free ammonium half saturation coeff for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_FNA";
  unit      <- "gN/m3";
  interval  <- {: lowerBound <- 0; upperBound <- 10 :};
:};

CLASS NSaturationCoefficientForMampaey "Saturation coefficient"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "K";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
:};

CLASS FreeAmmoniaInhibitionCoeff "Inhibition coefficient for free Ammonia"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_I_";
  unit      <- "gN/m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};   

CLASS FreeNitrousAcidInhibitionCoeff "Inhibition coefficient for free nitrous acid"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_I_";
  unit      <- "gN/m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};   

CLASS NitricOxideInhibitionCoeffForDenitrification "Inhibition coefficient for nitric oxide substances during denitrification"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_I_";
  unit      <- "gN/m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};   

CLASS OxygenHalfSatCoeffForAutotrForMampaeyA "Oxygen half-saturation coeff for autotrophic biomass"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_OA";
  unit      <- "gO2/m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};  

CLASS NHalfSatCoeffForDenitrification "Half saturation coefficient for N substances during denitrification"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "K_I_";
  unit      <- "gN/m3";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};   

CLASS PartialPressureInAir "A class for Partial Pressure in air"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Pressure";
  unit      <- "atm";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS bCoeffForRatkowsky "b coefficient of Ratkowsky temperature correction"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "eta";
  unit     <- "1/[(d^0.5)*(deg C)]";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};

CLASS cCoeffForRatkowsky "c coefficient of Ratkowsky temperature correction"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "eta";
  unit     <- "1/degC";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};

CLASS NitrogenConversionFactor "A class for typical conversion factors of Nitrogen for continuity equations"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "I";
  unit      <- "gN/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};

CLASS Euro "Euro"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "euro";
  unit      <- "E";
:};

CLASS CarbonContentPerUnitCOD "Carbon content per unit COD"
SPECIALISES PhysicalQuantityType :=
{:
  unit     <- "mol/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS NitrogenContentPerUnitCOD "Nitrogen content (mol N) per unit COD"
SPECIALISES PhysicalQuantityType :=
{:
  unit     <- "mol/gCOD";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS MaxUptakeRate "Maximum uptake rate for microorganisms"
SPECIALISES PhysicalQuantityType :=
{:
  unit     <- "1/d";
:};


CLASS FlowRateRate "Rate of change in flow rate"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "FlowRateRate";
  unit     <- "m3/d2";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};


CLASS Rainfall "A class for rainfall during Kosim simulations"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Rainfall depth";
  unit      <- "mm";
  interval  <- {: lowerBound <- MINUS_INF; upperBound <- PLUS_INF:};
:};    


CLASS RainfallIntensity "A class for rainfall intensity during Kosim simulations"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Rainfall Intensity";
  unit      <- "mm/d";
  interval  <- {: lowerBound <- MINUS_INF; upperBound <- PLUS_INF:};
:};    


CLASS ArealFluxHa "Mass per unit of surface and per unit of time"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "ArealFlux";
  unit     <- "kg/(ha*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};


TYPE HourlyTimeVector =
ENUM {H00, H01, H02, H03, H04, H05, H06, H07, H08, H09, H10,
H11, H12, H13, H14, H15, H16, H17, H18, H19, H20, H21, H22, H23};

OBJ NrOfHourlyTimeVectorElements : Integer := Cardinality(HourlyTimeVector);

CLASS HourlyDailyPattern "Daily pattern" = Real[NrOfHourlyTimeVectorElements;];



# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\generic.msl" 2



# 17 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl" 2


# 27 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl"


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.main.msl" 1
 




















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.general.msl" 1
 



















# 45 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.general.msl"


TYPE YearlyTimeVector =
    ENUM {M01, M02, M03, M04, M05, M06, M07, M08, M09, M10, M11, M12};                        

OBJ NrOfMonthlyTimeVectorElements : Integer := Cardinality(YearlyTimeVector);

CLASS MonthlyYearlyPattern "Monthly pattern" = Real[NrOfMonthlyTimeVectorElements;];


# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.definitions.msl" 1
 
























# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.reactions.msl" 1
 


















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Kosim1/sewer.VolumeKosim1ConversionModel.reactions.msl" 1
 

TYPE Kosim1Reactions "The reactions between the components considered" = 
ENUM
{
  Removal_SCOD,
  Removal_XCOD,
  Removal_PO4,
  Removal_NH4
};

# 20 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.reactions.msl" 2



# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.main.msl" 2


# 44 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Sewer/sewer.main.msl"



# 29 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 1
 




















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.general.msl" 1
 


















 

 
OBJ NrOfComponents "The number of biological components considered in the WWTP models"
: Integer := Cardinality(Components);

OBJ NrOfReactions
  "The number of reactions between biological components considered in the WWTP models"
  : Integer := Cardinality(Reactions);

OBJ NrOfLayers "The number of layers in the secondary clarifier"
  : Integer := 10 ;

OBJ IndexOfFeedLayer "The index of the layer where the influent is feeded to the clarifier"
  : Integer := 5 ;

OBJ NrOfLayersButOne "The number of layers in the secondary clarifier minus one"
  : Integer := 9 ;

OBJ NrOfLayersPlusOne "The number of layers in the secondary clarifier plus one"
  : Integer := 11 ;

 
OBJ IndexOfFeedLayerBurger "The index of the layer where the influent is feeded to the clarifier" : Integer := 25 ;

OBJ NrOfLayersBurger "Burger-Diehl model: The number of layers in the secondary clarifier (N)" : Integer := 90 ;
OBJ NrOfLayersPlusOneBurger "Burger-Diehl model: The number of layers in the clarifier plus one (N+1)" : Integer := 91 ;
OBJ NrOfLayersPlusTwoBurger "Burger-Diehl model: The number of layers in the clarifier plus two extra layers in the underflow (N+2)" : Integer := 92 ;
OBJ NrOfLayersPlusThreeBurger "Burger-Diehl model: The number of layers in the secondary clarifier plus 3 (N+3)" : Integer := 93 ;
OBJ NrOfLayersPlusFourBurger "Burger-Diehl model: The number of layers in the clarifier plus the extra layers in effluent and underflow (N+4)" : Integer := 94 ;
 

 

 
 
CLASS WWTPTerminal
"The variables which are passed between WWTP model building blocks"
= MassFlux[NrOfComponents;] ;

CLASS InWWTPTerminal SPECIALISES WWTPTerminal;  
CLASS OutWWTPTerminal SPECIALISES WWTPTerminal;  

 
CLASS WWTPConcTerminal = Concentration[NrOfComponents;]; 

CLASS InWWTPConcTerminal SPECIALISES WWTPConcTerminal;  
CLASS OutWWTPConcTerminal SPECIALISES WWTPConcTerminal;  

OBJ Terminal "Temporary iteration variable" : WWTPTerminal;
OBJ In_Terminal "Temporary iteration variable" : WWTPTerminal;
OBJ Out_Terminal "Temporary iteration variable" : WWTPTerminal;



CLASS MassVector = Mass[NrOfComponents;];
CLASS MassFluxVector = MassFlux[NrOfComponents;];
CLASS ConcentrationVector = Concentration[NrOfComponents;];
CLASS SpecificVolumeVector = SpecificVolume[NrOfComponents;];
 
 
CLASS LengthVector = Length[NrOfLayers;];

 
CLASS LayerConcentrationVector = Concentration[NrOfLayers;];
CLASS LayerVelocityVector = Velocity[NrOfLayers;];
CLASS LayerArealFluxVector = ArealFlux[NrOfLayers;];
CLASS LayerConcentrationMatrix = Concentration[NrOfComponents;][NrOfLayers;];



 


 
OBJ SiegristNrOfComponents : Integer := Cardinality(SiegristComponents);
OBJ SiegristNrOfReactions : Integer := Cardinality(SiegristReactions);

CLASS SiegristWWTPTerminal = MassFlux[SiegristNrOfComponents;] ;

CLASS SiegristSpecificVolumeVector = SpecificVolume[SiegristNrOfComponents;];
CLASS SiegristConcentrationVector = Concentration[SiegristNrOfComponents;];
CLASS SiegristMassVector = Mass[SiegristNrOfComponents;];
CLASS SiegristMassFluxVector = MassFlux[SiegristNrOfComponents;];

OBJ Siegrist_Terminal "Temporary iteration variable" : SiegristWWTPTerminal ;





 
 
CLASS kgMass "A class for (kg, kmol) mass in the scope of ADM1"
SPECIALISES PhysicalQuantityType := 
{:
  quantity  <- "Mass";
  unit      <- "kg";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
:};

CLASS kgConcentration "A class for kg concentration in the scope of ADM1"
SPECIALISES PhysicalQuantityType :=
{:
  nature <- "ACROSS";
  quantity <- "Concentration";
  unit <- "kg/m3";
  interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS kmolConcentration "A class for kmol concentration in the scope of ADM1"
SPECIALISES PhysicalQuantityType :=
{:
  nature <- "ACROSS";
  quantity <- "Concentration";
  unit <- "kmol/m3";
  interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS kgMassFlux "Mass per time unit"
SPECIALISES PhysicalQuantityType :=
 {:
  quantity  <- "MassFlux";   
  unit      <- "kg/d";
  interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF :};
  nature <- "THROUGH";
 :};

OBJ ADM1NrOfComponents : Integer := Cardinality(ADM1Components);
OBJ ADM1NrOfReactions : Integer := Cardinality(ADM1Reactions);

CLASS ADM1ConcTerminal = Concentration[ADM1NrOfComponents;];

CLASS ADM1MassVector = kgMass[ADM1NrOfComponents;]; 
 
 
CLASS ADM1GasConcTerminal = Concentration[3;];

CLASS ADM1ConcentrationVector = kgConcentration[ADM1NrOfComponents;];
CLASS ADM1MassFluxVector = kgMassFlux[ADM1NrOfComponents;];




 
# 204 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.general.msl"


 
 
















 


OBJ ASM1_ABNrOfComponents : Integer := Cardinality(ASM1_ABComponents);
OBJ ASM1_ABNrOfReactions : Integer := Cardinality(ASM1_ABReactions);

 
 
CLASS ASM1_ABWWTPTerminal = MassFlux[ASM1_ABNrOfComponents;] ;

CLASS ASM1_ABInWWTPTerminal SPECIALISES ASM1_ABWWTPTerminal;  
CLASS ASM1_ABOutWWTPTerminal SPECIALISES ASM1_ABWWTPTerminal;  

 
CLASS ASM1_ABWWTPConcTerminal = Concentration[ASM1_ABNrOfComponents;]; 

CLASS ASM1_ABInWWTPConcTerminal SPECIALISES ASM1_ABWWTPConcTerminal;  
CLASS ASM1_ABOutWWTPConcTerminal SPECIALISES ASM1_ABWWTPConcTerminal;  

OBJ ASM1_ABTerminal "Temporary iteration variable" : ASM1_ABWWTPTerminal;
OBJ ASM1_ABIn_Terminal "Temporary iteration variable" : ASM1_ABWWTPTerminal;
OBJ ASM1_ABOut_Terminal "Temporary iteration variable" : ASM1_ABWWTPTerminal;
 

CLASS ASM1_ABMassVector = Mass[ASM1_ABNrOfComponents;];
CLASS ASM1_ABMassFluxVector = MassFlux[ASM1_ABNrOfComponents;];
CLASS ASM1_ABSpecificVolumeVector = SpecificVolume[ASM1_ABNrOfComponents;];
CLASS ASM1_ABConcentrationVector = Concentration[ASM1_ABNrOfComponents;];





# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.definitions.msl" 1
 


















  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

  
 
 

  
  
  
  
  
  

  
  


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.definitionsASM1Temp.msl" 1
 

TYPE Components "The components considered" = 
ENUM
{
  H2O,
  S_I,
  S_S,
  S_O,
  S_NO,
  S_ND,
  S_NH,
  S_ALK,
  X_I,
  X_BH,
  X_BA,
  X_P,
  X_S,
  X_ND
};


OBJ IndexOfSolvent "Index of the solvent in the component vector" : Integer := 1;

OBJ IndexOfFirstSolubleComponent "Index of the first soluble component in the component vector" : Integer := 2;
OBJ IndexOfLastSolubleComponent "Index of the last soluble component in the component vector" : Integer := 8;

OBJ IndexOfFirstParticulateComponent "Index of the first particulate component in the component vector" : Integer := 9;
OBJ IndexOfLastParticulateComponent "Index of the last particulate component in the component vector" : Integer := 14;

OBJ IndexOfFirstTSSComponent "Index of the first TSS component in the component vector" : Integer := 9;
OBJ IndexOfLastTSSComponent "Index of the last TSS component in the component vector" : Integer := 13;

# 56 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.definitions.msl" 2














 
 








 
 










 
 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.definitionsSiegrist.msl" 1
 

TYPE SiegristComponents "The components considered" = 
ENUM
{
  H2O,
  S_H2,
  S_CH4,
  S_CO2,
  S_HCO3,
  S_H,
  S_NH4,
  S_AC,
  S_PRO,
  S_AS,
  S_FA,
  S_IN,
  X_S,
  X_AS,
  X_FA,
  X_PRO,
  X_AC,
  X_H2,
  X_IN
};


OBJ SiegristIndexOfSolvent "Index of the solvent in the component vector" : Integer := 1;

OBJ SiegristIndexOfFirstSolubleComponent "Index of the first soluble component in the component vector" : Integer := 2;
OBJ SiegristIndexOfLastSolubleComponent "Index of the last soluble component in the component vector" : Integer := 12;

OBJ SiegristIndexOfFirstParticulateComponent "Index of the first particulate component in the component vector" : Integer := 13;
OBJ SiegristIndexOfLastParticulateComponent "Index of the last particulate component in the component vector" : Integer := 19;

OBJ SiegristIndexOfFirstTSSComponent "Index of the first TSS component in the component vector" : Integer := 13;
OBJ SiegristIndexOfLastTSSComponent "Index of the last TSS component in the component vector" : Integer := 19;

# 95 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.definitions.msl" 2



 
 
 


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.definitionsADM1.msl" 1
 

TYPE ADM1Components "The components considered" = 
ENUM
{
  H2O,
  S_INN,
  S_IC,
  S_ch4,
  S_h2,
  S_IC_liq,
  S_ch4_liq,
  S_h2_liq,
  S_aa,
  S_ac,
  S_bu,
  S_fa,
  S_Inert,
  S_pro,
  S_su,
  S_va,
  X_aa,
  X_ac,
  X_c,
  X_c4,
  X_ch,
  X_fa,
  X_h2,
  X_Inert,
  X_li,
  X_pr,
  X_pro,
  X_su,
  S_an,
  S_cat,
  G_CO2,
  G_H2,
  G_CH4
};


OBJ ADM1IndexOfSolvent "Index of the solvent in the component vector" : Integer := 1;

OBJ ADM1IndexOfFirstSolubleComponent "Index of the first soluble component in the component vector" : Integer := 2;
OBJ ADM1IndexOfLastSolubleComponent "Index of the last soluble component in the component vector" : Integer := 16;

OBJ ADM1IndexOfFirstParticulateComponent "Index of the first particulate component in the component vector" : Integer := 17;
OBJ ADM1IndexOfLastParticulateComponent "Index of the last particulate component in the component vector" : Integer := 28;

OBJ ADM1IndexOfFirstGasComponent "Index of the first gas component in the component vector" : Integer := 31;
OBJ ADM1IndexOfLastGasComponent "Index of the last gas component in the component vector" : Integer := 33;

OBJ ADM1IndexOfFirstTSSComponent "Index of the first TSS component in the component vector" : Integer := 17;
OBJ ADM1IndexOfLastTSSComponent "Index of the last TSS component in the component vector" : Integer := 28;

# 103 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.definitions.msl" 2






 
 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.definitionsASM1_AB.msl" 1
 

TYPE ASM1_ABComponents "The components considered" = 
ENUM
{
  H2O,
  S_Bf,
  S_Bs,
  S_O,
  S_U,
  S_NOx,
  S_NHx,
  S_NB,
  S_Alk,
  C_U,
  C_B,
  X_B,
  X_U,
  X_OHO,
  X_ANO,
  X_E,
  X_STO,
  X_EPS,
  X_NB
};


OBJ ASM1_ABIndexOfSolvent "Index of the solvent in the component vector" : Integer := 1;

OBJ ASM1_ABIndexOfFirstSolubleComponent "Index of the first soluble component in the component vector" : Integer := 2;
OBJ ASM1_ABIndexOfLastSolubleComponent "Index of the last soluble component in the component vector" : Integer := 11;

OBJ ASM1_ABIndexOfFirstParticulateComponent "Index of the first particulate component in the component vector" : Integer := 12;
OBJ ASM1_ABIndexOfLastParticulateComponent "Index of the last particulate component in the component vector" : Integer := 19;

OBJ ASM1_ABIndexOfFirstTSSComponent "Index of the first TSS component in the component vector" : Integer := 12;
OBJ ASM1_ABIndexOfLastTSSComponent "Index of the last TSS component in the component vector" : Integer := 18;

# 112 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.definitions.msl" 2





# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.reactions.msl" 1
 



















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.reactions.msl" 1
 

TYPE Reactions "The reactions between the components considered" = 
ENUM
{
  AerGrowthHetero,
  AnGrowthHetero,
  AerGrowthAuto,
  DecayOfHetero,
  DecayOfAuto,
  AmmonOfSolOrgN,
  HydrolOfEntrOrg,
  HydrolOfEntrOrgN,
  Aeration
};

# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.reactions.msl" 2














 
 








 
 








 
 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.reactions.msl" 1
 

TYPE SiegristReactions "The reactions between the components considered" = 
ENUM
{
  H2Stripping,
  CH4Stripping,
  CO2Stripping,
  BiopolymHydrol,
  ASFermentation,
  AnOxOfS_FA,
  AnOxOfS_PRO,
  AcToCH4Conv,
  H2ToCH4Conv,
  DecayOfX_AS,
  DecayOfX_FA,
  DecayOfX_PRO,
  DecayOfX_AC,
  DecayOfX_H2,
  ProtolysisOfHCO3,
  DeprotolysisOfCO2
};

# 58 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.reactions.msl" 2








# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.reactions.msl" 1
 

TYPE ADM1Reactions "The reactions between the components considered" = 
ENUM
{
  decay_aa,
  decay_ac,
  decay_c4,
  decay_fa,
  decay_h2,
  decay_pro,
  decay_su,
  dis,
  hyd_ch,
  hyd_li,
  hyd_pr,
  uptake_aa,
  uptake_ac,
  uptake_bu,
  uptake_fa,
  uptake_h2,
  uptake_pro,
  uptake_su,
  uptake_va,
  transfer_co2,
  transfer_h2,
  transfer_ch4
};

# 66 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.reactions.msl" 2






 
 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.reactions.msl" 1
 

TYPE ASM1_ABReactions "The reactions between the components considered" = 
ENUM
{
  AerGrowthOHOfast,
  AerGrowthOHOslow,
  AnGrowthOHO,
  AerGrowthANO,
  DecayOHO,
  DecayANO,
  AmmonifSolOrgN,
  HydrolEntrapOrg,
  HydrolEntrapOrgN,
  FlocculatCB,
  FlocculatCU,
  HydrolXSTO,
  HydrolXEPS,
  Aerat
};

# 75 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.reactions.msl" 2





# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl" 1
 


















 CLASS WWTPAtomicModel
 " A generic atomic WWTP model. Only specifies mass balances"
 
 
 
 
 
 
 
 
 SPECIALISES PhysicalDAEModelType :=
 {:
 
  parameters <-
  {
   
   
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
   
  OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing the specific volume (= 1/density) for all the components"
    : SpecificVolumeVector;

   
   
   
   
   
   
   
  };

  initial <-
  {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  };

  independent <- 
  {
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ M "Vector containing masses for all the components" : MassVector 

         := [{: value <- 1000000000:},{: value <- 1 :},
                  {: value <- 2 :},{: value <- 1 :},
                {: value <- 2 :}, {: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                                {: value <- 1000 :},{: value <- 100 :},
                {: value <- 1 :},{: value <- 1 :}; ]

































# 138 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl"

# 147 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl"

# 158 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl"

;
    OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": MassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversion terms for all the components": MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
     



    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:


    state.FluxPerComponent[Comp_Index] =
     
     
     
     
     

    (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
    In_Terminal[Comp_Index])+
    (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
    Out_Terminal[Comp_Index]);};

     
     
     
     



    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:


    DERIV(state.M[Comp_Index],[independent.t]) =
        state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index] ; };

     



    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:


    state.InFluxPerComponent[Comp_Index] =
        SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };
    
    state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent] ;
    
     
     
  };

:};

 
 
 

 
 
 

CLASS WWTPAtomicModelWithoutVolume SPECIALISES PhysicalDAEModelType :=
{:

  parameters <-
  {
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
  };
  
  initial <-
  {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  };
  
  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
  };
  
  state <-
  {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
  };
  
  equations <-
  {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
        SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };
    
    state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent] ;
  };

:};

 
 
 

 CLASS WWTPAtomicModelWithVolume EXTENDS WWTPAtomicModel WITH
 {:

   state <-
    {
      OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Dimension" :};
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
    };

   equations <-
    {
      
      
    };

 :};


 
 
 

 CLASS WWTPAtomicModelWithVariableVolume
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:

  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  parameters <-  
   {
     OBJ N "Number of weirs on a tank" : PhysicalQuantityType := {: value <- 100 ; interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}; group <- "Hydraulic" :} ;
     OBJ A (* is_favorite = "1" *) "Surface area of the tank" : Area := {: value <- 200; group <- "Dimension"  :} ;
     OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic"  :};
     OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
     OBJ V_Const (* is_favorite = "1" *) "Constant tank volume beneath the lowest point of the weir" : Volume := {: value <- 1900; group <- "Dimension" :};
   };   

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
     
     
     

    state.Q_Out = IF (state.V > parameters.V_Const) THEN
        parameters.N * parameters.alfa * pow((state.V - parameters.V_Const)/parameters.A, parameters.beta)
        ELSE 0.0 ;

     
     

    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index] * state.M[Comp_Index]) ;

     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    state.C[Comp_Index] = IF (state.V == 0) THEN 0
        ELSE state.M[Comp_Index]/state.V ; };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out ; };
   };

:};


  
  
  
  
  

 CLASS VarVolumeConversionModel EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
    OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
    OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 348 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl" 2

 :};
 
  

 CLASS VarVolumeASMConversionModel EXTENDS VarVolumeConversionModel WITH
 {:
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 15.000000; :}; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; unit <- "1/d"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 5000.000000; :}; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; unit <- "m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.state.msl" 1
 

    OBJ K_X_Temp (* *) "K_X at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ b_A_Temp (* *) "b_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H_Temp (* *) "b_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_a_Temp (* *) "k_a at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_h_Temp (* *) "k_h at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_A_Temp (* *) "mu_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H_Temp (* *) "mu_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[AerGrowthHetero][S_S] := - 1 / (parameters.Y_H);
    parameters.Stoichiometry[AerGrowthHetero][S_O] := - (1 - parameters.Y_H) / parameters.Y_H;
    parameters.Stoichiometry[AerGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AerGrowthHetero][S_ALK] := - parameters.i_X_B / 14;
    parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AnGrowthHetero][S_S] := - 1 / parameters.Y_H;
    parameters.Stoichiometry[AnGrowthHetero][S_NO] := - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
    parameters.Stoichiometry[AnGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
    parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AerGrowthAuto][S_O] := - (4.57 - parameters.Y_A) / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NH] := - parameters.i_X_B - 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_ALK] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
    parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
    parameters.Stoichiometry[DecayOfHetero][X_BH] := - 1;
    parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[DecayOfAuto][X_BA] := - 1;
    parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] := - 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.000000 / 14.000000;
    parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrg][X_S] := - 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] := - 1;
    parameters.Stoichiometry[Aeration][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;
    state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A, state.Temp_Actual - parameters.Temp_Ref);
    state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H, state.Temp_Actual - parameters.Temp_Ref);
    state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H, state.Temp_Actual - parameters.Temp_Ref);

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthAuto] = state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
    state.Kinetics[AerGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
    state.Kinetics[Aeration] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonOfSolOrgN] = state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
    state.Kinetics[AnGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
    state.Kinetics[DecayOfAuto] = state.b_A_Temp * state.C[X_BA];
    state.Kinetics[DecayOfHetero] = state.b_H_Temp * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrg] = state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrgN] = (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);

# 55 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NH];
    interface.NO3 = state.C[S_NO];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA]));
    interface.OfflineTKN = (state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.OnlineCOD = (state.C[S_S] + state.C[S_I] + state.C[X_BH] + state.C[X_BA] + state.C[X_S] + state.C[X_I] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 59 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 2


































# 355 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl" 2

 :};


 
 
 


CLASS WWTPAtomicModelWithPumpedVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Q_Pump (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired effluent flow rate" : FlowRate := {: causality <- "CIN" ; value <- 100; group <- "Operational" :} ;
   };

  parameters <-
   {
     OBJ V_Max (* is_favorite = "1" *) "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min (* is_favorite = "1" *) "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
   };

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min && 
                    interface.Q_Pump > state.Q_In) 
                THEN state.Q_In
                ELSE  
                  IF (state.V < parameters.V_Max)
                  THEN interface.Q_Pump
                  ELSE
                    IF (state.Q_In < interface.Q_Pump)
                    THEN interface.Q_Pump
                    ELSE state.Q_In ;    

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};

CLASS PumpedVolumeConversionModel EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
    OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
    OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 417 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl" 2

 :};

 CLASS PumpedVolumeASMConversionModel EXTENDS PumpedVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 15.000000; :}; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; unit <- "1/d"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 5000.000000; :}; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; unit <- "m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.state.msl" 1
 

    OBJ K_X_Temp (* *) "K_X at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ b_A_Temp (* *) "b_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H_Temp (* *) "b_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_a_Temp (* *) "k_a at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_h_Temp (* *) "k_h at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_A_Temp (* *) "mu_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H_Temp (* *) "mu_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[AerGrowthHetero][S_S] := - 1 / (parameters.Y_H);
    parameters.Stoichiometry[AerGrowthHetero][S_O] := - (1 - parameters.Y_H) / parameters.Y_H;
    parameters.Stoichiometry[AerGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AerGrowthHetero][S_ALK] := - parameters.i_X_B / 14;
    parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AnGrowthHetero][S_S] := - 1 / parameters.Y_H;
    parameters.Stoichiometry[AnGrowthHetero][S_NO] := - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
    parameters.Stoichiometry[AnGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
    parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AerGrowthAuto][S_O] := - (4.57 - parameters.Y_A) / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NH] := - parameters.i_X_B - 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_ALK] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
    parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
    parameters.Stoichiometry[DecayOfHetero][X_BH] := - 1;
    parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[DecayOfAuto][X_BA] := - 1;
    parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] := - 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.000000 / 14.000000;
    parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrg][X_S] := - 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] := - 1;
    parameters.Stoichiometry[Aeration][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;
    state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A, state.Temp_Actual - parameters.Temp_Ref);
    state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H, state.Temp_Actual - parameters.Temp_Ref);
    state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H, state.Temp_Actual - parameters.Temp_Ref);

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthAuto] = state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
    state.Kinetics[AerGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
    state.Kinetics[Aeration] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonOfSolOrgN] = state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
    state.Kinetics[AnGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
    state.Kinetics[DecayOfAuto] = state.b_A_Temp * state.C[X_BA];
    state.Kinetics[DecayOfHetero] = state.b_H_Temp * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrg] = state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrgN] = (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);

# 55 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NH];
    interface.NO3 = state.C[S_NO];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA]));
    interface.OfflineTKN = (state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.OnlineCOD = (state.C[S_S] + state.C[S_I] + state.C[X_BH] + state.C[X_BA] + state.C[X_S] + state.C[X_I] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 59 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 2


































# 422 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl" 2

 :};



 
 
 

 CLASS WWTPAtomicModelWithFixedVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:
 
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  parameters <-  
   {
     OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
   };   
   
  state <-
   {
   };

  initial <-  
  {
  state.M[IndexOfSolvent] = parameters.Vol / parameters.WWTPSpecificVolume[IndexOfSolvent];
  };
  
  equations <-
   {
     
     
     
 
      
     
     
     

    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: interface.Outflow[Comp_Index] =
      - state.C[Comp_Index] * state.Q_In ;};
   };

:};

 CLASS FixVolumeConversionModel EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
    OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
    OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 487 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl" 2

 :};
 
 CLASS FixVolumeASMConversionModel EXTENDS FixVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 15.000000; :}; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; unit <- "1/d"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 5000.000000; :}; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; unit <- "m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.state.msl" 1
 

    OBJ K_X_Temp (* *) "K_X at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ b_A_Temp (* *) "b_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H_Temp (* *) "b_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_a_Temp (* *) "k_a at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_h_Temp (* *) "k_h at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_A_Temp (* *) "mu_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H_Temp (* *) "mu_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[AerGrowthHetero][S_S] := - 1 / (parameters.Y_H);
    parameters.Stoichiometry[AerGrowthHetero][S_O] := - (1 - parameters.Y_H) / parameters.Y_H;
    parameters.Stoichiometry[AerGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AerGrowthHetero][S_ALK] := - parameters.i_X_B / 14;
    parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AnGrowthHetero][S_S] := - 1 / parameters.Y_H;
    parameters.Stoichiometry[AnGrowthHetero][S_NO] := - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
    parameters.Stoichiometry[AnGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
    parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AerGrowthAuto][S_O] := - (4.57 - parameters.Y_A) / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NH] := - parameters.i_X_B - 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_ALK] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
    parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
    parameters.Stoichiometry[DecayOfHetero][X_BH] := - 1;
    parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[DecayOfAuto][X_BA] := - 1;
    parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] := - 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.000000 / 14.000000;
    parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrg][X_S] := - 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] := - 1;
    parameters.Stoichiometry[Aeration][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;
    state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A, state.Temp_Actual - parameters.Temp_Ref);
    state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H, state.Temp_Actual - parameters.Temp_Ref);
    state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H, state.Temp_Actual - parameters.Temp_Ref);

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthAuto] = state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
    state.Kinetics[AerGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
    state.Kinetics[Aeration] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonOfSolOrgN] = state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
    state.Kinetics[AnGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
    state.Kinetics[DecayOfAuto] = state.b_A_Temp * state.C[X_BA];
    state.Kinetics[DecayOfHetero] = state.b_H_Temp * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrg] = state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrgN] = (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);

# 55 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NH];
    interface.NO3 = state.C[S_NO];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA]));
    interface.OfflineTKN = (state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.OnlineCOD = (state.C[S_S] + state.C[S_I] + state.C[X_BH] + state.C[X_BA] + state.C[X_S] + state.C[X_I] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 59 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 2


































# 492 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.msl" 2

 :};

 

 
 
 

 
 
 

 
 
 
 
 


# 27 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 1
 


















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.twocombiner.msl" 1
 


















 CLASS TwoCombiner
 (* icon = "two_combiner" ; is_default = "true" *)  
 "two combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of two flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1" :};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.threecombiner.msl" 1
 


















 CLASS ThreeCombiner
 (* icon = "three_combiner" ; is_default = "true" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of three flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.fourcombiner.msl" 1
 


















 CLASS FourCombiner
 (* icon = "four_combiner" ; is_default = "true" *)  
 "Four combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of four flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.fivecombiner.msl" 1
 














 



 CLASS FiveCombiner
 (* icon = "five_combiner" ; is_default = "true" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of five flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Inflow5 (* terminal = "in_5" *) "Inflow5" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 5":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In5 (* is_favorite = "1" *) "Influent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In5 = interface.Inflow5[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2


 
 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.reltwosplitter.msl" 1
 














 



CLASS RelTwoSplitter
 (* icon = "two_fraction_splitter" ; is_default = "true" *)
 "relative splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.9; group <- "Operational" :};
   };
  parameters <-
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 
 
 :};


# 29 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.relthreesplitter.msl" 1
 














 



 CLASS RelThreeSplitter
 (* icon = "three_fraction_splitter" ; is_default = "true" *)
 "relative three splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.8 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};


# 30 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.relfoursplitter.msl" 1
 


















 CLASS RelFourSplitter
 (* icon = "four_fraction_splitter" ; is_default = "true" *)
 "relative four splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into four flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};
 


# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.relfivesplitter.msl" 1
 


















 CLASS RelFiveSplitter
 (* icon = "five_fraction_splitter" ; is_default = "true" *)
 "relative five splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into five flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow5" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out5 (* is_favorite = "1" *) "Effluent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4 + interface.f_Out5) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out5)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
      };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index] - interface.Outflow5[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out5 = - interface.Outflow5[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};


# 32 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2


 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.abstwosplitter.msl" 1
 


















CLASS AbsTwoSplitter (* icon = "two_flow_splitter" *)
"absolute two way splitter"

 

EXTENDS AbsTwoSplitter_Base WITH
{:
  comments <- "A model for an absolute splitter into two flows";

  interface <-
  { 
    OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
  };

  parameters <- 
  { 
     
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };
  
  state <-
  {
     
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };
  
  initial <-
  {
    state.Integ_PE = 0.0 ;
  };
  
  equations <-
  {
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Out2_Actual ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  }; 

:};



CLASS AbsTwoSplitter_Base (* icon = "two_flow_splitter"; is_default = "true" *) "Base class for an absolute two-way splitter"
EXTENDS WWTPAtomicModelWithoutVolume WITH
{:
  comments <- "Base class for an absolute two way splitter";

  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired flow rate (outflow #2)" : FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
     
    OBJ Q_Op1 (* terminal = "out_3" *) "Actual operating flow rate no.1" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op2 (* terminal = "out_3" *) "Actual operating flow rate no.2" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
  };

  state <-
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate := {: group <- "Operational" :};
  };
  
  equations <-
  {
    state.Q_Out1 = IF(interface.Q_Out2 > state.Q_In) THEN 0.0
      ELSE state.Q_In - state.Q_Out2_Actual ;
    
    state.Q_Out2_Actual = IF(interface.Q_Out2 > state.Q_In) THEN state.Q_In
      ELSE interface.Q_Out2;
    
    state.f_Out2 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out2_Actual / state.Q_In ;
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out2) ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

     
    interface.Q_Op1 = state.Q_Out1 ;
    interface.Q_Op2 = state.Q_Out2_Actual ;
  }; 

:};



# 36 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.absthreesplitter.msl" 1
 


















CLASS AbsThreeSplitter (* icon = "three_flow_splitter" *)
"absolute three way splitter"

 

EXTENDS AbsThreeSplitter_Base WITH
{:

  comments <- "A model for an absolute splitter into three flows";

  interface <-
  { 
    OBJ PumpingEnergy (* terminal = "out_4" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_4" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };

  parameters <- 
  { 
     
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };

  state <-
  {
     
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };

  initial <-
  {
    state.Integ_PE = 0.0 ;
  };

  equations <-
  {
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * (state.Q_Out2_Actual + state.Q_Out3_Actual) ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  }; 

:};


CLASS AbsThreeSplitter_Base (* icon = "three_flow_splitter"; is_default = "true" *)
"Base class for an absolute three-way splitter"
EXTENDS WWTPAtomicModelWithoutVolume WITH
{:

  comments <- "Base class for an absolute three-way splitter";

  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" :  InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
     
    OBJ Q_Op1 (* terminal = "out_4" *) "Actual operating flow rate no.1" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op2 (* terminal = "out_4" *) "Actual operating flow rate no.2" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op3 (* terminal = "out_4" *) "Actual operating flow rate no.3" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
  };

  state <-
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual);
    
    state.Q_Out2_Actual = IF (interface.Q_Out2 > state.Q_In)
      THEN state.Q_In
      ELSE interface.Q_Out2;
    
    state.Q_Out3_Actual = IF ((interface.Q_Out2 + interface.Q_Out3) > state.Q_In)
      THEN state.Q_In - state.Q_Out2_Actual
      ELSE interface.Q_Out3;
    
    state.f_Out1 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out1 /state.Q_In ;
    
    state.f_Out2 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out2_Actual /state.Q_In ; 
    
    state.f_Out3 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out3_Actual / state.Q_In ;
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

     
    interface.Q_Op1 = state.Q_Out1 ;
    interface.Q_Op2 = state.Q_Out2_Actual ;
    interface.Q_Op3 = state.Q_Out3_Actual ;
  }; 

:};



# 37 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.absfoursplitter.msl" 1
 



















CLASS AbsFourSplitter (* icon = "four_flow_splitter" *)
"absolute four way splitter"

 

EXTENDS AbsFourSplitter_Base WITH
{:

  comments <- "A model for an absolute splitter into four flows";

  interface <-
  { 
    OBJ PumpingEnergy (* terminal = "out_5" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_5" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
  };

  parameters <- 
  { 
   
  OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };

  state <-
  {
     
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };
  
  initial <-
  {
    state.Integ_PE = 0.0 ;
  };
  
  equations <-
  {
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual) ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  }; 

:};


CLASS AbsFourSplitter_Base (* icon = "four_flow_splitter" ; is_default = "true" *)
"Base class for an absolute four-way splitter"
EXTENDS WWTPAtomicModelWithoutVolume WITH
{:

  comments <- "Base class for an absolute four-way splitter";

  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
     
    OBJ Q_Op1 (* terminal = "out_5" *) "Actual operating flow rate no.1" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op2 (* terminal = "out_5" *) "Actual operating flow rate no.2" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op3 (* terminal = "out_5" *) "Actual operating flow rate no.3" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op4 (* terminal = "out_5" *) "Actual operating flow rate no.4" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
  };

  state <-
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual);
     
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
      THEN state.Q_In
      ELSE interface.Q_Out2;
    
    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
      THEN state.Q_In - state.Q_Out2_Actual
      ELSE interface.Q_Out3;
    
    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
      THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
      ELSE interface.Q_Out4;
    
    state.f_Out1 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out1 /state.Q_In ;
    
    state.f_Out2 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out2_Actual /state.Q_In ; 
    
    state.f_Out3 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out3_Actual / state.Q_In ;
    
    state.f_Out4 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out4_Actual /state.Q_In ; 
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};

     
    interface.Q_Op1 = state.Q_Out1 ;
    interface.Q_Op2 = state.Q_Out2_Actual ;
    interface.Q_Op3 = state.Q_Out3_Actual ;
    interface.Q_Op4 = state.Q_Out4_Actual ;
  }; 

:};



# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.base.splitters_combiners.absfivesplitter.msl" 1
 



















CLASS AbsFiveSplitter (* icon = "five_flow_splitter" *)
"absolute five way splitter"

 

EXTENDS AbsFiveSplitter_Base WITH
{:

  comments <- "A model for an absolute splitter into five flows";

  interface <-
  { 
    OBJ PumpingEnergy (* terminal = "out_6" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_6" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
  };

  parameters <- 
  { 
     
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };

  state <-
  {
     
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };

  initial <-
  {
    state.Integ_PE = 0.0 ;
  };

  equations <-
  {
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual) ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  }; 

:};


CLASS AbsFiveSplitter_Base (* icon = "five_flow_splitter" ; is_default = "true" *)
"Base class for an absolute five-way splitter"
EXTENDS WWTPAtomicModelWithoutVolume WITH
{:
  comments <- "Base class for an absolute five-way splitter";

  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" :  InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow5 rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
     
    OBJ Q_Op1 (* terminal = "out_6" *) "Actual operating flow rate no.1" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op2 (* terminal = "out_6" *) "Actual operating flow rate no.2" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op3 (* terminal = "out_6" *) "Actual operating flow rate no.3" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op4 (* terminal = "out_6" *) "Actual operating flow rate no.4" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op5 (* terminal = "out_6" *) "Actual operating flow rate no.5" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
  };

  state <-
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ f_Out5 (* hidden = "1" *) "Fraction of the influent flux going to outflow5" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate ;
    OBJ Q_Out5_Actual (* is_favorite = "1" *) "Help variable for outflow5 rate" : FlowRate ;
  };

  equations <-
  {
    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual);
     
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
      THEN state.Q_In
      ELSE interface.Q_Out2;
    
    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
      THEN state.Q_In - state.Q_Out2_Actual
      ELSE interface.Q_Out3;
    
    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
      THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
      ELSE interface.Q_Out4;
    
    state.Q_Out5_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4+interface.Q_Out5) > state.Q_In)
      THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual - state.Q_Out4_Actual
      ELSE interface.Q_Out5;
    
    state.f_Out1 = IF (state.Q_In == 0) THEN 0.0
    ELSE state.Q_Out1 /state.Q_In ;
    
    state.f_Out2 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out2_Actual /state.Q_In ; 
    
    state.f_Out3 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out3_Actual / state.Q_In ;
    
    state.f_Out4 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out4_Actual /state.Q_In ; 
    
    state.f_Out5 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out5_Actual / state.Q_In ;
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out5 ;};

     
    interface.Q_Op1 = state.Q_Out1 ;
    interface.Q_Op2 = state.Q_Out2_Actual ;
    interface.Q_Op3 = state.Q_Out3_Actual ;
    interface.Q_Op4 = state.Q_Out4_Actual ;
    interface.Q_Op5 = state.Q_Out5_Actual ;
  }; 

:};



# 39 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2


 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.multi.splitters_combiners.msl" 1
 



















CLASS WeightPos "Positive weight"
SPECIALISES PhysicalQuantityType :=
{:
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};


CLASS CombiSplit_Base EXTENDS WWTPAtomicModelWithoutVolume WITH
{:

  interface <-
  { 
    OBJ Inflow01 (* terminal = "in_1" *) "Inflow 1" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1" :};
    OBJ Inflow02 (* terminal = "in_1" *) "Inflow 2" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2" :};
    OBJ Inflow03 (* terminal = "in_1" *) "Inflow 3" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3" :};
    OBJ Inflow04 (* terminal = "in_1" *) "Inflow 4" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4" :};
    OBJ Inflow05 (* terminal = "in_1" *) "Inflow 5" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 5" :};
    OBJ Inflow06 (* terminal = "in_1" *) "Inflow 6" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 6" :};
    OBJ Inflow07 (* terminal = "in_1" *) "Inflow 7" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 7" :};
    OBJ Inflow08 (* terminal = "in_1" *) "Inflow 8" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 8" :};
    OBJ Inflow09 (* terminal = "in_1" *) "Inflow 9" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 9" :};
    OBJ Inflow10 (* terminal = "in_1" *) "Inflow 10" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 10" :};
    OBJ Outflow01 (* terminal = "out_1" *) "Outflow 1" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow02 (* terminal = "out_1" *) "Outflow 2" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow03 (* terminal = "out_1" *) "Outflow 3" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow04 (* terminal = "out_1" *) "Outflow 4" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow05 (* terminal = "out_1" *) "Outflow 5" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ Outflow06 (* terminal = "out_1" *) "Outflow 6" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 6" :};
    OBJ Outflow07 (* terminal = "out_1" *) "Outflow 7" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 7" :};
    OBJ Outflow08 (* terminal = "out_1" *) "Outflow 8" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 8" :};
    OBJ Outflow09 (* terminal = "out_1" *) "Outflow 9" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 9" :};
    OBJ Outflow10 (* terminal = "out_1" *) "Outflow 10" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 10" :};
  };

  state <-  
  {
    OBJ Q_In01 (* is_favorite = "1" *) "Influent flow rate #1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In02 (* is_favorite = "1" *) "Influent flow rate #2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In03 (* is_favorite = "1" *) "Influent flow rate #3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In04 "Influent flow rate #4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In05 "Influent flow rate #5" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In06 "Influent flow rate #6" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In07 "Influent flow rate #7" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In08 "Influent flow rate #8" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In09 "Influent flow rate #9" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In10 "Influent flow rate #10" : FlowRate := {: group <- "Operational" :};

    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out01 (* is_favorite = "1" *) "Effluent flow rate #1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out02 (* is_favorite = "1" *) "Effluent flow rate #2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out03 (* is_favorite = "1" *) "Effluent flow rate #3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out04 "Effluent flow rate #4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out05 "Effluent flow rate #5" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out06 "Effluent flow rate #6" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out07 "Effluent flow rate #7" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out08 "Effluent flow rate #8" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out09 "Effluent flow rate #9" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out10 "Effluent flow rate #10" : FlowRate := {: group <- "Operational" :};
  };   

  equations <-
  {
    state.Q_In01 = interface.Inflow01[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In02 = interface.Inflow02[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In03 = interface.Inflow03[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In04 = interface.Inflow04[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In05 = interface.Inflow05[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In06 = interface.Inflow06[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In07 = interface.Inflow07[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In08 = interface.Inflow08[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In09 = interface.Inflow09[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In10 = interface.Inflow10[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    
    state.Q_Out01 = - interface.Outflow01[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out02 = - interface.Outflow02[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out03 = - interface.Outflow03[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out04 = - interface.Outflow04[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out05 = - interface.Outflow05[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out06 = - interface.Outflow06[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out07 = - interface.Outflow07[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out08 = - interface.Outflow08[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out09 = - interface.Outflow09[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out10 = - interface.Outflow10[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
  }; 

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.splitters_combiners.rel.msl" 1
 



















CLASS CombiSplit_Rel (* icon = "Link"; is_default = "true" *)  
"Relative multi combiner/splitter (valve)"
EXTENDS CombiSplit_Rel_Base WITH
{:
  comments <- "Relative multi combiner/splitter (valve)";

  interface <-
  {
    OBJ Q_Out_01 (* terminal = "out_2" *) "Flow rate #1" : FlowRate := {: causality <- "COUT" ; group <- "Sensor" :};
    OBJ Q_Out_02 (* terminal = "out_2" *) "Flow rate #2" : FlowRate := {: causality <- "COUT" ; group <- "Sensor" :};
    OBJ Q_Out_03 (* terminal = "out_2" *) "Flow rate #3" : FlowRate := {: causality <- "COUT" ; group <- "Sensor" :};
    OBJ Q_Out_04 (* terminal = "out_2" *) "Flow rate #4" : FlowRate := {: causality <- "COUT" ; group <- "Sensor" :};
  };
  
  equations <-
  {
    state.weight = interface.f01 + interface.f02 + interface.f03 + interface.f04 + interface.f05 +
      interface.f06 + interface.f07 + interface.f08 + interface.f09 + interface.f10 ;
      
    state.Q_Out = state.Q_Out01 + state.Q_Out02 + state.Q_Out03 + state.Q_Out04 + state.Q_Out05 +
      state.Q_Out06 + state.Q_Out07 + state.Q_Out08 + state.Q_Out09 + state.Q_Out10 ;
    
    interface.Q_Out_01 = state.Q_Out01 ;
    interface.Q_Out_02 = state.Q_Out02 ;
    interface.Q_Out_03 = state.Q_Out03 ;
    interface.Q_Out_04 = state.Q_Out04 ;
     
  }; 

:};


 



 

CLASS CombiSplit_Rel_Base EXTENDS CombiSplit_Base WITH
{:

  interface <-
  { 
    OBJ f01 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the influent going to outflow #1" : WeightPos
      := {: causality <- "CIN" ; value <- 1.0; group <- "Operational" :};
    OBJ f02 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the influent going to outflow #2" : WeightPos
      := {: causality <- "CIN" ; value <- 1.0; group <- "Operational" :};
    OBJ f03 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the influent going to outflow #3" : WeightPos
      := {: causality <- "CIN" ; value <- 1.0; group <- "Operational" :};
    OBJ f04 (* terminal = "in_2"; manip = "1"; *) "Fraction of the influent going to outflow #4" : WeightPos
      := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ f05 (* terminal = "in_2"; manip = "1"; *) "Fraction of the influent going to outflow #5" : WeightPos
      := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ f06 (* terminal = "in_2"; manip = "1"; *) "Fraction of the influent going to outflow #6" : WeightPos
      := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ f07 (* terminal = "in_2"; manip = "1"; *) "Fraction of the influent going to outflow #7" : WeightPos
      := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ f08 (* terminal = "in_2"; manip = "1"; *) "Fraction of the influent going to outflow #8" : WeightPos
      := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ f09 (* terminal = "in_2"; manip = "1"; *) "Fraction of the influent going to outflow #9" : WeightPos
      := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ f10 (* terminal = "in_2"; manip = "1"; *) "Fraction of the influent going to outflow #10" : WeightPos
      := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
  };

  state <-  
  {
    OBJ weight (* hidden = "1" *) "sum of weights" : WeightPos ;
  };   

  equations <-
  {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow01[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f01 / state.weight) ;  
    };   
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow02[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f02 / state.weight) ;  
    };   
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow03[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f03 / state.weight) ;  
    };
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow04[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f04 / state.weight) ;  
    };   
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow05[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f05 / state.weight) ;  
    };   

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow06[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f06 / state.weight) ;  
    };   

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow07[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f07 / state.weight) ;  
    };
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow08[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f08 / state.weight) ;  
    };
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow09[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f09 / state.weight) ;  
    };   
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow10[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (interface.f10 / state.weight) ;  
    };   
  }; 

:};



# 110 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.multi.splitters_combiners.msl" 2

 



# 43 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.splitters_combiners.msl" 2




# 29 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.buffertanks.msl" 1
 


















CLASS PumpedVolumeBuffer
 "A class for buffertanks with a pumped variable volume"
 EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
  comments <- "A model for a tank with a variable volume caused by a pump";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Volume of the tank" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
     OBJ Q_Bypass (* terminal = "out_2" *) "Bypass flow rate" : FlowRate := {: causality <- "COUT"; group <- "Measurement data" :};
     OBJ Q_Dewatering (* terminal = "in_2"; manip = "1" *) "Dewatering flow rate" : FlowRate  := {: causality <- "CIN"; group <- "Operational" :};
   };

  state <-
   {
     OBJ Help_Q_Bypass (* hidden = "1" *) "Bypass flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
     interface.V_Buffer = state.V;

     state.Help_Q_Bypass = IF ((state.V > (0.9 * parameters.V_Max)) && (interface.Q_Dewatering > interface.Q_Pump))
     	THEN interface.Q_Dewatering ELSE 0.0 ;
     	
     interface.Q_Bypass = state.Help_Q_Bypass ;
   };

 :};

CLASS FixVolumeBuffer
 "A class for buffertanks with a fixed volume"
 EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
   comments <- "A model for a tank with a fixed volume";

   interface <-
   {
     OBJ V_Buffer  (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

   equations <-
   {
     interface.V_Buffer = state.V;
   };

   initial <-
   {
   };
 :};

CLASS VarVolumeBuffer
 "A class for buffertanks with variable volume"
 EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
  comments <- "A model for a  tank with a variable volume caused by a weir";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

  equations <-
   {
    interface.V_Buffer = state.V;
   };

  initial <-
   {
   }; :};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/buffertank/wwtp.base.buffertanks.pumpedvolumestormtank.msl" 1
 














 



CLASS PumpedVolumeStormTank
  (* icon = "storm_tank" ; is_default = "true" *)
  "Model for a storm tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a storm tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *) "Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
   initial <-
   {
   state.Integ_ME = 0.0 ;
   state.Integ_PE = 0.0 ;
   };

  equations <-
  {
 
     
    interface.MixingPower = state.ME_Instant ;
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Out ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :}; 


# 94 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/buffertank/wwtp.base.buffertanks.pumpedvolumebuffertank.msl" 1
 


















CLASS PumpedVolumeBufferTank
  (* icon = "buffer_tank" ; is_default = "true" *)
  "Model for a buffer tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a buffer tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
   initial <-
   {
   state.Integ_ME = 0.0 ;
   state.Integ_PE = 0.0 ;
   };

  equations <-
  {
 
     
    interface.MixingPower = state.ME_Instant ;
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Out ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :};  
 


# 95 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/buffertank/wwtp.base.buffertanks.fixvolumeequalisationtank.msl" 1
 


















  CLASS FixVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES FixVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
   initial <-
   {
   state.Integ_ME = 0.0 ;
   };

  equations <-
  {
 
     
    interface.MixingPower = state.ME_Instant ;
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  


# 96 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/buffertank/wwtp.base.buffertanks.varvolumeequalisationtank.msl" 1
 


















  CLASS VarVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES VarVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
   initial <-
   {
   state.Integ_ME = 0.0 ;
   };

  equations <-
  {
 
     
    interface.MixingPower = state.ME_Instant ;
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  


# 97 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.buffertanks.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/buffertank/wwtp.buffertanks.pumpedvolume.msl" 1
 




















CLASS BufferTank_Pumped2 (* icon = "buffer_tank2" *) "Storm tank with a pump-regulated volume (when V>Vmax)"
EXTENDS VolumeBuffer_Pumped2 WITH
{:

  comments <- "Storm tank with a pump-regulated volume (when V>Vmax)" ;

  interface <-
  {
    OBJ MixingEnergy (* terminal = "out_2" *) "Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingEnergy (* terminal = "out_2" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
    OBJ V_Buffer (* terminal = "out_2" *) "Volume of the tank" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
  };
  
  parameters <- 
  {
     
    OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
     
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };
  
  state <-
  {
     
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
    OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
     
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };
  
  initial <-
  {
    state.Integ_ME = 0.0 ;
    state.Integ_PE = 0.0 ;
  };
  
  equations <-
  {
    interface.V_Buffer = state.V;
    
     
     
    interface.MixingPower = state.ME_Instant ;
    state.ME_Instant = parameters.ME_unit * state.V;    
    DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
    interface.MixingEnergy = state.Integ_ME ;
    
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Out ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };

:};


CLASS VolumeBuffer_Pumped2 EXTENDS WWTPAtomicModelWithVolume WITH
{:

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Overflow (* terminal = "out_3" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Overflow" :};
    OBJ Q_Pump (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Pump flow rate" : FlowRate := {: causality <- "CIN" ; value <- 100; group <- "Operation" :} ;
  };

  parameters <-
  {
    OBJ V_Max (* is_favorite = "1" *) "Maximum volume of the tank" : Volume := {: group <- "Operation" :};
    OBJ V_Min (* is_favorite = "1" *) "Minimum volume of the tank" : Volume := {: group <- "Operation" :}; 
    OBJ Q_Min (* hidden = "1" *) "Min overflow" : FlowRate := {: value <- 10 ; group <- "Operation" :};
  };

  state <-
  {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Over (* is_favorite = "1" *) "Overflow" : FlowRate := {: group <- "Operational" :};
  };
  
  initial <-
  {
    state.M[H2O] = parameters.V_Min * 1E06 ; 
  };  

  equations <-
  {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      (parameters.WWTPSpecificVolume[Comp_Index] * state.M[Comp_Index]) ;
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.C[Comp_Index] = IF (state.V <= 0) THEN 0.0 ELSE state.M[Comp_Index] / state.V ; };

    state.Q_Out = IF (state.V < parameters.V_Min) THEN 0.0
      ELSE IF (state.V < parameters.V_Max) THEN
         
        IF (state.Q_In <= 0.0) THEN interface.Q_Pump ELSE 0.0
 
          ELSE interface.Q_Pump ;

     
     
    state.Q_Over = IF (state.V < parameters.V_Max) THEN 0.0
      ELSE IF (interface.Q_Pump <= 0.0) THEN parameters.Q_Min     
      ELSE IF (state.Q_In < interface.Q_Pump) THEN 0.0     
        ELSE state.Q_In - interface.Q_Pump ;               

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out ; };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Overflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Over ; };
  };

:};



# 100 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.buffertanks.msl" 2




# 30 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.activated_sludge_units.msl" 1
 


















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl" 1
 



















CLASS FixVolumeASU (* icon = "activated_sludge_unit" ; is_default = "true" *)
SPECIALISES FixVolumeASMConversionModel :=
{:

  comments <- "Model for an activated sludge unit with a fixed volume";
  
  interface <-  
  {
    OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
    
    OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge" : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
    
    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    
    



  };   
  
  parameters <- 
  {
     
    OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : EnergyForMixing := {: value <- 0.005; group <- "Mixing energy":};
    OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};  
  };
  
  state <-
  {
    OBJ HRT (* is_favorite = "1" *) "Retention time" : Time := {: group <- "Operational":};
     
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
     
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
    OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : EnergyIndex := {: group <- "Mixing":};
  };
  
  initial <-
  {
    state.Integ_AE = 0.0 ;
    state.Integ_ME = 0.0 ;
  };
  
  equations <- 
  {
    state.Kla_Actual = interface.Kla;
    
    state.Temp_Actual = interface.Temp;
    
    
     
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
    DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
    interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 
    
     
    state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0)) THEN parameters.ME_unit * state.V
      ELSE IF (parameters.Mixing_When_Aerated == 1) THEN parameters.ME_unit * state.V
      ELSE 0 ;    
    
     
    interface.MixingPower = state.ME_Instant ;
    DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
    interface.MixingEnergy = state.Integ_ME ;
    
     
    
# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl"

    
    state.HRT = IF (state.Q_In <= 0.0) THEN 0.0 ELSE state.V / state.Q_In ;
  };   

:};



# 20 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.base.activated_sludge_units.pumpedvolumeasu.msl" 1
 


















 CLASS PumpedVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES PumpedVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable pumped volume";
   interface <-  
   {
    OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
      := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 

   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : EnergyForMixing := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : EnergyIndex := {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_AE = 0.0 ;
   state.Integ_ME = 0.0 ;
   state.Integ_PE = 0.0 ;
   };

   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;


 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
  DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
  interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant ;
  interface.MixingEnergy = state.Integ_ME ;

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Out ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };   
 :};



# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.base.activated_sludge_units.varvolumeasu.msl" 1
 


















 CLASS VarVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES VarVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable volume";
   interface <-  
   {
    OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
      := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 

   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : EnergyForMixing := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume	 ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : EnergyIndex:= {: group <- "Mixing":};
   };

   initial <-
   {
   state.Integ_AE = 0.0 ;
   state.Integ_ME = 0.0 ;
   };

   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;


 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
    DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
    interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
   };   
 :};



# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.activated_sludge_units.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.activated_sludge_units.fixvolumefixoxyasu.msl" 1
 


















 CLASS FixVolumeFixOxyASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES FixVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a fixed volume and controlled DO";
   interface <-  
   {
    OBJ DOsp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Dissolved Oxygen setpoint" : Concentration := {: causality <- "CIN" ; value <- 0.5 ; group <- "Operational" :};
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
    OBJ Kla (* terminal = "out_2"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Operational" :};   

	 OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge" : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :};

	 OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
	 OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };   

   parameters <- 
   {
	  
	 OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : EnergyForMixing := {: value <- 0.005; group <- "Mixing energy":};
	 OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
	 OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
   };
 
   state <-
   {
	 OBJ Kinetics_Aeration (* hidden = "1" *) : OxygenUptakeRate ;
	 OBJ O2_Consumption "O2 consumed by reactions" : OxygenUptakeRate := {: group <- "Aeration" :} ;
	  
	 OBJ Integ_AE (* hidden = "1" *) "Integral aeration energy" : Volume ;
	  
	 OBJ Integ_ME (* hidden = "1" *) "Integral mixing energy" : ElectricalEnergy ;
	 OBJ ME_Instant (* hidden = "1" *) "Instantaneous mixing energy" : EnergyIndex := {: group <- "Mixing":};
   };


   initial <-
   {
	 state.M[S_O] = parameters.Vol * interface.DOsp ;
	 state.C[S_O] = interface.DOsp ;
	 state.Integ_AE = 0.0 ;
	 state.Integ_ME = 0.0 ;
   };

   equations <- 
   {

	 state.Temp_Actual = interface.Temp;


	 state.O2_Consumption =  - state.ConversionTermPerComponent[S_O] / state.V
	 	+ parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration]  ; 

	 state.Kinetics_Aeration = ((state.Q_In * interface.DOsp - interface.Inflow[S_O]) / state.V
	 	+ previous(state.O2_Consumption)) / parameters.Stoichiometry[Aeration][S_O] ; 

	 state.Kla_Actual = state.Kinetics_Aeration / (state.S_O_Saturation - interface.DOsp) ;
	 
	 interface.Kla = state.Kla_Actual ;
	
	  
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
    DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
    interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 
	  
	 state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0)) THEN parameters.ME_unit * state.V
		ELSE IF (parameters.Mixing_When_Aerated == 1)
			 THEN parameters.ME_unit * state.V
			 ELSE 0 ;    

     
    interface.MixingPower = state.ME_Instant ;
    DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
    interface.MixingEnergy = state.Integ_ME ; 
   };   

 :};



# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.activated_sludge_units.msl" 2




# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 1
 


















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 1
 


















CLASS  FixVolumeTwoTank SPECIALISES CoupledModelType :=
{:
 interface <-
 {
  OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :},
  OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent" :},

  OBJ Temp (* terminal = "in_2"; manip = "1" *) "Temperature of the activated sludge" : CelsiusTemperature := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  OBJ Kla1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU1" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ Kla2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU2" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy1 (* terminal = "out_2" *)"Aeration energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower1 (* terminal = "out_2" *) "Aeration power for ASU1" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy1 (* terminal = "out_2" *)"Mixing energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower1 (* terminal = "out_2" *) "Mixing power for ASU1" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ AerationEnergy2 (* terminal = "out_2" *)"Aeration energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower2 (* terminal = "out_2" *) "Aeration power for ASU2" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy2 (* terminal = "out_2" *)"Mixing energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower2 (* terminal = "out_2" *) "Mixing power for ASU2" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  


   
    OBJ DO_ASU1 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU1" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU1 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU1 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU1 (* terminal = "out_2" *)"Total suspended solids concentration in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU1 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU1 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU1 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU1 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU1 (* terminal = "out_2" *)"Volume measurement data in ASU1" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU1 (* terminal = "out_2" *)"OUR measurement data in ASU1" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU1 (* terminal = "out_2" *)"NUR measurement data in ASU1" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU1 (* terminal = "out_2" *)"NPR measurement data in ASU1" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU1 (* terminal = "out_2" *)"AUR measurement data in ASU1" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU1 (* terminal = "out_2" *)"Kla measurement data in ASU1" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
 
    OBJ DO_ASU2 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU2" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU2 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU2 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU2 (* terminal = "out_2" *)"Total suspended solids concentration in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU2 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU2 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU2 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU2 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU2 (* terminal = "out_2" *)"Volume measurement data in ASU2" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU2 (* terminal = "out_2" *)"OUR measurement data in ASU2" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU2 (* terminal = "out_2" *)"NUR measurement data in ASU2" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU2 (* terminal = "out_2" *)"NPR measurement data in ASU2" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU2 (* terminal = "out_2" *)"AUR measurement data in ASU2" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU2 (* terminal = "out_2" *)"Kla measurement data in ASU2" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 40 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2


 };

 parameters <-
 {
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.parameters.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.parameters.msl" 2






























# 46 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

  OBJ Vol1 (* is_favorite = "1" *) "Volume of ASU1" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  OBJ Vol2 (* is_favorite = "1" *) "Volume of ASU2" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
 };

 sub_models <-
 {
  OBJ ASU1 : FixVolumeASU,
  OBJ ASU2 : FixVolumeASU,
 };

 coupling <-
 {
   
  sub_models.ASU1.parameters.Vol.value := parameters.Vol1.value,
  sub_models.ASU2.parameters.Vol.value := parameters.Vol2.value,


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 


















  sub_models.ASU1.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU2.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU1.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU2.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU1.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU2.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU1.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU2.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU1.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU2.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU1.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU2.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU1.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU2.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU1.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU2.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU1.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU2.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU1.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU2.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU1.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU2.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU1.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU2.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU1.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU2.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU1.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU2.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU1.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU2.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU1.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU2.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU1.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU2.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU1.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU2.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU1.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU2.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU1.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU2.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU1.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU2.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU1.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU2.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU1.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU2.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU1.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU2.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU1.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU2.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU1.parameters.K_OA.value := parameters.K_OA.value,
  sub_models.ASU2.parameters.K_OA.value := parameters.K_OA.value,


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 64 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 

















  connect(sub_models.ASU1.interface.DO, interface.DO_ASU1),
  connect(sub_models.ASU2.interface.DO, interface.DO_ASU2),
  connect(sub_models.ASU1.interface.NH4, interface.NH4_ASU1),
  connect(sub_models.ASU2.interface.NH4, interface.NH4_ASU2),
  connect(sub_models.ASU1.interface.NO3, interface.NO3_ASU1),
  connect(sub_models.ASU2.interface.NO3, interface.NO3_ASU2),
  connect(sub_models.ASU1.interface.TSS, interface.TSS_ASU1),
  connect(sub_models.ASU2.interface.TSS, interface.TSS_ASU2),
  connect(sub_models.ASU1.interface.OnlineCOD, interface.OnlineCOD_ASU1),
  connect(sub_models.ASU2.interface.OnlineCOD, interface.OnlineCOD_ASU2),
  connect(sub_models.ASU1.interface.OfflineBOD, interface.OfflineBOD_ASU1),
  connect(sub_models.ASU2.interface.OfflineBOD, interface.OfflineBOD_ASU2),
  connect(sub_models.ASU1.interface.OnlineTN, interface.OnlineTN_ASU1),
  connect(sub_models.ASU2.interface.OnlineTN, interface.OnlineTN_ASU2),
  connect(sub_models.ASU1.interface.OfflineTKN, interface.OfflineTKN_ASU1),
  connect(sub_models.ASU2.interface.OfflineTKN, interface.OfflineTKN_ASU2),
  connect(sub_models.ASU1.interface.V_ASU, interface.V_ASU1),
  connect(sub_models.ASU2.interface.V_ASU, interface.V_ASU2),
  connect(sub_models.ASU1.interface.OUR_ASU, interface.OUR_ASU1),
  connect(sub_models.ASU2.interface.OUR_ASU, interface.OUR_ASU2),
  connect(sub_models.ASU1.interface.NUR, interface.NUR_ASU1),
  connect(sub_models.ASU2.interface.NUR, interface.NUR_ASU2),
  connect(sub_models.ASU1.interface.NPR, interface.NPR_ASU1),
  connect(sub_models.ASU2.interface.NPR, interface.NPR_ASU2),
  connect(sub_models.ASU1.interface.AUR, interface.AUR_ASU1),
  connect(sub_models.ASU2.interface.AUR, interface.AUR_ASU2),
  connect(sub_models.ASU1.interface.Kla_ASU, interface.Kla_ASU1),
  connect(sub_models.ASU2.interface.Kla_ASU, interface.Kla_ASU2),



# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2




  sub_models.ASU1.parameters.Temp_Ref.value := parameters.Temp_Ref.value,
  sub_models.ASU2.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   
  connect(interface.Inflow, sub_models.ASU1.interface.Inflow),
  connect(sub_models.ASU1.interface.Outflow, sub_models.ASU2.interface.Inflow),
  connect(interface.Kla1, sub_models.ASU1.interface.Kla),
  connect(interface.Kla2, sub_models.ASU2.interface.Kla),
  connect(sub_models.ASU1.interface.AerationPower, interface.AerationPower1),
  connect(sub_models.ASU2.interface.AerationPower, interface.AerationPower2),
  connect(sub_models.ASU1.interface.AerationEnergy, interface.AerationEnergy1),
  connect(sub_models.ASU2.interface.AerationEnergy, interface.AerationEnergy2),
  connect(sub_models.ASU1.interface.MixingEnergy, interface.MixingEnergy1),
  connect(sub_models.ASU2.interface.MixingEnergy, interface.MixingEnergy2),
  connect(sub_models.ASU1.interface.MixingPower, interface.MixingPower1),
  connect(sub_models.ASU2.interface.MixingPower, interface.MixingPower2),

  connect(interface.Temp, sub_models.ASU1.interface.Temp),
  connect(interface.Temp, sub_models.ASU2.interface.Temp),

 };
:};


# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasutwotank.msl" 1
 



















CLASS  FixVolumeASUTwoTank (* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTwoTank:=
{:

  comments <- "A coupled model for two activated sludge units in series";
  
  interface <-
  {
    



    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };
  
  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS)) / interface.V_Tot ;
  };

  coupling <-
  {
     
    connect(sub_models.ASU2.interface.Outflow, interface.Outflow),

    



  };

:};



# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 1
 


















CLASS  FixVolumeThreeTank
EXTENDS FixVolumeTwoTank WITH
{:

 sub_models <-
 {

  OBJ ASU3 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU3" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy3 (* terminal = "out_2" *)"Aeration energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower3 (* terminal = "out_2" *) "Aeration power for ASU3" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy3 (* terminal = "out_2" *)"Mixing energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower3 (* terminal = "out_2" *) "Mixing power for ASU3" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU3 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU3" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU3 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU3 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU3 (* terminal = "out_2" *)"Total suspended solids concentration in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU3 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU3 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU3 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU3 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU3 (* terminal = "out_2" *)"Volume measurement data in ASU3" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU3 (* terminal = "out_2" *)"OUR measurement data in ASU3" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU3 (* terminal = "out_2" *)"NUR measurement data in ASU3" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU3 (* terminal = "out_2" *)"NPR measurement data in ASU3" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU3 (* terminal = "out_2" *)"AUR measurement data in ASU3" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU3 (* terminal = "out_2" *)"Kla measurement data in ASU3" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol3 (* is_favorite = "1" *) "Volume of ASU3" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU3.parameters.Vol.value := parameters.Vol3.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU3.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU3.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU3.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU3.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU3.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU3.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU3.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU3.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU3.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU3.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU3.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU3.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU3.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU3.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU3.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU3.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU3.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU3.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU3.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU3.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU3.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU3.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU3.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU3.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU3.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU3.parameters.K_OA.value := parameters.K_OA.value,


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU3.interface.DO, interface.DO_ASU3),
  connect(sub_models.ASU3.interface.NH4, interface.NH4_ASU3),
  connect(sub_models.ASU3.interface.NO3, interface.NO3_ASU3),
  connect(sub_models.ASU3.interface.TSS, interface.TSS_ASU3),
  connect(sub_models.ASU3.interface.OnlineCOD, interface.OnlineCOD_ASU3),
  connect(sub_models.ASU3.interface.OfflineBOD, interface.OfflineBOD_ASU3),
  connect(sub_models.ASU3.interface.OnlineTN, interface.OnlineTN_ASU3),
  connect(sub_models.ASU3.interface.OfflineTKN, interface.OfflineTKN_ASU3),
  connect(sub_models.ASU3.interface.V_ASU, interface.V_ASU3),
  connect(sub_models.ASU3.interface.OUR_ASU, interface.OUR_ASU3),
  connect(sub_models.ASU3.interface.NUR, interface.NUR_ASU3),
  connect(sub_models.ASU3.interface.NPR, interface.NPR_ASU3),
  connect(sub_models.ASU3.interface.AUR, interface.AUR_ASU3),
  connect(sub_models.ASU3.interface.Kla_ASU, interface.Kla_ASU3),


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

 


  sub_models.ASU3.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU2.interface.Outflow, sub_models.ASU3.interface.Inflow),
  connect(interface.Kla3, sub_models.ASU3.interface.Kla),
  connect(sub_models.ASU3.interface.AerationPower, interface.AerationPower3),
  connect(sub_models.ASU3.interface.AerationEnergy, interface.AerationEnergy3),
  connect(sub_models.ASU3.interface.MixingPower, interface.MixingPower3),
  connect(sub_models.ASU3.interface.MixingEnergy, interface.MixingEnergy3),

  connect(interface.Temp, sub_models.ASU3.interface.Temp),


 };
:};



# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasuthreetank.msl" 1
 



















CLASS  FixVolumeASUThreeTank (* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeThreeTank:=
{:

  comments <- "A coupled model for three activated sludge units in series";
  
  interface <-
  {
    




    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS)) / interface.V_Tot ;
  };

  coupling <-
  {
     
    connect(sub_models.ASU3.interface.Outflow, interface.Outflow),
    
    




  };

:};



# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 1
 


















CLASS  FixVolumeFourTank
EXTENDS FixVolumeThreeTank WITH
{:

 sub_models <-
 {

  OBJ ASU4 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU4" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy4 (* terminal = "out_2" *)"Aeration energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower4 (* terminal = "out_2" *) "Aeration power for ASU4" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy4 (* terminal = "out_2" *)"Mixing energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower4 (* terminal = "out_2" *) "Mixing power for ASU4" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU4 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU4" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU4 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU4 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU4 (* terminal = "out_2" *)"Total suspended solids concentration in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU4 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU4 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU4 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU4 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU4 (* terminal = "out_2" *)"Volume measurement data in ASU4" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU4 (* terminal = "out_2" *)"OUR measurement data in ASU4" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU4 (* terminal = "out_2" *)"NUR measurement data in ASU4" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU4 (* terminal = "out_2" *)"NPR measurement data in ASU4" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU4 (* terminal = "out_2" *)"AUR measurement data in ASU4" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU4 (* terminal = "out_2" *)"Kla measurement data in ASU4" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol4 (* is_favorite = "1" *) "Volume of ASU4" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU4.parameters.Vol.value := parameters.Vol4.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU4.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU4.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU4.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU4.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU4.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU4.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU4.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU4.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU4.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU4.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU4.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU4.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU4.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU4.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU4.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU4.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU4.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU4.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU4.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU4.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU4.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU4.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU4.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU4.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU4.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU4.parameters.K_OA.value := parameters.K_OA.value,



# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU4.interface.DO, interface.DO_ASU4),
  connect(sub_models.ASU4.interface.NH4, interface.NH4_ASU4),
  connect(sub_models.ASU4.interface.NO3, interface.NO3_ASU4),
  connect(sub_models.ASU4.interface.TSS, interface.TSS_ASU4),
  connect(sub_models.ASU4.interface.OnlineCOD, interface.OnlineCOD_ASU4),
  connect(sub_models.ASU4.interface.OfflineBOD, interface.OfflineBOD_ASU4),
  connect(sub_models.ASU4.interface.OnlineTN, interface.OnlineTN_ASU4),
  connect(sub_models.ASU4.interface.OfflineTKN, interface.OfflineTKN_ASU4),
  connect(sub_models.ASU4.interface.V_ASU, interface.V_ASU4),
  connect(sub_models.ASU4.interface.OUR_ASU, interface.OUR_ASU4),
  connect(sub_models.ASU4.interface.NUR, interface.NUR_ASU4),
  connect(sub_models.ASU4.interface.NPR, interface.NPR_ASU4),
  connect(sub_models.ASU4.interface.AUR, interface.AUR_ASU4),
  connect(sub_models.ASU4.interface.Kla_ASU, interface.Kla_ASU4),


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

 


  sub_models.ASU4.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU3.interface.Outflow, sub_models.ASU4.interface.Inflow),
  connect(interface.Kla4, sub_models.ASU4.interface.Kla),
  connect(sub_models.ASU4.interface.AerationPower, interface.AerationPower4),
  connect(sub_models.ASU4.interface.AerationEnergy, interface.AerationEnergy4),
  connect(sub_models.ASU4.interface.MixingPower, interface.MixingPower4),
  connect(sub_models.ASU4.interface.MixingEnergy, interface.MixingEnergy4),

  connect(interface.Temp, sub_models.ASU4.interface.Temp),


 };
:};



# 27 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasufourtank.msl" 1
 



















CLASS  FixVolumeASUFourTank (* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFourTank:=
{:

  comments <- "A coupled model for four activated sludge units in series";
  
  interface <-
  {
    





    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V + sub_models.ASU4.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS) + (sub_models.ASU4.state.V * sub_models.ASU4.interface.TSS)) / interface.V_Tot ;
  };

  coupling <-
  {
     
    connect(sub_models.ASU4.interface.Outflow, interface.Outflow),

    





  };

:};



# 28 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 1
 


















CLASS  FixVolumeFiveTank
EXTENDS FixVolumeFourTank WITH
{:

 sub_models <-
 {

  OBJ ASU5 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU5" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy5 (* terminal = "out_2" *)"Aeration energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower5 (* terminal = "out_2" *) "Aeration power for ASU5" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy5 (* terminal = "out_2" *)"Mixing energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower5 (* terminal = "out_2" *) "Mixing power for ASU5" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU5 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU5" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU5 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU5 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU5 (* terminal = "out_2" *)"Total suspended solids concentration in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU5 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU5 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU5 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU5 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU5 (* terminal = "out_2" *)"Volume measurement data in ASU5" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU5 (* terminal = "out_2" *)"OUR measurement data in ASU5" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU5 (* terminal = "out_2" *)"NUR measurement data in ASU5" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU5 (* terminal = "out_2" *)"NPR measurement data in ASU5" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU5 (* terminal = "out_2" *)"AUR measurement data in ASU5" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU5 (* terminal = "out_2" *)"Kla measurement data in ASU5" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol5 (* is_favorite = "1" *) "Volume of ASU5" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU5.parameters.Vol.value := parameters.Vol5.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU5.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU5.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU5.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU5.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU5.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU5.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU5.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU5.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU5.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU5.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU5.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU5.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU5.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU5.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU5.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU5.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU5.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU5.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU5.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU5.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU5.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU5.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU5.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU5.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU5.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU5.parameters.K_OA.value := parameters.K_OA.value,


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU5.interface.DO, interface.DO_ASU5),
  connect(sub_models.ASU5.interface.NH4, interface.NH4_ASU5),
  connect(sub_models.ASU5.interface.NO3, interface.NO3_ASU5),
  connect(sub_models.ASU5.interface.TSS, interface.TSS_ASU5),
  connect(sub_models.ASU5.interface.OnlineCOD, interface.OnlineCOD_ASU5),
  connect(sub_models.ASU5.interface.OfflineBOD, interface.OfflineBOD_ASU5),
  connect(sub_models.ASU5.interface.OnlineTN, interface.OnlineTN_ASU5),
  connect(sub_models.ASU5.interface.OfflineTKN, interface.OfflineTKN_ASU5),
  connect(sub_models.ASU5.interface.V_ASU, interface.V_ASU5),
  connect(sub_models.ASU5.interface.OUR_ASU, interface.OUR_ASU5),
  connect(sub_models.ASU5.interface.NUR, interface.NUR_ASU5),
  connect(sub_models.ASU5.interface.NPR, interface.NPR_ASU5),
  connect(sub_models.ASU5.interface.AUR, interface.AUR_ASU5),
  connect(sub_models.ASU5.interface.Kla_ASU, interface.Kla_ASU5),


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

 


  sub_models.ASU5.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU4.interface.Outflow, sub_models.ASU5.interface.Inflow),
  connect(interface.Kla5, sub_models.ASU5.interface.Kla),
  connect(sub_models.ASU5.interface.AerationEnergy, interface.AerationEnergy5),
  connect(sub_models.ASU5.interface.AerationPower, interface.AerationPower5),
  connect(sub_models.ASU5.interface.MixingEnergy, interface.MixingEnergy5),
  connect(sub_models.ASU5.interface.MixingPower, interface.MixingPower5),

  connect(interface.Temp, sub_models.ASU5.interface.Temp),


 };
:};



# 30 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasufivetank.msl" 1
 


















CLASS  FixVolumeASUFiveTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFiveTank:=
{:
 comments <- "A coupled model for five activated sludge units in series";

  interface <-
  {
    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V + sub_models.ASU4.state.V + sub_models.ASU5.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS) + (sub_models.ASU4.state.V * sub_models.ASU4.interface.TSS)  + (sub_models.ASU5.state.V * sub_models.ASU5.interface.TSS)) / interface.V_Tot ;
  };

  coupling <-
 {
   
  connect(sub_models.ASU5.interface.Outflow, interface.Outflow),
 };
:};



# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 1
 


















CLASS  FixVolumeSixTank
EXTENDS FixVolumeFiveTank WITH
{:

 sub_models <-
 {

  OBJ ASU6 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU6" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy6 (* terminal = "out_2" *)"Aeration energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower6 (* terminal = "out_2" *) "Aeration power for ASU6" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy6 (* terminal = "out_2" *)"Mixing energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower6 (* terminal = "out_2" *) "Mixing power for ASU6" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU6 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU6" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU6 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU6 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU6 (* terminal = "out_2" *)"Total suspended solids concentration in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU6 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU6 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU6 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU6 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU6 (* terminal = "out_2" *)"Volume measurement data in ASU6" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU6 (* terminal = "out_2" *)"OUR measurement data in ASU6" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU6 (* terminal = "out_2" *)"NUR measurement data in ASU6" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU6 (* terminal = "out_2" *)"NPR measurement data in ASU6" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU6 (* terminal = "out_2" *)"AUR measurement data in ASU6" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU6 (* terminal = "out_2" *)"Kla measurement data in ASU6" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol6 (* is_favorite = "1" *) "Volume of ASU6" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU6.parameters.Vol.value := parameters.Vol6.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU6.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU6.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU6.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU6.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU6.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU6.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU6.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU6.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU6.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU6.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU6.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU6.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU6.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU6.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU6.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU6.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU6.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU6.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU6.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU6.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU6.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU6.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU6.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU6.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU6.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU6.parameters.K_OA.value := parameters.K_OA.value,


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU6.interface.DO, interface.DO_ASU6),
  connect(sub_models.ASU6.interface.NH4, interface.NH4_ASU6),
  connect(sub_models.ASU6.interface.NO3, interface.NO3_ASU6),
  connect(sub_models.ASU6.interface.TSS, interface.TSS_ASU6),
  connect(sub_models.ASU6.interface.OnlineCOD, interface.OnlineCOD_ASU6),
  connect(sub_models.ASU6.interface.OfflineBOD, interface.OfflineBOD_ASU6),
  connect(sub_models.ASU6.interface.OnlineTN, interface.OnlineTN_ASU6),
  connect(sub_models.ASU6.interface.OfflineTKN, interface.OfflineTKN_ASU6),
  connect(sub_models.ASU6.interface.V_ASU, interface.V_ASU6),
  connect(sub_models.ASU6.interface.OUR_ASU, interface.OUR_ASU6),
  connect(sub_models.ASU6.interface.NUR, interface.NUR_ASU6),
  connect(sub_models.ASU6.interface.NPR, interface.NPR_ASU6),
  connect(sub_models.ASU6.interface.AUR, interface.AUR_ASU6),
  connect(sub_models.ASU6.interface.Kla_ASU, interface.Kla_ASU6),


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

 


  sub_models.ASU6.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU5.interface.Outflow, sub_models.ASU6.interface.Inflow),
  connect(interface.Kla6, sub_models.ASU6.interface.Kla),
  connect(sub_models.ASU6.interface.AerationEnergy, interface.AerationEnergy6),
  connect(sub_models.ASU6.interface.AerationPower, interface.AerationPower6),
  connect(sub_models.ASU6.interface.MixingEnergy, interface.MixingEnergy6),
  connect(sub_models.ASU6.interface.MixingPower, interface.MixingPower6),

  connect(interface.Temp, sub_models.ASU6.interface.Temp),


 };
:};



# 33 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasusixtank.msl" 1
 


















CLASS  FixVolumeASUSixTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSixTank:=
{:
 comments <- "A coupled model for six activated sludge units in series";

  interface <-
  {
    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V + sub_models.ASU4.state.V + sub_models.ASU5.state.V +
      sub_models.ASU6.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS) + (sub_models.ASU4.state.V * sub_models.ASU4.interface.TSS) + (sub_models.ASU5.state.V * sub_models.ASU5.interface.TSS) +
      (sub_models.ASU6.state.V * sub_models.ASU6.interface.TSS)) / interface.V_Tot ;
  };

 coupling <-
 {
   
  connect(sub_models.ASU6.interface.Outflow, interface.Outflow),
 };
:};



# 34 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 1
 


















CLASS  FixVolumeSevenTank
EXTENDS FixVolumeSixTank WITH
{:

 sub_models <-
 {

  OBJ ASU7 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU7" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy7 (* terminal = "out_2" *)"Aeration energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower7 (* terminal = "out_2" *) "Aeration power for ASU7" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy7 (* terminal = "out_2" *)"Mixing energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower7 (* terminal = "out_2" *) "Mixing power for ASU7" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU7 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU7" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU7 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU7 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU7 (* terminal = "out_2" *)"Total suspended solids concentration in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU7 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU7 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU7 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU7 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU7 (* terminal = "out_2" *)"Volume measurement data in ASU7" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU7 (* terminal = "out_2" *)"OUR measurement data in ASU7" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU7 (* terminal = "out_2" *)"NUR measurement data in ASU7" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU7 (* terminal = "out_2" *)"NPR measurement data in ASU7" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU7 (* terminal = "out_2" *)"AUR measurement data in ASU7" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU7 (* terminal = "out_2" *)"Kla measurement data in ASU7" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol7 (* is_favorite = "1" *) "Volume of ASU7" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU7.parameters.Vol.value := parameters.Vol7.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU7.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU7.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU7.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU7.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU7.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU7.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU7.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU7.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU7.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU7.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU7.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU7.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU7.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU7.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU7.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU7.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU7.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU7.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU7.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU7.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU7.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU7.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU7.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU7.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU7.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU7.parameters.K_OA.value := parameters.K_OA.value,


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU7.interface.DO, interface.DO_ASU7),
  connect(sub_models.ASU7.interface.NH4, interface.NH4_ASU7),
  connect(sub_models.ASU7.interface.NO3, interface.NO3_ASU7),
  connect(sub_models.ASU7.interface.TSS, interface.TSS_ASU7),
  connect(sub_models.ASU7.interface.OnlineCOD, interface.OnlineCOD_ASU7),
  connect(sub_models.ASU7.interface.OfflineBOD, interface.OfflineBOD_ASU7),
  connect(sub_models.ASU7.interface.OnlineTN, interface.OnlineTN_ASU7),
  connect(sub_models.ASU7.interface.OfflineTKN, interface.OfflineTKN_ASU7),
  connect(sub_models.ASU7.interface.V_ASU, interface.V_ASU7),
  connect(sub_models.ASU7.interface.OUR_ASU, interface.OUR_ASU7),
  connect(sub_models.ASU7.interface.NUR, interface.NUR_ASU7),
  connect(sub_models.ASU7.interface.NPR, interface.NPR_ASU7),
  connect(sub_models.ASU7.interface.AUR, interface.AUR_ASU7),
  connect(sub_models.ASU7.interface.Kla_ASU, interface.Kla_ASU7),


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

 


  sub_models.ASU7.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU6.interface.Outflow, sub_models.ASU7.interface.Inflow),
  connect(interface.Kla7, sub_models.ASU7.interface.Kla),
  connect(sub_models.ASU7.interface.AerationEnergy, interface.AerationEnergy7),
  connect(sub_models.ASU7.interface.AerationPower, interface.AerationPower7),
  connect(sub_models.ASU7.interface.MixingEnergy, interface.MixingEnergy7),
  connect(sub_models.ASU7.interface.MixingPower, interface.MixingPower7),

  connect(interface.Temp, sub_models.ASU7.interface.Temp),


 };
:};



# 36 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasuseventank.msl" 1
 


















CLASS  FixVolumeASUSevenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSevenTank:=
{:
 comments <- "A coupled model for seven activated sludge units in series";

  interface <-
  {
    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V + sub_models.ASU4.state.V + sub_models.ASU5.state.V +
      sub_models.ASU6.state.V + sub_models.ASU7.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS) + (sub_models.ASU4.state.V * sub_models.ASU4.interface.TSS) + (sub_models.ASU5.state.V * sub_models.ASU5.interface.TSS) +
      (sub_models.ASU6.state.V * sub_models.ASU6.interface.TSS) + (sub_models.ASU7.state.V * sub_models.ASU7.interface.TSS)) / interface.V_Tot ;
  };

 coupling <-
 {
   
  connect(sub_models.ASU7.interface.Outflow, interface.Outflow),
 };
:};



# 37 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 1
 


















CLASS  FixVolumeEightTank
EXTENDS FixVolumeSevenTank WITH
{:

 sub_models <-
 {

  OBJ ASU8 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU8" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy8 (* terminal = "out_2" *)"Aeration energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower8 (* terminal = "out_2" *) "Aeration power for ASU8" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy8 (* terminal = "out_2" *)"Mixing energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower8 (* terminal = "out_2" *) "Mixing power for ASU8" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU8 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU8" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU8 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU8 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU8 (* terminal = "out_2" *)"Total suspended solids concentration in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU8 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU8 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU8 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU8 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU8 (* terminal = "out_2" *)"Volume measurement data in ASU8" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU8 (* terminal = "out_2" *)"OUR measurement data in ASU8" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU8 (* terminal = "out_2" *)"NUR measurement data in ASU8" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU8 (* terminal = "out_2" *)"NPR measurement data in ASU8" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU8 (* terminal = "out_2" *)"AUR measurement data in ASU8" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU8 (* terminal = "out_2" *)"Kla measurement data in ASU8" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol8 (* is_favorite = "1" *) "Volume of ASU8" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU8.parameters.Vol.value := parameters.Vol8.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU8.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU8.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU8.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU8.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU8.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU8.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU8.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU8.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU8.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU8.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU8.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU8.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU8.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU8.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU8.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU8.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU8.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU8.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU8.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU8.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU8.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU8.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU8.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU8.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU8.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU8.parameters.K_OA.value := parameters.K_OA.value,


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU8.interface.DO, interface.DO_ASU8),
  connect(sub_models.ASU8.interface.NH4, interface.NH4_ASU8),
  connect(sub_models.ASU8.interface.NO3, interface.NO3_ASU8),
  connect(sub_models.ASU8.interface.TSS, interface.TSS_ASU8),
  connect(sub_models.ASU8.interface.OnlineCOD, interface.OnlineCOD_ASU8),
  connect(sub_models.ASU8.interface.OfflineBOD, interface.OfflineBOD_ASU8),
  connect(sub_models.ASU8.interface.OnlineTN, interface.OnlineTN_ASU8),
  connect(sub_models.ASU8.interface.OfflineTKN, interface.OfflineTKN_ASU8),
  connect(sub_models.ASU8.interface.V_ASU, interface.V_ASU8),
  connect(sub_models.ASU8.interface.OUR_ASU, interface.OUR_ASU8),
  connect(sub_models.ASU8.interface.NUR, interface.NUR_ASU8),
  connect(sub_models.ASU8.interface.NPR, interface.NPR_ASU8),
  connect(sub_models.ASU8.interface.AUR, interface.AUR_ASU8),
  connect(sub_models.ASU8.interface.Kla_ASU, interface.Kla_ASU8),


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

 


  sub_models.ASU8.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU7.interface.Outflow, sub_models.ASU8.interface.Inflow),
  connect(interface.Kla8, sub_models.ASU8.interface.Kla),
  connect(sub_models.ASU8.interface.AerationEnergy, interface.AerationEnergy8),
  connect(sub_models.ASU8.interface.AerationPower, interface.AerationPower8),
  connect(sub_models.ASU8.interface.MixingEnergy, interface.MixingEnergy8),
  connect(sub_models.ASU8.interface.MixingPower, interface.MixingPower8),

  connect(interface.Temp, sub_models.ASU8.interface.Temp),


 };
:};



# 39 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasueighttank.msl" 1
 


















CLASS  FixVolumeASUEightTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeEightTank:=
{:
 comments <- "A coupled model for eight activated sludge units in series";

  interface <-
  {
    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V + sub_models.ASU4.state.V + sub_models.ASU5.state.V +
      sub_models.ASU6.state.V + sub_models.ASU7.state.V + sub_models.ASU8.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS) + (sub_models.ASU4.state.V * sub_models.ASU4.interface.TSS) + (sub_models.ASU5.state.V * sub_models.ASU5.interface.TSS) +
      (sub_models.ASU6.state.V * sub_models.ASU6.interface.TSS) + (sub_models.ASU7.state.V * sub_models.ASU7.interface.TSS) + (sub_models.ASU8.state.V * sub_models.ASU8.interface.TSS)) / interface.V_Tot ;
  };

 coupling <-
 {
   
  connect(sub_models.ASU8.interface.Outflow, interface.Outflow),
 };
:};



# 40 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 1
 


















CLASS  FixVolumeNineTank
EXTENDS FixVolumeEightTank WITH
{:

 sub_models <-
 {

  OBJ ASU9 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla9 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU9" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy9 (* terminal = "out_2" *)"Aeration energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower9 (* terminal = "out_2" *) "Aeration power for ASU9" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy9 (* terminal = "out_2" *)"Mixing energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower9 (* terminal = "out_2" *) "Mixing power for ASU9" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU9 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU9" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU9 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU9 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU9 (* terminal = "out_2" *)"Total suspended solids concentration in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU9 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU9 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU9 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU9 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU9 (* terminal = "out_2" *)"Volume measurement data in ASU9" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU9 (* terminal = "out_2" *)"OUR measurement data in ASU9" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU9 (* terminal = "out_2" *)"NUR measurement data in ASU9" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU9 (* terminal = "out_2" *)"NPR measurement data in ASU9" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU9 (* terminal = "out_2" *)"AUR measurement data in ASU9" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU9 (* terminal = "out_2" *)"Kla measurement data in ASU9" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 195 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol9 (* is_favorite = "1" *) "Volume of ASU9" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU9.parameters.Vol.value := parameters.Vol9.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU9.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU9.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU9.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU9.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU9.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU9.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU9.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU9.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU9.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU9.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU9.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU9.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU9.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU9.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU9.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU9.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU9.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU9.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU9.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU9.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU9.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU9.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU9.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU9.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU9.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU9.parameters.K_OA.value := parameters.K_OA.value,


# 322 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU9.interface.DO, interface.DO_ASU9),
  connect(sub_models.ASU9.interface.NH4, interface.NH4_ASU9),
  connect(sub_models.ASU9.interface.NO3, interface.NO3_ASU9),
  connect(sub_models.ASU9.interface.TSS, interface.TSS_ASU9),
  connect(sub_models.ASU9.interface.OnlineCOD, interface.OnlineCOD_ASU9),
  connect(sub_models.ASU9.interface.OfflineBOD, interface.OfflineBOD_ASU9),
  connect(sub_models.ASU9.interface.OnlineTN, interface.OnlineTN_ASU9),
  connect(sub_models.ASU9.interface.OfflineTKN, interface.OfflineTKN_ASU9),
  connect(sub_models.ASU9.interface.V_ASU, interface.V_ASU9),
  connect(sub_models.ASU9.interface.OUR_ASU, interface.OUR_ASU9),
  connect(sub_models.ASU9.interface.NUR, interface.NUR_ASU9),
  connect(sub_models.ASU9.interface.NPR, interface.NPR_ASU9),
  connect(sub_models.ASU9.interface.AUR, interface.AUR_ASU9),
  connect(sub_models.ASU9.interface.Kla_ASU, interface.Kla_ASU9),


# 184 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

 


  sub_models.ASU9.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU8.interface.Outflow, sub_models.ASU9.interface.Inflow),
  connect(interface.Kla9, sub_models.ASU9.interface.Kla),
  connect(sub_models.ASU9.interface.AerationEnergy, interface.AerationEnergy9),
  connect(sub_models.ASU9.interface.AerationPower, interface.AerationPower9),
  connect(sub_models.ASU9.interface.MixingEnergy, interface.MixingEnergy9),
  connect(sub_models.ASU9.interface.MixingPower, interface.MixingPower9),

  connect(interface.Temp, sub_models.ASU9.interface.Temp),


 };
:};



# 42 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasuninetank.msl" 1
 


















CLASS  FixVolumeASUNineTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeNineTank:=
{:
 comments <- "A coupled model for nine activated sludge units in series";

  interface <-
  {
    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V + sub_models.ASU4.state.V + sub_models.ASU5.state.V +
      sub_models.ASU6.state.V + sub_models.ASU7.state.V + sub_models.ASU8.state.V + sub_models.ASU9.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS) + (sub_models.ASU4.state.V * sub_models.ASU4.interface.TSS) + (sub_models.ASU5.state.V * sub_models.ASU5.interface.TSS) +
      (sub_models.ASU6.state.V * sub_models.ASU6.interface.TSS) + (sub_models.ASU7.state.V * sub_models.ASU7.interface.TSS) + (sub_models.ASU8.state.V * sub_models.ASU8.interface.TSS) +
      (sub_models.ASU9.state.V * sub_models.ASU9.interface.TSS)) / interface.V_Tot ;
  };

 coupling <-
 {
   
  connect(sub_models.ASU9.interface.Outflow, interface.Outflow),
 };
:};



# 43 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 1
 


















CLASS  FixVolumeTenTank
EXTENDS FixVolumeNineTank WITH
{:

 sub_models <-
 {

  OBJ ASU10 : FixVolumeASU,
 };

 parameters <-  
 {
  OBJ Vol10 (* is_favorite = "1" *) "Volume of ASU10" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 interface <-
 {
  OBJ Kla10 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU10" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy10 (* terminal = "out_2" *)"Aeration energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ AerationPower10 (* terminal = "out_2" *) "Aeration power for ASU10" : Power := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy10 (* terminal = "out_2" *)"Mixing energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower10 (* terminal = "out_2" *) "Mixing power for ASU10" : Power := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU10 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU10" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU10 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU10 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU10 (* terminal = "out_2" *)"Total suspended solids concentration in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU10 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU10 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU10 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU10 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU10 (* terminal = "out_2" *)"Volume measurement data in ASU10" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU10 (* terminal = "out_2" *)"OUR measurement data in ASU10" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU10 (* terminal = "out_2" *)"NUR measurement data in ASU10" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU10 (* terminal = "out_2" *)"NPR measurement data in ASU10" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU10 (* terminal = "out_2" *)"AUR measurement data in ASU10" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU10 (* terminal = "out_2" *)"Kla measurement data in ASU10" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};



# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 43 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2


 };

 coupling <-
 {
   
  sub_models.ASU10.parameters.Vol.value := parameters.Vol10.value,
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU10.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU10.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU10.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU10.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU10.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU10.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU10.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU10.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU10.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU10.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU10.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU10.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU10.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU10.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU10.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU10.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU10.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU10.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU10.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU10.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU10.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU10.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU10.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU10.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU10.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU10.parameters.K_OA.value := parameters.K_OA.value,


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2


















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU10.interface.DO, interface.DO_ASU10),
  connect(sub_models.ASU10.interface.NH4, interface.NH4_ASU10),
  connect(sub_models.ASU10.interface.NO3, interface.NO3_ASU10),
  connect(sub_models.ASU10.interface.TSS, interface.TSS_ASU10),
  connect(sub_models.ASU10.interface.OnlineCOD, interface.OnlineCOD_ASU10),
  connect(sub_models.ASU10.interface.OfflineBOD, interface.OfflineBOD_ASU10),
  connect(sub_models.ASU10.interface.OnlineTN, interface.OnlineTN_ASU10),
  connect(sub_models.ASU10.interface.OfflineTKN, interface.OfflineTKN_ASU10),
  connect(sub_models.ASU10.interface.V_ASU, interface.V_ASU10),
  connect(sub_models.ASU10.interface.OUR_ASU, interface.OUR_ASU10),
  connect(sub_models.ASU10.interface.NUR, interface.NUR_ASU10),
  connect(sub_models.ASU10.interface.NPR, interface.NPR_ASU10),
  connect(sub_models.ASU10.interface.AUR, interface.AUR_ASU10),
  connect(sub_models.ASU10.interface.Kla_ASU, interface.Kla_ASU10),


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2


















# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

 


  sub_models.ASU10.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU9.interface.Outflow, sub_models.ASU10.interface.Inflow),
  connect(interface.Kla10, sub_models.ASU10.interface.Kla),
  connect(sub_models.ASU10.interface.AerationEnergy, interface.AerationEnergy10),
  connect(sub_models.ASU10.interface.AerationPower, interface.AerationPower10),
  connect(sub_models.ASU10.interface.MixingEnergy, interface.MixingEnergy10),
  connect(sub_models.ASU10.interface.MixingPower, interface.MixingPower10),

  connect(interface.Temp, sub_models.ASU10.interface.Temp),


 };
:};



# 45 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.n_tanks.fixvolumeasutentank.msl" 1
 


















CLASS  FixVolumeASUTenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTenTank:=
{:
 comments <- "A coupled model for ten activated sludge units in series";

  interface <-
  {
    OBJ V_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total volume" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_Tot (* terminal = "out_2"; is_favorite = "1" *) "Average TSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    interface.V_Tot = sub_models.ASU1.state.V + sub_models.ASU2.state.V + sub_models.ASU3.state.V + sub_models.ASU4.state.V + sub_models.ASU5.state.V +
      sub_models.ASU6.state.V + sub_models.ASU7.state.V + sub_models.ASU8.state.V + sub_models.ASU9.state.V + sub_models.ASU10.state.V ;
    interface.TSS_Tot = IF (interface.V_Tot <= 0.0) THEN 0.0
      ELSE ((sub_models.ASU1.state.V * sub_models.ASU1.interface.TSS) + (sub_models.ASU2.state.V * sub_models.ASU2.interface.TSS) +
      (sub_models.ASU3.state.V * sub_models.ASU3.interface.TSS) + (sub_models.ASU4.state.V * sub_models.ASU4.interface.TSS) + (sub_models.ASU5.state.V * sub_models.ASU5.interface.TSS) +
      (sub_models.ASU6.state.V * sub_models.ASU6.interface.TSS) + (sub_models.ASU7.state.V * sub_models.ASU7.interface.TSS) + (sub_models.ASU8.state.V * sub_models.ASU8.interface.TSS) +
      (sub_models.ASU9.state.V * sub_models.ASU9.interface.TSS) + (sub_models.ASU10.state.V * sub_models.ASU10.interface.TSS)) / interface.V_Tot ;
  };

 coupling <-
 {
   
  connect(sub_models.ASU10.interface.Outflow, interface.Outflow),
 };
:};



# 46 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.n_tanks.msl" 2



# 32 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.SBR.msl" 1
 


















CLASS SBRAtomicModel SPECIALISES PhysicalDAEModelType :=
  {:
  
  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "influent" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :};
  OBJ Outflow1 (* terminal = "out_1" *) "effluent" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 1" :};
  };
  
  parameters <- 
  {
   
    OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components": SpecificVolumeVector;
  
   
    OBJ Q_Waste (* is_favorite = "1" *) "Desired waste flow rate during the idle phase" : FlowRate := {: value <- 240; group <- "Operational" :};
  };

  independent <- 
  { 
    OBJ t "Time": Time := {: group <- "Time" :};
  };
    
  state <-
  
  {
    OBJ ConversionTermPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ V (* is_favorite = "1" *) "Volume in the tank" : Volume := {: group <- "Dimension" :};
    OBJ C "Concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
 
    OBJ FluxPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Incoming massflux per component" : MassFluxVector;
 
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
 
    OBJ M "Vector containing masses for all the components" : MassVector 

         := [{: value <- 1000000000:},{: value <- 1 :},
                  {: value <- 2 :},{: value <- 1 :},
                {: value <- 2 :}, {: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                                {: value <- 1000 :},{: value <- 100 :},
                {: value <- 1 :},{: value <- 1 :}; ]

































# 107 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.SBR.msl"

# 116 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.SBR.msl"

# 127 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.SBR.msl"

;
    };
  
  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    };  

  equations <- 
   {
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
       (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
         In_Terminal[Comp_Index])+
       (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
         Out_Terminal[Comp_Index]);
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
     };
   
 
    state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]);

 
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     (parameters.WWTPSpecificVolume[Comp_Index] * state.M[Comp_Index]);

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.C[Comp_Index] = IF (state.V == 0)
                   THEN 0
                 ELSE state.M[Comp_Index]/state.V;
     };  
    };  
    :};


CLASS SBRConversionModel EXTENDS SBRAtomicModel WITH
 {:
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
    OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
    OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 171 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.SBR.msl" 2

 :};


CLASS SBRASMConversionModel EXTENDS SBRConversionModel WITH
 {:
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 15.000000; :}; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; unit <- "1/d"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 5000.000000; :}; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; unit <- "m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.state.msl" 1
 

    OBJ K_X_Temp (* *) "K_X at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ b_A_Temp (* *) "b_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H_Temp (* *) "b_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_a_Temp (* *) "k_a at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_h_Temp (* *) "k_h at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_A_Temp (* *) "mu_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H_Temp (* *) "mu_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[AerGrowthHetero][S_S] := - 1 / (parameters.Y_H);
    parameters.Stoichiometry[AerGrowthHetero][S_O] := - (1 - parameters.Y_H) / parameters.Y_H;
    parameters.Stoichiometry[AerGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AerGrowthHetero][S_ALK] := - parameters.i_X_B / 14;
    parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AnGrowthHetero][S_S] := - 1 / parameters.Y_H;
    parameters.Stoichiometry[AnGrowthHetero][S_NO] := - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
    parameters.Stoichiometry[AnGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
    parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AerGrowthAuto][S_O] := - (4.57 - parameters.Y_A) / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NH] := - parameters.i_X_B - 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_ALK] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
    parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
    parameters.Stoichiometry[DecayOfHetero][X_BH] := - 1;
    parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[DecayOfAuto][X_BA] := - 1;
    parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] := - 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.000000 / 14.000000;
    parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrg][X_S] := - 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] := - 1;
    parameters.Stoichiometry[Aeration][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;
    state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A, state.Temp_Actual - parameters.Temp_Ref);
    state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H, state.Temp_Actual - parameters.Temp_Ref);
    state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H, state.Temp_Actual - parameters.Temp_Ref);

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthAuto] = state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
    state.Kinetics[AerGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
    state.Kinetics[Aeration] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonOfSolOrgN] = state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
    state.Kinetics[AnGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
    state.Kinetics[DecayOfAuto] = state.b_A_Temp * state.C[X_BA];
    state.Kinetics[DecayOfHetero] = state.b_H_Temp * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrg] = state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrgN] = (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);

# 55 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NH];
    interface.NO3 = state.C[S_NO];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA]));
    interface.OfflineTKN = (state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.OnlineCOD = (state.C[S_S] + state.C[S_I] + state.C[X_BH] + state.C[X_BA] + state.C[X_S] + state.C[X_I] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 59 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 2


































# 177 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.SBR.msl" 2

 :};
 


# 33 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 1
 


















CLASS SBRModel EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
   OBJ Outflow2 (* terminal = "out_3" *) "bypass" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 2" :};
   OBJ Underflow (* terminal = "out_4" *) "effluent waste" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Underflow" :};
   OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one SBR in a multi-sbr system configuration " : Time 
     := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
   OBJ T1 (* terminal = "in_2"; manip = "1" *) "Period for the fill phase" : Time 
     := {: causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
   OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time 
     := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
   OBJ T4 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ T5 (* terminal = "in_2"; manip = "1" *) "Period for the idle phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate 
       := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };
  
  parameters <- 
  {
  };
  
  state <-
  {
   
    OBJ T "Length of total cycle" : Time := {: group <- "Operational" :};
    OBJ T2 "Period for the reaction phase" : Time := {: value <- 0.125 ; group <- "Operational" :};
    OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
   
    OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    OBJ Q_Bypass "Bypass flow rate" : FlowRate := {: group <- "Operational" :};
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = interface.T1 + state.T2 + interface.T3 + interface.T4 + interface.T5 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};



CLASS SBRPointsettler EXTENDS SBRModel WITH
 {:
  interface <-
   {
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000 ; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0 ; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 10000 ; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1 ; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400 ; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005 ; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2 ; group <- "Settling":};
 
    
 
   
 

    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_AE = 0.0 ;
   state.Integ_ME = 0.0 ;
   state.Integ_PE = 0.0 ;
   };

  equations <-
   {
 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                        THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN 0
        ELSE
          IF (independent.t - state.t_Begin < (interface.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
          THEN 0
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3) )
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
              THEN state.Q_Out_Help_Draw
            ELSE 0;

   state.Q_Bypass =
       
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
     THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN state.Q_In
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN state.Q_In
         ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN state.Q_In
             ELSE state.Q_In;

    state.Q_Under =
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN 0
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN 0
             ELSE state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < interface.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE
       IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
       THEN state.ConversionTermPerComponent[Comp_Index]
       ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
           THEN state.FluxPerComponent[Comp_Index]
           ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:

       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN 0 
        ELSE
          IF (independent.t - state.t_Begin < interface.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
              THEN 0
              ELSE
                IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
                THEN - state.C[Comp_Index] * interface.Q_Draw * parameters.f_ns
                ELSE 0;
     };

    interface.Outflow2[IndexOfSolvent] = - state.Q_Bypass / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      
      interface.Outflow2[Comp_Index] =
       IF (independent.t < interface.T_Launch)
       THEN 0
       ELSE
         IF (independent.t - state.t_Begin < interface.T1)
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
           THEN - state.InFluxPerComponent[Comp_Index]
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
             THEN - state.InFluxPerComponent[Comp_Index]
             ELSE
               IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
               THEN - state.InFluxPerComponent[Comp_Index]
               ELSE - state.InFluxPerComponent[Comp_Index];
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns) ;
     };

 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
  DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
  interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * (state.Q_Under + state.Q_Out) ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
 
   };
 :};



# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler1phasereact.msl" 1
 



















CLASS SBRPointsettler1PhaseReact
(* icon = "sbr"; is_default = "true" *)
EXTENDS SBRPointsettler WITH
 {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

state <-
   {
    };
 
 equations <- 
   {
      state.T2 = interface.T2R1 ;
   
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < interface.T1 )
            THEN interface.Kla_Fill 
              ELSE
              IF ((independent.t - state.t_Begin) < (state.T2 +interface.T1))
            THEN interface.Kla_React1 
              ELSE 0; 
   };
   
    :};



# 336 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler2phasereact.msl" 1
 



















 CLASS SBRPointsettler2PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1 )
         THEN interface.Kla_Fill 
           ELSE 
             IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
             THEN interface.Kla_React1 
           ELSE 
               IF ( (independent.t - state.t_Begin)<(state.T2 + interface.T1) )
               THEN interface.Kla_React2
               ELSE 0; 
    };
    
    :};



# 337 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler3phasereact.msl" 1
 



















CLASS SBRPointsettler3PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
  interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
              THEN interface.Kla_React3
                  ELSE 0; 
            
    };
    
    :};



# 338 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler4phasereact.msl" 1
 



















CLASS SBRPointsettler4PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                THEN interface.Kla_React4
                    ELSE 0; 
            
    };
    
    :};



# 339 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler5phasereact.msl" 1
 



















CLASS SBRPointsettler5PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5;
      
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                  THEN interface.Kla_React5
                      ELSE 0; 
            
    };
    
    :};



# 340 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler6phasereact.msl" 1
 














 




CLASS SBRPointsettler6PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                    THEN interface.Kla_React6
                        ELSE 0; 
            
    };
    
    :};



# 341 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler7phasereact.msl" 1
 



















CLASS SBRPointsettler7PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                      THEN interface.Kla_React7
                          ELSE 0; 
            
    };
    
    :};



# 342 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/SBR/wwtp.base.SBR.sbrpointsettler8phasereact.msl" 1
 



















CLASS SBRPointsettler8PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T2R8;
   
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T1))
                        THEN interface.Kla_React7
                        ELSE  
                            IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                        THEN interface.Kla_React8
                            ELSE 0; 
            
    };
    
    :};



# 343 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.SBR.msl" 2




# 34 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 1
 


















CLASS CFCDModel EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFCD in a multi-CFCD system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };
    
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {: group <- "Operational" :};  
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = state.T1 + interface.T2 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};


CLASS CFCDPointsettler EXTENDS CFCDModel WITH
 {:
  interface <-
   {
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {

 

 

 

 
  
 

 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_AE = 0.0 ;
   state.Integ_ME = 0.0 ;
   state.Integ_PE = 0.0 ;
   };

  equations <-
   {
 
    

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out = state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       DERIV(state.M[Comp_Index],[independent.t]) =
      IF (independent.t < interface.T_Launch)
    THEN state.FluxPerComponent[Comp_Index]
    ELSE
        IF (independent.t - state.t_Begin < state.T1)
        THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
        ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out * parameters.f_ns
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns)
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };

 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
  DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
  interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};



# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler1phasereact.msl" 1
 



















CLASS CFCDPointsettler1PhaseReact
(* icon = "cfcd"; is_default = "true" *)
EXTENDS CFCDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed continuous discharge tank with 1 reaction phase";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFCD" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

  state <-

   {
     
    };
 
 equations <- 
   {
      state.T1 = interface.T1R1 ;
  
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN 0
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1 
              ELSE  0; 
   };
   
    :};
 


# 244 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler2phasereact.msl" 1
 



















 CLASS CFCDPointsettler2PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge with 2 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN 0 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 245 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler3phasereact.msl" 1
 



















CLASS CFCDPointsettler3PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 3 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 246 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler4phasereact.msl" 1
 



















CLASS CFCDPointsettler4PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 4 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
      state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
              THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 247 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler5phasereact.msl" 1
 














 




CLASS CFCDPointsettler5PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 5 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 248 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler6phasereact.msl" 1
 



















CLASS CFCDPointsettler6PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 6 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                  THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 249 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler7phasereact.msl" 1
 



















CLASS CFCDPointsettler7PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 7 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;

       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React7
                      ELSE 0; 
            
    };
    
    :};



# 250 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFCD/wwtp.base.CFCD.cfcdpointsettler8phasereact.msl" 1
 



















CLASS CFCDPointsettler8PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 8 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
     
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 251 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFCD.msl" 2





# 35 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 1
 


















CLASS CFIDModel EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFID in a multi-CFID system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time := {: causality <- "CIN" ; value <- 0.025; group <- "Operational":};
    OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };  
  
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {:value <- 0.25; group <- "Operational" :};
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
    state.T = state.T1 + interface.T2 + interface.T3 ;

 
   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};
  

CLASS CFIDPointsettler EXTENDS CFIDModel WITH
 {:
  interface <-
   {
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 

 

 

 
  
 
 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_AE = 0.0 ;
   state.Integ_ME = 0.0 ;
   state.Integ_PE = 0.0 ;
   };

  equations <-
   {
 

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                            THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN state.Q_Out_Help
        ELSE
          IF (independent.t - state.t_Begin < (state.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (state.T1 + interface.T2))
          THEN state.Q_Out_Help
          ELSE state.Q_Out_Help_Draw + state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < state.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE state.FluxPerComponent[Comp_Index];
     };

       

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };
 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
  DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
  interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * (state.Q_Under + state.Q_Out) ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};



# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler1phasereact.msl" 1
 














 




CLASS CFIDPointsettler1PhaseReact
(* icon = "cfid"; is_default = "true" *)
EXTENDS CFIDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed SBR with 1 reaction phase";
 
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

 parameters <-
   { 
    };

  state <-
   {
    };
 
 equations <- 
   {

    state.T1 = interface.T1R1;
    
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1
              ELSE  0; 
   };
   
    :};



# 262 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler2phasereact.msl" 1
 



















 CLASS CFIDPointsettler2PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 2 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 263 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler3phasereact.msl" 1
 



















CLASS CFIDPointsettler3PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 3 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 264 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler4phasereact.msl" 1
 



















CLASS CFIDPointsettler4PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 4 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 265 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler5phasereact.msl" 1
 



















CLASS CFIDPointsettler5PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 5 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 266 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler6phasereact.msl" 1
 



















CLASS CFIDPointsettler6PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 6 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 267 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler7phasereact.msl" 1
 



















CLASS CFIDPointsettler7PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 7 reaction phases";
  
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React7
                        ELSE 0; 
            
    };
    
    :};



# 268 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/CFID/wwtp.base.CFID.cfidpointsettler8phasereact.msl" 1
 



















CLASS CFIDPointsettler8PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 8 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                        THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 269 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.CFID.msl" 2




# 36 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.clarifier.msl" 1
 



















CLASS PointSettler "Intermediate class for a point-settler"

 
 
 
 
 
 
 
 
 
 

EXTENDS PointSettler_Base WITH
{:

  comments <- "Intermediate class for a point-settler" ;

  parameters <- 
  { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  };

  state <-
  {
    OBJ f_ns_help (* hidden = "1" *) "Non-settleable fraction of suspended solids" : Fraction ;
  };

  equations <-
  {
     
    
     
     
     
     
     
     
     
     

     
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out * state.f_ns_help ; };   
     

    
    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (interface.Inflow[Comp_Index]) ) ;
    
    state.X_In = IF (state.Q_In <= 0) THEN 0.0 ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD ;
    
    state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (- interface.Outflow[Comp_Index]) ) ;
    
    state.X_Out = IF (state.Q_In <= interface.Q_Under) THEN 0.0 ELSE state.Help_X_Out / (state.Q_In - interface.Q_Under) * parameters.F_TSS_COD ;
    
    state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]) ) ;
    
    state.X_Under = IF (state.Q_In <= interface.Q_Under) THEN
      IF (state.Q_In <= 0) THEN 0.0 ELSE state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
      ELSE IF (interface.Q_Under <= 0) THEN 0.0 ELSE state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
    
    
    
# 91 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.clarifier.msl"

  };

:};


CLASS PointSettler_Base "Base class for a point-settler" EXTENDS WWTPAtomicModelWithoutVolume WITH
{:

  comments <- "Base class for a point-settler" ;

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
     
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operation" :};  
     
    OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d"; group <- "Energy" :};
  };

  parameters <- 
  { 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };

  state <-
  {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};

    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };

  initial <-
  {
    state.Integ_PE = 0.0 ;
  };

  equations <-
  {
     
    
     
     
    
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under) THEN state.Q_In ELSE interface.Q_Under ; 
    
    state.Q_Out = state.Q_In - state.Q_Under_Actual ;
    
    state.f_Out = IF  (state.Q_In <= interface.Q_Under) THEN 0.0 ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;
    
    state.f_Under = IF (state.Q_In <= interface.Q_Under) THEN 1.0 ELSE interface.Q_Under/state.Q_In ;
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};
    
    interface.Underflow[IndexOfSolvent] = IF  (state.Q_In <= interface.Q_Under) THEN - state.Q_In / parameters.WWTPSpecificVolume[IndexOfSolvent]
      ELSE - interface.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    
    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index]* state.f_Under ; };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = IF (state.Q_In <= interface.Q_Under) THEN
        IF (state.Q_In <= 0.0) THEN 0.0 ELSE - state.InFluxPerComponent[Comp_Index]
        ELSE - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]) ; };
    
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };

:};


 
CLASS PointSettler_BSM2 "Pointsettler model in BSM2"
EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
   interface <-
    { 
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
          OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
          OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
     OBJ Q_over (* terminal = "out_3" *) "Underflow" : 
          FlowRate := {: causality <- "COUT" ; group <- "Measurements" :};
     OBJ Q_under (* terminal = "out_3" *) "Underflow" : 
          FlowRate := {: causality <- "COUT" ; group <- "Measurements" :};		 		 
    };
 
   parameters <- 
    { 
     OBJ X_under "Desired percentage of underflow concentration (expressed as fraction)" : 
          Fraction := {: value <- 0.28 ; group <- "Settling" :};
     OBJ rem_perc "Desired removal percentage" : Fraction := {: value <- 0.98 ; group <- "Settling" :};
     OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    };
 
   state <-
    {
     OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
     OBJ Q_Under "Underflow rate" : FlowRate := {: group <- "Operational" :};
     OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
     OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
     OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
     OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
     OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
     OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     OBJ f_thick "Thickening factor" : Real;
    };
 
   equations <-
    {
       
 	 
     state.f_thick = IF (state.X_In == 0)
 	            THEN 0
 				ELSE 1e6 * parameters.X_under / state.X_In;
   
       
       
       
 
     state.Q_Under = IF (state.f_thick == 0)
 	            THEN 0
 				ELSE state.Q_In / state.f_thick * parameters.rem_perc; 
 
     state.Q_Out = state.Q_In - state.Q_Under;
 
 
     state.f_Out = IF	(state.Q_In <= state.Q_Under)
 		      	  THEN 0
 		      	  ELSE (state.Q_In - state.Q_Under) / state.Q_In ;
     state.f_Under = IF (state.Q_In <= state.Q_Under)
 		          	THEN 1
 		        	ELSE state.Q_Under/state.Q_In ;
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    interface.Underflow[IndexOfSolvent] = IF	(state.Q_In <= state.Q_Under)
		  			 		   THEN - state.Q_In / parameters.WWTPSpecificVolume[IndexOfSolvent]
		  			 		   ELSE - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = 
     - state.InFluxPerComponent[Comp_Index]* state.f_Under ;};

      
      
      
      
      
      
      
      


    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =			   
      - state.InFluxPerComponent[Comp_Index] * state.f_thick * state.f_Under;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Outflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Underflow[Comp_Index]);};


    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    state.X_In = IF (state.Q_In == 0)
				  THEN 0
				  ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     

    state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (- interface.Outflow[Comp_Index]));

    {state.X_Out = IF (state.Q_In <= state.Q_Under)
			 	   THEN 0
			 	   ELSE state.Help_X_Out / (state.Q_In - state.Q_Under) * parameters.F_TSS_COD;
     };

     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));

    {state.X_Under = 
    		IF (state.Q_In <= state.Q_Under)
			THEN
		  	  IF (state.Q_In == 0)
		  	  THEN 0
		  	  ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
			ELSE 
		  	  IF (state.Q_Under == 0)
		  	  THEN 0
		  	  ELSE
               state.Help_X_Under / state.Q_Under * parameters.F_TSS_COD ;
     };


# 328 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.clarifier.msl"


     interface.Q_over = state.Q_Out;
	 interface.Q_under = state.Q_Under;


   };
 :};


CLASS SettlingTank_TakacsNonSVI_Reactive "Base class for a reactive Takacs model with constant r_H"
EXTENDS SettlingTank_Takacs_Reactive WITH
{:

  parameters <-
  {
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
  };

  initial <-
  {
    state.Help_r_H = parameters.r_H ;
  };

:};


CLASS SettlingTank_Takacs_Reactive "Base class for a Takacs model with reactions"
EXTENDS SettlingTank_Takacs WITH
{:

  state <-
  {    
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
  };

  initial <-
  {
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.C[1][Layer_Index] = 1E-06 ; };
      
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      { FOREACH Comp_Index IN {2 .. NrOfComponents}:
        state.C[Comp_Index][Layer_Index] = 1.0 ; }; };
  };
  
  equations <-
  {
    interface.Overflow[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    
     
    { FOREACH Comp_Index IN {2 .. NrOfComponents}:
      interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ; };
  };
  
:};


CLASS SettlingTank_TakacsSVI "Base class for a non-reactive Takacs model with SVI correlation"
EXTENDS SettlingTank_Takacs_NonReactive WITH
{:

  interface <-
  {
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge Volume Index in mL/g" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Settling" :};
  };

  state <-
  {
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: group <- "Settling" :}; 
  };

  equations <-
  {
    state.Help_r_H = (0.148 + 0.00210 * interface.SVI) / 1000 ;
    state.r_H = state.Help_r_H ;
  };

:};


CLASS SettlingTank_TakacsNonSVI "Base class for a non-reactive Takacs model with constant r_H"
EXTENDS SettlingTank_Takacs_NonReactive WITH
{:

  parameters <-
  {
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
  };

  initial <-
  {
    state.Help_r_H = parameters.r_H ;
  };

:};


CLASS SettlingTank_Takacs_NonReactive "Base class for a non-reactive Takacs model"
EXTENDS SettlingTank_Takacs WITH
{:
  
  equations <-
  {
    DERIV(state.X_Layer[1],[independent.t]) =
      (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ;

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
      DERIV(state.X_Layer[Layer_Index],[independent.t]) = IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) * (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index] + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
          (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index] + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index] +
          state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) ; };

    DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
      (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) - (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] = IF (state.Q_In <= 0) THEN 0.0
        ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = IF (state.SolidFlux_In <= 0) THEN 0.0
        ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = IF (state.Q_In <= 0) THEN 0.0
        ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };
  };

:};


CLASS SettlingTank_Takacs "Base class for a Takacs model"
EXTENDS SettlingTank_Base WITH
{:

  interface <-
  { 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1"*) "Height of the sludge blanket" : Length := {: causality <- "COUT" ; group <- "Measurement data":};
  };

  parameters <- 
  {
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
  };

  state <-
  {
     
    OBJ Help_f_ns (* hidden = "1" *) "Non-settleable fraction of suspended solids" : Fraction := {: group <- "Settling" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of each layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of each layer" : Length ;
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ Help_r_H (* hidden = "1" *) "Settling parameter (hindered settling)" : SpecificVolume ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : LayerVelocityVector;  
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": LayerVelocityVector;  
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": LayerArealFluxVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : LayerArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : LayerArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : LayerArealFluxVector;
     
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
     
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : LayerConcentrationVector := {: group <- "Concentration : Solids" :};  
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
  };

  initial <-
  {
     
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers) ; 
    state.H_Layer = parameters.H / NrOfLayers ;
  };
  
  equations <-
  {
    state.v_Up = state.Q_Out / parameters.A; 
    state.v_Dn = state.Q_Under_Actual / parameters.A; 
    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = parameters.v0 * exp(state.Help_r_H * state.X_Min); 

    state.SolidConcentration =
      (SUMOVER Layer_Index IN {1 .. NrOfLayers}: state.X_Layer[Layer_Index]) / NrOfLayers ;

    state.X_Min = IF (state.Q_In <= 0) THEN state.Help_f_ns * state.SolidConcentration
      ELSE state.Help_f_ns * state.SolidFlux_In / state.Q_In ;

    state.X_Out = IF (state.Q_Out <= 0) THEN 0.0
      ELSE state.X_Layer[1];
    
    state.X_Under = IF (state.Q_Under_Actual <= 0) THEN 0.0
      ELSE state.X_Layer[NrOfLayers];
    
     
    { FOREACH Layer_Index IN {1 .. NrOfLayers}: state.v_S_Help[Layer_Index] =
      IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0.0 
        ELSE (state.v0_H * exp(- state.Help_r_H * state.X_Layer[Layer_Index]) - state.v0_P * exp(- parameters.r_P * state.X_Layer[Layer_Index])) ; };
    
    { FOREACH Layer_Index IN {1 .. NrOfLayers}: state.v_S[Layer_Index] =
      IF (state.v_S_Help[Layer_Index] > parameters.v00) THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index] ; };

     
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.J_G_Help[Layer_Index] = state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };
    
    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
      state.J_Up[Layer_Index] = state.v_Up * state.X_Layer[Layer_Index] ; };
    
    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
      state.J_Dn[Layer_Index] = state.v_Dn * state.X_Layer[Layer_Index] ; };
    
    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
      state.J_G[Layer_Index-1] = IF (state.X_Layer[Layer_Index] < parameters.X_T) THEN state.J_G_Help[Layer_Index-1]
        ELSE IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index]) THEN state.J_G_Help[Layer_Index]
          ELSE state.J_G_Help[Layer_Index-1] ; };
    
    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
      state.J_G[Layer_Index] = IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1]) THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ; };

     
    state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]), NrOfLayers, parameters.X_Lim) ;
    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) * state.H_Layer ;

    interface.Sludge_Blanket_Height = state.H_S;
  };

:};


CLASS SettlingTank_Base "Base class for a 1ary and 2ary settling tanks"
EXTENDS WWTPAtomicModelWithoutVolume WITH
{:

  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
     
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
  };

  parameters <- 
  {
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  };

  state <-
  {
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration : Solids" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration : Solids" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration : Solids" :};
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
     
    OBJ Integ_PE (* hidden = "1" *) "Integral Pumping energy" : ElectricalEnergy ;
  };

  initial <-
  {
    state.Integ_PE = 0.0 ;
  };

  equations <-
  {
     
    state.Q_Out = state.Q_In - state.Q_Under_Actual ;
    
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
      THEN state.Q_In ELSE interface.Q_Under ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

     
    
    { state.SolidFlux_In =
      SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
      state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ; };
    

    



     
    state.X_In = IF (state.Q_In <= 0) THEN 0.0
      ELSE state.SolidFlux_In / state.Q_In ;
      
     
    
    state.SolidFlux_Out = state.X_Out * state.Q_Out ;
    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual ;
  };

:};




# 37 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 1
 


















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primarypointsettler.msl" 1
 





















CLASS PrimaryPointSettler (* icon = "primary_clarifier"; is_default = "true" *) "Point-settler model for primary clarifier"
EXTENDS PointSettler WITH
{:

  comments <- "A model for a primary point settler only using mass balances";
  
  interface <-
  {
    OBJ f_ns (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Non-settleable fraction of suspended solids" :
      Fraction := {: causality <- "CIN" ; value <- 0.6 ; group <- "Settling" :};
  };
  
  equations <-
  {
    state.f_ns_help = IF (state.Q_Under_Actual > 0) THEN interface.f_ns
    ELSE 1.0 ;
  };
  
:};


 CLASS PrimaryPointSettler_BSM2  (* icon = "primary_clarifier" *)
 "Point-settler model for primary clarifier in BSM2"
  EXTENDS PointSettler_BSM2 WITH
  {:
    comments <- "A model for a primary point settler only using mass balances for BSM2";
    initial <-
    {
    };
  :};




# 20 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl" 1
 


















 CLASS BSMAtomicModelWithFixedVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:

  interface <-
   {
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   };

  parameters <- 
   { 
   OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
   };
   
  initial <-  
  {
  state.M[IndexOfSolvent] = parameters.Vol / parameters.WWTPSpecificVolume[IndexOfSolvent];
  };   

  equations <-
  {
  state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}: (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);
  
  {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.C[Comp_Index] =
		IF (state.V == 0) THEN 0
		   ELSE state.M[Comp_Index]/state.V ; };
  };

 :};
 



 
CLASS PrimaryOtterpohlFreund
 (* icon = "primary_clarifier" *)
 "Otterpohl & Freund model for primary clarifiers according to BSM2"
 EXTENDS BSMAtomicModelWithFixedVolume WITH
 {:
 
  interface <-
   {
    
   OBJ Outflow (* terminal = "out_1" *)"Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    
    
   OBJ f_PS (* terminal = "in_2"; manip = "1"; is_favorite = "true" *) "Ratio Primary sludge flow rate/Influent flow rate (1-2%)" : Fraction := {: causality <- "CIN" ; value <- 0.007 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_3" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

  parameters <- 
   { 
   OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
   OBJ f_corr "Correction factor removal efficiency (tuning parameter)" : Fraction := {: value <- 0.65 ; group <- "Settling" :};
   OBJ f_X "Particulate COD to total COD (mean value)" : Fraction := {: value <- 0.85 ; group <- "Settling" :};
   OBJ t_m "Smoothing time constant" : Time := {: value <- 0.125 ; group <- "Settling" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
   OBJ Q_Out (* is_favorite = "true" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   OBJ Q_m "Mean influent flow rate" : FlowRate := {: value <- 1.0 ; group <- "Operational" :};
   OBJ Q_Under (* is_favorite = "true" *) "Primary sludge or underflow rate" : FlowRate := {: group <- "Operational" :};
   OBJ t_h "Hydraulic retention time" : Time := {: group <- "Operational" :};
   OBJ f_i "Effluent concentration factor" : Real;
   OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
   OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
   OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
   OBJ X_In (* is_favorite = "true" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
   OBJ X_Out (* is_favorite = "true" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
   OBJ X_Under (* is_favorite = "true" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    
   OBJ Eff_COD "COD removal efficiency (total)" : Real := {: group <- "Settling" :};
   OBJ Eff_X_COD "COD removal efficiency (particulate)" : Real := {: group <- "Settling" :};
   OBJ TSS "TSS in primary clarifier": Concentration := {: group <- "Settling" :};
   OBJ Eff_TSS "Removal efficiency based on TSS": Real := {: group <- "Settling" :};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_PE = 0.0 ;
   };

  equations <-
   {
    
   state.Q_Under = interface.f_PS * state.Q_In ;
   state.Q_Out = state.Q_In - state.Q_Under ;
   
   interface.Outflow[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];
   interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];
   
    
   DERIV(state.Q_m, [independent.t]) = (state.Q_In - state.Q_m) / parameters.t_m ;
   state.t_h = state.V/(state.Q_m + 0.001); 
    
   state.Eff_COD = parameters.f_corr * (2.88 * parameters.f_X - 0.118) * (1.45 + 6.15 * log(state.t_h * 24.0 * 60.0));
   state.Eff_X_COD =  state.Eff_COD / parameters.f_X ;

   state.f_i = 1.0 - state.Eff_X_COD / 100;  

    
   {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
		interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out ; };	 

   {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
		interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out * state.f_i ; };	  

    
   {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
		interface.Underflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Under ; };		

   {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
		interface.Underflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Under  * ((1.0 - state.f_i) * state.Q_In / state.Q_Under + state.f_i) ; };	
	
    

   state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: interface.Inflow[Comp_Index]) ;
   state.X_In = IF (state.Q_In == 0) THEN 0
		ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD ;

   state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: - interface.Outflow[Comp_Index]);
   state.X_Out = IF (state.Q_Out == 0) THEN 0
		ELSE state.Help_X_Out / state.Q_Out * parameters.F_TSS_COD ;

   state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: - interface.Underflow[Comp_Index]);
   state.X_Under = IF (state.Q_Under == 0) THEN 0
		ELSE state.Help_X_Under / state.Q_Under * parameters.F_TSS_COD ;

   state.TSS = parameters.F_TSS_COD * (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (state.C[Comp_Index]));










	  
    
   state.Eff_TSS = IF (state.X_In == 0) THEN 0
		ELSE (1.0 - state.X_Out/state.X_In)*100.0 ;

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




 

 CLASS PrimaryOtterpohlFreundOrig
 
 "Otterpohl & Freund model for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Otterpohl and Freund";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "true" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ alfa "Otterpohl and Freund function constant" : PhysicalQuantityType := 
        {: 
          value <- 2.7;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ beta "Otterpohl and Freund function constant" : PhysicalQuantityType := 
        {:
          value <- 9;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    
    
    
    OBJ V_Clar (* is_favorite = "true" *) "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "true" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "true" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ Eff_COD "Efficiency of COD removal" : PhysicalQuantityType := {: group <- "Settling" :};
    OBJ Eff_X_COD "Efficiency of particulate COD removal" :     PhysicalQuantityType := {: group <- "Settling" :};
    OBJ COD "Total COD in the clarifier influent" : MassFlux := {: group <- "Influent characterization" :};
    OBJ X_COD "Particulate COD in the clarifier influent" : MassFlux := {: group <- "Influent characterization" :};
    OBJ X_In (* is_favorite = "true" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "true" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "true" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent waterflux going to the Overflow" : Fraction ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_PE = 0.0 ;
   };

  equations <-
   {

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;


    {state.COD = 
              state.X_COD
              +interface.Inflow[S_I] + interface.Inflow[S_S] ;
     };

     {state.X_COD = 
      (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (interface.Inflow[Comp_Index]));
     };


# 316 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl"



















    state.Eff_COD =   IF ( state.Q_In == 0)
            THEN 1
            ELSE  parameters.alfa * 0.01 *
               ( log ( pow(24 * parameters.V_Clar/state.Q_In,2) ) + parameters.beta ) ;

    state.Eff_X_COD = IF (state.X_COD == 0)
              THEN 0
          ELSE state.Eff_COD * state.COD / state.X_COD ;

      
      

    state.f_Out = IF (state.Q_In <= interface.Q_Under)
      THEN 0
      ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

     
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * 
        (1 - state.Eff_X_COD) ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};



    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

      state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (- interface.Outflow[Comp_Index]));
    {
      state.X_Out = IF (state.Q_In <= interface.Q_Under)
        THEN 0
        ELSE state.Help_X_Out * parameters.F_TSS_COD / (state.Q_In - interface.Q_Under) ;
     };
     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));

    {state.X_Under = 
        IF (state.Q_In <= interface.Q_Under)
    THEN
      IF (state.Q_In == 0)
      THEN 0
      ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
    ELSE 
      IF (interface.Q_Under == 0)
      THEN 0
      ELSE
               state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
     };


# 427 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl"


 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    }; 

 :};



# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.tay.msl" 1
 






















 CLASS Tay
 (* icon = "primary_clarifier" *)
 "The model of Tay for primary clarifiers"

 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Tay";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ T_A "Half removal time" : Time := {: value <- 0.125 ; group <- "Settling" :};
    OBJ Delta_t "Time period defining the interval over which the average flow rate is calculated" : Time := {: value <- 0.1 ; group <- "Settling" :};
    OBJ t_Start "Time where the calculation of the average flow rate starts" : Time := {: value <- 0.1 ; group <- "Settling":};
    
    
    OBJ V_Clar (* is_favorite = "1" *) "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ thelp (* hidden = "1" *) "Previous time help variable" : Time;
    OBJ Qmean (* hidden = "1" *) "Averaged influent flow rate" : FlowRate;
    OBJ Qprev1 (* hidden = "1" *) "Influent flow rate over a period Delta_t back in time" : FlowRate;
    OBJ Qprev2 (* hidden = "1" *) "Influent flow rate over a period Delta_t, two times Delta_t back in time" : FlowRate;
    OBJ Qprev3 (* hidden = "1" *) " Influent flow rate over a period Delta_t, three times Delta_t back in time " : FlowRate;
    OBJ Qprev4 (* hidden = "1" *) " Influent flow rate over a period Delta_t, four times Delta_t back in time " : FlowRate;
    OBJ Qprev5 (* hidden = "1" *) " Influent flow rate over a period Delta_t, five times Delta_t back in time " : FlowRate;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_PE = 0.0 ;
   };

  equations <-
   {
      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.f_Out := IF (state.Q_In <= interface.Q_Under)
                   THEN 0
       ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;

    state.Qprev1 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN state.Q_In
                     ELSE previous(state.Qprev1);

    state.Qprev2 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev1)
                     ELSE previous(state.Qprev2);

    state.Qprev3 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev2)
                     ELSE previous(state.Qprev3);

    state.Qprev4 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev3)
                     ELSE previous(state.Qprev4);

    state.Qprev5 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev4)
                     ELSE previous(state.Qprev5);

    state.thelp = IF (independent.t < parameters.t_Start)
                   THEN independent.t
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN independent.t
                     ELSE previous(state.thelp);

    state.Qmean = (state.Qprev1 + state.Qprev2 + state.Qprev3 + state.Qprev4 + state.Qprev5) / 5;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] = 
      IF (state.Q_In == 0 || state.Qmean == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                       (state.Q_In * (1 + parameters.V_Clar / (state.Qmean * parameters.T_A)));
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

      
      

    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

     state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Outflow[Comp_Index]));

    {state.X_Out = IF (state.Q_In <= interface.Q_Under)
       THEN 0
       ELSE state.Help_X_Out * parameters.F_TSS_COD / (state.Q_In - interface.Q_Under);
     };

     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));
 
    {state.X_Under = 
        IF (state.Q_In <= interface.Q_Under)
    THEN
      IF (state.Q_In == 0)
      THEN 0
      ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
    ELSE 
      IF (interface.Q_Under == 0)
      THEN 0
      ELSE
               state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
     };


# 235 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.tay.msl"

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    }; 
  :};





# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.lessardbeck.msl" 1
 




















CLASS L_and_B_ConcentrationVector = Concentration[5;];

CLASS LessardBeck
 (* icon = "primary_clarifier" *)
 "The model of Lessard and Beck for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Lessard and Beck";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

  parameters <- 
   {
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors":};
    OBJ alfa "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 3.6 ; group <- "Settling" :};
    OBJ beta "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 59 ; group <- "Settling" :};
    OBJ gamma "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 1.17 ; group <- "Settling" :};
    OBJ lambda "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 8.05 ; group <- "Settling":};
    OBJ H (* is_favorite = "1" *) "Height" : Length := {: value <- 3 ; group <- "Dimension" :};
    OBJ v_PC "Settling velocity" : Velocity := {: value <- 1 ; group <- "Settling":};
    OBJ k_a "Ammonification rate" : AmmonificationRate:= {: value <- 0.003 ; group <- "Kinetic":};
    OBJ k_h "Specific Hydrolysis rate" : MaxSpecificHydrolysisRate:= {: value <- 0.083 ; group <- "Kinetic":};
    OBJ pi (* hidden = "1" *) "" : Real := {: value <- 3.1415927 :};
     
    OBJ V_Clar (* is_favorite = "1" *) "Volume of the clarifier" : Volume := {: value <- 1000 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;    
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ Scour (* hidden = "1" *) "Scouring term" : Real;
    OBJ Setterm (* hidden = "1" *) "Settling term" : Real;
    OBJ A (* is_favorite = "1" *) "Surface" : Area := {: group <- "Dimension" :};
    OBJ R "Radius" : Length := {: group <- "Dimension" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of the layers" : Volume;
    OBJ Q_Out_Div_V_Layer (* hidden = "1" *) "Q_Out/V_Layer" : PhysicalQuantityType;
    OBJ Q_Under_Div_V_Layer (* hidden = "1" *) "Q_Under/V_Layer" : PhysicalQuantityType;
    OBJ Hydrolysis_X_S_Layer1 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 1" : Real;
    OBJ Hydrolysis_X_ND_Layer1 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 1" : Real;
    OBJ Ammonification_Layer1 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 1" : Real;
    OBJ Hydrolysis_X_S_Layer2 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 2" : Real;
    OBJ  Hydrolysis_X_ND_Layer2 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 2" : Real;
    OBJ  Ammonification_Layer2 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 2" : Real;
    OBJ Hydrolysis_X_S_Layer3 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 3" : Real;
    OBJ  Hydrolysis_X_ND_Layer3 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 3" : Real;
    OBJ  Ammonification_Layer3 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 3" : Real;
    OBJ Hydrolysis_X_S_Layer4 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 4" : Real;
    OBJ  Hydrolysis_X_ND_Layer4 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 4" : Real;
    OBJ  Ammonification_Layer4 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 4" : Real;
    OBJ Hydrolysis_X_S_Layer5 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 5" : Real;
    OBJ  Hydrolysis_X_ND_Layer5 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 5" : Real;
    OBJ  Ammonification_Layer5 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 5" : Real;
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ S_I_Layer "Vector containing S_I concentration for all the layers" : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ND_Layer " Vector containing S_ND concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NH_Layer " Vector containing S_NH concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NO_Layer " Vector containing S_NO concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_O_Layer " Vector containing S_O concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_S_Layer " Vector containing S_S concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ALK_Layer " Vector containing S_ALK concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_BA_Layer " Vector containing X_BA concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_BH_Layer " Vector containing X_BH concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_I_Layer " Vector containing X_I concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_P_Layer " Vector containing X_P concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_ND_Layer " Vector containing X_ND concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_S_Layer " Vector containing X_S concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration  := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration  := {: group <- "Concentration" :}; 
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration  := {: group <- "Concentration" :};   
 
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    state.V_Layer = parameters.V_Clar / 5;
    state.A = parameters.V_Clar / parameters.H;
    state.R = sqrt(state.A / parameters.pi);
    state.Q_Under_Div_V_Layer = interface.Q_Under / state.V_Layer;

   state.Integ_PE = 0.0 ;
   };

  equations <-
   {
    state.Q_Out = IF (state.Q_In <= interface.Q_Under)
      THEN 0
      ELSE state.Q_In - interface.Q_Under;

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    interface.Outflow[IndexOfSolvent] = - state.Q_Out
               / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    interface.Underflow[IndexOfSolvent] = 
    IF (state.Q_In <= interface.Q_Under)
    THEN - state.Q_In / parameters.WWTPSpecificVolume[IndexOfSolvent]
    ELSE - interface.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 

    state.Scour = parameters.gamma * exp(-parameters.lambda / parameters.alfa /
      (exp ((parameters.beta * state.Q_Out / (2.0 * parameters.pi * parameters.H * state.R * sqrt(7.32e10 * parameters.H))))));
    state.Q_Out_Div_V_Layer = state.Q_Out / state.V_Layer;

    state.Setterm = (1 - state.Scour) * parameters.v_PC * state.A / state.V_Layer;

 
 
 

    
    state.Hydrolysis_X_S_Layer1 = IF (state.X_S_Layer[1] > 0)
                    THEN parameters.k_h * state.X_S_Layer[1]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer1 = IF ((state.X_S_Layer[1] * state.X_ND_Layer[1]) > 0)
                    THEN state.Hydrolysis_X_S_Layer1 * (state.X_ND_Layer[1] / state.X_S_Layer[1])
                    ELSE 0;

    state.Ammonification_Layer1 = IF ((state.S_ND_Layer[1] * state.X_BH_Layer[1]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[1] * state.X_BH_Layer[1]
                    ELSE 0;

    {DERIV(state.S_I_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_I_Layer[2] - state.S_I_Layer[1]);
    };

    {DERIV(state.S_O_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_O_Layer[2] - state.S_O_Layer[1]);
    };

    {DERIV(state.S_S_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_S_Layer[2] - state.S_S_Layer[1]) + state.Hydrolysis_X_S_Layer1;
    };

    {DERIV(state.S_ALK_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ALK_Layer[2] - state.S_ALK_Layer[1]);
    };

    {DERIV(state.S_NH_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NH_Layer[2] - state.S_NH_Layer[1]) + state.Ammonification_Layer1;
    };

    {DERIV(state.S_ND_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ND_Layer[2] - state.S_ND_Layer[1])
      - state.Ammonification_Layer1 + state.Hydrolysis_X_ND_Layer1;
    };

    {DERIV(state.S_NO_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NO_Layer[2] - state.S_NO_Layer[1]);
    };

    {DERIV(state.X_BA_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BA_Layer[2] - state.X_BA_Layer[1]) 
           - state.Setterm * state.X_BA_Layer[1];
    };

    {DERIV(state.X_BH_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BH_Layer[2] - state.X_BH_Layer[1])
           - state.Setterm * state.X_BH_Layer[1];
    };

    {DERIV(state.X_I_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_I_Layer[2] - state.X_I_Layer[1])
           - state.Setterm * state.X_I_Layer[1];
    };

    {DERIV(state.X_P_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_P_Layer[2] - state.X_P_Layer[1])
           - state.Setterm * state.X_P_Layer[1];
    };

    {DERIV(state.X_S_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_S_Layer[2] - state.X_S_Layer[1])
           - state.Setterm * state.X_S_Layer[1] - state.Hydrolysis_X_S_Layer1;
    };

    {DERIV(state.X_ND_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_ND_Layer[2] - state.X_ND_Layer[1])
           - state.Setterm * state.X_ND_Layer[1] - state.Hydrolysis_X_ND_Layer1;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer2 = IF (state.X_S_Layer[2] > 0)
                    THEN parameters.k_h * state.X_S_Layer[2]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer2 = IF ((state.X_S_Layer[2] * state.X_ND_Layer[2]) > 0)
                    THEN state.Hydrolysis_X_S_Layer2 * (state.X_ND_Layer[2] / state.X_S_Layer[2])
                    ELSE 0;

    state.Ammonification_Layer2 = IF ((state.S_ND_Layer[2] * state.X_BH_Layer[2]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[2] * state.X_BH_Layer[2]
                    ELSE 0;

    {DERIV(state.S_I_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_I_Layer[3] - state.S_I_Layer[2]);
    };

    {DERIV(state.S_O_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_O_Layer[3] - state.S_O_Layer[2]);
    };

    {DERIV(state.S_S_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_S_Layer[3] - state.S_S_Layer[2]) + state.Hydrolysis_X_S_Layer2;
    };

    {DERIV(state.S_ALK_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ALK_Layer[3] - state.S_ALK_Layer[2]);
    };

    {DERIV(state.S_NH_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NH_Layer[3] - state.S_NH_Layer[2]) + state.Ammonification_Layer2;
    };

    {DERIV(state.S_ND_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ND_Layer[3] - state.S_ND_Layer[2])
      - state.Ammonification_Layer2 + state.Hydrolysis_X_ND_Layer2;
    };

    {DERIV(state.S_NO_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NO_Layer[3] - state.S_NO_Layer[2]);
    };

    {DERIV(state.X_BA_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BA_Layer[3] - state.X_BA_Layer[2])
           - state.Setterm * state.X_BA_Layer[2] + state.Setterm * state.X_BA_Layer[1];
    };

    {DERIV(state.X_BH_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BH_Layer[3] - state.X_BH_Layer[2])
           - state.Setterm * state.X_BH_Layer[2] + state.Setterm * state.X_BH_Layer[1];
    };

    {DERIV(state.X_I_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_I_Layer[3] - state.X_I_Layer[2])
           - state.Setterm * state.X_I_Layer[2] + state.Setterm * state.X_I_Layer[1];
    };

    {DERIV(state.X_P_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_P_Layer[3] - state.X_P_Layer[2])
           - state.Setterm * state.X_P_Layer[2] + state.Setterm * state.X_P_Layer[1];
    };

    {DERIV(state.X_S_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_S_Layer[3] - state.X_S_Layer[2])
           - state.Setterm * state.X_S_Layer[2] + state.Setterm * state.X_S_Layer[1] - state.Hydrolysis_X_S_Layer2;
    };

    {DERIV(state.X_ND_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_ND_Layer[3] - state.X_ND_Layer[2])
           - state.Setterm * state.X_ND_Layer[2] + state.Setterm * state.X_ND_Layer[1] - state.Hydrolysis_X_ND_Layer2;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer3 = IF (state.X_S_Layer[3] > 0)
                    THEN parameters.k_h * state.X_S_Layer[3]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer3 = IF ((state.X_S_Layer[3] * state.X_ND_Layer[3]) > 0)
                    THEN state.Hydrolysis_X_S_Layer3 * (state.X_ND_Layer[3] / state.X_S_Layer[3])
                    ELSE 0;

    state.Ammonification_Layer3 = IF ((state.S_ND_Layer[3] * state.X_BH_Layer[3]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[3] * state.X_BH_Layer[3]
                    ELSE 0;

    {DERIV(state.S_I_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_I] - state.Q_In * state.S_I_Layer[3]);
    };

    {DERIV(state.S_O_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_O] - state.Q_In * state.S_O_Layer[3]);
    };

    {DERIV(state.S_S_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_S] - state.Q_In * state.S_S_Layer[3]) + state.Hydrolysis_X_S_Layer3;
    };

    {DERIV(state.S_ALK_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_ALK] - state.Q_In * state.S_ALK_Layer[3]);
    };

    {DERIV(state.S_NH_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_NH] - state.Q_In * state.S_NH_Layer[3]) + state.Ammonification_Layer3;
    };

    {DERIV(state.S_ND_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_ND] - state.Q_In * state.S_ND_Layer[3]) - state.Ammonification_Layer3 + state.Hydrolysis_X_ND_Layer3;
    };

    {DERIV(state.S_NO_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_NO] - state.Q_In * state.S_NO_Layer[3]);
    };

    {DERIV(state.X_BA_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_BA] - state.Q_In * state.X_BA_Layer[3])
           - state.Setterm * state.X_BA_Layer[3] + state.Setterm * state.X_BA_Layer[2];
    };

    {DERIV(state.X_BH_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_BH] - state.Q_In * state.X_BH_Layer[3])
           - state.Setterm * state.X_BH_Layer[3] + state.Setterm * state.X_BH_Layer[2];
    };

    {DERIV(state.X_I_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_I] - state.Q_In * state.X_I_Layer[3])
           - state.Setterm * state.X_I_Layer[3] + state.Setterm * state.X_I_Layer[2];
    };

    {DERIV(state.X_P_Layer[3],[independent.t]) =
      1/state.V_Layer * (interface.Inflow[X_P] - state.Q_In * state.X_P_Layer[3])
           - state.Setterm * state.X_P_Layer[3] + state.Setterm * state.X_P_Layer[2];
    };
    {DERIV(state.X_S_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_S] - state.Q_In * state.X_S_Layer[3])
           - state.Setterm * state.X_S_Layer[3] + state.Setterm * state.X_S_Layer[2] - state.Hydrolysis_X_S_Layer3;
    };

    {DERIV(state.X_ND_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_ND] - state.Q_In * state.X_ND_Layer[3])
           - state.Setterm * state.X_ND_Layer[3] + state.Setterm * state.X_ND_Layer[2] - state.Hydrolysis_X_ND_Layer3;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer4 = IF (state.X_S_Layer[4] > 0)
                    THEN parameters.k_h * state.X_S_Layer[4]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer4 = IF ((state.X_S_Layer[4] * state.X_ND_Layer[4]) > 0)
                    THEN state.Hydrolysis_X_S_Layer4 * (state.X_ND_Layer[4] / state.X_S_Layer[4])
                    ELSE 0;

    state.Ammonification_Layer4 = IF ((state.S_ND_Layer[4] * state.X_BH_Layer[4]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[4] * state.X_BH_Layer[4]
                    ELSE 0;

    {DERIV(state.S_I_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_I_Layer[3] - state.S_I_Layer[4]);
    };

    {DERIV(state.S_O_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_O_Layer[3] - state.S_O_Layer[4]);
    };

    {DERIV(state.S_S_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_S_Layer[3] - state.S_S_Layer[4]) + state.Hydrolysis_X_S_Layer4;
    };

    {DERIV(state.S_ALK_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ALK_Layer[3] - state.S_ALK_Layer[4]);
    };

    {DERIV(state.S_NH_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NH_Layer[3] - state.S_NH_Layer[4]) + state.Ammonification_Layer4;
    };

    {DERIV(state.S_ND_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ND_Layer[3] - state.S_ND_Layer[4])
      - state.Ammonification_Layer4 + state.Hydrolysis_X_ND_Layer4;
    };

    {DERIV(state.S_NO_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NO_Layer[3] - state.S_NO_Layer[4]);
    };

    {DERIV(state.X_BA_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BA_Layer[3] - state.X_BA_Layer[4])
           - state.Setterm * state.X_BA_Layer[4] + state.Setterm * state.X_BA_Layer[3];
    };

    {DERIV(state.X_BH_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BH_Layer[3] - state.X_BH_Layer[4])
           - state.Setterm * state.X_BH_Layer[4] + state.Setterm * state.X_BH_Layer[3];
    };

    {DERIV(state.X_I_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_I_Layer[3] - state.X_I_Layer[4])
           - state.Setterm * state.X_I_Layer[4] + state.Setterm * state.X_I_Layer[3];
    };

    {DERIV(state.X_P_Layer[4],[independent.t]) =
      state.Q_Under_Div_V_Layer * (state.X_P_Layer[3] - state.X_P_Layer[4])
           - state.Setterm * state.X_P_Layer[4] + state.Setterm * state.X_P_Layer[3];
    };

    {DERIV(state.X_S_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_S_Layer[3] - state.X_S_Layer[4])
           - state.Setterm * state.X_S_Layer[4] + state.Setterm * state.X_S_Layer[3] - state.Hydrolysis_X_S_Layer4;
    };

    {DERIV(state.X_ND_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_ND_Layer[3] - state.X_ND_Layer[4])
           - state.Setterm * state.X_ND_Layer[4] + state.Setterm * state.X_ND_Layer[3] - state.Hydrolysis_X_ND_Layer4;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer5 = IF (state.X_S_Layer[5] > 0)
                    THEN parameters.k_h * state.X_S_Layer[5]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer5 = IF ((state.X_S_Layer[5] * state.X_ND_Layer[5]) > 0)
                    THEN state.Hydrolysis_X_S_Layer5 * (state.X_ND_Layer[5] / state.X_S_Layer[5])
                    ELSE 0;

    state.Ammonification_Layer5 = IF ((state.S_ND_Layer[5] * state.X_BH_Layer[5]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[5] * state.X_BH_Layer[5]
                    ELSE 0;

    {DERIV(state.S_I_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_I_Layer[4] - state.S_I_Layer[5]);
    };

    {DERIV(state.S_O_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_O_Layer[4] - state.S_O_Layer[5]);
    };

    {DERIV(state.S_S_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_S_Layer[4] - state.S_S_Layer[5]) + state.Hydrolysis_X_S_Layer5;
    };

    {DERIV(state.S_ALK_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ALK_Layer[4] - state.S_ALK_Layer[5]);
    };

    {DERIV(state.S_NH_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NH_Layer[4] - state.S_NH_Layer[5]) + state.Ammonification_Layer5;
    };

    {DERIV(state.S_ND_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ND_Layer[4] - state.S_ND_Layer[5])
      - state.Ammonification_Layer5 + state.Hydrolysis_X_ND_Layer5;
    };

    {DERIV(state.S_NO_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NO_Layer[4] - state.S_NO_Layer[5]);
    };

    {DERIV(state.X_BA_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BA_Layer[4] - state.X_BA_Layer[5])
           + state.Setterm * state.X_BA_Layer[4];
    };

    {DERIV(state.X_BH_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BH_Layer[4] - state.X_BH_Layer[5])
           + state.Setterm * state.X_BH_Layer[4];
    };

    {DERIV(state.X_I_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_I_Layer[4] - state.X_I_Layer[5])
           + state.Setterm * state.X_I_Layer[4];
    };

    {DERIV(state.X_P_Layer[5],[independent.t]) =
      state.Q_Under_Div_V_Layer * (state.X_P_Layer[4] - state.X_P_Layer[5])
           + state.Setterm * state.X_P_Layer[4];
    };

    {DERIV(state.X_S_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_S_Layer[4] - state.X_S_Layer[5])
           + state.Setterm * state.X_S_Layer[4] - state.Hydrolysis_X_S_Layer5;
    };

    {DERIV(state.X_ND_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_ND_Layer[4] - state.X_ND_Layer[5])
           + state.Setterm * state.X_ND_Layer[4] - state.Hydrolysis_X_ND_Layer5;
    };

 
 
 

    interface.Underflow[S_I] = - state.S_I_Layer[5] * interface.Q_Under;
    interface.Underflow[S_O] = - state.S_O_Layer[5] * interface.Q_Under;
    interface.Underflow[S_S] = - state.S_S_Layer[5] * interface.Q_Under;
    interface.Underflow[S_ALK] = - state.S_ALK_Layer[5] * interface.Q_Under;
    interface.Underflow[S_NH] = - state.S_NH_Layer[5] * interface.Q_Under;
    interface.Underflow[S_ND] = - state.S_ND_Layer[5] * interface.Q_Under;
    interface.Underflow[S_NO] = - state.S_NO_Layer[5] * interface.Q_Under;
    interface.Underflow[X_BA] = - state.X_BA_Layer[5] * interface.Q_Under;
    interface.Underflow[X_BH] = - state.X_BH_Layer[5] * interface.Q_Under;
    interface.Underflow[X_I] = - state.X_I_Layer[5] * interface.Q_Under;
    interface.Underflow[X_P] = - state.X_P_Layer[5] * interface.Q_Under;
    interface.Underflow[X_S] = - state.X_S_Layer[5] * interface.Q_Under;
    interface.Underflow[X_ND] = - state.X_ND_Layer[5] * interface.Q_Under;

 
 
 

    interface.Outflow[S_I] = - state.S_I_Layer[1] * state.Q_Out;
    interface.Outflow[S_O] = - state.S_O_Layer[1] * state.Q_Out;
    interface.Outflow[S_S] = - state.S_S_Layer[1] * state.Q_Out;
    interface.Outflow[S_ALK] = - state.S_ALK_Layer[1] * state.Q_Out;
    interface.Outflow[S_NH] = - state.S_NH_Layer[1] * state.Q_Out;
    interface.Outflow[S_ND] = - state.S_ND_Layer[1] * state.Q_Out;
    interface.Outflow[S_NO] = - state.S_NO_Layer[1] * state.Q_Out;
    interface.Outflow[X_BA] = - state.X_BA_Layer[1] * state.Q_Out;
    interface.Outflow[X_BH] = - state.X_BH_Layer[1] * state.Q_Out;
    interface.Outflow[X_I] = - state.X_I_Layer[1] * state.Q_Out;
    interface.Outflow[X_P] = - state.X_P_Layer[1] * state.Q_Out;
    interface.Outflow[X_S] = - state.X_S_Layer[1] * state.Q_Out;
    interface.Outflow[X_ND] = - state.X_ND_Layer[1] * state.Q_Out;

 
 
 
    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

     state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Outflow[Comp_Index]));

    {
     state.X_Out = IF (state.Q_In <= interface.Q_Under)
       THEN 0
       ELSE state.Help_X_Out *  parameters.F_TSS_COD / (state.Q_In - interface.Q_Under );

     };

     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));

    {state.X_Under = 
        IF (state.Q_In <= interface.Q_Under)
    THEN
      IF (state.Q_In == 0)
      THEN 0
      ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
    ELSE 
      IF (interface.Q_Under == 0)
      THEN 0
      ELSE
               state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
     };

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
	 
   };
 :};




# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primarytakacs.msl" 1
 



















 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



CLASS PrimaryTakacs (* icon = "primary_clarifier" *) "Layered clarifier model by Takacs"
EXTENDS SettlingTank_TakacsNonSVI WITH
{:

  comments <- "A model for a primary settler by Takacs";
  
  interface <-
  { 
    OBJ PumpingEnergy (* terminal = "out_3" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };
  
  parameters <- 
  {     
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };
  
  initial <-
  {
    state.Help_f_ns := parameters.f_ns ;
  };
  
  equations <-
  {
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };

:};



# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primarytakacssolublespropagator.msl" 1
 



















 
 
 

 
 

 
 CLASS PrimaryTakacsSolublesPropagator
 (* icon = "primary_clarifier" *)
 "Takacs Solubles Propagator for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 EXTENDS PST_Takacs_PropagateSolubles_Base WITH
{:

   parameters <- 
   {     
	OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
   };

   state <-
   {
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
   };

  equations <-
   {
    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };
   };

:};


 CLASS PST_Takacs_PropagateSolubles_Base
 SPECIALISES PhysicalDAEModelType :=
{:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :}; 
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length  := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration  := {: group <- "Settling" :};  
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration  := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration  := {: group <- "Concentration" :}; 
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration  := {: group <- "Concentration" :};   
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_I_Layer "Vector containing concentration of S_I for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_S_Layer "Vector containing concentration of S_S for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_O_Layer "Vector containing concentration of S_O for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NO_Layer "Vector containing concentration of S_NO for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NH_Layer "Vector containing concentration of S_NH for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ND_Layer "Vector containing concentration of S_ND for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ALK_Layer "Vector containing concentration of S_ALK for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v_S "Static settling velocity" : LayerVelocityVector;  
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": LayerVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : LayerArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : LayerArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : LayerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": LayerArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of the layers" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of the layers" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual ; 

    { 
     state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD ;
    };

    state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (state.Q_Under_Actual  / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    { DERIV(state.S_I_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_I_Layer[2] - state.S_I_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_I_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_I] - state.Q_In * state.S_I_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_I_Layer[Layer_Index+1] - state.S_I_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_I_Layer[Layer_Index-1] - state.S_I_Layer[Layer_Index]);
    };

    { DERIV(state.S_S_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_S_Layer[2] - state.S_S_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_S_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_S] - state.Q_In * state.S_S_Layer[IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_S_Layer[Layer_Index+1] - state.S_S_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_S_Layer[Layer_Index-1] - state.S_S_Layer[Layer_Index]);
    };    

    { DERIV(state.S_O_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_O_Layer[2] - state.S_O_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_O_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_O] - state.Q_In * state.S_O_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_O_Layer[Layer_Index+1] - state.S_O_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_O_Layer[Layer_Index-1] - state.S_O_Layer[Layer_Index]);
    };

    { DERIV(state.S_NO_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NO_Layer[2] - state.S_NO_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NO_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NO] - state.Q_In * state.S_NO_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NO_Layer[Layer_Index+1] - state.S_NO_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NO_Layer[Layer_Index-1] - state.S_NO_Layer[Layer_Index]);
    };

    { DERIV(state.S_NH_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NH_Layer[2] - state.S_NH_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NH_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NH] - state.Q_In * state.S_NH_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NH_Layer[Layer_Index+1] - state.S_NH_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NH_Layer[Layer_Index-1] - state.S_NH_Layer[Layer_Index]);
    };

    { DERIV(state.S_ND_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ND_Layer[2] - state.S_ND_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ND_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ND] - state.Q_In * state.S_ND_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ND_Layer[Layer_Index+1] - state.S_ND_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ND_Layer[Layer_Index-1] - state.S_ND_Layer[Layer_Index]);
    };

    { DERIV(state.S_ALK_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ALK_Layer[2] - state.S_ALK_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ALK_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ALK] - state.Q_In * state.S_ALK_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ALK_Layer[Layer_Index+1] - state.S_ALK_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ALK_Layer[Layer_Index-1] - state.S_ALK_Layer[Layer_Index]);
    };

    { DERIV(state.S_I_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_I_Layer[NrOfLayersButOne] - state.S_I_Layer[NrOfLayers]);
    };
 
    { DERIV(state.S_S_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_S_Layer[NrOfLayersButOne] - state.S_S_Layer[NrOfLayers]);
    };

    { DERIV(state.S_O_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_O_Layer[NrOfLayersButOne] - state.S_O_Layer[NrOfLayers]);
    };

    { DERIV(state.S_NO_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NO_Layer[NrOfLayersButOne] - state.S_NO_Layer[NrOfLayers]);
    };

    { DERIV(state.S_NH_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NH_Layer[NrOfLayersButOne] - state.S_NH_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ND_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ND_Layer[NrOfLayersButOne] - state.S_ND_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ALK_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ALK_Layer[NrOfLayersButOne] - state.S_ALK_Layer[NrOfLayers]);
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];    

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                parameters.H / NrOfLayers;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;
    
    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];
    interface.Overflow[S_I] = -state.S_I_Layer[1]*state.Q_Out;
    interface.Overflow[S_S] = -state.S_S_Layer[1]*state.Q_Out;
    interface.Overflow[S_O] = -state.S_O_Layer[1]*state.Q_Out;
    interface.Overflow[S_NO] = -state.S_NO_Layer[1]*state.Q_Out;
    interface.Overflow[S_NH] = -state.S_NH_Layer[1]*state.Q_Out;
    interface.Overflow[S_ND] = -state.S_ND_Layer[1]*state.Q_Out;
    interface.Overflow[S_ALK] = -state.S_ALK_Layer[1]*state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual  / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    interface.Underflow[S_I] = -state.S_I_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_S] = -state.S_S_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_O] = -state.S_O_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_NO] = -state.S_NO_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_NH] = -state.S_NH_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ND] = -state.S_ND_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ALK] = -state.S_ALK_Layer[NrOfLayers]*state.Q_Under_Actual ;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

 

    interface.Sludge_Blanket_Height = state.H_S;
   };

:};





# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primarytakacsallfractionpropagator.msl" 1
 



















 CLASS PrimaryTakacsAllFractionPropagator
 (* icon = "primary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : LayerVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": LayerVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : LayerArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : LayerArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : LayerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": LayerArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;

   state.Integ_PE = 0.0 ;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD  ;
    };






    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 


{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
    state.X_Layer[Layer_Index] = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
state.C[Comp_Index][Layer_Index] * parameters.F_TSS_COD);
};








 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};



# 26 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.base.primary_clarifier.primarytakacsreactive1.msl" 1
 




















 CLASS PrimaryTakacsReactive1
 (* icon = "primary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1"*) "Height of the sludge blanket" : 
         Length := {: causality <- "COUT" ; group <- "Measurement data":};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
 
 
   };

   parameters <-
   {
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components, m^3*g^-1" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :};
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ k_Floc "Flocculation rate constant" : Rate := {: value <- 0.5 ; group <- "Kinetic" :};
    OBJ k_a "Ammonification rate constant" : Rate := {: value <- 0.5 ; group <- "Kinetic" :};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :};
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};
    OBJ X_Layer "Concentration of particulates in a layer" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : LayerVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": LayerVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : LayerArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : LayerArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : LayerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": LayerArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In "Sum of massfluxes of particulates" : MassFlux  := {: group <- "Influent characterization" :};
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ;
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers);
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A;

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index];
    };

    { state.Q_In =
       (parameters.WWTPSpecificVolume[IndexOfSolvent]
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 

    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD;
    };

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 

{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
    state.X_Layer[Layer_Index] = ((SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
state.C[Comp_Index][Layer_Index]) * parameters.F_TSS_COD);
};

 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A;

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min)
        THEN 0
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index])
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 

   
   

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. S_S}:
    { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1])
       - parameters.k_Floc * state.C[Comp_Index][1] * state.X_Layer[1] / parameters.F_TSS_COD;
    };
};

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. S_S}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
             - parameters.k_Floc * state.C[Comp_Index][IndexOfFeedLayer] * state.X_Layer[IndexOfFeedLayer] / parameters.F_TSS_COD
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
             - parameters.k_Floc * state.C[Comp_Index][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD
        ELSE state.D_Under * (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index])
             - parameters.k_Floc * state.C[Comp_Index][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD;
    };
};

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. S_S}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers])
       - parameters.k_Floc * state.C[Comp_Index][NrOfLayers] * state.X_Layer[NrOfLayers] / parameters.F_TSS_COD;
    };
};

   

   { DERIV(state.C[S_O][1],[independent.t]) =
       state.D_Out * (state.C[S_O][2] - state.C[S_O][1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_O][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_O]
       - state.Q_In * state.C[S_O][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out *
     (state.C[S_O][Layer_Index+1] - state.C[S_O][Layer_Index])
        ELSE state.D_Under *
         (state.C[S_O][Layer_Index-1] - state.C[S_O][Layer_Index]);
    };

    { DERIV(state.C[S_O][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_O][NrOfLayersButOne] - state.C[S_O][NrOfLayers]);
    };
   

   { DERIV(state.C[S_NO][1],[independent.t]) =
       state.D_Out * (state.C[S_NO][2] - state.C[S_NO][1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_NO][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NO]
       - state.Q_In * state.C[S_NO][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out *
     (state.C[S_NO][Layer_Index+1] - state.C[S_NO][Layer_Index])
        ELSE state.D_Under *
         (state.C[S_NO][Layer_Index-1] - state.C[S_NO][Layer_Index]);
    };

    { DERIV(state.C[S_NO][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_NO][NrOfLayersButOne] - state.C[S_NO][NrOfLayers]);
    };

 

    { DERIV(state.C[S_NH][1],[independent.t]) =
       state.D_Out * (state.C[S_NH][2] - state.C[S_NH][1])
      + parameters.k_a * state.C[S_ND][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_NH][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NH] - state.Q_In * state.C[S_NH][IndexOfFeedLayer])
             + parameters.k_a * state.C[S_ND][IndexOfFeedLayer]
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * (state.C[S_NH][Layer_Index+1] - state.C[S_NH][Layer_Index])
             + parameters.k_a * state.C[S_ND][Layer_Index]
        ELSE state.D_Under * (state.C[S_NH][Layer_Index-1] - state.C[S_NH][Layer_Index])
             + parameters.k_a * state.C[S_ND][Layer_Index];
    };

    { DERIV(state.C[S_NH][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_NH][NrOfLayersButOne] - state.C[S_NH][NrOfLayers])
       + parameters.k_a * state.C[S_ND][NrOfLayers];
    };

   

    { DERIV(state.C[S_ND][1],[independent.t]) =
       state.D_Out * (state.C[S_ND][2] - state.C[S_ND][1])
       - parameters.k_a * state.C[S_ND][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_ND][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ND] - state.Q_In * state.C[S_ND][IndexOfFeedLayer])
             - parameters.k_a * state.C[S_ND][IndexOfFeedLayer]
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * (state.C[S_ND][Layer_Index+1] - state.C[S_ND][Layer_Index])
             - parameters.k_a * state.C[S_ND][Layer_Index]
        ELSE state.D_Under * (state.C[S_ND][Layer_Index-1] - state.C[S_ND][Layer_Index])
             - parameters.k_a * state.C[S_ND][Layer_Index];
    };

    { DERIV(state.C[S_ND][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_ND][NrOfLayersButOne] - state.C[S_ND][NrOfLayers])
       - parameters.k_a * state.C[S_ND][NrOfLayers];
    };

   
   { DERIV(state.C[S_ALK][1],[independent.t]) =
       state.D_Out * (state.C[S_ALK][2] - state.C[S_ALK][1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_ALK][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ALK]
       - state.Q_In * state.C[S_ALK][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out *
     (state.C[S_ALK][Layer_Index+1] - state.C[S_ALK][Layer_Index])
        ELSE state.D_Under *
         (state.C[S_ALK][Layer_Index-1] - state.C[S_ALK][Layer_Index]);
    };

    { DERIV(state.C[S_ALK][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_ALK][NrOfLayersButOne] - state.C[S_ALK][NrOfLayers]);
    };

 

   
   

{ DERIV(state.C[X_I][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_I][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_I][1] / state.X_Layer[1]) - state.D_Out * state.C[X_I][1]
       + parameters.k_Floc * state.C[S_I][1] * state.X_Layer[1] / parameters.F_TSS_COD;
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_I][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_I][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_I][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_I]
             + parameters.k_Floc * state.C[S_I][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_I][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_I][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_I][Layer_Index] / state.X_Layer[Layer_Index])
             + parameters.k_Floc * state.C[S_I][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD;
    };

    { DERIV(state.C[X_I][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_I][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_I][NrOfLayers]
       + parameters.k_Floc * state.C[S_I][NrOfLayers] * state.X_Layer[NrOfLayers] / parameters.F_TSS_COD;
    };

   
   

{ DERIV(state.C[X_S][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_S][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_S][1] / state.X_Layer[1]) - state.D_Out * state.C[X_S][1]
       + parameters.k_Floc * state.C[S_S][1] * state.X_Layer[1] / parameters.F_TSS_COD;
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_S][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_S][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_S][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_S]
             + parameters.k_Floc * state.C[S_S][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_S][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_S][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_S][Layer_Index] / state.X_Layer[Layer_Index])
             + parameters.k_Floc * state.C[S_S][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD;
    };

    { DERIV(state.C[X_S][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_S][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_S][NrOfLayers]
       + parameters.k_Floc * state.C[S_S][NrOfLayers] * state.X_Layer[NrOfLayers] / parameters.F_TSS_COD;
    };

   

  { DERIV(state.C[X_BH][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_BH][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_BH][1] / state.X_Layer[1]) - state.D_Out * state.C[X_BH][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_BH][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_BH][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_BH][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_BH]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_BH][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_BH][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_BH][Layer_Index] / state.X_Layer[Layer_Index]);
    };

   { DERIV(state.C[X_BH][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_BH][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_BH][NrOfLayers];
    };

   

  { DERIV(state.C[X_BA][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_BA][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_BA][1] / state.X_Layer[1]) - state.D_Out * state.C[X_BA][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_BA][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_BA][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_BA][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_BA]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_BA][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_BA][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_BA][Layer_Index] / state.X_Layer[Layer_Index]);
    };

   { DERIV(state.C[X_BA][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_BA][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_BA][NrOfLayers];
    };

 

  { DERIV(state.C[X_P][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_P][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_P][1] / state.X_Layer[1]) - state.D_Out * state.C[X_P][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_P][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_P][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_P][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_P]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_P][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_P][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_P][Layer_Index] / state.X_Layer[Layer_Index]);
    };

   { DERIV(state.C[X_P][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_P][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_P][NrOfLayers];
    };

   

    { DERIV(state.C[X_ND][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_ND][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_ND][1] / state.X_Layer[1]) - state.D_Out * state.C[X_ND][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_ND][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_ND][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_ND][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_ND]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_ND][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_ND][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_ND][Layer_Index] / state.X_Layer[Layer_Index]);
    };

    { DERIV(state.C[X_ND][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_ND][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_ND][NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 

    state.SolidFlux_Out = state.X_Out * state.Q_Out ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

    interface.Sludge_Blanket_Height = state.H_S;

   };

 :};





# 27 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

 
 



 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.pointsettler.tss.msl" 1
 




















# 354 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.pointsettler.tss.msl"




# 35 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.pointsettler.iss.msl" 1
 



















# 89 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/wwtp.pointsettler.iss.msl"




# 36 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.primary_clarifier.msl" 2




# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 1
 


















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarypointsettler.msl" 1
 





















CLASS SecondaryPointSettler (* icon = "secondary_clarifier" *)
"Point-settler model for secondary clarifiers"
EXTENDS PointSettler WITH
{:

  comments <- "A model for a secondary point settler only using mass balances";
  
  interface <-
  {
    OBJ f_ns (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Non-settleable fraction of suspended solids" :
      Fraction := {: causality <- "CIN" ; value <- 0.005 ; group <- "Settling" :};
  };
  
  state <-
  {
    OBJ DS "Dry Solid content of the primary sludge" : Real := {: unit <- "%"; group <- "Settling" :};
  };
  
  equations <-
  {
    state.f_ns_help = IF (state.Q_Under_Actual > 0) THEN interface.f_ns
      ELSE 1.0 ;

    state.DS = state.X_Under / 10000 ;
  };

:};





# 20 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.marsililibelli.msl" 1
 



















 CLASS MarsiliLibelli
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
 
 
 
 
 
 
 
 
 
 
 
 
 
   Comments <- "A model for a secondary settler by Marsili Libelli";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ A (* is_favorite = "1" *) "Surface of secondary clarifier" : Area := {: value <- 400 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of secondary clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Limit sedimentation velocity for diluted suspensions" : Velocity := {: value <- 4 ; group <- "Settling" :};
    OBJ N "Cole sludge concentration dependency parameter" : Real := {: value <- 2.75 ; group <- "Settling" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ J_T "Total sludge flux" : ArealFlux := {: group <- "Settling" :};
    OBJ help (* hidden = "1" *) "Help variable" : Real;
    OBJ AA (* hidden = "1" *) "Help variable" : Real;
    OBJ U "Underflow velocity" : Velocity := {: group <- "Settling" :};
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ M "Mass of sludge in secondary clarifier" : Mass := {: group <- "Mass" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_L "Limiting sludge biomass concentration" : Concentration := {: group <- "Settling" :};
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   state.Integ_PE = 0.0 ;
   };

  equations <-
   {           
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 
    
    state.U = state.Q_Under_Actual / parameters.A;

    state.AA = 1 - parameters.N;
    state.help = IF (state.U == 0)
         THEN 0
         ELSE log(-state.U / (state.AA * parameters.v0)) ;

    state.J_T = 1000 * (parameters.v0 * exp(state.AA / (state.AA - 1) * state.help) + state.U *
               exp(1 / (state.AA - 1) * state.help));
    state.X_L = 1000 * exp(1 / (state.AA - 1) * state.help);

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.H_S = state.M / state.X_L / parameters.A;

    state.X_Out = IF (state.H_S <= parameters.H)
                THEN 0
                ELSE state.X_L;

 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD)  ;
    };






    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

    state.X_Under = IF (( state.SolidFlux_In) >= (parameters.A *state.J_T))   
          THEN
              IF (state.Q_Under_Actual == 0)
          THEN 0 
          ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                    ELSE
                      IF (state.H_S > 0)
                      THEN
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                      ELSE
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE state.SolidFlux_In / state.Q_Under_Actual;

    {DERIV(state.M,[independent.t]) =
             IF (state.SolidFlux_In >= (parameters.A * state.J_T))
             THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
             ELSE
               IF (state.H_S > 0)
               THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
               ELSE 0;
    };

 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
interface.Overflow[Comp_Index] = 
IF (state.Q_In == 0)
    THEN 0 
    ELSE
- state.InFluxPerComponent[Comp_Index] * state.Q_Out / state.Q_In;
      };

       interface.Underflow[IndexOfSolvent] = 
              - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent];

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] = 
 - (state.InFluxPerComponent[Comp_Index]
        + interface.Overflow[Comp_Index]) ;
     };

    interface.TSS = state.M /(parameters.A * parameters.H);

    interface.V_Clarifier = parameters.A * parameters.H;  

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };
 :};




# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondaryotterpohlfreund.msl" 1
 



















 CLASS SecondaryOtterpohlFreund
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
 
 
 
 
 
 
 
 
 
 
 
 
 
 

   Comments <- "A model for a secondary settler by Otterpohl and Freund";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge volume index" : Real := 
        {: 
          causality <- "CIN" ; 
      value <- 100;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; upperBound <- 1000; :};
        :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

   parameters <- 
   {
    
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v_FS "Settling velocity for small fraction of solids" : Velocity := {: value <- 0.24 ; group <- "Settling" :};
    OBJ f0 "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.04;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ A_FS "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.00078;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ J_Up_FS (* hidden = "1" *) "Upward sludge flux of the small solids fraction" : LayerArealFluxVector;
    OBJ J_Up_FM (* hidden = "1" *) "Upward sludge flux of the macroflocs" : LayerArealFluxVector;
    OBJ J_Dn_FS (* hidden = "1" *) "Downward sludge flux of the small solids fraction" : LayerArealFluxVector;
    OBJ J_Dn_FM (* hidden = "1" *) "Downward sludge flux macroflocs" : LayerArealFluxVector;
    OBJ J_G_FS (* hidden = "1" *) "Static sludge flux of the small solids fraction" : LayerArealFluxVector;
    OBJ J_G_FM (* hidden = "1" *) "Static sludge flux of the macroflocs" : LayerArealFluxVector;
    OBJ J_G_FM_Help (* hidden = "1" *) "Static sludge flux of the macroflocs": LayerArealFluxVector;
    OBJ J_G_FS_Help (* hidden = "1" *) "Static sludge flux of the small solids fraction": LayerArealFluxVector;
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;

    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};

    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    
    OBJ X_FM_Layer "Vector containing concentration of macroflocs for all the layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ X_FS_Layer "Vector containing concentration of small solids  for all the layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
    OBJ v_FM "Settling velocity for macroflocs" : LayerVelocityVector := {: group <- "Settling" :};
    OBJ f1 "Fraction of small solids" : Fraction := {: group <- "Influent characterization" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  

     
    OBJ B (* hidden = "1" *) "variable B of the omega function" : Real ;
    OBJ help_var_omega (* hidden = "1" *) "help state" : Real ;
    
    OBJ H_T "Height of transition point" : Length := {: group <- "Settling" :};
    OBJ H_C "Height of compressing point" : Length := {: group <- "Settling" :};
    OBJ H0 "Height of influent" : Length := {: group <- "Dimension" :};
    OBJ omega (* hidden = "1" *) "Hartels omega function" : Real[NrOfLayers;] ;
    OBJ z (* hidden = "1" *) "Vertical coordinate, bottom z=0" : LengthVector ;
    OBJ X_C "Solids concentration at compression point" : Concentration := {: group <- "Settling" :};
    OBJ X_AT "Solids concentration of the aeration tank" : Concentration := {: group <- "Concentration" :};
    OBJ X_FM_AT "Solids concentration of the aeration tank, macroflocs" : Concentration := {: group <- "Concentration" :};
    OBJ X_FS_AT "Solids concentration of the aeration tank, small solids" : Concentration := {: group <- "Concentration" :};
    OBJ k (* hidden = "1" *) "Part of the Vesilind equation, here results of Hartel" : Real ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of small solids and macroflocs" : Concentration ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
    state.H0 = ((NrOfLayers - IndexOfFeedLayer) + 0.5) * state.H_Layer;
    state.X_C = 480 / interface.SVI ;
    state.k = 1.043 - 0.9834 * exp( -0.00581 * interface.SVI) ;
    state.help_var_omega = -(1 + 2 * interface.SVI / (100 + interface.SVI));

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
     state.z[Layer_Index] =
        ((NrOfLayers - Layer_Index) + 0.5) * state.H_Layer ;
    };

   state.Integ_PE = 0.0 ;
   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
          state.InFluxPerComponent[Comp_Index]* parameters.F_TSS_COD) ;
    };






     
     
     
    state.B = - (( 100 + interface.SVI) / interface.SVI + 1)
                * pow(state.H_C, (1 + 2 * interface.SVI / (100 + interface.SVI)));

    

    state.H_T = IF(2 * state.H_C > state.H0)
                THEN state.H0
                ELSE 2 * state.H_C ;

    state.H_C = (state.X_AT * state.H0 / state.X_C) * (1 - 1 / (state.X_C * state.k)) ;
    state.X_AT = IF (state.Q_In == 0 )
             THEN 0
         ELSE state.SolidFlux_In / state.Q_In;

 
 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.omega[Layer_Index] = IF (state.H_T == 0)
             THEN 1 / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega))
             ELSE (1 - state.B * pow(state.H_T,state.help_var_omega))
              / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega));
    };

    state.f1 = parameters.f0 * exp( - parameters.A_FS * state.X_AT) ;

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.v_FM[Layer_Index] = 
             (17.4 * exp(-0.00581 * interface.SVI) + 3.931)
             * (exp(-(-0.9834e-3 * exp(-0.00581 * interface.SVI) + 1.043e-3)
                       * (state.X_FM_Layer[Layer_Index] + state.X_FS_Layer[Layer_Index])))
             * 24 ;
    };

     
     
     

    state.X_FM_AT = state.X_AT * (1 - state.f1) ;
    state.X_FS_AT = state.X_AT * state.f1 ;

    state.v_Up = state.Q_Out / parameters.A; 
    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FM_Help[Layer_Index] =
        state.v_FM[Layer_Index] * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FS_Help[Layer_Index] =
        parameters.v_FS * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FS[Layer_Index] =
        state.v_Up * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FM[Layer_Index] =
        state.v_Up * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FS[Layer_Index] =
        state.v_Dn * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FM[Layer_Index] =
        state.v_Dn * state.X_FM_Layer[Layer_Index];
    };

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FS[Layer_Index] =
        IF (state.J_G_FS_Help[Layer_Index] > state.J_G_FS_Help[Layer_Index+1])
        THEN state.J_G_FS_Help[Layer_Index+1]
        ELSE state.J_G_FS_Help[Layer_Index] ;
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FM[Layer_Index] =
        IF (state.J_G_FM_Help[Layer_Index] > state.J_G_FM_Help[Layer_Index+1])
        THEN state.J_G_FM_Help[Layer_Index+1]
        ELSE state.J_G_FM_Help[Layer_Index] ;
    };

     
     
     

    { DERIV(state.X_FS_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FS[2] - state.J_G_FS[1] - ( state.Q_Out / parameters.A * state.X_FS_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FS_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FS[Layer_Index] - state.J_Up_FS[Layer_Index]
             + state.J_G_FS[Layer_Index-1]
             - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * state.f1
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FS[Layer_Index+1] - ( state.J_Up_FS[Layer_Index])
                - state.J_G_FS[Layer_Index] + state.J_G_FS[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FS[Layer_Index-1] - ( state.J_Dn_FS[Layer_Index])
                + (state.J_G_FS[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FS_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FS[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FS_Layer[NrOfLayers])
       + (state.J_G_FS[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    { DERIV(state.X_FM_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FM[2] - state.J_G_FM[1] - ( state.Q_Out / parameters.A * state.X_FM_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FM_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FM[Layer_Index] - state.J_Up_FM[Layer_Index]
             + state.J_G_FM[Layer_Index-1]
             - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * (1 - state.f1)
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FM[Layer_Index+1] - ( state.J_Up_FM[Layer_Index])
                - state.J_G_FM[Layer_Index] + state.J_G_FM[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FM[Layer_Index-1] - ( state.J_Dn_FM[Layer_Index])
                + (state.J_G_FM[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FM_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FM[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FM_Layer[NrOfLayers])
       + (state.J_G_FM[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_FS_Layer[1] + state.X_FM_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_FS_Layer[NrOfLayers] + state.X_FM_Layer[NrOfLayers];

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    }; 

    { state.SolidConcentration = (SUMOVER Layer_Index IN {1 .. NrOfLayers}:
       state.X_FS_Layer[Layer_Index] + state.X_FM_Layer[Layer_Index]) ;
    };

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.takacs.msl" 1
 




















 
 
 
 
 
 
 
 
 
 
 
 

CLASS Takacs (* icon = "secondary_clarifier"*) "Layered clarifier model by Takacs"
EXTENDS SettlingTank_TakacsNonSVI WITH
{:

  comments <- "A model for a secondary settler by Takacs";

  interface <-
  { 
    OBJ TSS (* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *) "Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PumpingEnergy (* terminal = "out_3" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };
  
  parameters <- 
  {     
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };
  
  initial <-
  {
    state.Help_f_ns := parameters.f_ns ;
  };
  
  equations <-
  {
     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
     
    interface.TSS = state.SolidConcentration;
    interface.V_Clarifier = parameters.A * parameters.H;  
  };

:};






# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.takacssvi.msl" 1
 




















 
 
 
 
 
 
 
 
 
 
 
 
 

CLASS Takacs_SVI (* icon = "secondary_clarifier"; is_default = "true" *) "Layered clarifier model by Takacs"
EXTENDS SettlingTank_TakacsSVI WITH
{:
  comments <- "A model for a secondary settler by Takacs";
  
  interface <-
  { 
    OBJ f_ns (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Non-settleable fraction of suspended solids" :
      Fraction := {: causality <- "CIN" ; value <- 0.00228 ; group <- "Settling" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };
  
  parameters <- 
  {     
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };
  
  state <-
  {
    OBJ DS "Dry Solid content of the secondary sludge" : Real := {: unit <- "%"; group <- "Settling" :};
  };

  equations <-
  {
    state.Help_f_ns = interface.f_ns ;
    state.DS = state.X_Under / 10000 ;

     
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
     
    interface.TSS = state.SolidConcentration;
    interface.V_Clarifier = parameters.A * parameters.H;  
  };

:};





# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl" 1
 



















 
 
 

 
 

 CLASS SecondaryTakacsSolublesPropagator
 (* icon = "secondary_clarifier" *)
 "Takacs_Solubles"

 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :}; 
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : LayerConcentrationVector := {: group <- "Concentration" :};

 

    OBJ S_S_Layer "Vector containing concentration of S_S for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NO_Layer "Vector containing concentration of S_NO for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ND_Layer "Vector containing concentration of S_ND for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};

 
# 110 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"

 
# 122 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


    OBJ S_O_Layer "Vector containing concentration of S_O for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_I_Layer "Vector containing concentration of S_I for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NH_Layer "Vector containing concentration of S_NH for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ALK_Layer "Vector containing concentration of S_ALK for all layers" : LayerConcentrationVector := {: group <- "Concentration" :};

    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : LayerVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": LayerVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : LayerArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : LayerArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : LayerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": LayerArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *) "Volume of the layers" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of the layers" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual ; 

    
    { 
     state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD ;
    };
    

    





    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };
 
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.S_I_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_I_Layer[2] - state.S_I_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_I_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_I] - state.Q_In * state.S_I_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_I_Layer[Layer_Index+1] - state.S_I_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_I_Layer[Layer_Index-1] - state.S_I_Layer[Layer_Index]);
    };

    { DERIV(state.S_O_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_O_Layer[2] - state.S_O_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_O_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_O] - state.Q_In * state.S_O_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_O_Layer[Layer_Index+1] - state.S_O_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_O_Layer[Layer_Index-1] - state.S_O_Layer[Layer_Index]);
    };

 

    { DERIV(state.S_NO_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NO_Layer[2] - state.S_NO_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NO_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NO] - state.Q_In * state.S_NO_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NO_Layer[Layer_Index+1] - state.S_NO_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NO_Layer[Layer_Index-1] - state.S_NO_Layer[Layer_Index]);
    };

    { DERIV(state.S_S_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_S_Layer[2] - state.S_S_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_S_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_S] - state.Q_In * state.S_S_Layer[IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_S_Layer[Layer_Index+1] - state.S_S_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_S_Layer[Layer_Index-1] - state.S_S_Layer[Layer_Index]);
    };    
	 
    { DERIV(state.S_ND_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ND_Layer[2] - state.S_ND_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ND_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ND] - state.Q_In * state.S_ND_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ND_Layer[Layer_Index+1] - state.S_ND_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ND_Layer[Layer_Index-1] - state.S_ND_Layer[Layer_Index]);
    };


 
# 480 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


 
# 628 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


    { DERIV(state.S_NH_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NH_Layer[2] - state.S_NH_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NH_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NH] - state.Q_In * state.S_NH_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NH_Layer[Layer_Index+1] - state.S_NH_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NH_Layer[Layer_Index-1] - state.S_NH_Layer[Layer_Index]);
    };

{ DERIV(state.S_ALK_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ALK_Layer[2] - state.S_ALK_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ALK_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ALK] - state.Q_In * state.S_ALK_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ALK_Layer[Layer_Index+1] - state.S_ALK_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ALK_Layer[Layer_Index-1] - state.S_ALK_Layer[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (state.Q_Under_Actual  / state.V_Layer) * state.X_Layer[NrOfLayers];
    };
    
 

    { DERIV(state.S_NO_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NO_Layer[NrOfLayersButOne] - state.S_NO_Layer[NrOfLayers]);
    };

    { DERIV(state.S_S_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_S_Layer[NrOfLayersButOne] - state.S_S_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ND_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ND_Layer[NrOfLayersButOne] - state.S_ND_Layer[NrOfLayers]);
    };



 
# 719 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


 
# 761 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


    { DERIV(state.S_I_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_I_Layer[NrOfLayersButOne] - state.S_I_Layer[NrOfLayers]);
    };
 
    { DERIV(state.S_O_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_O_Layer[NrOfLayersButOne] - state.S_O_Layer[NrOfLayers]);
    };

    { DERIV(state.S_NH_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NH_Layer[NrOfLayersButOne] - state.S_NH_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ALK_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ALK_Layer[NrOfLayersButOne] - state.S_ALK_Layer[NrOfLayers]);
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];
    

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                parameters.H / NrOfLayers;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;
    
    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 

    interface.Overflow[S_NO] = -state.S_NO_Layer[1]*state.Q_Out;
    interface.Overflow[S_S] = -state.S_S_Layer[1]*state.Q_Out;
    interface.Overflow[S_ND] = -state.S_ND_Layer[1]*state.Q_Out;

	 
 
# 822 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


 
# 835 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


    interface.Overflow[S_I] = -state.S_I_Layer[1]*state.Q_Out;
    interface.Overflow[S_O] = -state.S_O_Layer[1]*state.Q_Out;
    interface.Overflow[S_NH] = -state.S_NH_Layer[1]*state.Q_Out;
    interface.Overflow[S_ALK] = -state.S_ALK_Layer[1]*state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual ;
    

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual  / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 

    interface.Underflow[S_NO] = -state.S_NO_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_S] = -state.S_S_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ND] = -state.S_ND_Layer[NrOfLayers]*state.Q_Under_Actual ;

	 
 
# 872 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"

	 
 
# 885 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"


    interface.Underflow[S_I] = -state.S_I_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_O] = -state.S_O_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_NH] = -state.S_NH_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ALK] = -state.S_ALK_Layer[NrOfLayers]*state.Q_Under_Actual ;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

 

    interface.Sludge_Blanket_Height = state.H_S;
 
    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};



# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacsallfractionpropagator.msl" 1
 



















 CLASS SecondaryTakacsAllFractionPropagator
 (* icon = "secondary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : LayerConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : LayerVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": LayerVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : LayerArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : LayerArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : LayerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": LayerArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;

   state.Integ_PE = 0.0 ;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD  ;
    };






    {state.X_In = IF (state.Q_In == 0)
                        THEN 0
                        ELSE state.SolidFlux_In / state.Q_In;
     };

 


{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
    state.X_Layer[Layer_Index] = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
state.C[Comp_Index][Layer_Index] * parameters.F_TSS_COD);
};








 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

    interface.Sludge_Blanket_Height = state.H_S;
 
    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

   
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 26 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.secondary_clarifier.burger.msl" 1
 














 
 




CLASS LengthFlux "Mass per unit of length and per unit of time"
SPECIALISES PhysicalQuantityType :=
{:
  quantity <- "LengthFlux";
  unit     <- "g/(m*d)";
  interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};

CLASS BurgerConcentrationVector = Concentration[NrOfLayersPlusFourBurger;];
CLASS BurgerArealFluxVector = ArealFlux[NrOfLayersPlusFourBurger;];





CLASS Base_Burger
"Burger-Diehl model for a layered clarifier with Vesilind settling function" SPECIALISES PhysicalDAEModelType :=
{:

    interface <-
    {
		OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
		OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
		OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
		OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
		 
		OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    };
	
    parameters <-
    {
		OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/d2)": Acceleration := {: value <- 7.32312576e10 :};
		OBJ PI (* hidden = "1" *) "PI": Real := {: value <- 3.141592653 :};
		OBJ A "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
		OBJ H "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
		OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
		OBJ X_Lim "Minimum concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
		 
		OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
		OBJ r_V "Settling parameter" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :};
		 
		OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
		 
		 
		OBJ Comp_ON "Switch on/off compression": Integer :={: value <- 0 ; group <- "Compression" :};
		OBJ Alpha "Effective solids stress parameter" : Real := {: value <- 0.8;
		  unit <- "m2/s2"; interval  <- {: lowerbound <- 0; upperbound <- PLUS_INF; :}; group <- "Compression" :};
		OBJ Rhos "Solid density": Density := {: value <- 1050000 ; group <- "Compression" :};
		OBJ Rhof "Fluid density": Density := {: value <- 998000 ; group <- "Compression" :};
		OBJ C_crit "Gel point" : Concentration := {: value <- 6000 ; group <- "Compression" :};
		 
		OBJ C_min (* hidden = "1" *) "Minimum packing concentration" : Concentration := {: value <- 0 ; group <- "Settling" :};
		OBJ C_max (* hidden = "1" *) "Maximum packing concentration" : Concentration := {: value <- 20000 ; group <- "Settling" :};
		OBJ TOL (* hidden = "1" *) "Tolerance level to calculate concentration with maximum settling flux" : Fraction := {: value <- 1e-10 ; group <- "Settling" :};
		 
		OBJ Disp_ON "Switch on/off dispersion": Integer :={: value <- 0 ; group <- "Dispersion" :};
		OBJ a_mix "Dispersion parameter" : Length := {: value <- 0.4 ; group <- "Dispersion" :};
		OBJ b_mix "Dispersion parameter" : Real := {: value <- 0.00001;
		  unit <- "d/m2"; interval <- {: lowerbound <- 0; upperbound <- PLUS_INF; :}; group <- "Dispersion" :};
    };
	
    state <-
    {
		OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
		OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;
		OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
		 
		OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
		OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
		OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
		OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;
		OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
		OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
		OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
		 
		OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Under_Actual "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
		OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :};
		OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		 
		 
		OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
		 
		 
		OBJ Fbk_max (* hidden = "1" *) "Maximum flux" : ArealFlux := {: group <- "Settling" :};
		OBJ C_fbk_max (* hidden = "1" *) "Concentration corresponding to maximal settling flux" : Concentration := {: group <- "Settling" :};
    };
	
    initial <-
    {
		parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
		 
		 
		state.C_fbk_max = MSLUBurgerCHat(parameters.v0, parameters.r_V, parameters.C_min, parameters.C_max, parameters.TOL) ;
		state.Fbk_max = parameters.v0 * exp(-parameters.r_V * state.C_fbk_max) * state.C_fbk_max ;
		 
		state.Integ_PE = 0.0 ;
    };

    independent <-
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
	
    equations <-
    {
		state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under) THEN state.Q_In
			ELSE interface.Q_Under ;

		state.v_Dn = state.Q_Under_Actual / parameters.A ;
		
		{ FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
		  	SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

		state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]);
		state.Q_Out = state.Q_In - state.Q_Under_Actual ;

		
		{ state.SolidFlux_In = SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
		  	state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ; };
		

		



		state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;

		state.v_Up = state.Q_Out / parameters.A ;
		
		 
		state.SolidFlux_Out = state.X_Out * state.Q_Out ;
		{ FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent} : interface.Overflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0	ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
		  		IF (state.SolidFlux_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

		 
		state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
		interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
		{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}: interface.Underflow[Comp_Index] =
		  		- state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

		 
		 
		interface.Sludge_Blanket_Height = state.H_S ;
		interface.TSS = state.SolidConcentration ;
		interface.V_Clarifier = parameters.A * parameters.H ;  
		 
		 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
		DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
		interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    };

 :};


CLASS BurgerDiehl
  (* icon = "secondary_clarifier" *)
  "Layered clarifier model by Burger with Vesilind settling function" EXTENDS Base_Burger WITH
  {:
    comments <- "A model for a secondary settler by Burger & Diehl with Vesilind settling";

    state <-
    {
		OBJ v_S (* hidden = "1" *) "Static settling velocity" : Velocity[NrOfLayersPlusFourBurger;];
		OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : BurgerArealFluxVector;
		OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : BurgerArealFluxVector;
		OBJ J_G (* hidden = "1" *) "Static sludge flux" : BurgerArealFluxVector;
		OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": BurgerArealFluxVector;
		 
		OBJ X_Layer "Vector containing concentration of particulates for all the layers" : BurgerConcentrationVector := {: group <- "Concentration" :};
		 
		 
		 
		OBJ D_comp (* hidden = "1" *) "Primitive of compression function" : LengthFlux[NrOfLayersPlusFourBurger;];
		 
		OBJ d_mix (* hidden = "1" *) "Dispersion function" : Diffusivity[NrOfLayersPlusFourBurger;];
		OBJ z "Height in clarifier" : Length[NrOfLayersPlusFourBurger;];
    };

    initial <-
    {
		state.V_Layer = parameters.A * (parameters.H / NrOfLayersBurger);
		state.H_Layer = parameters.H / (NrOfLayersBurger);
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.z[Layer_Index] =
		  	fabs(state.H_Layer * (Layer_Index - IndexOfFeedLayerBurger)) ; };
	};

    equations <-
    {
		{state.SolidConcentration = ( SUMOVER Layer_Index IN {3 .. NrOfLayersPlusTwoBurger}:
			state.X_Layer[Layer_Index]) / NrOfLayersBurger; };
		
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.v_S[Layer_Index] =
		  	parameters.v0 * exp(-parameters.r_V * state.X_Layer[Layer_Index]) ; }; 

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.J_G_Help[Layer_Index] =
		  	state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };
	
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}: state.J_G[Layer_Index] =
		  	IF (state.X_Layer[Layer_Index]<state.X_Layer[Layer_Index+1]) THEN MSLUGetMin2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1])
			   ELSE IF (((state.C_fbk_max-state.X_Layer[Layer_Index])*(state.C_fbk_max-state.X_Layer[Layer_Index+1]))<0) THEN state.Fbk_max
			   ELSE MSLUGetMax2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1]) ; };
	
		 
		{ FOREACH Layer_Index IN {2 .. IndexOfFeedLayerBurger}: state.J_Up[Layer_Index] =
		  	state.v_Up * state.X_Layer[Layer_Index] ; };
		{ FOREACH Layer_Index IN {IndexOfFeedLayerBurger .. NrOfLayersPlusFourBurger}: state.J_Dn[Layer_Index] =
		  	state.v_Dn * state.X_Layer[Layer_Index] ; };

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.D_comp[Layer_Index] =
		       IF (state.X_Layer[Layer_Index] < parameters.C_crit) THEN 0
		 	   ELSE
			   parameters.Comp_ON * parameters.Alpha * pow(24*3600,2) *parameters.Rhos * parameters.v0 *
			   (exp(-parameters.r_V * state.X_Layer[Layer_Index])-exp(-parameters.r_V * parameters.C_crit)) /
			   (-parameters.r_V * parameters.g * (parameters.Rhos-parameters.Rhof)) ; };

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.d_mix[Layer_Index] =
		  	IF (state.z[Layer_Index] < (parameters.b_mix*state.Q_In))
			THEN parameters.Disp_ON * parameters.a_mix/parameters.A * state.Q_In *
			  pow(cos(parameters.PI*state.z[Layer_Index]/(2*parameters.b_mix*state.Q_In)),2)
			ELSE 0 ; };

		 
		 
		{ DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[2]) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };
		{ DERIV(state.X_Layer[2],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[3] - state.J_Up[2] - state.J_G[2] + (1 / state.H_Layer) *(state.D_comp[3]- state.D_comp[2])); };
		
		 
		{ DERIV(state.X_Layer[3],[independent.t]) = IF (3 == IndexOfFeedLayerBurger)
		  	THEN (1 / state.H_Layer) * (- state.J_Up[3] - state.J_Dn[3] + state.J_G[2] - state.J_G[3] +
			(1 / state.H_Layer) *(state.d_mix[3]*(state.X_Layer[4]-state.X_Layer[3]) + state.D_comp[4]+state.D_comp[2]-2*state.D_comp[3])) + 
			(1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[4] - state.J_Up[3] + state.J_Dn[2] - state.J_Dn[3] + state.J_G[2] -
			state.J_G[3] + (1 / state.H_Layer) *(state.d_mix[3]*((state.X_Layer[4]-state.X_Layer[3])) + state.D_comp[4]+state.D_comp[2] -
			2*state.D_comp[3])); };
		
		 
		{ FOREACH Layer_Index IN {4 .. NrOfLayersPlusOneBurger}: DERIV(state.X_Layer[Layer_Index],[independent.t]) =
		  	IF (Layer_Index == IndexOfFeedLayerBurger) THEN (1 / state.H_Layer) * (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
			   state.d_mix[Layer_Index] *(state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) 
			   - state.d_mix[Layer_Index-1] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) + 
			   state.D_comp[Layer_Index+1] + state.D_comp[Layer_Index-1] - 2*state.D_comp[Layer_Index])) +
			   (1 / state.V_Layer) * state.SolidFlux_In
			   ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index] + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
				state.d_mix[Layer_Index]*(state.X_Layer[Layer_Index+1] - 
			   state.X_Layer[Layer_Index]) - state.d_mix[Layer_Index-1] *(state.X_Layer[Layer_Index]-state.X_Layer[Layer_Index-1]) +
			   state.D_comp[Layer_Index+1]+state.D_comp[Layer_Index-1]-2*state.D_comp[Layer_Index])) ; };

		 
		{ DERIV(state.X_Layer[NrOfLayersPlusTwoBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusOneBurger] - state.J_Dn[NrOfLayersPlusTwoBurger] +
		  		state.J_G[NrOfLayersPlusOneBurger] - state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) * (
				-state.d_mix[NrOfLayersPlusOneBurger] * (state.X_Layer[NrOfLayersPlusTwoBurger] - state.X_Layer[NrOfLayersPlusOneBurger]) + 
				state.D_comp[NrOfLayersPlusThreeBurger] + state.D_comp[NrOfLayersPlusOneBurger] - 2*state.D_comp[NrOfLayersPlusTwoBurger])) ; };
		
		 
		{ DERIV(state.X_Layer[NrOfLayersPlusThreeBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusTwoBurger] - state.J_Dn[NrOfLayersPlusThreeBurger] +
		  		state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) *(state.D_comp[NrOfLayersPlusTwoBurger]-state.D_comp[NrOfLayersPlusThreeBurger])) ; };
		{ DERIV(state.X_Layer[NrOfLayersPlusFourBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusThreeBurger] - state.J_Dn[NrOfLayersPlusFourBurger]); };

		state.X_Out = IF (state.Q_Out == 0)	THEN 0 ELSE state.X_Layer[1] ;
		state.X_Under = IF (state.Q_Under_Actual == 0) THEN 0 ELSE state.X_Layer[NrOfLayersPlusFourBurger] ;
		
		 
		state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayersPlusFourBurger,parameters.X_Lim) ;
		state.H_S = (NrOfLayersPlusTwoBurger - state.IndexOfSludgeBlanket + 1) * state.H_Layer ;
    };

 :};




# 29 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.secondary_clarifier.plosz.msl" 1
 



















CLASS PloszConcentrationVector = Concentration[60;];
CLASS PloszVelocityVector = Velocity[60;];
CLASS PloszArealFluxVector = ArealFlux[60;];
CLASS PloszDiffusivityVector = Diffusivity[60;];



CLASS BasePlosz
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   interface <-
   {
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" :};
   OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" :};
   OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" :};
   OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    
   OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 754 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 3 ; group <- "Dimension" :};
 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.001375 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ L_60 (* hidden = "1" *) "Fraction of underflow withdrawn from layer 60" : Fraction := {: value <- 1.0 :};
 







 
    OBJ Eta_Con "Downwards convection control" : Velocity := {: value <- 0.504 :};
    OBJ D_01 "Over flow dependent dispersion model parameter" : Diffusivity := {: value <- 3.95 :}; 
    OBJ V_OV_DIS "Boundary overflow velocity for dispersion" : Velocity := {: value <- 15 :}; 
    OBJ V_F_CON "Boundary feedflow velocity for convection" : Length := {: value <- 30.5 :};
    OBJ g_DIS "Dispersion function coefficient" : Time := {: value <- 0.022 :}; 
 
    OBJ D_C_max "Maximum value of the dispersion coefficient" : Diffusivity := {: value <- 15 :};
 
 
    OBJ L_F_max "Maximum height of the feed layer" : Integer := {: value <- 32 :};
 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : PloszConcentrationVector := {: group <- "Concentration" :};
 
    OBJ D_Con_Help (* hidden = "1" *) "Help for the over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ D_Con "Over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ V_Ff "Clarifier feed velocity" : Velocity;
    OBJ V_Fo "Clarifier overflow velocity" : Velocity;
    OBJ Eta_CC "Feed velocity dependent convection reduction factor" : Real;
    OBJ Eta_Con_Help (* hidden = "1" *) "Help for convection reduction factor" : Real;
 
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;	
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : PloszVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": PloszVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : PloszArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : PloszArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : PloszArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": PloszArealFluxVector;
 
    OBJ DynamicIndexOfFeedLayer_Help (* hidden = "1" *) "Dynamic Index of Feed Layer - HELP" : Real := {: group <- "Operational" :};
    OBJ DynamicIndexOfFeedLayer "Dynamic Index of Feed Layer" : Real := {: group <- "Operational" :};
 
    OBJ J_Dis (* hidden = "1" *) "Dispersion flux": PloszArealFluxVector;
    OBJ D_1 (* hidden = "1" *) "Dispersion with the following layer ": PloszDiffusivityVector; 
    OBJ D_2 (* hidden = "1" *) " Dispersion with the precedent layer ": PloszDiffusivityVector; 
    OBJ J_GUp_Help (* hidden = "1" *) "Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective help fluxes": PloszArealFluxVector; 
    OBJ J_GUp (* hidden = "1" *) " Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective fluxes": PloszArealFluxVector; 
 
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;	
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[H2O] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / 60); 
    state.H_Layer = parameters.H / 60;

   state.Integ_PE = 0.0 ;
   };

  independent <- { OBJ t "Time": Time; };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

 
    state.v_Dn = (state.Q_Under_Actual / parameters.A) * state.Eta_CC; 

 
 
    state.DynamicIndexOfFeedLayer_Help = MSLUFindThreshold(ref(state.X_Layer[1]),60,state.X_In);
    state.DynamicIndexOfFeedLayer = MSLUGetMax2(state.DynamicIndexOfFeedLayer_Help,parameters.L_F_max);
 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
			SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

    state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]) ;

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In = SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
			state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ; };






    state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;

	{ state.SolidConcentration =
			(SUMOVER Layer_Index IN {1 .. 60}: state.X_Layer[Layer_Index]) / 60 ; };

    state.X_Min = IF (state.Q_In == 0) THEN parameters.f_ns * state.SolidConcentration
			ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

 




    state.v_Up = state.Q_Out / parameters.A; 

 
    state.V_Ff = state.Q_In / parameters.A;
    state.V_Fo = state.Q_Out / parameters.A;

    state.D_Con_Help = IF (state.V_Fo < parameters.V_OV_DIS) THEN parameters.D_01
			ELSE parameters.D_01 + parameters.g_DIS * (state.V_Fo - parameters.V_OV_DIS) * (state.V_Fo - parameters.V_OV_DIS) ;

    state.D_Con = MSLUGetMin2(state.D_Con_Help, parameters.D_C_max);
	 
    state.Eta_Con_Help = IF (state.V_Ff < parameters.V_F_CON) THEN parameters.Eta_Con
			ELSE parameters.Eta_Con + (state.V_Ff - parameters.V_F_CON) /  parameters.V_F_CON * (state.V_Ff - parameters.V_F_CON) / parameters.V_F_CON;

    state.Eta_CC = MSLUGetMin2(state.Eta_Con_Help, 1.0);
 
    
 
    { FOREACH Layer_Index IN {1 .. 59}: state.D_1[Layer_Index] = state.D_Con ; };
    { FOREACH Layer_Index IN {1 .. 60}: state.D_2[Layer_Index] = state.D_Con ; };
 

 







        
    { FOREACH Layer_Index IN {1 .. 60}: state.J_G_Help[Layer_Index] =
			state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };

 
    { FOREACH Layer_Index IN {2 .. 60}: state.J_Up[Layer_Index] = 
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 0		   
					ELSE state.v_Up * state.X_Layer[Layer_Index]; };	 

 
    { FOREACH Layer_Index IN {1 .. 59}: state.J_Dn[Layer_Index] =
			IF (Layer_Index >= state.DynamicIndexOfFeedLayer) THEN state.v_Dn * state.X_Layer[Layer_Index]	 
					ELSE 0; }; 								  	   		 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_Dis[Layer_Index] =
			- state.D_2[Layer_Index] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) / state.H_Layer
			+ state.D_1[Layer_Index] * (state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) / state.H_Layer ; };
 

 

 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_G[Layer_Index-1] =
			IF (Layer_Index <= state.DynamicIndexOfFeedLayer) THEN
					IF (state.J_G_Help[Layer_Index-1] <= state.J_G_Help[Layer_Index]) THEN state.J_G_Help[Layer_Index-1]
					   		ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index-1] ; };

    { FOREACH Layer_Index IN {1 .. 59}: state.J_G[Layer_Index] =
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 
					IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1]) THEN state.J_G_Help[Layer_Index+1]
							ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index] ; };
 


 
    { DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1] + state.D_1[1] * (state.X_Layer[2]
			- state.X_Layer[1]) / state.H_Layer) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };

    { FOREACH Layer_Index IN {2 .. 59}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == state.DynamicIndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]);
    };

 
 
















































    { DERIV(state.X_Layer[60],[independent.t]) =  IF (60 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] ; };

    state.X_Out = IF (state.Q_Out == 0) THEN 0
			ELSE state.X_Layer[1]; 
 

 

    state.X_Under = IF (state.Q_Under_Actual == 0)
			  THEN 0
			  ELSE state.X_Layer[60] ; 
 



 

 
    state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),60,parameters.X_Lim) ;
    state.H_S = (60 - state.IndexOfSludgeBlanket + 1) * state.H_Layer ;

 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}: interface.Overflow[Comp_Index] =
	  		IF (state.Q_In == 0) THEN 0
			ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
			IF (state.SolidFlux_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

 
    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
			interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
			IF (state.Q_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

 
 
    interface.Sludge_Blanket_Height = state.H_S;
    interface.TSS = state.SolidConcentration;
    interface.V_Clarifier = parameters.A * parameters.H;  

	 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
	DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual ;
	interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};




CLASS Plosz
 (* icon = "secondary_clarifier" *)
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 103.012 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.0002526 ; group <- "Settling" :}; 
   };

  equations <-
   {
    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > parameters.v0) THEN parameters.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 30 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.secondary_clarifier.ploszsvi.msl" 1
 




















CLASS Plosz_SVI
 (* icon = "secondary_clarifier" *)
 "Layered convection-dispersion model of the secondary settling tank - Benedek Gy. Plosz"

 
 
 
 
 

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    
    OBJ V_alpha "SSVI3.5(ml/g) - V0(m/d) exponential regression - alpha value" : Velocity := {: value <- 133.7472 :};
    OBJ V_beta "SSVI3.5(ml/g) - V0(m/d) exponential regression - exponent" : Concentration := {: value <- 3446.7 :};
    OBJ r_H_lambda "SSVI3.5(ml/g) - r_H(m3/g) linear regression - slope" : Real := {: value <- 0.0000026 :};
    OBJ r_H_kappa "SSVI3.5(ml/g) - r_H(m3/g) linear regression - y-intercept" : SpecificVolume := {: value <- 0.0000628 :};
    OBJ DSVI "Diluted sludge volume index, DSVI" : SpecificVolume := {: value <- 0.000085 :};
    OBJ p_SVI "SSVI3.5/DSVI ratio" : Real := {: value <- 0.658 :};
    
   };

   state <-
   {
 
    OBJ v0 "Maximum theoretical settling velocity" : Velocity ;
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume ;
 
   };

  equations <-
   {
 
    state.v0 = parameters.V_alpha * exp(- parameters.V_beta * parameters.DSVI * parameters.p_SVI);
    state.r_H = parameters.r_H_lambda * parameters.DSVI * parameters.p_SVI + parameters.r_H_kappa;
	
    state.v0_P = state.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = state.v0 * exp(state.r_H * state.X_Min);

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - state.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > state.v0) THEN state.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.secondary_clarifier.msl" 2

 
 
 



# 39 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sand_filter.msl" 1
 





















CLASS DownFlow "Base class for a semicontinuous downflow granular medium filter"
EXTENDS Base_DownFlow WITH
{:

  comments <- "Base class for a semicontinuous downflow granular medium filter" ;

  interface <-
  {
    OBJ Overflow (* terminal = "out_3" *) "Outflow unfiltered" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Overflwo" :};
  };
  
  parameters <-
  {
    OBJ I_bw "Backwash Intensity" : Real := {: unit <- "m-3"; value <- 0.02 ; group <- "Filtration" :};
    OBJ f_Qin (* is_favorite = "1" *) "Threshold for residual flow" : Fraction := {: value <- 0.5 ; group <- "Filtration" :};
  };
  
  state <-
  {
    OBJ BW_On (* hidden = "1" *) "Is backwash needed? (0/1)" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :} ; group <- "Operation" :};
    OBJ Qratio (* hidden = "1" *) "Ratio Q filtered / Q in" : Real ;
    
    OBJ f_Over (* hidden = "1" *) "Fraction of the influent flux going to the unfiltered outflow" : Fraction ;
  };
  
  initial <-
  {
    state.BW_On = 0 ;
  };
  
  equations <-
  {
     
     
    state.Q_Out = IF (state.BW_On <= 0) THEN state.Q_BW + state.Help_Q_Out ELSE 0.0 ;

    state.Q_Over = IF (state.H > parameters.H_Max) THEN
      IF (state.BW_On <= 0) THEN
        IF (state.Help_Q_Over < 0) THEN 0.0 ELSE state.Help_Q_Over
      ELSE state.Q_In + state.Q_BW
    ELSE 0.0 ;

    state.X_BW = IF (state.BW_On < 1 || state.Q_BW <= 0.0) THEN 0.0 ELSE state.Help_X_Backwash / state.Q_BW ;
    
     
    state.f_Out = IF (state.BW_On <= 0) THEN
      IF ((state.Q_Out + state.Q_Over) <= 0) THEN 0.0
      ELSE state.Q_Out / (state.Q_Out + state.Q_Over)
    ELSE 0.0 ;
    
    state.f_Over = 1 - state.f_Out ;

     
    state.r_BW = IF (state.H > parameters.H_Max) THEN state.BW_On * state.Q_BW * parameters.I_bw ELSE 0.0 ;

     
    DERIV(state.M_TSS,[independent.t]) =
      ((state.X_In * state.Q_In + state.X_BW * state.Q_BW - state.Q_Out * state.X_Out - state.Q_Over * state.X_Over) / parameters.A) ;

     
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    DERIV(state.M[Comp_Index],[independent.t]) =
      (interface.Inflow[Comp_Index] + interface.Inflow_Backwash[Comp_Index] + interface.Outflow_Filtered[Comp_Index] + interface.Overflow[Comp_Index]) ; };

     
    
    state.Help_X_Over = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: - interface.Overflow[Comp_Index] * parameters.F_TSS_COD) ;
    

    



     
    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out - (1 - state.BW_On) * interface.Inflow_Backwash[Comp_Index] ; };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * parameters.f_nf * state.f_Out - (1 - state.BW_On) * interface.Inflow_Backwash[Comp_Index] ; };

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Over - state.BW_On * interface.Inflow_Backwash[Comp_Index] ; };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Over - state.BW_On * interface.Inflow_Backwash[Comp_Index] - state.M[Comp_Index] * state.r_BW ; };      
  };

:};


CLASS Base_DownFlow "Base class for a semicontinuous downflow granular medium filter"
SPECIALISES PhysicalDAEModelType :=
{:

  comments <- "Base class for a semicontinuous downflow granular medium filter" ;

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Inflow_Backwash (* terminal = "in_3" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent backwash" :};
    OBJ Outflow_Filtered (* terminal = "out_1" *) "Outflow filtered" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent Filtered" :};
  };
  
  parameters <-
  {
    OBJ alfa "Empirical factor" : Real := {: value <- 2500 ; group <- "Model" :};
    OBJ beta "Empirical factor" : Real := {: value <- 1 ; group <- "Model" :};
    OBJ k "Sludge resistance coefficient" : Real := {: value <- 0.001 ; group <- "Model" :};
    OBJ f0 "Clean filter bed resistance factor": Fraction := {: value <- 0.025 ; group <- "Model" :};

    OBJ A (* is_favorite = "1" *) "Surface" : Area:= {: value <- 1500 ; group <- "Tank" :};
    OBJ H_Max (* is_favorite = "1" *) "Maximum height of the water in the sand filter" : Length := {: value <- 1 ; group <- "Tank" :};
    
    OBJ f_nf "Non-filterable fraction" : Fraction := {: value <- 0.005 ; group <- "Filtration" :};

    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  };
  
  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };
  
  state <-
  {
    OBJ Help_Q_Out (* hidden = "1" *) "..." : FlowRate := {: group <- "Operation" :};
    OBJ Help_Q_Over (* hidden = "1" *) "Unfiltered effluent flow rate" : Real := {: group <- "Operation" :};
    OBJ r_BW (* hidden = "1" *) "Backwash rate" : Frequency := {: group <- "Operational" :};
    
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operation" :};
    OBJ Q_Out (* is_favorite = "1" *) "Filtered effluent flow rate" : FlowRate := {: group <- "Operation" :};
    OBJ Q_Over (* is_favorite = "1" *) "Unfiltered effluent flow rate" : FlowRate := {: group <- "Operation" :};
    OBJ Q_BW  (* is_favorite = "1" *) "Backwash flow rate" : FlowRate := {: group <- "Operation" :};

    OBJ H (* is_favorite = "1" *) "Height of the water on the sand filter" : Length := {: group <- "Operation" :};
    OBJ V "Volume" : Volume := {: group <- "Tank" :};
    OBJ M_TSS "Total in TSS per surface area" : SurfaceDensity := {: group <- "Operation" :};
     
    OBJ M "Mass of sludge on the sand filter" : MassVector := {: group <- "Operation" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the filtered outflow" : Fraction ;
    
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Backwash (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Over (* hidden = "1" *) "" : MassFlux;

    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_BW (* is_favorite = "1" *) "Backwash suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Filtered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Over (* is_favorite = "1" *) "Unfiltered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
  };
  
  equations <-
  {
     
    state.Q_In = 1E-06 * interface.Inflow[IndexOfSolvent];
    state.Help_Q_Out = parameters.alfa * pow(state.H, parameters.beta) * (1 - (parameters.f0 * exp(parameters.k * state.M_TSS))) ;
     
    state.Q_BW = IF (interface.Inflow_Backwash[IndexOfSolvent] > 0.0) THEN 1E-06 * interface.Inflow_Backwash[IndexOfSolvent] ELSE 0.0 ;

     
    DERIV(state.H,[independent.t]) = 1 / parameters.A * (state.Q_In + state.Q_BW - state.Q_Out - state.Q_Over) ;
    state.V = state.H * parameters.A;

     
     
    state.Help_Q_Over = state.Q_In - state.Help_Q_Out ;
    
     
    
    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: interface.Inflow[Comp_Index] * parameters.F_TSS_COD) ;
    
    state.Help_X_Backwash = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: interface.Inflow_Backwash[Comp_Index] * parameters.F_TSS_COD) ;
    
    state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: - interface.Outflow_Filtered[Comp_Index] * parameters.F_TSS_COD) ;
    

    







    state.X_In = IF (state.Q_In <= 0.0) THEN 0.0 ELSE state.Help_X_In / state.Q_In ;

    state.X_Out = IF (state.Q_Out <= 0.0) THEN 0.0 ELSE state.Help_X_Out / state.Q_Out ;
    
    state.X_Over  = IF (state.Q_Over <= 0.0) THEN 0.0 ELSE state.Help_X_Over  / state.Q_Over ;
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sandfilter/wwtp.base.sand_filter.simpledownflow.msl" 1
 




















CLASS SimpleDownFlow
(* icon = "sand_filter" ; is_default = "true" *)
"Semicontinuous Downflow granular medium filter"
EXTENDS DownFlow WITH
{:

  comments <- "A model for sand filtration";
  
  equations <-
  {
    state.BW_On = IF (independent.t <= 0) THEN 0.0
      ELSE IF (state.Q_BW > 0.0) THEN 1 ELSE 0.0 ; 
  };

:};
 

 
CLASS DownFlow_BW (* icon = "sand_filter" *)
"Semicontinuous downflow granular medium filter - with automatic detection of backwash conditions"
EXTENDS DownFlow WITH
{:

  comments <- "Semicontinuous downflow granular medium filter - with automatic detection of backwash conditions";

  interface <-
  {
    OBJ Is_BW (* terminal = "out_2"; is_favorite = "1" *) "Backwashing state (1=on 0=off)" : Integer := {: causality <- "COUT" ; group <- "Operation" :};
  };
    
  initial <-
  {
    state.BW_On = 0 ;
  };
  
  equations <-
  {
     
    state.Qratio = state.Help_Q_Out / state.Q_In ;
    interface.Is_BW = state.BW_On ;
    state.BW_On = IF (independent.t <= 0) THEN 0.0
 
      ELSE IF (previous(state.BW_On) < 1 && state.Qratio <= parameters.f_Qin) THEN 1 ELSE 0.0 ; 
     
  };

:};



# 218 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sand_filter.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sandfilter/wwtp.sand_filter.autobw.msl" 1
 




















CLASS DownFlow_AutoBW (* icon = "sand_filter" *)
"Semicontinuous downflow granular medium filter - with automatic detection of backwash conditions"
EXTENDS DownFlow_tbw WITH
{:

  comments <- "Semicontinuous downflow granular medium filter - with automatic detection of backwash conditions";

  interface <-
  {
     
    OBJ Is_Qin (* terminal = "out_2"; is_favorite = "1" *) "Feeding state (1=on 0=off)" : Integer := {: causality <- "COUT" ; group <- "Operation" :};
    OBJ Is_BW (* terminal = "out_2"; is_favorite = "1" *) "Backwashing state (1=on 0=off)" : Integer := {: causality <- "COUT" ; group <- "Operation" :};
 
 
    OBJ TSS_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum TSS density" : SurfaceDensity := {: causality <- "CIN" ; value <- 1000 ; group <- "Operation" :};
  };

  parameters <-
  {
    OBJ Tau (* hidden = "1" *) "Implicit loop breaker time constant" : Time := {: value <- 0.0005 :};
  };
  
  state <-
  {
    OBJ Help_TSS (* hidden = "1" *) "Total in TSS per surface area" : SurfaceDensity := {: group <- "Operation" :};
    OBJ IsTSS_Max (* hidden = "1" *) "TSS density exceeds max (1) or not (0)" : Integer := {: group <- "Operation" :};
  	OBJ BW_Begin (* hidden = "1" *) "Start time of each backwash period (TSS density exceeds max)" : Time := {: group <- "Operation" :};
  };
  
  initial <-
  {
    state.BW_On = 0 ;
  	state.BW_Begin = 0.0 ;
  	state.Help_TSS = 0.0 ;
  };
  
  equations <-
  {
     
    DERIV(state.Help_TSS,[independent.t]) = - (1 / parameters.Tau) * (state.Help_TSS - state.M_TSS) ;

    state.IsTSS_Max = IF (state.Help_TSS >= interface.TSS_Max) THEN 1.0 ELSE 0.0 ;
    
    state.BW_Begin = IF (state.IsTSS_Max == 1.0) THEN
      IF (previous(state.IsTSS_Max) == 0.0) THEN independent.t ELSE previous(state.BW_Begin)
      ELSE previous(state.BW_Begin) ;

    state.BW_On = IF (state.BW_Begin > previous(state.BW_Begin)) THEN 1
      ELSE IF (previous(state.BW_On) == 1 && state.M_TSS > 10.0) THEN 1 ELSE 0 ; 
    
    interface.Is_BW = state.BW_On ;
    interface.Is_Qin = 1 - state.BW_On ;
 
  };

:};


 
CLASS DownFlow_tbw "Base class for a semicontinuous downflow granular medium filter, with backwash duration"
EXTENDS DownFlow_Base WITH
{:

  comments <- "Base class for a semicontinuous downflow granular medium filter, with backwash duration" ;

  interface <-
  {
    OBJ t_BW_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum duration BW" : Time := {: causality <- "CIN" ; value <- 0.002 ; group <- "Operation" :};    
  };

  equations <-
  {
    state.Help_I_bw = IF (state.Q_BW * interface.t_BW_Max > 0.0) THEN 1 / (state.Q_BW * interface.t_BW_Max) ELSE 0.0 ;
  };

:};


 
CLASS DownFlow_Base "Base class for a semicontinuous downflow granular medium filter"
EXTENDS Base_DownFlow WITH
{:

  comments <- "Base class for a semicontinuous downflow granular medium filter" ;

  interface <-
  {
    OBJ Overflow (* terminal = "out_4" *) "Outflow unfiltered" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Overflow" :};
    OBJ Outflow_Backwash (* terminal = "out_3" *) "Outflow during backwash" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Backwash effluent" :};
  };

  state <-
  {
    OBJ BW_On (* hidden = "0" *) "Backwash mode: 0=off vs 1=on" : Real := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :} ; group <- "Operation" :};

    OBJ Help_I_bw (* hidden = "0" *) "Backwash Intensity" : Real := {: unit <- "m-3" ; group <- "Filtration" :};
    
    OBJ X_TSS "Mass of total solids" : Mass := {: group <- "Operation" :};
    
     
    OBJ Help_V_In (* hidden = "1" *) "Cumulated volume entered" : Volume := {: group <- "Mass balance" :}; ;
    OBJ Help_V_Out (* hidden = "1" *) "Cumulated volume exited" : Volume := {: group <- "Mass balance" :}; ;
    OBJ Help_V_Out2 (* hidden = "1" *) "Cumulated volume exited" : Volume := {: group <- "Mass balance" :}; ;
    OBJ Help_V_Tot (* hidden = "1" *) "Cumulated volume exited + stored" : Volume := {: group <- "Mass balance" :}; ;
  };

  initial <-
  {
    state.Help_V_In = 0.0 ;
    state.Help_V_Out = 0.0 ;
    state.Help_V_Out2 = 0.0 ;
  };
  
  equations <-
  {
     
     
 
    DERIV(state.Help_V_In,[independent.t]) = (interface.Inflow[IndexOfSolvent] + interface.Inflow_Backwash[IndexOfSolvent]) * 1E-06 ;
    DERIV(state.Help_V_Out,[independent.t]) = state.Q_Out + state.Q_Over - interface.Outflow_Backwash[IndexOfSolvent] * 1E-06 ;
    DERIV(state.Help_V_Out2,[independent.t]) = - (interface.Outflow_Filtered[IndexOfSolvent] + interface.Overflow[IndexOfSolvent] + interface.Outflow_Backwash[IndexOfSolvent]) * 1E-06 ;
    state.Help_V_Tot = state.Help_V_Out + state.V ;
      
     
     
 
    state.Q_Out = IF (state.Q_BW <= 1E-08) THEN state.Q_BW + state.Help_Q_Out ELSE 0.0 ;

     
    state.Q_Over = IF (state.H > parameters.H_Max) THEN
      IF (state.Q_In - state.Q_Out >= 0.0) THEN (state.Q_In - state.Q_Out) ELSE 0.0
      ELSE 0.0 ;

     
 
    state.f_Out = IF (state.Q_BW <= 1E-08) THEN    
      IF ((state.Q_Out + state.Q_Over) <= 0) THEN 0.0
      ELSE state.Q_Out / (state.Q_Out + state.Q_Over)
    ELSE 0.0 ;
    
     
    state.r_BW = IF (state.H > parameters.H_Max) THEN state.BW_On * state.Q_BW * state.Help_I_bw ELSE 0.0 ;

     
 
     
    state.M_TSS = state.X_TSS / parameters.A ;

     
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    DERIV(state.M[Comp_Index],[independent.t]) =
      (interface.Inflow[Comp_Index] + interface.Inflow_Backwash[Comp_Index] * state.BW_On + interface.Outflow_Filtered[Comp_Index] + interface.Overflow[Comp_Index] + interface.Outflow_Backwash[Comp_Index] ) ; };

     
    
    state.Help_X_Over = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: - interface.Overflow[Comp_Index] * parameters.F_TSS_COD) ;

    state.X_TSS = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: state.M[Comp_Index] * parameters.F_TSS_COD) ;
    

    





 
    state.X_BW = IF (state.Q_BW <= 1E-08) THEN 0.0 ELSE state.Help_X_Backwash / state.Q_BW ;

     
    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out - (1 - state.BW_On) * interface.Inflow_Backwash[Comp_Index] ; };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out * parameters.f_nf - (1 - state.BW_On) * interface.Inflow_Backwash[Comp_Index] ; };

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] = - interface.Inflow[Comp_Index] * (1 - state.f_Out) ; };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = - interface.Inflow[Comp_Index] * (1 - state.f_Out) ; };

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Backwash[Comp_Index] = - state.BW_On * interface.Inflow_Backwash[Comp_Index] ; };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Backwash[Comp_Index] = - state.BW_On * interface.Inflow_Backwash[Comp_Index] - state.M[Comp_Index] * state.r_BW ; };
  };

:};



# 219 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sand_filter.msl" 2







# 40 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.anaerobic_digestion.msl" 1
 



















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.lessarddesjardins.msl" 1
 




















 CLASS Lessard_Desjardins
 (* icon = "anaerobic_digester" *)
 "anaerobic digester"

  
  
  

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  

  
  
  
  

  
  
  

 EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
   comments <- "A model for anaerobic digestion processes by Lessard and Desjardins";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Gas_LD (* terminal = "out_3"; is_favorite = "1" *) "gasflow" : 
         FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ C_X_B_Anaerobic (* terminal = "out_3" *) "Concentration of the anaerobic biomass" : 
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

  parameters <- 
   { 
    OBJ S_PO4_In "Influent phosphate concentration" : Concentration := {: value <- 10 ; group <- "Influent characterization" :};
    OBJ mu_H "Maximum specific growth rate for heterotrophic biomass" : MaxGrowthRate := {: value <- 0.3 ; group <- "Kinetic" :};
    OBJ b_H "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {:value <- 0.40 ; group <- "Kinetic" :};
    OBJ k_h "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate :=  {:value <- 2.00 ; group <- "Kinetic" :};
    OBJ K_VFA "Substrate half saturation coeff for heterotrophic biomass" : HalfSatCoeff := {: value <- 140 ; group <- "Kinetic" :};
    OBJ Y_XB_VFA "Yield for biomass production associated with VFA consumption" : Yield := {: value <- 0.06 ; group <- "Stoichiometry" :};
    OBJ Y_NH_VSS "Yield for S_NH production associated with VSS hydrolysis" : Yield := {: value <- 0.038 ; group <- "Stoichiometry" :};
    OBJ Y_PO_VSS "Yield for S_PO4 production associated with VSS hydrolysis" : Yield := {: value <- 0.00066 ; group <- "Stoichiometry" :};
    OBJ Y_CH_XB "Yield for methane production associated with biomass growth" : Yield := {: value <- 0.6 ; group <- "Stoichiometry" :};
    OBJ F_VFA_SS "VFA Fraction of SS" : Fraction := {: value <- 0.5 ; group <- "Conversion factors" :};
    OBJ i_X_B     "Mass Of Nitrogen Per Mass Of COD In Biomass"
      : MassOfNitrogenPerMassOfCODInBiomass := {:value <- 0.086 ; group <- "Composition parameters" :};
    OBJ i_X_P     "Mass Of Nitrogen Per Mass Of COD In Products Formed"
      : MassOfNitrogenPerMassOfCODInProdFromBiomass := {:value <- 0.06 ; group <- "Composition parameters" :};
    OBJ f_P      "Fraction Of Biomass Converted To Inert Matter"
      : FractOfBiomassLeadingToPartProd := {:value<- 0.08 ; group <- "Conversion factors":};
    OBJ rho_CH4 "Density of CH4" : Density := {: value <- 717 ; group <- "Conversion factors":};
    OBJ V (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000 ; group <- "Dimension":};
 
   };

  state <-
   {
    OBJ Help1 (* hidden = "1" *) "Rate of reaction for hydrolysis" : Real;
    OBJ Help2 (* hidden = "1" *) "Rate of reaction for growth" : Real;
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ VSSnb_In "Non-biodegradable susp. solids conc. of the influent" : Concentration := {: group <- "Influent characterization" :};
    OBJ VSSnb "Non-biodegradable susp. solids conc." : Concentration := {: group <- "Concentration" :};
    OBJ VSSb_In "Biodegradable susp. solids conc. of the influent" : Concentration := {: group <- "Influent characterization" :};
    OBJ VSSb "Biodegradable susp. solids conc." : Concentration := {: group <- "Concentration" :};
    OBJ VFA_In "Volatile fatty acids conc. in the influent" : Concentration := {: group <- "Influent characterization" :};
    OBJ VFA "Volatile fatty acids conc." : Concentration := {: group <- "Concentration" :};
    OBJ X_B "Methane and acetogene bacteria conc." : Concentration := {: group <- "Concentration" :};
    OBJ S_PO4 "Phosphate" : Concentration := {: group <- "Concentration" :};
    OBJ S_NH "Ammonia" : Concentration := {: group <- "Concentration" :};
    OBJ X_ND "Soluble biodegradable organic nitrogen" : Concentration := {: group <- "Concentration" :};
    OBJ CH4 "Methane" : MolConcentration := {: group <- "Concentration" :};
    OBJ Q_Under_Real (* is_favorite = "1" *) "Real underflow rate" : FlowRate := {: group <- "Operational" :};
   };

  initial <-
   {
   };

  equations <-
   {
   state.Q_Under_Real = IF (interface.Q_Under > state.Q_In)
        THEN state.Q_In
        ELSE interface.Q_Under;

   state.Q_Out = state.Q_In - state.Q_Under_Real ;

   state.VSSnb_In = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[X_I] / state.Q_In ;
   state.VSSb_In = IF (state.Q_In == 0)
       THEN 0
       ELSE ( interface.Inflow[X_S] + interface.Inflow[X_BH] + interface.Inflow[X_BA] ) / state.Q_In ;
   state.VFA_In = IF (state.Q_In == 0)
      THEN 0
      ELSE parameters.F_VFA_SS * interface.Inflow[S_S] / state.Q_In ;

   state.Help1 = parameters.k_h * state.VSSb ;
   state.Help2 = parameters.mu_H * (state.VFA / (parameters.K_VFA + state.VFA)) *  state.X_B ;

    
   {DERIV(state.VSSb,[independent.t]) =
          - state.Help1 
      + parameters.b_H * state.X_B * (1-parameters.f_P) 
      + state.Q_In / parameters.V * (state.VSSb_In - state.VSSb) ;
   };

    

   {DERIV(state.VSSnb,[independent.t]) =
          parameters.b_H * state.X_B * parameters.f_P
      + state.Q_In / parameters.V * (state.VSSnb_In - state.VSSnb) ;
   };
   {DERIV(state.VFA,[independent.t]) =
          state.Help1 - 1 / parameters.Y_XB_VFA * state.Help2 
          + state.Q_In / parameters.V * (state.VFA_In - state.VFA) ;
   };
   {DERIV(state.S_NH,[independent.t]) =
          parameters.Y_NH_VSS * state.Help1 
          + 1 / parameters.V * (interface.Inflow[S_NH] - state.Q_In * state.S_NH) ;
   };

    

   {DERIV(state.X_ND,[independent.t]) =
          parameters.b_H * state.X_B * (parameters.i_X_B - parameters.f_P * parameters.i_X_P)
      + 1 / parameters.V * (interface.Inflow[X_ND] - state.Q_In * state.X_ND) ;
   };

   {DERIV(state.S_PO4,[independent.t]) =
          parameters.Y_PO_VSS * state.Help1 
          + state.Q_In / parameters.V * (parameters.S_PO4_In - state.S_PO4) ;
   };

   {DERIV(state.X_B,[independent.t]) =
          state.Help2 - parameters.b_H * state.X_B - state.Q_In / parameters.V *  state.X_B;
   };
   {DERIV(state.CH4,[independent.t]) =
          parameters.Y_CH_XB * state.Help2 ;
   };

    
    

   interface.Q_Gas_LD = 16 * parameters.Y_CH_XB * state.Help2 * parameters.V / parameters.rho_CH4 ;
   interface.C_X_B_Anaerobic = state.X_B;

   interface.Outflow[H2O] = state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];			  
   interface.Outflow[X_BH] = 0 ;
   interface.Outflow[X_BA] = 0 ;
   interface.Outflow[S_O] = 0 ;   
 
 
   interface.Outflow[S_S] = IF (state.Q_In == 0)
              THEN 0 
              ELSE - ( interface.Inflow[S_S] / state.Q_In - state.VFA_In + state.VFA ) * state.Q_Out ;   
   interface.Outflow[X_S] = -( state.VSSb * state.Q_Out + state.X_B * state.Q_Out);   
   interface.Outflow[X_I] = - state.VSSnb * state.Q_Out;
   interface.Outflow[S_NH] = - state.S_NH * state.Q_Out; 
   interface.Outflow[X_ND] = - state.X_ND * state.Q_Out;
   interface.Outflow[S_ND] = IF (state.Q_In == 0)
               THEN 0
               ELSE - interface.Inflow[S_ND] * state.Q_Out / state.Q_In; 
   interface.Outflow[S_I] = IF (state.Q_In == 0)
              THEN 0
              ELSE - interface.Inflow[S_I] * state.Q_Out / state.Q_In;
   interface.Outflow[S_ALK] = IF (state.Q_In == 0)
            THEN 0
            ELSE - interface.Inflow[S_ALK] * state.Q_Out / state.Q_In;
   interface.Outflow[S_NO] = IF (state.Q_In == 0)
               THEN 0
               ELSE - interface.Inflow[S_NO] * state.Q_Out / state.Q_In;
   interface.Outflow[X_P] = IF (state.Q_In == 0)
              THEN 0
              ELSE - interface.Inflow[X_P] * state.Q_Out / state.Q_In;

   interface.Underflow[H2O] = state.Q_Under_Real / parameters.WWTPSpecificVolume[IndexOfSolvent];			  
   interface.Underflow[X_BH] = 0 ;
   interface.Underflow[X_BA] = 0 ;
   interface.Underflow[S_O] = 0 ;   
   interface.Underflow[S_S] = IF (state.Q_In == 0)
            THEN 0
            ELSE - ( interface.Inflow[S_S] / state.Q_In - state.VFA_In + state.VFA ) * state.Q_Under_Real ;   
   interface.Underflow[X_S] = -( state.VSSb * state.Q_Under_Real + state.X_B * state.Q_Under_Real);   
   interface.Underflow[X_I] = - state.VSSnb * state.Q_Under_Real ;
   interface.Underflow[S_NH] = - state.S_NH * state.Q_Under_Real ; 
   interface.Underflow[X_ND] = - state.X_ND * state.Q_Under_Real;
   interface.Underflow[S_ND] = IF (state.Q_In == 0)
            THEN 0
            ELSE - interface.Inflow[S_ND] * state.Q_Under_Real / state.Q_In; 
   interface.Underflow[S_I] = IF (state.Q_In == 0)
            THEN 0
            ELSE - interface.Inflow[S_I] * state.Q_Under_Real / state.Q_In;
   interface.Underflow[S_ALK] = IF (state.Q_In == 0)
              THEN 0
              ELSE - interface.Inflow[S_ALK] * state.Q_Under_Real / state.Q_In;
   interface.Underflow[S_NO] = IF (state.Q_In == 0)
             THEN 0
             ELSE - interface.Inflow[S_NO] * state.Q_Under_Real / state.Q_In;
   interface.Underflow[X_P] = IF (state.Q_In == 0)
                THEN 0
                ELSE - interface.Inflow[X_P] * state.Q_Under_Real / state.Q_In;

  };

 :};
 



# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.anaerobic_digestion.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.siegrist.msl" 1
 




















CLASS AD_Siegrist (* icon = "anaerobic_digester" *) "Anaerobic digester according to Siegrist et al. (incl. interface transformers for ASM1)"
SPECIALISES CoupledModelType :=
{:
  comments <- "A model for anaerobic digestion processes by Siegrist et al. (incl. interface transformers for ASM1)";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- CIN ; group <- "Effluent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- COUT ; group <- "Effluent" :};
    OBJ Q_Stripping (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Gas flow for stripping" : FlowRate := {: causality <- "CIN" ; value <- 30 ; group <- "Operational" :}; 
    OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Celsius Temperature" : CelsiusTemperature := {: causality <- "CIN" ; value <- 35.0 ; group <- "Operational":};
     
    OBJ Q_Biogas (* terminal = "out_4"; is_favorite = "1" *) "Biogas flow (incl. stripping gas)" : FlowRate := {: causality <- "COUT" ; group <- "Operational" :}; 
  };
  
  parameters <-
  {
    OBJ f_X_Out (* is_favorite = "1" *) "Fraction of particulate matter that leaves the reactor" : Fraction := {: value <- 0.10 ; group <- "Settling" :};
    OBJ p (* is_favorite = "1" *) "Head pressure in the digester" : Pressure := {:value <- 101325.00 ; group <- "Operational":};
    OBJ Vol (* is_favorite = "1";  *) "Volume of liquid in the reactor" : Volume := {: value <- 3400; group <- "Dimension"; :};

 
    OBJ i_X_B "Mass of N per mass of COD in biomass (ASM1)" : Fraction := {: value <- 0.086 ; group <- "Conversion factors" :};
    OBJ i_X_P "Mass of N per mass of COD in products formed (ASM1)" : Fraction := {: value <- 0.04 ; group <- "Conversion factors" :};
    OBJ i_S_AS "Mass of N per mass of COD in Amino Acids (S_AS)" : Fraction := {: value <- 0.040 ; group <- "Conversion factors" :};
    OBJ i_X_S_An "Mass of N per mass of COD in slowly biodegradable matter (X_S)" : Fraction := {: value <- 0.020 ; group <- "Conversion factors" :};
    OBJ i_X_An "Mass of N per mass of COD in anaerobic biomass" : Fraction := {: value <- 0.080 ; group <- "Conversion factors" :};
    OBJ i_X_IN "Mass of N per mass of COD in inert particulates" : Fraction := {: value <- 0.040 ; group <- "Conversion factors" :};
    OBJ f_AC_S "Acetate (S_AC) fraction of S_S" : Fraction := {: value <- 0.30 ; group <- "Conversion factors" :};
    OBJ f_PRO_S "Propionate (S_PRO) fraction of S_S" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_AS_S "Amino Acids and sugar (S_AS) fraction of S_S" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_XS_I "X_I fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_XS_H "X_BH fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.08 ; group <- "Conversion factors" :};
    OBJ f_XS_A "X_BA fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.92 ; group <- "Conversion factors" :};
    OBJ f_XS_P "X_P fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_AS_H "Fraction of X_BH that are capable of fermenting" : Fraction := {: value <- 0.50 ; group <- "Conversion factors" :};
    OBJ f_P_An "Fraction of anaerobic biomass that leads to inert matter" : Fraction := {: value <- 0.08 ; group <- "Conversion factors" :};
    OBJ f_H_AS "Fraction of fermenting biomass that are heterotrophs" : Fraction := {: value <- 0.50 ; group <- "Conversion factors" :};
  };
  
  sub_models <-
  {
    OBJ Trans_In : ASM1ToSiegrist ;
    OBJ Digester : SiegristConversionModel;
    OBJ Trans_Out : SiegristToASM1;
  };
  
  coupling <-
  {
    sub_models.Digester.parameters.Vol.value := parameters.Vol.value,
    sub_models.Digester.parameters.f_X_Out.value := parameters.f_X_Out.value,
    sub_models.Digester.parameters.p.value := parameters.p.value,
    sub_models.Trans_In.parameters.i_X_B.value := parameters.i_X_B.value,
    sub_models.Trans_Out.parameters.i_X_B.value := parameters.i_X_B.value,
    sub_models.Trans_In.parameters.i_X_P.value := parameters.i_X_P.value,
    sub_models.Trans_Out.parameters.i_X_P.value := parameters.i_X_P.value,
    sub_models.Trans_In.parameters.i_S_AS.value := parameters.i_S_AS.value,
    sub_models.Trans_Out.parameters.i_S_AS.value := parameters.i_S_AS.value,
    sub_models.Trans_In.parameters.i_X_S_An.value := parameters.i_X_S_An.value,
    sub_models.Trans_Out.parameters.i_X_S_An.value := parameters.i_X_S_An.value,
    sub_models.Trans_In.parameters.i_X_An.value := parameters.i_X_An.value,
    sub_models.Trans_Out.parameters.i_X_An.value := parameters.i_X_An.value,
    sub_models.Trans_In.parameters.i_X_IN.value := parameters.i_X_IN.value,
    sub_models.Trans_Out.parameters.i_X_IN.value := parameters.i_X_IN.value,
    sub_models.Trans_In.parameters.f_AC_S.value := parameters.f_AC_S.value,
    sub_models.Trans_In.parameters.f_PRO_S.value := parameters.f_PRO_S.value,
    sub_models.Trans_In.parameters.f_AS_S.value := parameters.f_AS_S.value,
    sub_models.Trans_In.parameters.f_XS_I.value := parameters.f_XS_I.value,
    sub_models.Trans_In.parameters.f_XS_H.value := parameters.f_XS_H.value,
    sub_models.Trans_In.parameters.f_XS_A.value := parameters.f_XS_A.value,
    sub_models.Trans_In.parameters.f_XS_P.value := parameters.f_XS_P.value,
    sub_models.Trans_In.parameters.f_AS_H.value := parameters.f_AS_H.value,
    sub_models.Trans_Out.parameters.f_P_An.value := parameters.f_P_An.value,
    sub_models.Trans_Out.parameters.f_H_AS.value := parameters.f_H_AS.value,

    connect(interface.Q_Stripping, sub_models.Digester.interface.Q_Stripping),
    connect(interface.Temp, sub_models.Digester.interface.Temp),
    connect(sub_models.Digester.interface.Q_Biogas, interface.Q_Biogas),
  
    connect(interface.Inflow, sub_models.Trans_In.interface.Inflow),
    connect(sub_models.Trans_In.interface.Outflow, sub_models.Digester.interface.Inflow),
    connect(sub_models.Digester.interface.Outflow, sub_models.Trans_Out.interface.Inflow),
    connect(sub_models.Trans_Out.interface.Outflow, interface.Outflow),
  };

:};



CLASS SiegristConversionModel "A model for anaerobic digestion processes by Siegrist et al."
EXTENDS Base_DigesterSiegrist WITH
{:
  
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristModel.interface.msl" 1
 


# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.parameters.msl" 1
 

    OBJ H_CH4 (* *) "Henry coefficient for CH4" : HenryCoefficient := {: value <- 0.876; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry"; :};
    OBJ H_CO2 (* *) "Henry coefficient for CO2" : HenryCoefficient := {: value <- 0.04; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry"; :};
    OBJ H_H2 (* *) "Henry coefficient for H2" : HenryCoefficient := {: value <- 1.334; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry"; :};
    OBJ K_I_AC_FA (* *) "Anaerobic FA oxidation inhibition concentration for S_AC" : Concentration := {: value <- 2000.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_I_AC_PRO (* *) "Anaerobic propionate inhibition concentration for S_AC" : Concentration := {: value <- 1500.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_I_H2_FA (* *) "Anaerobic FA oxidation inhibition concentration for S_H2" : Concentration := {: value <- 12E-03; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_I_H2_PRO (* *) "Anaerobic propionate oxidation inhibition concentration for S_H2" : Concentration := {: value <- 0.6E-03; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_I_H_AC (* *) "Acetate to methane conversion inhibition concentration for S_H" : MolConcentration := {: value <- 6.3E-4; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_I_H_H2 (* *) "Hydrogen to methane conversion inhibition concentration for S_H" : MolConcentration := {: value <- 6.3E-4; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_I_H_PRO (* *) "Anaerobic propionate oxidation inhibition concentration for S_H" : MolConcentration := {: value <- 6.3E-4; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_AC (* *) "Acetate to methane conversion half-saturation concentration for S_AC" : HalfSatCoeff := {: value <- 30.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_AS (* *) "Anaerobic fermentation half-saturation concentration for S_AS" : HalfSatCoeff := {: value <- 50.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_FA (* *) "Anaerobic FA oxidation half-saturation concentration for S_FA" : HalfSatCoeff := {: value <- 200.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_H2 (* *) "Hydrogen to methane conversion half-saturation concentration for S_H2" : HalfSatCoeff := {: value <- 0.06; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_H_AC (* *) "Acetate to methane conversion half-saturation concentration for S_H" : MolConcentration := {: value <- 1E-5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_H_H2 (* *) "Hydrogen to methane conversion half-saturation concentration for S_H" : MolConcentration := {: value <- 1E-5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_H_PRO (* *) "Anaerobic propionate oxidation half-saturation concentration for S_H" : MolConcentration := {: value <- 1E-5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ K_S_PRO (* *) "Anaerobic propionate oxidation half-saturation concentration for S_PRO" : HalfSatCoeff := {: value <- 15.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ TempCoef1 (* hidden = "1"; *) "Temperature coefficient" : Real := {: unit <- "-"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- +INF; :}; :};
    OBJ TempCoef2 (* hidden = "1"; *) "Temperature coefficient" : Real := {: unit <- "-"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- +INF; :}; :};
    OBJ b_AC (* *) "Specific decay rate for acetate to methane converting bacteria" : DecayCoefficient := {: value <- 0.10; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_AS (* *) "Specific decay rate for AA and sugar fermenting bacteria" : DecayCoefficient := {: value <- 1.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_FA (* *) "Specific decay rate for FA oxidising anaerobic bacteria" : DecayCoefficient := {: value <- 0.10; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H2 (* *) "Specific decay rate for hydrogen to methane converting bacteria" : DecayCoefficient := {: value <- 0.4; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_PRO (* *) "Specific decay rate for propionate oxidising anaerobic bacteria" : DecayCoefficient := {: value <- 0.10; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_CO2 (* *) "Rate of carbon dioxide deprotolysis" : Real := {: value <- 0.0045; interval <- {: lowerBound <- 0.0; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_HCO3 (* *) "Rate of bicarbonate protolysis" : Real := {: unit <- "d-1.m3.Mol-1"; value <- 10.0; interval <- {: lowerBound <- 0.0; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_R (* *) "Specific hydrolysis rate of biopolymers" : MaxSpecificHydrolysisRate := {: value <- 0.25; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_AC (* *) "Maximum specific growth rate of acetate to methane converting bacteria" : MaxGrowthRate := {: value <- 0.95; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_AS (* *) "Maximum specific growth rate of AA and sugar fermenting bacteria" : MaxGrowthRate := {: value <- 5.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_FA (* *) "Maximum specific growth rate of FA oxidising anaerobic bacteria" : MaxGrowthRate := {: value <- 0.55; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H2 (* *) "Maximum specific growth rate of hydrogen to methane converting bacteria" : MaxGrowthRate := {: value <- 3.60; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_PRO (* *) "Maximum specific growth rate of propionate oxidising bacteria" : MaxGrowthRate := {: value <- 0.80; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.state.msl" 1
 


# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.body.msl" 2

  };

  initial <-
  {
     

    parameters.TempCoef1 := exp(0.069 * (interface.Temp - 35.0));
    parameters.TempCoef2 := exp(0.069 * (interface.Temp - 35.0));

     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[H2Stripping][S_H2] := -parameters.H_H2;
    parameters.Stoichiometry[CH4Stripping][S_CH4] := -parameters.H_CH4;
    parameters.Stoichiometry[CO2Stripping][S_CO2] := -parameters.H_CO2;
    parameters.Stoichiometry[BiopolymHydrol][S_AS] := 0.50;
    parameters.Stoichiometry[BiopolymHydrol][S_FA] := 0.45;
    parameters.Stoichiometry[BiopolymHydrol][S_IN] := 0.05;
    parameters.Stoichiometry[BiopolymHydrol][X_S] := -1.00;
    parameters.Stoichiometry[ASFermentation][S_H2] := 0.96;
    parameters.Stoichiometry[ASFermentation][S_CO2] := 0.082;
    parameters.Stoichiometry[ASFermentation][S_HCO3] := -0.051;
    parameters.Stoichiometry[ASFermentation][S_NH4] := 0.187;
    parameters.Stoichiometry[ASFermentation][S_AC] := 3.29;
    parameters.Stoichiometry[ASFermentation][S_PRO] := 1.42;
    parameters.Stoichiometry[ASFermentation][S_AS] := -6.67;
    parameters.Stoichiometry[ASFermentation][X_AS] := 1.00;
    parameters.Stoichiometry[AnOxOfS_FA][S_H2] := 6.70;
    parameters.Stoichiometry[AnOxOfS_FA][S_CO2] := 0.199;
    parameters.Stoichiometry[AnOxOfS_FA][S_HCO3] := -0.202;
    parameters.Stoichiometry[AnOxOfS_FA][S_NH4] := -0.08;
    parameters.Stoichiometry[AnOxOfS_FA][S_AC] := 14.3;
    parameters.Stoichiometry[AnOxOfS_FA][S_FA] := -22.0;
    parameters.Stoichiometry[AnOxOfS_FA][X_FA] := 1.00;
    parameters.Stoichiometry[AnOxOfS_PRO][S_H2] := 8.20;
    parameters.Stoichiometry[AnOxOfS_PRO][S_CO2] := 0.163;
    parameters.Stoichiometry[AnOxOfS_PRO][S_HCO3] := 0.004;
    parameters.Stoichiometry[AnOxOfS_PRO][S_NH4] := -0.08;
    parameters.Stoichiometry[AnOxOfS_PRO][S_AC] := 10.8;
    parameters.Stoichiometry[AnOxOfS_PRO][S_PRO] := -20.0;
    parameters.Stoichiometry[AnOxOfS_PRO][X_PRO] := 1.00;
    parameters.Stoichiometry[AcToCH4Conv][S_CH4] := 39.0;
    parameters.Stoichiometry[AcToCH4Conv][S_CO2] := -0.007;
    parameters.Stoichiometry[AcToCH4Conv][S_HCO3] := 0.619;
    parameters.Stoichiometry[AcToCH4Conv][S_NH4] := -0.08;
    parameters.Stoichiometry[AcToCH4Conv][S_AC] := -40.0;
    parameters.Stoichiometry[AcToCH4Conv][X_AC] := 1.00;
    parameters.Stoichiometry[H2ToCH4Conv][S_H2] := -22.0;
    parameters.Stoichiometry[H2ToCH4Conv][S_CH4] := 21.0;
    parameters.Stoichiometry[H2ToCH4Conv][S_CO2] := -0.291;
    parameters.Stoichiometry[H2ToCH4Conv][S_HCO3] := -0.006;
    parameters.Stoichiometry[H2ToCH4Conv][S_NH4] := -0.08;
    parameters.Stoichiometry[H2ToCH4Conv][X_H2] := 1.00;
    parameters.Stoichiometry[DecayOfX_AS][S_HCO3] := 0.004;
    parameters.Stoichiometry[DecayOfX_AS][S_NH4] := 0.056;
    parameters.Stoichiometry[DecayOfX_AS][X_S] := 0.80;
    parameters.Stoichiometry[DecayOfX_AS][X_AS] := -1.00;
    parameters.Stoichiometry[DecayOfX_AS][X_IN] := 0.20;
    parameters.Stoichiometry[DecayOfX_FA][S_HCO3] := 0.004;
    parameters.Stoichiometry[DecayOfX_FA][S_NH4] := 0.056;
    parameters.Stoichiometry[DecayOfX_FA][X_S] := 0.80;
    parameters.Stoichiometry[DecayOfX_FA][X_FA] := -1.00;
    parameters.Stoichiometry[DecayOfX_FA][X_IN] := 0.20;
    parameters.Stoichiometry[DecayOfX_PRO][S_HCO3] := 0.004;
    parameters.Stoichiometry[DecayOfX_PRO][S_NH4] := 0.056;
    parameters.Stoichiometry[DecayOfX_PRO][X_S] := 0.80;
    parameters.Stoichiometry[DecayOfX_PRO][X_PRO] := -1.00;
    parameters.Stoichiometry[DecayOfX_PRO][X_IN] := 0.20;
    parameters.Stoichiometry[DecayOfX_AC][S_HCO3] := 0.004;
    parameters.Stoichiometry[DecayOfX_AC][S_NH4] := 0.056;
    parameters.Stoichiometry[DecayOfX_AC][X_S] := 0.80;
    parameters.Stoichiometry[DecayOfX_AC][X_AC] := -1.00;
    parameters.Stoichiometry[DecayOfX_AC][X_IN] := 0.20;
    parameters.Stoichiometry[DecayOfX_H2][S_HCO3] := 0.04;
    parameters.Stoichiometry[DecayOfX_H2][S_NH4] := 0.056;
    parameters.Stoichiometry[DecayOfX_H2][X_S] := 0.80;
    parameters.Stoichiometry[DecayOfX_H2][X_H2] := -1.00;
    parameters.Stoichiometry[DecayOfX_H2][X_IN] := 0.20;
    parameters.Stoichiometry[ProtolysisOfHCO3][S_CO2] := 1.00;
    parameters.Stoichiometry[ProtolysisOfHCO3][S_HCO3] := -1.00;
    parameters.Stoichiometry[ProtolysisOfHCO3][S_H] := -1.00;
    parameters.Stoichiometry[DeprotolysisOfCO2][S_CO2] := -1.00;
    parameters.Stoichiometry[DeprotolysisOfCO2][S_HCO3] := 1.00;
    parameters.Stoichiometry[DeprotolysisOfCO2][S_H] := 1.00;

# 33 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.body.msl" 2

  };

  equations <-
  {
     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.kinetics.msl" 1
 

    state.Kinetics[ASFermentation] = parameters.mu_AS * (state.C[S_AS] / (parameters.K_S_AS + state.C[S_AS])) * state.C[X_AS] * parameters.TempCoef1;
    state.Kinetics[AcToCH4Conv] = parameters.mu_AC * (state.C[S_AC] / (parameters.K_S_AC + state.C[S_AC])) * (state.C[S_H] / (parameters.K_S_H_AC + state.C[S_H])) *

(parameters.K_I_H_AC / (parameters.K_I_H_AC + state.C[S_H])) * state.C[X_AC] * parameters.TempCoef2;
    state.Kinetics[AnOxOfS_FA] = parameters.mu_FA * (state.C[S_FA] / (parameters.K_S_FA + state.C[S_FA])) * (parameters.K_I_AC_FA / (parameters.K_I_AC_FA + state.C[S_AC])) *

(parameters.K_I_H2_FA / (parameters.K_I_H2_FA + state.C[S_H2])) * state.C[X_FA] * parameters.TempCoef1;
    state.Kinetics[AnOxOfS_PRO] = parameters.mu_PRO * (state.C[S_PRO] / (parameters.K_S_PRO + state.C[S_PRO])) * (parameters.K_I_AC_PRO / (parameters.K_I_AC_PRO + state.C[S_AC])) *

(parameters.K_I_H2_PRO / (parameters.K_I_H2_PRO + state.C[S_H2])) * (state.C[S_H] / (parameters.K_S_H_PRO + state.C[S_H])) * (parameters.K_I_H_PRO /

(parameters.K_I_H_PRO + state.C[S_H])) * state.C[X_PRO] * parameters.TempCoef2;
    state.Kinetics[BiopolymHydrol] = parameters.k_R * state.C[X_S] * parameters.TempCoef1;
    state.Kinetics[CH4Stripping] = state.rate_Stripping * state.C[S_CH4];
    state.Kinetics[CO2Stripping] = state.rate_Stripping * state.C[S_CO2];
    state.Kinetics[DecayOfX_AC] = parameters.b_AC * state.C[X_AC] * parameters.TempCoef2;
    state.Kinetics[DecayOfX_AS] = parameters.b_AS * state.C[X_AS] * parameters.TempCoef1;
    state.Kinetics[DecayOfX_FA] = parameters.b_FA * state.C[X_FA] * parameters.TempCoef1;
    state.Kinetics[DecayOfX_H2] = parameters.b_H2 * state.C[X_H2] * parameters.TempCoef2;
    state.Kinetics[DecayOfX_PRO] = parameters.b_PRO * state.C[X_PRO] * parameters.TempCoef2;
    state.Kinetics[DeprotolysisOfCO2] = parameters.k_CO2 * state.C[S_CO2];
    state.Kinetics[H2Stripping] = state.rate_Stripping * state.C[S_H2];
    state.Kinetics[H2ToCH4Conv] = parameters.mu_H2 * (state.C[S_H2] / (parameters.K_S_H2 + state.C[S_H2])) * (state.C[S_H] / (parameters.K_S_H_H2 + state.C[S_H])) *

(parameters.K_I_H_H2 / (parameters.K_I_H_H2 + state.C[S_H])) * state.C[X_H2] * parameters.TempCoef2;
    state.Kinetics[ProtolysisOfHCO3] = parameters.k_HCO3 * state.C[S_HCO3] * state.C[S_H];

# 46 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristModel.sensors.msl" 1
 


# 50 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\Siegrist/wwtp.VolumeSiegristConversionModel.body.msl" 2

  };

# 114 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.siegrist.msl" 2

:};



CLASS Base_DigesterSiegrist SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for anaerobic digestion processes by Siegrist et al.";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : SiegristWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : SiegristWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Q_Stripping (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Gas flow for stripping" : FlowRate := {: causality <- "CIN" ; value <- 30 ; group <- "Operational" :}; 
    OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Celsius Temperature" : CelsiusTemperature := {: causality <- "CIN" ; value <- 35.0 ; group <- "Operational":};
     
    OBJ Q_Biogas (* terminal = "out_4"; is_favorite = "1" *) "Biogas flow (incl. stripping gas)" : FlowRate := {: causality <- "COUT" ; group <- "Operational" :}; 
  };

  parameters <-
  {
    OBJ SiegristSpecificVolume (* hidden = "1" *) "Specific volume for all Siegrist components" : SiegristSpecificVolumeVector ;
    OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[SiegristNrOfReactions;][SiegristNrOfComponents,];
    OBJ f_X_Out (* is_favorite = "1" *) "Fraction of particulate matter that leaves the reactor" : Fraction := {: value <- 0.10 ; group <- "Settling" :};
    OBJ p (* is_favorite = "1" *) "Head pressure in the digester" : Pressure := {:value <- 101325.00 ; group <- "Operational":};
    OBJ R_Gas (* hidden = "1" *) "Universal gas constant" : Real := {: unit <- "J/(mol*K)"; value <- 8.314510; :};
    OBJ Q_Gas0 "Initial (previous) value of Q_Gas_Tot" : FlowRate := {: value <- 655 ; group <- "Operational":};
    OBJ Vol (* is_favorite = "1";  *) "Volume of liquid in the reactor" : Volume := {: value <- 3400; group <- "Dimension"; :};
  };

  state <-
  {
    OBJ MolVol_T (* hidden = "1" *) "Volume of 1 mol gas at temperature T (in degC)" : Volume ;
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[SiegristNrOfReactions;];
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Conversion terms for all the components" : MassFlux[SiegristNrOfComponents;];
    OBJ OutFluxPerComponent (* hidden = "1" *) "Vector containing outgoing fluxes" : MassFlux[SiegristNrOfComponents;];
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes" : MassFlux[SiegristNrOfComponents;];
    OBJ rate_Stripping "Stripping rate: linearly proportional to total gas production": Rate := {: group <- "Operational"; :};
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :}; 
    OBJ V_L (* hidden = "1" *) "Volume of liquid phase in the digester" : Volume := {: group <- "Dimension" :};
    OBJ M "Mass vector for all components" : SiegristMassVector :=
 
      [{: value <- 1000000000:}, {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :},
 
      {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :},
 
      {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :}, {: value <- 10 :}, {: value <- 10 :},
 
      {: value <- 10 :}, {: value <- 10 :}, {: value <- 10 :}, {: value <- 10 :}, {: value <- 10 :}; ] ;
    OBJ C "Concentration vector for all the components" : SiegristConcentrationVector := {: group <- "Concentration" :};
    OBJ pH_Reactor (* is_favorite = "1" *) "pH in the digester" : pH := {: group <- "Operational" :};
    OBJ Flux_H2 "Flux of hydrogen gas produced" : MolFlowRate := {: group <- "Biogas" :};
    OBJ Flux_CH4 "Flux of methane gas produced" : MolFlowRate := {: group <- "Biogas" :};
    OBJ Flux_CO2 "Flux of carbon dioxide gas produced" : MolFlowRate := {: group <- "Biogas" :};
    OBJ Q_H2 (* is_favorite = "1" *) "Flow rate of hydrogen gas produced" : FlowRate := {: group <- "Biogas" :};
    OBJ Q_CH4 (* is_favorite = "1" *) "Flow rate of methane gas produced" : FlowRate := {: group <- "Biogas" :};
    OBJ Q_CO2 (* is_favorite = "1" *) "Flow rate of carbon dioxide gas produced" : FlowRate := {: group <- "Biogas" :};
    OBJ Q_Gas_Prod "Flow rate of gas produced" : FlowRate := {: group <- "Biogas" :};
    OBJ Q_Gas_Tot (* hidden = "1" *) "Total gas flow rate (incl. stripping gas)" : FlowRate := {: group <- "Biogas" :};
    OBJ C_H2 (* is_favorite = "1" *) "H2 concentration in total gas stream" : MolConcentration := {: group <- "Concentration" :};
    OBJ C_CH4 (* is_favorite = "1" *) "CH4 concentration in total gas stream" : MolConcentration := {: group <- "Concentration" :};
    OBJ C_CO2 (* is_favorite = "1" *) "CO2 concentration in total gas stream" : MolConcentration := {: group <- "Concentration" :};
    OBJ prev_Q_Gas_Tot (* hidden = "1" *) "Help variable for the calculation of the previous value of Q_Gas_Tot" : FlowRate ;
  };

  initial <-
  {
    parameters.SiegristSpecificVolume[H2O] := 0.000001;
    state.MolVol_T := 22.4e-3 * ((interface.Temp + 273.15) / 273.15);
    state.M[H2O] := 1E06 * parameters.Vol ;    
    state.V_L := 1E-06 * state.M[H2O] ;
    state.C[S_H] := state.M[S_H] / state.V_L ; 
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  equations <-
  {
    state.prev_Q_Gas_Tot = IF (previous(independent.t) >= independent.t) THEN parameters.Q_Gas0
      ELSE previous(state.Q_Gas_Tot) ;
      
    state.rate_Stripping = IF (state.V_L <= 0) THEN 0.0
      ELSE state.prev_Q_Gas_Tot / (state.V_L * (parameters.R_Gas / parameters.p) * (273.15 + interface.Temp)) ;

    state.pH_Reactor = IF (state.C[S_H] <= 0) THEN 0.0
      ELSE - log10(state.C[S_H] / 1000);

    state.V_L = SUMOVER Comp_Index IN {1 .. SiegristNrOfComponents}:
      (parameters.SiegristSpecificVolume[Comp_Index] * state.M[Comp_Index]);

     
    {FOREACH Comp_Index IN {1 .. SiegristNrOfComponents}: state.ConversionTermPerComponent[Comp_Index] =
        SUMOVER Reaction_Index IN {1 .. SiegristNrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index] * state.Kinetics[Reaction_Index]) * state.V_L ; };

    {FOREACH Comp_Index IN {1 .. SiegristNrOfComponents}: DERIV(state.M[Comp_Index],[independent.t]) =
        state.InFluxPerComponent[Comp_Index] + state.OutFluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index] ; };
    
    state.Q_In = SUMOVER Comp_Index IN {1 .. SiegristNrOfComponents}:
        (parameters.SiegristSpecificVolume[Comp_Index] * state.InFluxPerComponent[Comp_Index]);

    {FOREACH Comp_Index IN {1 .. SiegristNrOfComponents}: state.C[Comp_Index] = state.M[Comp_Index] / state.V_L ; };
    
     
    {FOREACH Comp_Index IN {1 .. S_IN}: state.OutFluxPerComponent[Comp_Index] = - state.C[Comp_Index] * state.Q_In ; };
    
     
     
    {FOREACH Comp_Index IN {X_S .. X_IN}: state.OutFluxPerComponent[Comp_Index] = parameters.f_X_Out * (- state.C[Comp_Index] * state.Q_In) ; };
    
     
     
     
    state.Flux_H2 = - (parameters.Stoichiometry[H2Stripping][S_H2] * state.Kinetics[H2Stripping] * state.V_L) / 16.0 ;

     
    state.Flux_CH4 = - (parameters.Stoichiometry[CH4Stripping][S_CH4] * state.Kinetics[CH4Stripping] * state.V_L) / 64.0 ;

     
    state.Flux_CO2 = - (parameters.Stoichiometry[CO2Stripping][S_CO2] * state.Kinetics[CO2Stripping] * state.V_L) ;

    state.Q_H2 = state.Flux_H2 * state.MolVol_T ;
    state.Q_CH4 = state.Flux_CH4 * state.MolVol_T ;
    state.Q_CO2 = state.Flux_CO2 * state.MolVol_T ;

     
    state.Q_Gas_Prod = state.Q_H2 + state.Q_CH4 + state.Q_CO2 ;
    state.Q_Gas_Tot = state.Q_Gas_Prod + interface.Q_Stripping ;

     
    state.C_H2 = state.Flux_H2 / state.Q_Gas_Tot ;
    state.C_CH4 = state.Flux_CH4 / state.Q_Gas_Tot ;
    state.C_CO2 = state.Flux_CO2 / state.Q_Gas_Tot ;
    
    interface.Q_Biogas = state.Q_Gas_Tot ; 
  };

:};




# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.anaerobic_digestion.msl" 2




# 41 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sensors.msl" 1
 


















CLASS Sensor "Base class for generic (WWTP) sensor"
SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
  };

  parameters <- 
  {
    OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components" : SpecificVolumeVector ;
  };
  
  independent <- 
  {
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };
  
  state <- 
  {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector ;
    OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "State vector - concentrations" :};
  };

  initial <- 
  {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  };
  
  equations <- 
  {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
      SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] ; }; 
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.C[Comp_Index] = IF (state.Q_In <= 0.0) THEN 0.0 ELSE state.InFluxPerComponent[Comp_Index] / state.Q_In ; }; 
    
    state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent] ;
  };

:};

 
 












# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl" 1
 














 






CLASS MultiSensor (* icon = "sensor_multi"; is_default = "true" *) "Multi-probe sensor" EXTENDS Sensor WITH 
{:

  interface <-
  {
    OBJ y_Q (* terminal = "out_2"; is_favorite = "1" *) "Flow rate" : FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ y_DO (* terminal = "out_2"; is_favorite = "1" *) "Oxygen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_NH (* terminal = "out_2"; is_favorite = "1" *) "Ammonia concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_NO (* terminal = "out_2"; is_favorite = "1" *) "Nitrate concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_TSS (* terminal = "out_2"; is_favorite = "1" *) "Particulates concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_VSS (* terminal = "out_2"; is_favorite = "1" *) "VSS concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_COD (* terminal = "out_2"; is_favorite = "1" *) "COD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_BOD (* terminal = "out_2"; is_favorite = "1" *) "BOD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_TN (* terminal = "out_2"; is_favorite = "1" *) "Total Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ y_TKN (* terminal = "out_2"; is_favorite = "1" *) "Total Kjeldahl Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
     
     
    


    



    


    
  };

  parameters <- 
  {
     
     
     
    
     
    
    
    OBJ i_COD_VSS "VSS content of other X_COD components" : Real := {: unit <- "gCOD/gVS"; value <- 1.42; group <- "Conversion" :};
    OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};
    
     
    




    




    
    OBJ F_TSS_COD "Fraction TSS/COD" : Ratio := {: value <- 0.75 ; group <- "Conversion factors":};
    OBJ f_P "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: value<- 0.20 ; group <- "Stoichiometry" :};
    
    


    


        
    
    OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {:value <- 0.086 ; group <- "Composition parameters" :};
    OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {:value <- 0.06 ; group <- "Composition parameters" :};
     
    OBJ i_S_I "Nitrogen content of inert soluble COD S_I" : NitrogenConversionFactor := {:value <- 0.00 ; group <- "Composition parameters" :};
    
    






    
# 109 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"

    






    






    
    






    
# 140 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"

    






    
# 157 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"

    
  };

  state <- 
  {
    
# 172 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"

  };

  equations <- 
  {
     
    interface.y_Q = state.Q_In ;
    
    

     
    interface.y_DO = IF (state.Q_In == 0) THEN 0
      ELSE interface.Inflow[S_O] / state.Q_In ;

     
    



    
    interface.y_NH = IF (state.Q_In == 0) THEN 0
      ELSE interface.Inflow[S_NH] / state.Q_In ;
    
    
     
    
    interface.y_NO = IF (state.Q_In == 0) THEN 0
      ELSE interface.Inflow[S_NO] / state.Q_In ;
    
    



    




     
    
    interface.y_TSS = IF (state.Q_In == 0) THEN 0
      ELSE (interface.Inflow[X_BH] + interface.Inflow[X_BA] + interface.Inflow[X_S] +
      interface.Inflow[X_I] + interface.Inflow[X_P]) * parameters.F_TSS_COD / state.Q_In ; 
    
    




    




    



    
# 250 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"


     
    interface.y_VSS = IF (state.Q_In <= 0.0) THEN 0.0 ELSE
    
      
      (interface.Inflow[X_I] + interface.Inflow[X_S] + interface.Inflow[X_BH] + interface.Inflow[X_BA] + interface.Inflow[X_P]) / parameters.i_COD_VSS 
      

      



      





      



      



      



      



      



      / state.Q_In ;

     
     
    





    
     
    
    interface.y_COD = IF (state.Q_In == 0) THEN 0
      ELSE (interface.Inflow[S_S] + interface.Inflow[X_S] + interface.Inflow[S_I] +
      interface.Inflow[X_I] + interface.Inflow[X_P] + interface.Inflow[X_BH] + interface.Inflow[X_BA]) / state.Q_In ; 
    
    




    




    





    





    
# 339 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"

    




    






     
    
    interface.y_BOD = IF (state.Q_In == 0) THEN 0
      ELSE parameters.F_BOD_COD * (interface.Inflow[S_S] + interface.Inflow[X_S] +
      (1 - parameters.f_P) * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) ) / state.Q_In ; 
    
    




    




    





    





    
# 390 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"

    




    






     
    
       
    interface.y_TN = IF (state.Q_In == 0) THEN 0
      ELSE (interface.Inflow[S_NO] + interface.Inflow[S_NH] + interface.Inflow[S_ND] +
      interface.Inflow[X_ND] + parameters.i_X_B * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) +
      parameters.i_X_P * (interface.Inflow[X_P] + interface.Inflow[X_I]) + .parameters.i_S_I * interface.Inflow[S_I]) / state.Q_In ;
    
    





    





    






    







    






    





    







     
    
    interface.y_TKN = IF (state.Q_In == 0) THEN 0
       
    ELSE (interface.Inflow[S_NH] + interface.Inflow[S_ND] + interface.Inflow[X_ND] +
    parameters.i_X_B * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) + parameters.i_X_P * (interface.Inflow[X_P] +
    interface.Inflow[X_I]) + .parameters.i_S_I * interface.Inflow[S_I]) / state.Q_In ;
    
    





    





    






    






    






    





    







     
    






    







    






    






     
     
    



    
     
    
# 561 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"


    
# 574 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"


    
# 587 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"


    
  };

:};




# 799 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sensor/wwtp.base.sensors.sensor_multi.msl"




# 83 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sensors.msl" 2




# 42 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 1
 



















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.base.controllers.onoffideal.msl" 1
 


















CLASS OnOffIdeal
  (* icon = "controller_on_off" ; is_default = "" *)
  "Ideal On-off controller"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
         Real := {: causality <- "CIN" ; value <- 2  ; group <- "Operational":};
    OBJ u_Off (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when off" : 
    Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_On  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when on"  : 
    Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
     OBJ help_t (* hidden = "1" *) "Previous t help variable" : Real;
    };

    equations <-
    {
    state.e = interface.y_S - interface.y_M;

    state.help_u = interface.u;
    state.help_t = independent.t;
    interface.u = IF (interface.y_M > interface.y_S)
                  THEN interface.u_Off
                  ELSE interface.u_On;
   };

 :};

 


# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.base.controllers.onoffband.msl" 1
 


















CLASS OnOffBand (* icon = "controller_on_off" ; is_default = "true" *)
"On-off controller with a band"
SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for an on-off controller";

  interface <-
  {
    OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : Real := {: causality <- "COUT" ; group <- "Control action" :};
 
    OBJ y_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum allowed measured value" :  Real := {: causality <- "CIN" ; value <- 1.8  ; group <- "Operational":};
    OBJ y_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum allowed measured value" :  Real := {: causality <- "CIN" ; value <- 2.2  ; group <- "Operational":};
     
    OBJ u_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when measured value is y_Max" :  Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when measured value is y_Min"  :  Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
    OBJ help_y_S (* hidden = "1" *) "Set-point (mid point between Min-Max)" : Real := {: group <- "Operational" :};
    OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
    OBJ help_t (* hidden = "1" *) "Previous t help variable" : Real;
  };

  equations <-
  {
     
    state.e = state.help_y_S - interface.y_M;
    
    state.help_y_S = (interface.y_Min + interface.y_Max) / 2.0 ;
    state.help_u = interface.u;
    state.help_t = independent.t;
    
    interface.u = IF(interface.y_M < interface.y_Min) THEN interface.u_Min
      ELSE IF (interface.y_M > interface.y_Max) THEN interface.u_Max
        ELSE IF (previous(state.help_t) >= independent.t) THEN interface.u_Min
          ELSE previous(state.help_u) ;
  };

 :};

 


# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.base.controllers.constantratio.msl" 1
 


















CLASS ConstantRatio
  (* icon = "controller_ratio" *)
  "Ratio controller"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a ratio controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" :
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" :
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ ConstantRatio (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Ratio between measured value and controller output" :
        Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

    equations <-
    {

    interface.u = interface.ConstantRatio * interface.y_M;

    };
  :};

 


# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.base.controllers.p_saturation.msl" 1
 


















CLASS P_Saturation
  (* icon = "controller_p" *)
  "P controller with saturation"

 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable " : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) " Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

     state.e = interface.y_S - interface.y_M ;
     state.uhelp = interface.u0 + interface.K_P * state.e;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
   };

 :};

 


# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.base.controllers.pi_saturation.msl" 1
 



















CLASS BasePISaturation "PI controller with saturation"
SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
    OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ y_S  (* terminal = "in_2"; manip = "1" *) "Setpoint value for controlled variable" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
    OBJ u_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : Real := {: causality <- "CIN" ;value <- 0 ; group <- "Operational" :};
    OBJ u_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Operational" :};
    OBJ K_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" :Real := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};
    OBJ T_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ u (* terminal = "out_1" *) "Controlled variable" : Real := {: causality <- "COUT" ; group <- "Control action" :};
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ e "Error" : PhysicalQuantityType := {: group <- "Operational" :};
    OBJ Integ_e (* hidden = "1" *) "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
    OBJ help (* hidden = "1" *) "Previous time help variable" : Time;
    OBJ uhelp (* hidden = "1" *) "Help variable to calculate the PI control action" : Real;
    OBJ uhelp2 (* hidden = "1" *) "Help variable to calculate the PI control action after saturation" : Real ;   
   

};

  initial <-
  {
    state.Integ_e = 0.0 ;
  };

  equations <-
  {
    state.e = interface.y_S - interface.y_M;
    
    state.help = independent.t;
    
    DERIV(state.Integ_e, [independent.t]) = state.e ;

    state.uhelp2 = IF(state.uhelp < interface.u_Min) THEN (interface.u_Min)
      ELSE IF (state.uhelp > interface.u_Max) THEN interface.u_Max 
        ELSE state.uhelp ;

    interface.u = state.uhelp2;
  };

:};


CLASS PI_Saturation (* icon = "controller_pi"; is_default = "true" *)
"PI controller with saturation"
EXTENDS BasePISaturation WITH
{:
  comments <- "A model for a proportional-integral controller with saturation";
  
  equations <-
  {
    state.uhelp = interface.u0 + interface.K_P * (state.e + (1 / interface.T_I) * state.Integ_e) ;  
  };

:};
 

CLASS PI_Saturation_AntiWindup (* icon = "controller_pi" *)
"PI controller with saturation and anti-windup"
EXTENDS BasePISaturation WITH
{:
  comments <- "A model for a proportional-integral controller with saturation and anti-windup";
  
  interface <-
  {
    OBJ T_t (* terminal = "in_2"; manip = "1" *) "Antiwindup time constant, tracking time constant" : Time := {: causality <- "CIN" ; value <- 0.0002 ; group <- "Operational" :};
  };

state <-
  {
    OBJ uAntiwindup (* hidden = "1" *) "Help variable to calculate the antiwindup control action" : Real ;
  };
  
  equations <-
  {
    DERIV(state.uAntiwindup, [independent.t]) = (state.uhelp2 - state.uhelp)/interface.T_t; 
    
    state.uhelp = interface.u0 + interface.K_P * (state.e + (1 / interface.T_I) * state.Integ_e) + state.uAntiwindup ; 
  };

:};
 
 

# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.base.controllers.pid_saturation.msl" 1
 


















CLASS BasePIDSaturation
  "PID controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:

    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : Real := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ K_P (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Factor of proportionality" : Real := {: causality <- "CIN" ; value <- 25.0 ; group <- "Operational" :};
      OBJ T_I (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Integral time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ T_D (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Derivative time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
      OBJ u0  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
      OBJ u_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
      OBJ u_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
	  OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
	  OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
	  OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
	   
	  OBJ help_u_Unsat (* hidden = "1" *) "Help variable to calculate the proportional-integral-derivative control action" : Real;
	  OBJ Deriv_e (* hidden = "1" *) "Derivative of error" : Real := {: group <- "Operational" :};
	  OBJ Prev_t (* hidden = "1" *) : Time;
	  OBJ help_u_Sat (* hidden = "1" *) "Working variable for the output signal" : Real;
    };

    initial <-
    {
	  state.Integ_e = 0.0 ;
    };

    equations <-
    {
	  state.e = interface.y_S - interface.y_M;	 
	  
	  state.help = independent.t;	 
	  
	  state.Deriv_e = IF (previous(state.help) != state.help) THEN
	  	(previous(state.e) - state.e) / (previous(state.help) - state.help)
		ELSE previous(state.Deriv_e) ;   

 

 
	  state.help_u_Sat = IF(state.help_u_Unsat < interface.u_Min) THEN (interface.u_Min)
		ELSE IF (state.help_u_Unsat > interface.u_Max)
			 THEN interface.u_Max
			 ELSE state.help_u_Unsat ;

	  interface.u = state.help_u_Sat ;
    };

  :};


CLASS PID_Saturation
  (* icon = "controller_pid"; is_default = "true" *)
  "PID controller with saturation"
  EXTENDS BasePIDSaturation WITH
  {:
    comments <- "A model for a proportional-integral-derivative controller with saturation";

    equations <-
    {
     DERIV(state.Integ_e, [independent.t]) = state.e ;

     state.help_u_Unsat = interface.u0 + interface.K_P * (state.e + interface.T_D * state.Deriv_e + state.Integ_e / interface.T_I) ;
    };

  :};


CLASS PID_Saturation_AntiWindup
  (* icon = "controller_pid" *)
  "PID controller with saturation and anti-windup"
  EXTENDS BasePIDSaturation WITH
  {:
    comments <- "A model for a proportional-integral-derivative controller with saturation and anti-windup";

    interface <-
    {
      OBJ T_t (* terminal = "in_2"; manip = "1" *) "Tracking time (anti-windup)" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    };

    equations <-
    {
     DERIV(state.Integ_e, [independent.t]) = (interface.K_P * state.e / interface.T_I) + ((state.help_u_Sat - state.help_u_Unsat) / interface.T_t) ;

     state.help_u_Unsat = interface.u0 + interface.K_P * state.e + state.Integ_e + interface.K_P * interface.T_D * state.Deriv_e; 
    };

  :};

 


# 26 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.base.controllers.linear.msl" 1
 



















CLASS Ctl_Linear (* icon = "controller_ratio" *) "The control action is linealy dependent on the incoming signal"
SPECIALISES PhysicalDAEModelType :=
{:

	comments <- "The control action is linealy dependent on the incoming signal";
	
	interface <-
	{
		OBJ y_M (* terminal = "in_1" *) "Incoming signal" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ u (* terminal = "out_1" *) "Control action" : Real := {: causality <- "COUT" ; group <- "Control action" :};
		 
		OBJ m (* terminal = "in_2"; manip = "1" *) "Slope (y = mx + q)" : Real := {: causality <- "CIN" ; value <- 1.0 ; group <- "Operational" :};
		OBJ q (* terminal = "in_2"; manip = "1" *) "Intercept (y = mx + q)" : Real := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
	};

	independent <- 
	{ 
		OBJ t "Time" : Time := {: group <- "Time" :}; 
	};

	equations <-
	{
		interface.u = interface.m * interface.y_M + interface.q ;
	};

:};
 


# 28 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.controllers.raswas.msl" 1
 




















 
CLASS Ctl_Qas_Base SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
    OBJ y_Q (* terminal = "in_1"; is_favorite = "1" *) "Flow rate Q-in" : FlowRate := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Q_ML (* terminal = "out_1"; is_favorite = "1" *) "Flow rate Q ML" : FlowRate := {: causality <- "COUT" ; group <- "ML" :};
    OBJ Q_Under (* terminal = "out_1"; is_favorite = "1" *) "SST underflow" : FlowRate := {: causality <- "COUT" ; group <- "Action" :};
    OBJ Q_RAS (* terminal = "out_1"; is_favorite = "1" *) "Flow rate Q RAS" : FlowRate := {: causality <- "COUT" ; group <- "RAS & WAS" :};
    OBJ Q_WAS (* terminal = "out_1"; is_favorite = "1" *) "Flow rate Q WAS" : FlowRate := {: causality <- "COUT" ; group <- "RAS & WAS" :};
  };
  
  independent <-
  { 
    OBJ t "Time" : Time := {: group <- "Time" :} ; 
  };
  
  equations <-
  {
  };
  
:};
 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.controllers.raswas.flow.msl" 1
 




















CLASS Ctl_Qas_Flow (* icon = "controller_ratio" *)
 
"Flow rate-based controller for ML, RAS and WAS in an AS system"
 
EXTENDS Ctl_Qas_Base WITH
{:
  comments <- "Flow rate-based controller for ML, RAS and WAS in an AS system";
  
  interface <-
  {
    OBJ q_ML (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired ML flow" : FlowRate := {: causality <- "CIN" ; value <- 60000 ; group <- "Operation" :};
    OBJ q_RAS (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired RAS flow" : FlowRate := {: causality <- "CIN"; value <- 20000 ; group <- "Operation" :};
    OBJ q_WAS (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired WAS flow" : FlowRate := {: causality <- "CIN"; value <- 400 ; group <- "Operation" :};
  };
  
  equations <-
  {
    interface.Q_ML = interface.q_ML ;
    interface.Q_Under = interface.q_WAS + interface.q_RAS ;
    interface.Q_RAS = interface.q_RAS ;    
    interface.Q_WAS = interface.q_WAS ;
  };
  
:};
 
 

# 47 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.controllers.raswas.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.controllers.raswas.ratio.msl" 1
 




















 
CLASS Ctl_Qas_Ratio (* icon = "controller_ratio" *)
"Ratio-based controller for ML, RAS and WAS in an AS system"
 
EXTENDS Ctl_Qas_Base WITH
{:
  comments <- "Ratio-based controller for ML, RAS and WAS in an AS system";
  
  interface <-
  {
    OBJ R_ML (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Q ML / Q-in ratio" : Real := {: causality <- "CIN" ; value <- 3.0 ; group <- "Operation" :};
    OBJ R_RAS (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Q RAS / Q-in ratio" : Real := {: causality <- "CIN" ; value <- 1.0 ; group <- "Operation" :};
    OBJ R_WAS (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Q WAS / Q-in ratio" : Real := {: causality <- "CIN" ; value <- 0.015 ; group <- "Operation" :};
  };
  
  equations <-
  {
    interface.Q_ML = interface.R_ML * interface.y_Q ;
    interface.Q_Under = (interface.R_RAS + interface.R_WAS) * interface.y_Q ;
    interface.Q_RAS = interface.R_RAS * interface.y_Q ;    
    interface.Q_WAS = interface.R_WAS * interface.y_Q ;
  };
  
:};



# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.controllers.raswas.msl" 2




# 29 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/controller/wwtp.controllers.multi.pi_saturation.msl" 1
 



















CLASS MultiPI_Saturation (* icon = "controller_pi" *) "5 PI controllers with saturation"
EXTENDS BasePIMultiSaturation WITH
{:
  comments <- "5 PI controllers with saturation";
  
  equations <-
  {
    state.u1help = interface.u01 + interface.K1_P * (state.e1 + (1 / interface.T1_I) * state.Integ_e1) ;  
    state.u2help = interface.u02 + interface.K2_P * (state.e2 + (1 / interface.T2_I) * state.Integ_e2) ;  
    state.u3help = interface.u03 + interface.K3_P * (state.e3 + (1 / interface.T3_I) * state.Integ_e3) ;  
    state.u4help = interface.u04 + interface.K4_P * (state.e4 + (1 / interface.T4_I) * state.Integ_e4) ;  
    state.u5help = interface.u05 + interface.K5_P * (state.e5 + (1 / interface.T5_I) * state.Integ_e5) ;  
  };

:};


CLASS BasePIMultiSaturation "Base class for 5 PI controllers with saturation"
SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
    OBJ y_M1 (* terminal = "in_1" *) "Probe no.1" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ y_M2 (* terminal = "in_1" *) "Probe no.2" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ y_M3 (* terminal = "in_1" *) "Probe no.3" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ y_M4 (* terminal = "in_1" *) "Probe no.4" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ y_M5 (* terminal = "in_1" *) "Probe no.5" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
     
    OBJ y_S1  (* terminal = "in_2"; manip = "1" *) "Set-point no.1" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Set-point" :};
    OBJ y_S2  (* terminal = "in_2"; manip = "1" *) "Set-point no.2" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Set-point" :};
    OBJ y_S3  (* terminal = "in_2"; manip = "1" *) "Set-point no.3" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Set-point" :};
    OBJ y_S4  (* terminal = "in_2"; manip = "1" *) "Set-point no.4" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Set-point" :};
    OBJ y_S5  (* terminal = "in_2"; manip = "1" *) "Set-point no.5" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Set-point" :};
     
    OBJ u1_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : Real := {: causality <- "CIN" ;value <- 0 ; group <- "Ctl 1" :};
    OBJ u1_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Ctl 1" :};
    OBJ K1_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" :Real := {: causality <- "CIN" ; value <- 25 ; group <- "Ctl 1" :};
    OBJ T1_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Ctl 1" :};
    OBJ u01 (* terminal = "in_2"; manip = "1" *) "No error action" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Ctl 1" :};

    OBJ u2_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : Real := {: causality <- "CIN" ;value <- 0 ; group <- "Ctl 2" :};
    OBJ u2_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Ctl 2" :};
    OBJ K2_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" :Real := {: causality <- "CIN" ; value <- 25 ; group <- "Ctl 2" :};
    OBJ T2_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Ctl 2" :};
    OBJ u02 (* terminal = "in_2"; manip = "1" *) "No error action" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Ctl 2" :};
    
    OBJ u3_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : Real := {: causality <- "CIN" ;value <- 0 ; group <- "Ctl 3" :};
    OBJ u3_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Ctl 3" :};
    OBJ K3_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" :Real := {: causality <- "CIN" ; value <- 25 ; group <- "Ctl 3" :};
    OBJ T3_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Ctl 3" :};
    OBJ u03 (* terminal = "in_2"; manip = "1" *) "No error action" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Ctl 3" :};

    OBJ u4_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : Real := {: causality <- "CIN" ;value <- 0 ; group <- "Ctl 4" :};
    OBJ u4_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Ctl 4" :};
    OBJ K4_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" :Real := {: causality <- "CIN" ; value <- 25 ; group <- "Ctl 4" :};
    OBJ T4_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Ctl 4" :};
    OBJ u04 (* terminal = "in_2"; manip = "1" *) "No error action" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Ctl 4" :};

    OBJ u5_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : Real := {: causality <- "CIN" ;value <- 0 ; group <- "Ctl 5" :};
    OBJ u5_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Ctl 5" :};
    OBJ K5_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" :Real := {: causality <- "CIN" ; value <- 25 ; group <- "Ctl 5" :};
    OBJ T5_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Ctl 5" :};
    OBJ u05 (* terminal = "in_2"; manip = "1" *) "No error action" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Ctl 5" :};
     
    OBJ u1 (* terminal = "out_1" *) "Action no.1" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u2 (* terminal = "out_1" *) "Action no.2" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u3 (* terminal = "out_1" *) "Action no.3" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u4 (* terminal = "out_1" *) "Action no.4" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u5 (* terminal = "out_1" *) "Action no.5" : Real := {: causality <- "COUT" ; group <- "Control action" :};
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ e1 "Error no.1" : PhysicalQuantityType := {: group <- "Operational" :};
    OBJ e2 "Error no.2" : PhysicalQuantityType := {: group <- "Operational" :};
    OBJ e3 "Error no.3" : PhysicalQuantityType := {: group <- "Operational" :};
    OBJ e4 "Error no.4" : PhysicalQuantityType := {: group <- "Operational" :};
    OBJ e5 "Error no.5" : PhysicalQuantityType := {: group <- "Operational" :};
    OBJ Integ_e1 (* hidden = "1" *) "Integral of error no.1": PhysicalQuantityType := {: group <- "Operational" :};
    OBJ Integ_e2 (* hidden = "1" *) "Integral of error no.2": PhysicalQuantityType := {: group <- "Operational" :};
    OBJ Integ_e3 (* hidden = "1" *) "Integral of error no.3": PhysicalQuantityType := {: group <- "Operational" :};
    OBJ Integ_e4 (* hidden = "1" *) "Integral of error no.4": PhysicalQuantityType := {: group <- "Operational" :};
    OBJ Integ_e5 (* hidden = "1" *) "Integral of error no.5": PhysicalQuantityType := {: group <- "Operational" :};
    
    OBJ help (* hidden = "1" *) "Previous time help variable" : Time;
    
    OBJ u1help (* hidden = "1" *) "Help variable to calculate the PI control action" : Real;
    OBJ u2help (* hidden = "1" *) "Help variable to calculate the PI control action" : Real;
    OBJ u3help (* hidden = "1" *) "Help variable to calculate the PI control action" : Real;
    OBJ u4help (* hidden = "1" *) "Help variable to calculate the PI control action" : Real;
    OBJ u5help (* hidden = "1" *) "Help variable to calculate the PI control action" : Real;
    OBJ uhelp2_1 (* hidden = "1" *) "Help variable to calculate the PI control action after saturation" : Real ;   
    OBJ uhelp2_2 (* hidden = "1" *) "Help variable to calculate the PI control action after saturation" : Real ;   
    OBJ uhelp2_3 (* hidden = "1" *) "Help variable to calculate the PI control action after saturation" : Real ;   
    OBJ uhelp2_4 (* hidden = "1" *) "Help variable to calculate the PI control action after saturation" : Real ;   
    OBJ uhelp2_5 (* hidden = "1" *) "Help variable to calculate the PI control action after saturation" : Real ;   
  };

  initial <-
  {
    state.Integ_e1 = 0.0 ;
    state.Integ_e2 = 0.0 ;
    state.Integ_e3 = 0.0 ;
    state.Integ_e4 = 0.0 ;
    state.Integ_e5 = 0.0 ;
  };

  equations <-
  {
    state.e1 = interface.y_S1 - interface.y_M1;
    state.e2 = interface.y_S2 - interface.y_M2;
    state.e3 = interface.y_S3 - interface.y_M3;
    state.e4 = interface.y_S4 - interface.y_M4;
    state.e5 = interface.y_S5 - interface.y_M5;
    
    state.help = independent.t;
    
    DERIV(state.Integ_e1, [independent.t]) = state.e1 ;
    DERIV(state.Integ_e2, [independent.t]) = state.e2 ;
    DERIV(state.Integ_e3, [independent.t]) = state.e3 ;
    DERIV(state.Integ_e4, [independent.t]) = state.e4 ;
    DERIV(state.Integ_e5, [independent.t]) = state.e5 ;

    state.uhelp2_1 = IF(state.u1help < interface.u1_Min) THEN (interface.u1_Min)
      ELSE IF (state.u1help > interface.u1_Max) THEN interface.u1_Max 
        ELSE state.u1help ;
    state.uhelp2_2 = IF(state.u2help < interface.u2_Min) THEN (interface.u2_Min)
      ELSE IF (state.u2help > interface.u2_Max) THEN interface.u2_Max 
        ELSE state.u2help ;
    state.uhelp2_3 = IF(state.u3help < interface.u3_Min) THEN (interface.u3_Min)
      ELSE IF (state.u3help > interface.u3_Max) THEN interface.u3_Max 
        ELSE state.u3help ;
    state.uhelp2_4 = IF(state.u4help < interface.u4_Min) THEN (interface.u4_Min)
      ELSE IF (state.u4help > interface.u4_Max) THEN interface.u4_Max 
        ELSE state.u4help ;
    state.uhelp2_5 = IF(state.u5help < interface.u5_Min) THEN (interface.u5_Min)
      ELSE IF (state.u5help > interface.u5_Max) THEN interface.u5_Max 
        ELSE state.u5help ;

    interface.u1 = state.uhelp2_1;
    interface.u2 = state.uhelp2_2;
    interface.u3 = state.uhelp2_3;
    interface.u4 = state.uhelp2_4;
    interface.u5 = state.uhelp2_5;
  };

:}; 

 

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.controllers.msl" 2




# 43 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 1
 



















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer21.msl" 1
 














 



 
CLASS Timer21 (* icon = "timer" *) "Timer with 2 periods and 1 output"
SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
    OBJ u1 (* terminal = "out_1" *) "Controlled variable" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
  };
  
  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };
  
  state <-
  {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
  };
  
  equations <-
  {
    state.T = interface.T1 + interface.T2 ;
    
    state.Prev_t = IF (independent.t - previous(state.Prev_t) < (state.T)) THEN previous(state.Prev_t)
      ELSE previous(state.Prev_t) + state.T ;
    
    interface.u1 = IF (independent.t - state.Prev_t < interface.T1) THEN interface.u11
      ELSE interface.u12 ;  
  };

:};

  

# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer22.msl" 1
 


















CLASS Timer22
  (* icon = "timer" *)
  "Timer with 2 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE  interface.u12;

    interface.u2 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE  interface.u22;
    };
  :};

  

# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer31.msl" 1
 


















CLASS Timer31
  (* icon = "timer" *)
  "Timer with 3 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};     
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
       THEN interface.u11
       ELSE
         IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
         THEN interface.u12
         ELSE interface.u13;
    };
  :};

  


# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer32.msl" 1
 


















CLASS Timer32
  (* icon = "timer" *)
  "Timer with 3 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u12
          ELSE  interface.u13;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u22
          ELSE  interface.u23;

    };
  :};

  


# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer41.msl" 1
 


















CLASS Timer41
  (* icon = "timer" *)
  "Timer with 4 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};      
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;
    };
  :};

  


# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer42.msl" 1
 


















CLASS Timer42
  (* icon = "timer" *)
  "Timer with 4 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE  interface.u24;
    };
  :};

  


# 26 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer51.msl" 1
 


















CLASS Timer51
  (* icon = "timer" *)
  "Timer with 5 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;
    };
  :};

  


# 27 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer52.msl" 1
 


















CLASS Timer52
  (* icon = "timer" *)
  "Timer with 5 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u24
              ELSE  interface.u25;

    };
  :};

  


# 28 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer61.msl" 1
 


















CLASS Timer61
  (* icon = "timer" *)
  "Timer with 6 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;
    };
  :};

  


# 29 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer62.msl" 1
 


















CLASS Timer62
  (* icon = "timer" *)
  "Timer with 6 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE  interface.u26;

    };
  :};

  


# 30 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer71.msl" 1
 


















CLASS Timer71
  (* icon = "timer" *)
  "Timer with 7 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;
    };
  :};

  


# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer72.msl" 1
 


















CLASS Timer72
  (* icon = "timer" *)
  "Timer with 7 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE  interface.u27;

    };
  :};

  

# 32 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer81.msl" 1
 














 



CLASS Timer81
  (* icon = "timer" *)
  "Timer with 8 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eight period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eight period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;
    };
  :};

  

# 33 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.base.timers.timer82.msl" 1
 


















CLASS Timer82
  (* icon = "timer" *)
  "Timer with 8 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u28 (* terminal = "in_2"; manip = "1" *) "Output 2 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eigth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u27
                       ELSE  interface.u28;

    };
  :};

  

# 34 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.timers.timer44.msl" 1
 







CLASS Timer44 (* icon = "timer" *)
"Timer with 4 periods and 4 outputs"
SPECIALISES PhysicalDAEModelType :=
{:
  interface <-
  {
    OBJ u1 (* terminal = "out_1" *) "Signal no.1" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u2 (* terminal = "out_1" *) "Signal no.2" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u3 (* terminal = "out_1" *) "Signal no.3" : Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u4 (* terminal = "out_1" *) "Signal no.4" : Real := {: causality <- "COUT" ; group <- "Control action" :};
     
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Signal no.1 / Period 1" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Signal no.1 / Period 2" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Signal no.1 / Period 3" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Signal no.1 / Period 4" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Signal no.2 / Period 1" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Signal no.2 / Period 2" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Signal no.2 / Period 3" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Signal no.2 / Period 4" : Real := {: causality <- "CIN" ; value <- 0.001 ; group <- "Operational" :};         
    OBJ u31 (* terminal = "in_2"; manip = "1" *) "Signal no.3 / Period 1" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :}; 
    OBJ u32 (* terminal = "in_2"; manip = "1" *) "Signal no.3 / Period 2" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
    OBJ u33 (* terminal = "in_2"; manip = "1" *) "Signal no.3 / Period 3" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};   
    OBJ u34 (* terminal = "in_2"; manip = "1" *) "Signal no.3 / Period 4" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};         
    OBJ u41 (* terminal = "in_2"; manip = "1" *) "Signal no.4 / Period 1" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :}; 
    OBJ u42 (* terminal = "in_2"; manip = "1" *) "Signal no.4 / Period 2" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
    OBJ u43 (* terminal = "in_2"; manip = "1" *) "Signal no.4 / Period 3" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};   
    OBJ u44 (* terminal = "in_2"; manip = "1" *) "Signal no.4 / Period 4" : Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};         
     
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "Period 1" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period 2" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period 3" : Time := {:causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Period 4" : Time := {:causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
  };

  equations <-
  {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;
    
    state.Prev_t = IF (independent.t - previous(state.Prev_t) < (state.T))
      THEN previous(state.Prev_t)
      ELSE previous(state.Prev_t) + state.T;
    
    interface.u1 = IF (independent.t - state.Prev_t < interface.T1) THEN interface.u11
      ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2)) THEN interface.u12
        ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3)) THEN interface.u13
        ELSE interface.u14 ;
    
    interface.u2 = IF (independent.t - state.Prev_t < interface.T1) THEN interface.u21
      ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2)) THEN interface.u22
        ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3)) THEN interface.u23
          ELSE interface.u24;

    interface.u3 = IF (independent.t - state.Prev_t < interface.T1) THEN interface.u31
      ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2)) THEN interface.u32
        ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3)) THEN interface.u33
          ELSE interface.u34;

    interface.u4 = IF (independent.t - state.Prev_t < interface.T1) THEN interface.u41
      ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2)) THEN interface.u42
        ELSE IF (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3)) THEN interface.u43
          ELSE interface.u44;
  };

:};

  

# 37 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/timer/wwtp.timers.timer21.RT2.msl" 1
 














 




CLASS Timer21_RT2 (* icon = "timer" *) "Timer with 2 phases and 1 2nd-order response-time output"
EXTENDS Base_RT21 WITH
{:
  
  comments <- "Timer with 2 phases and (one) 2nd-order response-time output" ;

  interface <-
  {
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
  };

  state <-
  {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
  };

  equations <-
  {
    state.T = interface.T1 + interface.T2 ;
    
    state.Prev_t = IF (independent.t - previous(state.Prev_t) < (state.T))
      THEN previous(state.Prev_t) ELSE previous(state.Prev_t) + state.T ;

    state.Help_u1 = IF (independent.t - state.Prev_t < interface.T1)
      THEN interface.u11 ELSE interface.u12 ;
  };

:};



# 40 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.timers.msl" 2




# 44 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.loopbreaker.msl" 1
 


















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/loopbreaker/wwtp.base.loopbreaker.differentialloopbreaker.msl" 1
 


















CLASS DifferentialLoopBreaker
(* icon = "loop_breaker" ; is_default = "true"; is_loopbreaker = "true" *)
"An Explicit Implicit Algebraic Loop Breaker using differential equations "

SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for a loopbreaker without differential equations";
  interface <-
  {
   OBJ Inflow (* terminal = "in_1" *) "inflow" :
        InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "outflow" :
        OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
   OBJ Tau "Implicit loop breaker time constant, d" : Time := {: value <- 0.0005 ; group <- "Miscellaneous" :};
  };

  independent <- 
  { 
   OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
   OBJ FluxPerComponent (* hidden = "1" *) : MassFluxVector;
  };

  equations <-
  {

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.FluxPerComponent[Comp_Index],[independent.t]) =
       - (1 / parameters.Tau) *
       (state.FluxPerComponent[Comp_Index] - interface.Inflow[Comp_Index]);
   };

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.FluxPerComponent[Comp_Index];
   };

  };

:};




# 20 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.loopbreaker.msl" 2





# 45 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.process_calculator.msl" 1
 



















 
 
 
 
CLASS OperationalParameters (* icon = "process_calculator" ; is_default = "true" *) "Calculation of the basic operational parameters of the plant: eg SRT, HRT"
EXTENDS BaseParameters WITH
{:

  comments <- "A model for the calculation of basic operational parameters";

  interface <-
  {
     
    OBJ TSS_out (* terminal = "in_1" *) "Sludge concentration in the effluent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
     
    OBJ Q_In (* terminal = "in_1" *) "Influent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational":};
    OBJ Q_Out (* terminal = "in_1" *) "Effluent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational" :};
     
    OBJ BOD_In (* terminal = "in_1" *) "BOD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ COD_In (* terminal = "in_1" *) "COD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
     
    OBJ y_SRT (* terminal = "out_1" *) "Instantenous Sludge retention time" : Time := {: causality <- "COUT" ; group <- "Output" :};
    OBJ y_HRT (* terminal = "out_1" *) "Hydraulic retention time" : Time := {: causality <- "COUT" ; group <- "Output" :};
  };
  
  state <-
  {
    OBJ SRT "Instantenous Sludge retention time" : Time := {: group <- "Operational" :};
    OBJ HRT "Hydraulic retention time" : Time := {: group <- "Operational" :};
    OBJ F_M_BOD "Food to microorganism ratio on BOD basis" : Rate := {: group <- "Operational" :};
    OBJ F_M_COD "Food to microorganism ratio on COD basis" : Rate := {: group <- "Operational" :};
  };
  
  equations <-
  {
     
    state.SRT =  IF ((interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste) <= 0)
    THEN 0
    ELSE state.m_TSS / (interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste);
     
    state.HRT = IF (interface.Q_In == 0)
    THEN 0
    ELSE state.V / interface.Q_In;
    state.F_M_BOD = IF (interface.Q_In == 0)
    THEN 0
    ELSE interface.BOD_In / (state.m_TSS / interface.Q_In);
    state.F_M_COD = IF (interface.Q_In == 0)
    THEN 0
    ELSE interface.COD_In / (state.m_TSS / interface.Q_In);
     
    interface.y_SRT = state.SRT ;
    interface.y_HRT = state.HRT ;
  };

:};


CLASS BaseParameters "Base class for all process calculators, ie cost and process parameters"
SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
     
    OBJ V1 (* terminal = "in_1" *)"Volume of unit 1" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V2 (* terminal = "in_1" *)"Volume of unit 2" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V3 (* terminal = "in_1" *)"Volume of unit 3" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V4 (* terminal = "in_1" *)"Volume of unit 4" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V5 (* terminal = "in_1" *)"Volume of unit 5" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V6 (* terminal = "in_1" *)"Volume of unit 6" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V7 (* terminal = "in_1" *)"Volume of unit 7" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V8 (* terminal = "in_1" *)"Volume of unit 8" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V9 (* terminal = "in_1" *)"Volume of unit 9" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V10 (* terminal = "in_1" *)"Volume of unit 10" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
     
    OBJ TSS1 (* terminal = "in_1" *) "Tot.susp.solids (unit 1)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS2 (* terminal = "in_1" *) "Tot.susp.solids (unit 2)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS3 (* terminal = "in_1" *) "Tot.susp.solids (unit 3)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS4 (* terminal = "in_1" *) "Tot.susp.solids (unit 4)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS5 (* terminal = "in_1" *) "Tot.susp.solids (unit 5)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS6 (* terminal = "in_1" *) "Tot.susp.solids (unit 6)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS7 (* terminal = "in_1" *) "Tot.susp.solids (unit 7)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS8 (* terminal = "in_1" *) "Tot.susp.solids (unit 8)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS9 (* terminal = "in_1" *) "Tot.susp.solids (unit 9)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS10 (* terminal = "in_1" *) "Tot.susp.solids (unit 10)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
     
     
    OBJ Q_Waste (*terminal = "in_1" *) "Flow rate of waste sludge": FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
    OBJ TSS_waste (* terminal = "in_1" *) "Suspended solids in the waste sludge" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
  };
  
  independent <-
  {
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };
  
  state <-
  {
    OBJ m_TSS (* hidden = "1" *) "Amount of sludge accumulated in the system" : Mass :={:group <- "Measurement data":};
    OBJ V (* hidden = "1" *) "Total volume of the tanks" : Volume := {: group <- "Dimension" :};
  };
  
  equations <-
  {
    state.m_TSS = interface.V1 * interface.TSS1 + interface.V2 * interface.TSS2 + interface.V3 * interface.TSS3 +
      interface.V4 * interface.TSS4 + interface.V5 * interface.TSS5 + interface.V6 * interface.TSS6 +
      interface.V7 * interface.TSS7 + interface.V8 * interface.TSS8 + interface.V9 * interface.TSS9 + interface.V10 * interface.TSS10 ;
      
    state.V = interface.V1 + interface.V2 + interface.V3 + interface.V4 + interface.V5 + interface.V6 + interface.V7 +
      interface.V8 + interface.V9 + interface.V10 ;
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/process_calculator/wwtp.calculator.AS.SRT.msl" 1
 



















CLASS Calc_SRT_AS (* icon = "process_calculator" *)
"Computation of the sludge age (total; instantaneous and averaged) and of the anoxic-to-aerated ratio for an activated sludge system"
EXTENDS Calc_SRT_AS_Base WITH
{:

  comments <- "Computation of the sludge age (total; instantaneous and averaged) and of the anoxic-to-aerated ratio for an activated sludge system";
  
  interface <-
  {
     
    OBJ V_01 (* terminal = "in_1" *) "Volume of tank no.1" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_02 (* terminal = "in_1" *) "Volume of tank no.2" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_03 (* terminal = "in_1" *) "Volume of tank no.3" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_04 (* terminal = "in_1" *) "Volume of tank no.4" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_05 (* terminal = "in_1" *) "Volume of tank no.5" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_06 (* terminal = "in_1" *) "Volume of tank no.6" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_07 (* terminal = "in_1" *) "Volume of tank no.7" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_08 (* terminal = "in_1" *) "Volume of tank no.8" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_09 (* terminal = "in_1" *) "Volume of tank no.9" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_10 (* terminal = "in_1" *) "Volume of tank no.10" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_11 (* terminal = "in_1" *) "Volume of tank no.11" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_12 (* terminal = "in_1" *) "Volume of tank no.12" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_13 (* terminal = "in_1" *) "Volume of tank no.13" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_14 (* terminal = "in_1" *) "Volume of tank no.14" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_15 (* terminal = "in_1" *) "Volume of tank no.15" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_16 (* terminal = "in_1" *) "Volume of tank no.16" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_17 (* terminal = "in_1" *) "Volume of tank no.17" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_18 (* terminal = "in_1" *) "Volume of tank no.18" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_19 (* terminal = "in_1" *) "Volume of tank no.19" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_20 (* terminal = "in_1" *) "Volume of tank no.20" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_21 (* terminal = "in_1" *) "Volume of tank no.21" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_22 (* terminal = "in_1" *) "Volume of tank no.22" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_23 (* terminal = "in_1" *) "Volume of tank no.23" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_24 (* terminal = "in_1" *) "Volume of tank no.24" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_25 (* terminal = "in_1" *) "Volume of tank no.25" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_26 (* terminal = "in_1" *) "Volume of tank no.26" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_27 (* terminal = "in_1" *) "Volume of tank no.27" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_28 (* terminal = "in_1" *) "Volume of tank no.28" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_29 (* terminal = "in_1" *) "Volume of tank no.29" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
    OBJ V_30 (* terminal = "in_1" *) "Volume of tank no.30" : Volume := {:causality <- "CIN" ; group <- "Tank volumes" :};
     
    OBJ TSS_01 (* terminal = "in_1" *) "TSS in tank no.1" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_02 (* terminal = "in_1" *) "TSS in tank no.2" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_03 (* terminal = "in_1" *) "TSS in tank no.3" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_04 (* terminal = "in_1" *) "TSS in tank no.4" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_05 (* terminal = "in_1" *) "TSS in tank no.5" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_06 (* terminal = "in_1" *) "TSS in tank no.6" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_07 (* terminal = "in_1" *) "TSS in tank no.7" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_08 (* terminal = "in_1" *) "TSS in tank no.8" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_09 (* terminal = "in_1" *) "TSS in tank no.9" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_10 (* terminal = "in_1" *) "TSS in tank no.10" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_11 (* terminal = "in_1" *) "TSS in tank no.11" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_12 (* terminal = "in_1" *) "TSS in tank no.12" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_13 (* terminal = "in_1" *) "TSS in tank no.13" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_14 (* terminal = "in_1" *) "TSS in tank no.14" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_15 (* terminal = "in_1" *) "TSS in tank no.15" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_16 (* terminal = "in_1" *) "TSS in tank no.16" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_17 (* terminal = "in_1" *) "TSS in tank no.17" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_18 (* terminal = "in_1" *) "TSS in tank no.18" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_19 (* terminal = "in_1" *) "TSS in tank no.19" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_20 (* terminal = "in_1" *) "TSS in tank no.20" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_21 (* terminal = "in_1" *) "TSS in tank no.21" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_22 (* terminal = "in_1" *) "TSS in tank no.22" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_23 (* terminal = "in_1" *) "TSS in tank no.23" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_24 (* terminal = "in_1" *) "TSS in tank no.24" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_25 (* terminal = "in_1" *) "TSS in tank no.25" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_26 (* terminal = "in_1" *) "TSS in tank no.26" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_27 (* terminal = "in_1" *) "TSS in tank no.27" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_28 (* terminal = "in_1" *) "TSS in tank no.28" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_29 (* terminal = "in_1" *) "TSS in tank no.29" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
    OBJ TSS_30 (* terminal = "in_1" *) "TSS in tank no.30" : Concentration := {:causality <- "CIN" ; group <- "Solids concentrations" :};
  };
  
  equations <-
  {
     
    state.TSS_Tanks = interface.V_01 * interface.TSS_01 + interface.V_02 * interface.TSS_02 + interface.V_03 * interface.TSS_03 +
      interface.V_04 * interface.TSS_04 + interface.V_05 * interface.TSS_05 + interface.V_06 * interface.TSS_06 +
      interface.V_07 * interface.TSS_07 + interface.V_08 * interface.TSS_08 + interface.V_09 * interface.TSS_09 +
      interface.V_10 * interface.TSS_10 + interface.V_11 * interface.TSS_11 + interface.V_12 * interface.TSS_12 + 
      interface.V_13 * interface.TSS_13 + interface.V_14 * interface.TSS_14 + interface.V_15 * interface.TSS_15 + 
      interface.V_16 * interface.TSS_16 + interface.V_17 * interface.TSS_17 + interface.V_18 * interface.TSS_18 + 
      interface.V_19 * interface.TSS_19 + interface.V_20 * interface.TSS_20 + interface.V_21 * interface.TSS_21 +
      interface.V_22 * interface.TSS_22 + interface.V_23 * interface.TSS_23 + interface.V_24 * interface.TSS_24 +
      interface.V_25 * interface.TSS_25 + interface.V_26 * interface.TSS_26 + interface.V_27 * interface.TSS_27 +
      interface.V_28 * interface.TSS_28 + interface.V_29 * interface.TSS_29 + interface.V_30 * interface.TSS_30 ;
  };

:};


CLASS Calc_SRT_AS_Base "Base class for sludge age and anoxic / aerated ratios for an activated sludge system"
SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
     
    OBJ Q_Waste1 (* terminal = "in_1" *) "Flow rate of waste sludge no.1": FlowRate := {: causality <- "CIN" ; group <- "Waste sludge" :};
    OBJ TSS_Waste1 (* terminal = "in_1" *) "TSS in waste sludge no.1" : Concentration := {: causality <- "CIN" ; group <- "Waste sludge" :};
    OBJ Q_Waste2 (* terminal = "in_1" *) "Flow rate of waste sludge no.2": FlowRate := {: causality <- "CIN" ; group <- "Waste sludge" :};
    OBJ TSS_Waste2 (* terminal = "in_1" *) "TSS in waste sludge no.2" : Concentration := {: causality <- "CIN" ; group <- "Waste sludge" :};
     
    OBJ TSS_Out (* terminal = "in_1" *) "Sludge concentration in the effluent" : Concentration := {: causality <- "CIN"; group <- "Effluent" :};
    OBJ Q_Out (* terminal = "in_1" *) "Effluent flow rate": FlowRate:= {:causality <- "CIN"; group <- "Effluent" :};
     
    OBJ T_Window (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Moving window": Time := {: causality <- "CIN" ; value <- 1 ; group <- "Calculation" :};
     
    OBJ SRT_Tot (* terminal = "out_1" *) "Total sludge age" : Time := {: causality <- "COUT" ; group <- "Output" :};
  };
  
  independent <-
  {
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };
  
  state <-
  {
    OBJ TSS_Tanks (* hidden = "1" *) "Total amount of sludge accumulated in the tanks" : Mass := {: group <- "System" :};
    OBJ TSS_Flux (* hidden = "1" *) "Total flux of sludge leaving the system" : MassFlux := {: group <- "System" :};
    OBJ M_WAS "Sludge production" : MassFlux := {: group <- "Process" :};
    OBJ SRTi_Tot "Total SRT (instantaneous)" : Time := {: group <- "Process" :};
  	OBJ ID_Tot (* hidden = "1" *) "dummy variable for buffer ID" : Real ;
  	OBJ temp_Tot (* hidden = "1" *) "dummy variable for initialisation" : Real ;
  	OBJ SRT_Tot_Out (* hidden = "1" *) "dummy variable for signal that is retrieved from buffer": Time := {: group <- "Buffer" :};
  };
  
  initial <-
  {
  	state.ID_Tot = MSLUBufferCreate(interface.T_Window, 0.001);
  };
  
  equations <-
  {
     
    state.TSS_Flux = (interface.TSS_Out * interface.Q_Out) + (interface.TSS_Waste1 * interface.Q_Waste1 + interface.TSS_Waste2 * interface.Q_Waste2) ;
    state.M_WAS = interface.TSS_Waste1 * interface.Q_Waste1 + interface.TSS_Waste2 * interface.Q_Waste2 ;
     
    state.SRTi_Tot = IF (state.TSS_Flux <= 0.0) THEN 0.0 ELSE state.TSS_Tanks / state.TSS_Flux ;
     
    state.temp_Tot = MSLUBufferPut(state.ID_Tot, independent.t, state.SRTi_Tot);
    state.SRT_Tot_Out = MSLUBufferGetMean(state.ID_Tot);
     
    interface.SRT_Tot = state.SRT_Tot_Out ;   
  };

:};



# 136 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.process_calculator.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/process_calculator/wwtp.controllers.WAS_SRT.msl" 1
 



















CLASS WAS_SRT_PI (* icon = "process_calculator" *)  SPECIALISES CoupledModelType := 
{:

  comments <- "PI controller for the WAS flow rate based on sludge age";

  interface <-
  {
     
    OBJ V_01 (*terminal = "in_1"; *) "Volume of tank no.1" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_02 (*terminal = "in_1"; *) "Volume of tank no.2" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_03 (*terminal = "in_1"; *) "Volume of tank no.3" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_04 (*terminal = "in_1"; *) "Volume of tank no.4" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_05 (*terminal = "in_1"; *) "Volume of tank no.5" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_06 (*terminal = "in_1"; *) "Volume of tank no.6" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_07 (*terminal = "in_1"; *) "Volume of tank no.7" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_08 (*terminal = "in_1"; *) "Volume of tank no.8" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_09 (*terminal = "in_1"; *) "Volume of tank no.9" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_10 (*terminal = "in_1"; *) "Volume of tank no.10" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_11 (*terminal = "in_1"; *) "Volume of tank no.11" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_12 (*terminal = "in_1"; *) "Volume of tank no.12" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_13 (*terminal = "in_1"; *) "Volume of tank no.13" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_14 (*terminal = "in_1"; *) "Volume of tank no.14" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_15 (*terminal = "in_1"; *) "Volume of tank no.15" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_16 (*terminal = "in_1"; *) "Volume of tank no.16" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_17 (*terminal = "in_1"; *) "Volume of tank no.17" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_18 (*terminal = "in_1"; *) "Volume of tank no.18" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_19 (*terminal = "in_1"; *) "Volume of tank no.19" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_20 (*terminal = "in_1"; *) "Volume of tank no.20" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_21 (*terminal = "in_1"; *) "Volume of tank no.21" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_22 (*terminal = "in_1"; *) "Volume of tank no.22" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_23 (*terminal = "in_1"; *) "Volume of tank no.23" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_24 (*terminal = "in_1"; *) "Volume of tank no.24" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_25 (*terminal = "in_1"; *) "Volume of tank no.25" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_26 (*terminal = "in_1"; *) "Volume of tank no.26" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_27 (*terminal = "in_1"; *) "Volume of tank no.27" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_28 (*terminal = "in_1"; *) "Volume of tank no.28" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_29 (*terminal = "in_1"; *) "Volume of tank no.29" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
    OBJ V_30 (*terminal = "in_1"; *) "Volume of tank no.30" : Volume := {: causality <- "CIN"; group <- "Tank volumes"; :};
     
    OBJ TSS_01 (*terminal = "in_1"; *) "TSS in tank no.1" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_02 (*terminal = "in_1"; *) "TSS in tank no.2" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_03 (*terminal = "in_1"; *) "TSS in tank no.3" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_04 (*terminal = "in_1"; *) "TSS in tank no.4" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_05 (*terminal = "in_1"; *) "TSS in tank no.5" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_06 (*terminal = "in_1"; *) "TSS in tank no.6" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_07 (*terminal = "in_1"; *) "TSS in tank no.7" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_08 (*terminal = "in_1"; *) "TSS in tank no.8" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_09 (*terminal = "in_1"; *) "TSS in tank no.9" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_10 (*terminal = "in_1"; *) "TSS in tank no.10" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_11 (*terminal = "in_1"; *) "TSS in tank no.11" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_12 (*terminal = "in_1"; *) "TSS in tank no.12" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_13 (*terminal = "in_1"; *) "TSS in tank no.13" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_14 (*terminal = "in_1"; *) "TSS in tank no.14" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_15 (*terminal = "in_1"; *) "TSS in tank no.15" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_16 (*terminal = "in_1"; *) "TSS in tank no.16" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_17 (*terminal = "in_1"; *) "TSS in tank no.17" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_18 (*terminal = "in_1"; *) "TSS in tank no.18" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_19 (*terminal = "in_1"; *) "TSS in tank no.19" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_20 (*terminal = "in_1"; *) "TSS in tank no.20" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_21 (*terminal = "in_1"; *) "TSS in tank no.21" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_22 (*terminal = "in_1"; *) "TSS in tank no.22" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_23 (*terminal = "in_1"; *) "TSS in tank no.23" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_24 (*terminal = "in_1"; *) "TSS in tank no.24" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_25 (*terminal = "in_1"; *) "TSS in tank no.25" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_26 (*terminal = "in_1"; *) "TSS in tank no.26" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_27 (*terminal = "in_1"; *) "TSS in tank no.27" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_28 (*terminal = "in_1"; *) "TSS in tank no.28" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_29 (*terminal = "in_1"; *) "TSS in tank no.29" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
    OBJ TSS_30 (*terminal = "in_1"; *) "TSS in tank no.30" : Concentration := {: causality <- "CIN"; group <- "Solids concentrations"; :};
     
     
    OBJ Q_Waste1 (*terminal = "in_1"; *) "Flow rate of waste sludge no.1" : FlowRate := {: causality <- "CIN"; group <- "Waste sludge"; :};
    OBJ Q_Waste2 (*terminal = "in_1"; *) "Flow rate of waste sludge no.2" : FlowRate := {: causality <- "CIN"; group <- "Waste sludge"; :};
    OBJ TSS_Waste1 (*terminal = "in_1"; *) "TSS in waste sludge no.1" : Concentration := {: causality <- "CIN"; group <- "Waste sludge"; :};
    OBJ TSS_Waste2 (*terminal = "in_1"; *) "TSS in waste sludge no.2" : Concentration := {: causality <- "CIN"; group <- "Waste sludge"; :};
     
    OBJ TSS_Out (*terminal = "in_1"; *) "Sludge concentration in the effluent" : Concentration := {: causality <- "CIN"; group <- "Effluent"; :};
    OBJ Q_Out (*terminal = "in_1"; *) "Effluent flow rate" : FlowRate := {: causality <- "CIN"; group <- "Effluent"; :};

    OBJ Q_WAS (*is_favorite = "1"; terminal = "out_1"; *) "WAS flow" : FlowRate := {: causality <- "COUT"; group <- "Action"; :};

    OBJ Mean_SRT (*manip = "1"; is_favorite = "1"; terminal = "in_2"; *) "Desired mean sludge age" : Time := {: causality <- "CIN"; value <- 7; group <- "Operation"; :};
    OBJ T_Window (*manip = "1"; terminal = "in_2"; *) "Moving window" : Time := {: causality <- "CIN"; value <- 7; group <- "Calculation"; :};
    OBJ K_P (*manip = "1"; terminal = "in_2"; *) "Proportionality factor for the PI controller" : Real := {: causality <- "CIN"; value <- - 1000.0; group <- "PI controller"; :};
    OBJ WAS_0 (*manip = "1"; terminal = "in_2"; *) "Reference (no-error) WAS flow rate" : FlowRate := {: causality <- "CIN"; value <- 300; group <- "PI controller"; :};
    OBJ WAS_Max (*manip = "1"; terminal = "in_2"; *) "Max WAS flow rate" : FlowRate := {: causality <- "CIN"; value <- 2000; group <- "PI controller"; :};
  };

  sub_models <-
  {
    OBJ ProcCalc "Process calculator" : Calc_SRT_AS ;
    OBJ Ctl_PI "PI Controller" : PI_Saturation_AntiWindup;
  };

  coupling <-
  {
     
    connect(interface.V_01, sub_models.ProcCalc.interface.V_01),
    connect(interface.V_02, sub_models.ProcCalc.interface.V_02),
    connect(interface.V_03, sub_models.ProcCalc.interface.V_03),
    connect(interface.V_04, sub_models.ProcCalc.interface.V_04),
    connect(interface.V_05, sub_models.ProcCalc.interface.V_05),
    connect(interface.V_06, sub_models.ProcCalc.interface.V_06),
    connect(interface.V_07, sub_models.ProcCalc.interface.V_07),
    connect(interface.V_08, sub_models.ProcCalc.interface.V_08),
    connect(interface.V_09, sub_models.ProcCalc.interface.V_09),
    connect(interface.V_10, sub_models.ProcCalc.interface.V_10),
    connect(interface.V_11, sub_models.ProcCalc.interface.V_11),
    connect(interface.V_12, sub_models.ProcCalc.interface.V_12),
    connect(interface.V_13, sub_models.ProcCalc.interface.V_13),
    connect(interface.V_14, sub_models.ProcCalc.interface.V_14),
    connect(interface.V_15, sub_models.ProcCalc.interface.V_15),
    connect(interface.V_16, sub_models.ProcCalc.interface.V_16),
    connect(interface.V_17, sub_models.ProcCalc.interface.V_17),
    connect(interface.V_18, sub_models.ProcCalc.interface.V_18),
    connect(interface.V_19, sub_models.ProcCalc.interface.V_19),
    connect(interface.V_20, sub_models.ProcCalc.interface.V_20),
    connect(interface.V_21, sub_models.ProcCalc.interface.V_21),
    connect(interface.V_22, sub_models.ProcCalc.interface.V_22),
    connect(interface.V_23, sub_models.ProcCalc.interface.V_23),
    connect(interface.V_24, sub_models.ProcCalc.interface.V_24),
    connect(interface.V_25, sub_models.ProcCalc.interface.V_25),
    connect(interface.V_26, sub_models.ProcCalc.interface.V_26),
    connect(interface.V_27, sub_models.ProcCalc.interface.V_27),
    connect(interface.V_28, sub_models.ProcCalc.interface.V_28),
    connect(interface.V_29, sub_models.ProcCalc.interface.V_29),
    connect(interface.V_30, sub_models.ProcCalc.interface.V_30),
     
    connect(interface.TSS_01, sub_models.ProcCalc.interface.TSS_01),
    connect(interface.TSS_02, sub_models.ProcCalc.interface.TSS_02),
    connect(interface.TSS_03, sub_models.ProcCalc.interface.TSS_03),
    connect(interface.TSS_04, sub_models.ProcCalc.interface.TSS_04),
    connect(interface.TSS_05, sub_models.ProcCalc.interface.TSS_05),
    connect(interface.TSS_06, sub_models.ProcCalc.interface.TSS_06),
    connect(interface.TSS_07, sub_models.ProcCalc.interface.TSS_07),
    connect(interface.TSS_08, sub_models.ProcCalc.interface.TSS_08),
    connect(interface.TSS_09, sub_models.ProcCalc.interface.TSS_09),
    connect(interface.TSS_10, sub_models.ProcCalc.interface.TSS_10),
    connect(interface.TSS_11, sub_models.ProcCalc.interface.TSS_11),
    connect(interface.TSS_12, sub_models.ProcCalc.interface.TSS_12),
    connect(interface.TSS_13, sub_models.ProcCalc.interface.TSS_13),
    connect(interface.TSS_14, sub_models.ProcCalc.interface.TSS_14),
    connect(interface.TSS_15, sub_models.ProcCalc.interface.TSS_15),
    connect(interface.TSS_16, sub_models.ProcCalc.interface.TSS_16),
    connect(interface.TSS_17, sub_models.ProcCalc.interface.TSS_17),
    connect(interface.TSS_18, sub_models.ProcCalc.interface.TSS_18),
    connect(interface.TSS_19, sub_models.ProcCalc.interface.TSS_19),
    connect(interface.TSS_20, sub_models.ProcCalc.interface.TSS_20),
    connect(interface.TSS_21, sub_models.ProcCalc.interface.TSS_21),
    connect(interface.TSS_22, sub_models.ProcCalc.interface.TSS_22),
    connect(interface.TSS_23, sub_models.ProcCalc.interface.TSS_23),
    connect(interface.TSS_24, sub_models.ProcCalc.interface.TSS_24),
    connect(interface.TSS_25, sub_models.ProcCalc.interface.TSS_25),
    connect(interface.TSS_26, sub_models.ProcCalc.interface.TSS_26),
    connect(interface.TSS_27, sub_models.ProcCalc.interface.TSS_27),
    connect(interface.TSS_28, sub_models.ProcCalc.interface.TSS_28),
    connect(interface.TSS_29, sub_models.ProcCalc.interface.TSS_29),
    connect(interface.TSS_30, sub_models.ProcCalc.interface.TSS_30),
     
    connect(interface.Q_Out, sub_models.ProcCalc.interface.Q_Out),
    connect(interface.TSS_Out, sub_models.ProcCalc.interface.TSS_Out),
     
    connect(interface.Q_Waste1, sub_models.ProcCalc.interface.Q_Waste1),
    connect(interface.Q_Waste2, sub_models.ProcCalc.interface.Q_Waste2),
    connect(interface.TSS_Waste1, sub_models.ProcCalc.interface.TSS_Waste1),
    connect(interface.TSS_Waste2, sub_models.ProcCalc.interface.TSS_Waste2),

    connect(sub_models.ProcCalc.interface.SRT_Tot, sub_models.Ctl_PI.interface.y_M),

     
    connect(sub_models.Ctl_PI.interface.u, interface.Q_WAS),

     
    connect(interface.Mean_SRT, sub_models.Ctl_PI.interface.y_S),
    connect(interface.T_Window, sub_models.ProcCalc.interface.T_Window),
    connect(interface.K_P, sub_models.Ctl_PI.interface.K_P),
    connect(interface.WAS_0, sub_models.Ctl_PI.interface.u0),
    connect(interface.WAS_Max, sub_models.Ctl_PI.interface.u_Max),
  };

:};



# 137 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.process_calculator.msl" 2




# 46 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.evaluator.msl" 1
 


















 

CLASS OperationalCost_Base "Base class for cost calculation"
SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
     
    OBJ AerationPower1 (* terminal = "in_1" *) "Aeration power for unit 1" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower2 (* terminal = "in_1" *) "Aeration power for unit 2" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower3 (* terminal = "in_1" *) "Aeration power for unit 3" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower4 (* terminal = "in_1" *) "Aeration power for unit 4" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower5 (* terminal = "in_1" *) "Aeration power for unit 5" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower6 (* terminal = "in_1" *) "Aeration power for unit 6" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower7 (* terminal = "in_1" *) "Aeration power for unit 7" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower8 (* terminal = "in_1" *) "Aeration power for unit 8" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower9 (* terminal = "in_1" *) "Aeration power for unit 9" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
    OBJ AerationPower10 (* terminal = "in_1" *) "Aeration power for unit 10" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Aeration" :};
     
     
    OBJ PumpingPower1 (* terminal = "in_1" *) "Pumping power for unit 1" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower2 (* terminal = "in_1" *) "Pumping power for unit 2" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower3 (* terminal = "in_1" *) "Pumping power for unit 3" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower4 (* terminal = "in_1" *) "Pumping power for unit 4" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower5 (* terminal = "in_1" *) "Pumping power for unit 5" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower6 (* terminal = "in_1" *) "Pumping power for unit 6" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower7 (* terminal = "in_1" *) "Pumping power for unit 7" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower8 (* terminal = "in_1" *) "Pumping power for unit 8" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower9 (* terminal = "in_1" *) "Pumping power for unit 9" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower10 (* terminal = "in_1" *) "Pumping power for unit 10" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower11 (* terminal = "in_1" *) "Pumping power for unit 11" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower12 (* terminal = "in_1" *) "Pumping power for unit 12" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower13 (* terminal = "in_1" *) "Pumping power for unit 13" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower14 (* terminal = "in_1" *) "Pumping power for unit 14" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower15 (* terminal = "in_1" *) "Pumping power for unit 15" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower16 (* terminal = "in_1" *) "Pumping power for unit 16" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower17 (* terminal = "in_1" *) "Pumping power for unit 17" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower18 (* terminal = "in_1" *) "Pumping power for unit 18" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower19 (* terminal = "in_1" *) "Pumping power for unit 19" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
    OBJ PumpingPower20 (* terminal = "in_1" *) "Pumping power for unit 20" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Pumping" :};
     
     
    OBJ MixingPower1 (* terminal = "in_1" *) "Mixing power for unit 1" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower2 (* terminal = "in_1" *) "Mixing power for unit 2" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower3 (* terminal = "in_1" *) "Mixing power for unit 3" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower4 (* terminal = "in_1" *) "Mixing power for unit 4" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower5 (* terminal = "in_1" *) "Mixing power for unit 5" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower6 (* terminal = "in_1" *) "Mixing power for unit 6" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower7 (* terminal = "in_1" *) "Mixing power for unit 7" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower8 (* terminal = "in_1" *) "Mixing power for unit 8" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower9 (* terminal = "in_1" *) "Mixing power for unit 9" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower10 (* terminal = "in_1" *) "Mixing power for unit 10" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower11 (* terminal = "in_1" *) "Mixing power for unit 11" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower12 (* terminal = "in_1" *) "Mixing power for unit 12" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower13 (* terminal = "in_1" *) "Mixing power for unit 13" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower14 (* terminal = "in_1" *) "Mixing power for unit 14" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower15 (* terminal = "in_1" *) "Mixing power for unit 15" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower16 (* terminal = "in_1" *) "Mixing power for unit 16" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower17 (* terminal = "in_1" *) "Mixing power for unit 17" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower18 (* terminal = "in_1" *) "Mixing power for unit 18" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower19 (* terminal = "in_1" *) "Mixing power for unit 19" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
    OBJ MixingPower20 (* terminal = "in_1" *) "Mixing power for unit 20" : Real := {: causality <- "CIN" ; unit <- "kWh/d" ; group <- "Mixing" :};
     
     
    OBJ TSS1 (* terminal = "in_1" *) "TSS1" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 1" :};
    OBJ TSS2 (* terminal = "in_1" *) "TSS2" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 2" :};
    OBJ Q_Pump_Waste1 (* terminal = "in_1" *) "Q_Pump sludge wastage 1" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ Q_Pump_Waste2 (* terminal = "in_1" *) "Q_Pump sludge wastage 2" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
     
     
    OBJ Q1_COD (* terminal = "in_1" *) "External COD dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q1_MeOH (* terminal = "in_1" *) "Metal dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_COD (* terminal = "in_1" *) "External COD dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_MeOH (* terminal = "in_1" *) "Metal dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_COD (* terminal = "in_1" *) "External COD dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_MeOH (* terminal = "in_1" *) "Metal dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
     
     
    OBJ F_Energy (* terminal = "in_2"; manip = "1" *) "Cost per unit energy (Euro/kWh)" : Ratio := {: causality <- "CIN" ; value <- 0.07 ; group <- "Cost" :};   
  };
  
  parameters <-
  {
    OBJ F_SC "Sludge cost factor (Euro/kg)" : Ratio := {: value <- 0.58 ; group <- "Cost" :};
    OBJ C1_COD "COD cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C1_MeOH "Metal hydroxide cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_COD "COD cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_MeOH "Metal hydroxide cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_COD "COD cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_MeOH "Metal hydroxide cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
  };
    
  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
     
    OBJ TotalAerationPower "Aeration power" : Real := {: group <- "Energy" ; unit <- "kWh/d" :};
     
    OBJ TotalPumpingPower "Pumping power" : Real := {: group <- "Energy" ; unit <- "kWh/d" :};
     
    OBJ TotalMixingPower "Mixing power" : Real := {: group <- "Energy" ; unit <- "kWh/d" :};
     
     
    OBJ SludgeProduction "Sludge production" : Mass := {: group <- "Sludge" :};
    OBJ Integ_SP (* hidden = "1" *)"Integral sludge production" : Mass ;
     
    OBJ CODdosed "External COD dosed" : Volume := {: group <- "Chemicals" :};
    OBJ MeOHdosed "Metal hydroxide dosed" : Volume := {: group <- "Chemicals" :};
    OBJ Integ_COD (* hidden = "1" *) "Integral ext.COD addition" : Volume ;
    OBJ Integ_MeOH (* hidden = "1" *) "Integral MeOH addition" : Volume ;
    OBJ Integ_ChemicalCost (* hidden = "1" *) "Integral cost of chemicals" : Euro ;
     
    OBJ F_AC (* hidden = "1" *) "Aeration cost factor (Euro/kWh)" : Ratio := {: group <- "Cost" :};   
    OBJ F_PC (* hidden = "1" *) "Pumping cost factor (Euro/kWh)" : Ratio := {: group <- "Cost" :};   
    OBJ F_MC (* hidden = "1" *) "Mixing cost factor (Euro/kWh)" : Ratio := {: group <- "Cost" :};   
    
    OBJ AerationCost "Aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PumpingCost "Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MixingCost "Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SludgeCost "Sludge cost" : Euro := {: group <- "Cost" :};
    OBJ ChemicalCost "Cost of chemicals" : Euro := {: group <- "Chemicals" :};
    OBJ TotalCost "Total cost" : Euro := {: group <- "Cost" :};
    OBJ Prev_t (* hidden = "1" *) "Help variable for time" : Time ;
    OBJ Prev_TotalAerationEnergy (* hidden = "1" *) "Help variable to calculate the Periodical aeration cost" : ElectricalEnergy ;
    OBJ Prev_TotalPumpingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical pumping cost" : ElectricalEnergy ;
    OBJ Prev_TotalMixingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical mixing cost" : ElectricalEnergy ;
    OBJ Prev_Integ_SP (* hidden = "1" *) "Help variable to calculate the Periodical sludge cost" : Mass ;
    OBJ Prev_Integ_ChemicalCost (* hidden = "1" *) "Help variable to calculate the Periodical chemical cost (carbon addition)" : Euro ;
    OBJ AC_Period "Periodical aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PC_Period "Periodical Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MC_Period "Periodical Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SC_Period "Periodical sludge cost" : Euro := {: group <- "Cost" :};
    OBJ CC_Period "Periodical cost of COD addition" : Euro := {: group <- "Cost" :};
    OBJ TC_Period "Periodical total cost" : Euro := {: group <- "Cost" :};
  };
  
  initial <-
  {
    state.Integ_SP = 0.0 ;
    state.Integ_COD = 0.0 ;
    state.Integ_MeOH = 0.0 ;
    state.Integ_ChemicalCost = 0.0 ;
    state.AerationCost = 0.0 ;
    state.PumpingCost = 0.0 ;
    state.MixingCost = 0.0 ;
  };

  equations <-
  {
    state.F_AC = interface.F_Energy ;
    state.F_PC = interface.F_Energy ;
    state.F_MC = interface.F_Energy ;
     
    state.TotalAerationPower = interface.AerationPower1 + interface.AerationPower2 + interface.AerationPower3 +
      interface.AerationPower4 + interface.AerationPower5+ interface.AerationPower6 + interface.AerationPower7 +
      interface.AerationPower8 + interface.AerationPower9 + interface.AerationPower10 ;
     
     
     
     
    state.TotalPumpingPower = interface.PumpingPower1 + interface.PumpingPower2 + interface.PumpingPower3 +
      interface.PumpingPower4 + interface.PumpingPower5 + interface.PumpingPower6 + interface.PumpingPower7 +
      interface.PumpingPower8 + interface.PumpingPower9 + interface.PumpingPower10 + interface.PumpingPower11 +
      interface.PumpingPower12 + interface.PumpingPower13 + interface.PumpingPower14 + interface.PumpingPower15 +
      interface.PumpingPower16 + interface.PumpingPower17 + interface.PumpingPower18 + interface.PumpingPower19 +
      interface.PumpingPower20 ;
     
     
    state.TotalMixingPower = interface.MixingPower1 + interface.MixingPower2 + interface.MixingPower3 +
      interface.MixingPower4 + interface.MixingPower5 + interface.MixingPower6 + interface.MixingPower7 +
      interface.MixingPower8 + interface.MixingPower9 + interface.MixingPower10 + interface.MixingPower11 +
      interface.MixingPower12 + interface.MixingPower13 + interface.MixingPower14 + interface.MixingPower15 +
      interface.MixingPower16 + interface.MixingPower17 + interface.MixingPower18 + interface.MixingPower19 +
      interface.MixingPower20 ;
     
     
    DERIV(state.Integ_SP,[independent.t])= interface.TSS1 * interface.Q_Pump_Waste1 + interface.TSS2 * interface.Q_Pump_Waste2;
    state.SludgeProduction = state.Integ_SP ;
     
     
    DERIV(state.Integ_COD,[independent.t]) = interface.Q1_COD + interface.Q2_COD + interface.Q3_COD;
    DERIV(state.Integ_MeOH,[independent.t]) = interface.Q1_MeOH + interface.Q2_MeOH + interface.Q3_MeOH;
    state.CODdosed = state.Integ_COD;
    state.MeOHdosed = state.Integ_MeOH;
     
     
     
     
    DERIV(state.AerationCost,[independent.t]) = state.TotalAerationPower * state.F_AC ;
    
     
     
    DERIV(state.PumpingCost,[independent.t]) = state.TotalPumpingPower * state.F_PC;
    
    state.SludgeCost = state.SludgeProduction * parameters.F_SC / 1000.0;
    
     
     
    DERIV(state.MixingCost,[independent.t]) = state.TotalMixingPower * state.F_MC;
    DERIV(state.Integ_ChemicalCost,[independent.t]) =
    interface.Q1_COD * parameters.C1_COD + interface.Q2_COD  * parameters.C2_COD
    + interface.Q3_COD * parameters.C3_COD + interface.Q1_MeOH * parameters.C1_MeOH
    + interface.Q2_MeOH * parameters.C2_MeOH + interface.Q3_MeOH * parameters.C3_MeOH ;
    state.ChemicalCost = state.Integ_ChemicalCost;
    state.TotalCost = state.AerationCost + state.PumpingCost + state.SludgeCost + state.MixingCost + state.ChemicalCost ;
     
    state.Prev_t =  IF (independent.t < previous(state.Prev_t))
    THEN 0
    ELSE
    IF  (independent.t - previous(state.Prev_t) < parameters.Period)
    THEN  previous(state.Prev_t)
    ELSE  independent.t;

    state.Prev_Integ_SP = IF (independent.t < previous(state.Prev_t))
    THEN 0
    ELSE
    IF (independent.t - previous(state.Prev_t) < parameters.Period)
    THEN previous(state.Prev_Integ_SP)
    ELSE state.Integ_SP;
    state.Prev_Integ_ChemicalCost = IF (independent.t < previous(state.Prev_t))
    THEN 0
    ELSE
    IF (independent.t - previous(state.Prev_t) < parameters.Period)
    THEN previous(state.Prev_Integ_ChemicalCost)
    ELSE state.Integ_ChemicalCost;
     
    state.SC_Period = parameters.F_SC * (state.Integ_SP - state.Prev_Integ_SP) / 1000.0 ;
    state.CC_Period = state.Integ_ChemicalCost - state.Prev_Integ_ChemicalCost;
    state.TC_Period = state.AC_Period + state.PC_Period + state.SC_Period + state.CC_Period + state.MC_Period;
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/costs/wwtp.base.costs.operation.msl" 1
 


















 
 
 
 
 
 
 
 
 
 
 

 
 
 
CLASS OperationalCost  
"Calculation of the operational cost of the plant"
EXTENDS OperationalCost_Base WITH
{:

  interface <-
  {
     
    OBJ AerationEnergy1 (* terminal = "in_1" *) "AerationEnergy unit 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy2 (* terminal = "in_1" *) "AerationEnergy unit 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy3 (* terminal = "in_1" *) "AerationEnergy unit 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy4 (* terminal = "in_1" *) "AerationEnergy unit 4" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy5 (* terminal = "in_1" *) "AerationEnergy unit 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy6 (* terminal = "in_1" *) "AerationEnergy unit 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy7 (* terminal = "in_1" *) "AerationEnergy unit 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy8 (* terminal = "in_1" *) "AerationEnergy unit 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy9 (* terminal = "in_1" *) "AerationEnergy unit 9" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy10 (* terminal = "in_1" *) "AerationEnergy unit 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
     
     
    OBJ PumpingEnergy1 (* terminal = "in_1" *) "PumpingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy2 (* terminal = "in_1" *) "PumpingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy3 (* terminal = "in_1" *) "PumpingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy4 (* terminal = "in_1" *) "PumpingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy5 (* terminal = "in_1" *) "PumpingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy6 (* terminal = "in_1" *) "PumpingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy7 (* terminal = "in_1" *) "PumpingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy8 (* terminal = "in_1" *) "PumpingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy9 (* terminal = "in_1" *) "PumpingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy10 (* terminal = "in_1" *) "PumpingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy11 (* terminal = "in_1" *) "PumpingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy12 (* terminal = "in_1" *) "PumpingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy13 (* terminal = "in_1" *) "PumpingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy14 (* terminal = "in_1" *) "PumpingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy15 (* terminal = "in_1" *) "PumpingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy16 (* terminal = "in_1" *) "PumpingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy17 (* terminal = "in_1" *) "PumpingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy18 (* terminal = "in_1" *) "PumpingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy19 (* terminal = "in_1" *) "PumpingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy20 (* terminal = "in_1" *) "PumpingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
     
     
    OBJ MixingEnergy1 (* terminal = "in_1" *) "MixingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy2 (* terminal = "in_1" *) "MixingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy3 (* terminal = "in_1" *) "MixingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy4 (* terminal = "in_1" *) "MixingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy5 (* terminal = "in_1" *) "MixingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy6 (* terminal = "in_1" *) "MixingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy7 (* terminal = "in_1" *) "MixingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy8 (* terminal = "in_1" *) "MixingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy9 (* terminal = "in_1" *) "MixingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy10 (* terminal = "in_1" *) "MixingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy11 (* terminal = "in_1" *) "MixingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy12 (* terminal = "in_1" *) "MixingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy13 (* terminal = "in_1" *) "MixingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy14 (* terminal = "in_1" *) "MixingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy15 (* terminal = "in_1" *) "MixingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy16 (* terminal = "in_1" *) "MixingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy17 (* terminal = "in_1" *) "MixingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy18 (* terminal = "in_1" *) "MixingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy19 (* terminal = "in_1" *) "MixingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy20 (* terminal = "in_1" *) "MixingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
  };

  state <-
  {
     
    OBJ TotalAerationEnergy "Aeration energy" : ElectricalEnergy := {: group <- "Energy" :};
     
    OBJ TotalPumpingEnergy "Pumping energy" : ElectricalEnergy := {: group <- "Energy" :};
     
    OBJ TotalMixingEnergy "Mixing energy" : ElectricalEnergy := {: group <- "Energy" :};
  };

  equations <-
  {
     
    state.TotalAerationEnergy = interface.AerationEnergy1 + interface.AerationEnergy2 + interface.AerationEnergy3 +
      interface.AerationEnergy4 + interface.AerationEnergy5+ interface.AerationEnergy6 + interface.AerationEnergy7 +
      interface.AerationEnergy8 + interface.AerationEnergy9 + interface.AerationEnergy10 ;
     
     
     
     
    state.TotalPumpingEnergy = interface.PumpingEnergy1 + interface.PumpingEnergy2 + interface.PumpingEnergy3 +
      interface.PumpingEnergy4 + interface.PumpingEnergy5 + interface.PumpingEnergy6  + interface.PumpingEnergy7 +
      interface.PumpingEnergy8 + interface.PumpingEnergy9 + interface.PumpingEnergy10 + interface.PumpingEnergy11 +
      interface.PumpingEnergy12 + interface.PumpingEnergy13 + interface.PumpingEnergy14 + interface.PumpingEnergy15 +
      interface.PumpingEnergy16 + interface.PumpingEnergy17 + interface.PumpingEnergy18 + interface.PumpingEnergy19 +
      interface.PumpingEnergy20 ;
     
     
    state.TotalMixingEnergy = interface.MixingEnergy1 + interface.MixingEnergy2 + interface.MixingEnergy3 +
      interface.MixingEnergy4 + interface.MixingEnergy5 + interface.MixingEnergy6 + interface.MixingEnergy7 +
      interface.MixingEnergy8 + interface.MixingEnergy9 + interface.MixingEnergy10 + interface.MixingEnergy11 +
      interface.MixingEnergy12 + interface.MixingEnergy13 + interface.MixingEnergy14 + interface.MixingEnergy15 +
      interface.MixingEnergy16 + interface.MixingEnergy17 + interface.MixingEnergy18 + interface.MixingEnergy19 +
      interface.MixingEnergy20 ;

    state.Prev_TotalAerationEnergy = IF (independent.t < previous(state.Prev_t)) THEN 0.0
      ELSE IF (independent.t - previous(state.Prev_t) < parameters.Period) THEN previous(state.Prev_TotalAerationEnergy)
        ELSE state.TotalAerationEnergy ;

    state.Prev_TotalPumpingEnergy = IF (independent.t < previous(state.Prev_t)) THEN 0.0
      ELSE IF (independent.t - previous(state.Prev_t) < parameters.Period) THEN previous(state.Prev_TotalPumpingEnergy)
      ELSE state.TotalPumpingEnergy ;

    state.Prev_TotalMixingEnergy = IF (independent.t < previous(state.Prev_t)) THEN 0.0
      ELSE IF (independent.t - previous(state.Prev_t) < parameters.Period) THEN previous(state.Prev_TotalMixingEnergy)
        ELSE state.TotalMixingEnergy ;
     
    state.AC_Period = state.F_AC * (state.TotalAerationEnergy - state.Prev_TotalAerationEnergy);
    state.PC_Period = state.F_PC * (state.TotalPumpingEnergy - state.Prev_TotalPumpingEnergy);
    state.MC_Period = state.F_MC * (state.TotalMixingEnergy - state.Prev_TotalMixingEnergy);
  };

:};



# 260 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.evaluator.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/costs/wwtp.base.costs.operation2.msl" 1
 




















 
 
 
CLASS Cost_Operation (* icon = "cost" ; is_default = "true" *)
"Calculation of the operational cost of the plant"
EXTENDS OperationalCost_Base WITH
{:

  comments <- "Calculation of the operational cost of the plant";
  
  interface <-
  {
    OBJ TotEnergyAeration (* terminal = "out_1"; is_favorite = "1" *) "Aeration energy" : ElectricalEnergy := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ TotEnergyPumping (* terminal = "out_1"; is_favorite = "1" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ TotEnergyMixing (* terminal = "out_1"; is_favorite = "1" *) "Mixing energy" : ElectricalEnergy := {: causality <- "COUT" ; group <- "Energy" :};
  };

  state <-
  {
     
    OBJ Help_TotEnAerat (* hidden = "1" *) "Total aeration energy" : ElectricalEnergy := {: group <- "Energy" :};
    OBJ EnAerat01 "Aeration energy unit #1" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat02 "Aeration energy unit #2" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat03 "Aeration energy unit #3" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat04 "Aeration energy unit #4" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat05 "Aeration energy unit #5" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat06 "Aeration energy unit #6" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat07 "Aeration energy unit #7" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat08 "Aeration energy unit #8" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat09 "Aeration energy unit #9" : ElectricalEnergy := {: group <- "Aeration" :};
    OBJ EnAerat10 "Aeration energy unit #10" : ElectricalEnergy := {: group <- "Aeration" :};
     
    OBJ Help_TotEnPump (* hidden = "1" *) "Total pumping energy" : ElectricalEnergy := {: group <- "Energy" :};
    OBJ EnPump01 "Pumping energy unit #1" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump02 "Pumping energy unit #2" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump03 "Pumping energy unit #3" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump04 "Pumping energy unit #4" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump05 "Pumping energy unit #5" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump06 "Pumping energy unit #6" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump07 "Pumping energy unit #7" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump08 "Pumping energy unit #8" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump09 "Pumping energy unit #9" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump10 "Pumping energy unit #10" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump11 "Pumping energy unit #11" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump12 "Pumping energy unit #12" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump13 "Pumping energy unit #13" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump14 "Pumping energy unit #14" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump15 "Pumping energy unit #15" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump16 "Pumping energy unit #16" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump17 "Pumping energy unit #17" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump18 "Pumping energy unit #18" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump19 "Pumping energy unit #19" : ElectricalEnergy := {: group <- "Pumping" :};
    OBJ EnPump20 "Pumping energy unit #20" : ElectricalEnergy := {: group <- "Pumping" :};
     
    OBJ Help_TotEnMix (* hidden = "1" *) "Total mixing energy" : ElectricalEnergy := {: group <- "Energy" :};
    OBJ EnMix01 "Mixing energy unit #1" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix02 "Mixing energy unit #2" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix03 "Mixing energy unit #3" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix04 "Mixing energy unit #4" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix05 "Mixing energy unit #5" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix06 "Mixing energy unit #6" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix07 "Mixing energy unit #7" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix08 "Mixing energy unit #8" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix09 "Mixing energy unit #9" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix10 "Mixing energy unit #10" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix11 "Mixing energy unit #11" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix12 "Mixing energy unit #12" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix13 "Mixing energy unit #13" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix14 "Mixing energy unit #14" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix15 "Mixing energy unit #15" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix16 "Mixing energy unit #16" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix17 "Mixing energy unit #17" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix18 "Mixing energy unit #18" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix19 "Mixing energy unit #19" : ElectricalEnergy := {: group <- "Mixing" :};
    OBJ EnMix20 "Mixing energy unit #20" : ElectricalEnergy := {: group <- "Mixing" :};
  };
  
  initial <-
  {
     
    state.EnAerat01 = 0.0 ;    
    state.EnAerat02 = 0.0 ;    
    state.EnAerat03 = 0.0 ;    
    state.EnAerat04 = 0.0 ;    
    state.EnAerat05 = 0.0 ;    
    state.EnAerat06 = 0.0 ;    
    state.EnAerat07 = 0.0 ;    
    state.EnAerat08 = 0.0 ;    
    state.EnAerat09 = 0.0 ;    
    state.EnAerat10 = 0.0 ;
     
    state.EnPump01 = 0.0 ;    
    state.EnPump02 = 0.0 ;    
    state.EnPump03 = 0.0 ;    
    state.EnPump04 = 0.0 ;    
    state.EnPump05 = 0.0 ;    
    state.EnPump06 = 0.0 ;    
    state.EnPump07 = 0.0 ;    
    state.EnPump08 = 0.0 ;    
    state.EnPump09 = 0.0 ;    
    state.EnPump10 = 0.0 ;    
    state.EnPump11 = 0.0 ;    
    state.EnPump12 = 0.0 ;    
    state.EnPump13 = 0.0 ;    
    state.EnPump14 = 0.0 ;    
    state.EnPump15 = 0.0 ;    
    state.EnPump16 = 0.0 ;    
    state.EnPump17 = 0.0 ;    
    state.EnPump18 = 0.0 ;    
    state.EnPump19 = 0.0 ;    
    state.EnPump20 = 0.0 ;    
     
    state.EnMix01 = 0.0 ;    
    state.EnMix02 = 0.0 ;    
    state.EnMix03 = 0.0 ;    
    state.EnMix04 = 0.0 ;    
    state.EnMix05 = 0.0 ;    
    state.EnMix06 = 0.0 ;    
    state.EnMix07 = 0.0 ;    
    state.EnMix08 = 0.0 ;    
    state.EnMix09 = 0.0 ;    
    state.EnMix10 = 0.0 ;    
    state.EnMix11 = 0.0 ;    
    state.EnMix12 = 0.0 ;    
    state.EnMix13 = 0.0 ;    
    state.EnMix14 = 0.0 ;    
    state.EnMix15 = 0.0 ;    
    state.EnMix16 = 0.0 ;    
    state.EnMix17 = 0.0 ;    
    state.EnMix18 = 0.0 ;    
    state.EnMix19 = 0.0 ;    
    state.EnMix20 = 0.0 ;    
  };
  
  equations <-
  {
     
    DERIV(state.EnAerat01,[independent.t])= interface.AerationPower1 ;
    DERIV(state.EnAerat02,[independent.t])= interface.AerationPower2 ;
    DERIV(state.EnAerat03,[independent.t])= interface.AerationPower3 ;
    DERIV(state.EnAerat04,[independent.t])= interface.AerationPower4 ;
    DERIV(state.EnAerat05,[independent.t])= interface.AerationPower5 ;
    DERIV(state.EnAerat06,[independent.t])= interface.AerationPower6 ;
    DERIV(state.EnAerat07,[independent.t])= interface.AerationPower7 ;
    DERIV(state.EnAerat08,[independent.t])= interface.AerationPower8 ;
    DERIV(state.EnAerat09,[independent.t])= interface.AerationPower9 ;
    DERIV(state.EnAerat10,[independent.t])= interface.AerationPower10 ;

    state.Help_TotEnAerat = state.EnAerat01 + state.EnAerat02 + state.EnAerat03 + state.EnAerat04 +
      state.EnAerat05 + state.EnAerat06 + state.EnAerat07 + state.EnAerat08 + state.EnAerat09 + state.EnAerat10 ;

    interface.TotEnergyAeration = state.Help_TotEnAerat ;
     
     
    DERIV(state.EnPump01,[independent.t])= interface.PumpingPower1 ;
    DERIV(state.EnPump02,[independent.t])= interface.PumpingPower2 ;
    DERIV(state.EnPump03,[independent.t])= interface.PumpingPower3 ;
    DERIV(state.EnPump04,[independent.t])= interface.PumpingPower4 ;
    DERIV(state.EnPump05,[independent.t])= interface.PumpingPower5 ;
    DERIV(state.EnPump06,[independent.t])= interface.PumpingPower6 ;
    DERIV(state.EnPump07,[independent.t])= interface.PumpingPower7 ;
    DERIV(state.EnPump08,[independent.t])= interface.PumpingPower8 ;
    DERIV(state.EnPump09,[independent.t])= interface.PumpingPower9 ;
    DERIV(state.EnPump10,[independent.t])= interface.PumpingPower10 ;
    DERIV(state.EnPump11,[independent.t])= interface.PumpingPower11 ;
    DERIV(state.EnPump12,[independent.t])= interface.PumpingPower12 ;
    DERIV(state.EnPump13,[independent.t])= interface.PumpingPower13 ;
    DERIV(state.EnPump14,[independent.t])= interface.PumpingPower14 ;
    DERIV(state.EnPump15,[independent.t])= interface.PumpingPower15 ;
    DERIV(state.EnPump16,[independent.t])= interface.PumpingPower16 ;
    DERIV(state.EnPump17,[independent.t])= interface.PumpingPower17 ;
    DERIV(state.EnPump18,[independent.t])= interface.PumpingPower18 ;
    DERIV(state.EnPump19,[independent.t])= interface.PumpingPower19 ;
    DERIV(state.EnPump20,[independent.t])= interface.PumpingPower20 ;

    state.Help_TotEnPump = state.EnPump01 + state.EnPump02 + state.EnPump03 + state.EnPump04 + state.EnPump05 +
      state.EnPump06 + state.EnPump07 + state.EnPump08 + state.EnPump09 + state.EnPump10 +
      state.EnPump11 + state.EnPump12 + state.EnPump13 + state.EnPump14 + state.EnPump15 +
      state.EnPump16 + state.EnPump17 + state.EnPump18 + state.EnPump19 + state.EnPump20 ;

    interface.TotEnergyPumping = state.Help_TotEnPump ;
     
     
    DERIV(state.EnMix01,[independent.t])= interface.MixingPower1 ;
    DERIV(state.EnMix02,[independent.t])= interface.MixingPower2 ;
    DERIV(state.EnMix03,[independent.t])= interface.MixingPower3 ;
    DERIV(state.EnMix04,[independent.t])= interface.MixingPower4 ;
    DERIV(state.EnMix05,[independent.t])= interface.MixingPower5 ;
    DERIV(state.EnMix06,[independent.t])= interface.MixingPower6 ;
    DERIV(state.EnMix07,[independent.t])= interface.MixingPower7 ;
    DERIV(state.EnMix08,[independent.t])= interface.MixingPower8 ;
    DERIV(state.EnMix09,[independent.t])= interface.MixingPower9 ;
    DERIV(state.EnMix10,[independent.t])= interface.MixingPower10 ;
    DERIV(state.EnMix11,[independent.t])= interface.MixingPower11 ;
    DERIV(state.EnMix12,[independent.t])= interface.MixingPower12 ;
    DERIV(state.EnMix13,[independent.t])= interface.MixingPower13 ;
    DERIV(state.EnMix14,[independent.t])= interface.MixingPower14 ;
    DERIV(state.EnMix15,[independent.t])= interface.MixingPower15 ;
    DERIV(state.EnMix16,[independent.t])= interface.MixingPower16 ;
    DERIV(state.EnMix17,[independent.t])= interface.MixingPower17 ;
    DERIV(state.EnMix18,[independent.t])= interface.MixingPower18 ;
    DERIV(state.EnMix19,[independent.t])= interface.MixingPower19 ;
    DERIV(state.EnMix20,[independent.t])= interface.MixingPower20 ;

    state.Help_TotEnMix = state.EnMix01 + state.EnMix02 + state.EnMix03 + state.EnMix04 + state.EnMix05 +
      state.EnMix06 + state.EnMix07 + state.EnMix08 + state.EnMix09 + state.EnMix10 +
      state.EnMix11 + state.EnMix12 + state.EnMix13 + state.EnMix14 + state.EnMix15 +
      state.EnMix16 + state.EnMix17 + state.EnMix18 + state.EnMix19 + state.EnMix20 ;

    interface.TotEnergyMixing = state.Help_TotEnMix ;

    state.Prev_TotalAerationEnergy = IF (independent.t < previous(state.Prev_t)) THEN 0.0
      ELSE IF (independent.t - previous(state.Prev_t) < parameters.Period) THEN previous(state.Prev_TotalAerationEnergy)
        ELSE state.Help_TotEnAerat ;

    state.Prev_TotalPumpingEnergy = IF (independent.t < previous(state.Prev_t)) THEN 0.0
      ELSE IF (independent.t - previous(state.Prev_t) < parameters.Period) THEN previous(state.Prev_TotalPumpingEnergy)
        ELSE state.Help_TotEnPump ;

    state.Prev_TotalMixingEnergy = IF (independent.t < previous(state.Prev_t)) THEN 0.0
      ELSE IF (independent.t - previous(state.Prev_t) < parameters.Period) THEN previous(state.Prev_TotalMixingEnergy)
        ELSE state.Help_TotEnMix ;
     
    state.AC_Period = state.F_AC * (state.Help_TotEnAerat - state.Prev_TotalAerationEnergy) ;
    state.PC_Period = state.F_PC * (state.Help_TotEnPump - state.Prev_TotalPumpingEnergy);
    state.MC_Period = state.F_MC * (state.Help_TotEnMix - state.Prev_TotalMixingEnergy);
  };

:};

  
  

# 261 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.evaluator.msl" 2



# 47 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 1
 


















 CLASS DosingUnit_Base
 "A dosing unit model"
 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-
  {
   
   
   
  OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   
  OBJ C_Dose (* terminal = "in_1"; manip = "1" *) "Concentration of the solution" : 
      Concentration := {: causality <- "CIN"; value <- 10000 ; group <- "Operational" :};
  };

  parameters <-
  {
  OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components"
        : SpecificVolumeVector;
 



  OBJ MW (* hidden = "1" *) "Molecular weight of the chemical species dosed"
        : Real := {: group <- "System" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };

  independent <-
  {
  OBJ t "Time": Time := {: group <- "Time" :};
  };

  state <-
  {
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
    OBJ Help_QDose (* hidden = "1" *) "Flow rate of the solution" : FlowRate ;
  };
  initial <-
  {
  parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   state.Integ_PE = 0.0 ;
  };

  equations <-
  {
  interface.Outflow[IndexOfSolvent] = - state.Help_QDose
      / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
     
  interface.PumpingPower = parameters.F_Energy_FlowRate * state.Help_QDose ;
  DERIV(state.Integ_PE,[independent.t])=  state.Help_QDose;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };

 :};


 CLASS DosingUnit
 "A dosing unit model"
 EXTENDS DosingUnit_Base WITH
 {:

  interface <-
  {
  OBJ Q_Dose (* terminal = "in_1"; manip = "1" *) "Flow rate of the solution" : 
      FlowRate := {: causality <- "CIN"; value <- 10 ; group <- "Operational" :};
  };

  equations <-
  {
  state.Help_QDose = interface.Q_Dose ;
  };

 :};


 CLASS AdditionOfFermentationProducts
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {

   interface.Outflow[S_S] = - interface.Q_Dose * interface.C_Dose *
      (parameters.COD / parameters.MW) ;

    





    


  };

:};



 CLASS AdditionOfFermentableCOD
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {

   interface.Outflow[S_S] = - interface.Q_Dose * interface.C_Dose *
      (parameters.COD / parameters.MW) ;

    




  };

:};


# 267 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl"



# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.acetate.msl" 1
 














 




 CLASS Acetate
 (* icon = "dosing_unit_acetate"; is_default = "true" *)
 "A simple model for dosage of acetate"
 EXTENDS AdditionOfFermentationProducts WITH
 {:
  comments <- "A model for the addition of acetate as external carbon source";
  
  interface <-
  {
  OBJ M_Acetate (* terminal = "out_2" *) "Amount of acetate dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Acetate (* terminal = "out_2" *) "Flow rate of acetate dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  
  OBJ C_Alk (* hidden = "1" *) "1/Alkalinity 'released' by acetate uptake" : 
       Mass := {: value <- 64.0 ; group <- "Concentration" :};
  
  };
  
  initial <-
  {
  parameters.COD = 64;
  parameters.MW = 60;
  };

  equations <-
  {
  
  interface.Outflow[S_ALK] = interface.Outflow[S_S] / parameters.C_Alk ;
  
   
  interface.M_Acetate = interface.Q_Dose * interface.C_Dose ;
  interface.Q_Acetate = interface.Q_Dose ;
  };

:};


 


# 270 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.methanol.msl" 1
 



















 CLASS Methanol
 (* icon = "dosing_unit_methanol" *)
 "A simple model for dosage of methanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of methanol as external carbon source";

  interface <-
  {
  OBJ M_Methanol (* terminal = "out_2" *) "Amount of methanol dosed" : MassFlux
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Methanol (* terminal = "out_2" *) "Flow rate of methanol dosed" : FlowRate
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  initial <-
  {
  parameters.COD = 48;
  parameters.MW = 32;
  };

  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  equations <-
  {










   
  interface.M_Methanol = interface.Q_Dose * interface.C_Dose ;
  interface.Q_Methanol = interface.Q_Dose ;
  };

:};



# 271 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.ethanol.msl" 1
 



















 CLASS Ethanol
 (* icon = "dosing_unit_ethanol" *)
 "A simple model for dosage of ethanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of ethanol as external carbon source";

  interface <-
  {
  OBJ M_Ethanol (* terminal = "out_2" *) "Amount of ethanol dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Ethanol (* terminal = "out_2" *) "Flow rate of ethanol dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  initial <-
  {
  parameters.COD = 96;
  parameters.MW = 46;
  };

  equations <-
  {










   
  interface.M_Ethanol = interface.Q_Dose * interface.C_Dose ;
  interface.Q_Ethanol = interface.Q_Dose ;
  };

:};




# 272 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.alum.msl" 1
 


















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.alum.msl"



# 273 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.ironhydroxide.msl" 1
 


















# 48 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.ironhydroxide.msl"



# 274 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.base.dosing_units.xi.msl" 1
 
























CLASS AdditionOfXI (* icon = "dosing_unit_alkalinity" *)
"A dosing unit model to account for equivalent addition of inerts"
EXTENDS DosingUnit_Base WITH
{:

  comments <- "A dosing unit model to account for equivalent addition of inerts";

  interface <-
  {
    OBJ Q_Dose (* terminal = "in_1"; manip = "1" *) "Flow rate of the solution" : 
        FlowRate := {: causality <- "CIN"; value <- 10 ; group <- "Operational" :};
  }; 

  equations <-
  {
    


    interface.Outflow[X_I] = - interface.Q_Dose * interface.C_Dose ;
    
  };

:};





 

# 275 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2


 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.dosing.chemP.FeOH.msl" 1
 




















# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.dosing.chemP.FeOH.msl"




# 278 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.dosing.chemP.FeCl.msl" 1
 




















# 83 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.dosing.chemP.FeCl.msl"




# 279 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.dosing.chemP.NaAlO2.msl" 1
 




















# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/dosing_unit/wwtp.dosing.chemP.NaAlO2.msl"




# 280 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.dosing_units.msl" 2




# 50 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sludge_dewatering.msl" 1
 


















CLASS SolidSeparationModel EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ OutflowPermeate (* terminal = "out_1" *) "Permeate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   OBJ OutflowConcentrate (* terminal = "out_3" *) "Concentrate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    
   };

   parameters <-
   { 
   OBJ rho_sludge "Specific gravity of dewatered sludge" : Concentration := {: value <- 1.07e6 ; group <- "Operational" :};
    
   OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    
   };

   state <-
   {
   OBJ Q_Permeate "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   OBJ Q_Concentrate_Actual "Concentrate flow rate" : FlowRate := {: group <- "Operational" :};
    
   OBJ Help_X_Sludge (* hidden = "1" *) "Working variable to calculate TSS in the concentrate" : MassFlux;
   OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the outflow" : Fraction ;
   };

   equations <-
   {
    
   
   state.Help_X_Sludge = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
               (- interface.OutflowConcentrate[Comp_Index]) * parameters.F_TSS_COD);
   
    
    
   


   };

 :};

 
 
 
CLASS EfficiencyDewateringModel
 "efficiency-based dewatering"
 EXTENDS SolidSeparationModel WITH
 {:

  interface <-
  {
  OBJ DS (* terminal = "out_2" *) "Dry solids" : Real := {: causality <- "COUT" ; group <- "Measurement" :};
  OBJ e_X (* terminal = "in_2"; manip = "1" *) "Separation efficiency (fraction of solids going to sludge flow)" :
    Fraction := {: causality <- "CIN" ; value <- 0.96; group <- "Operational" :}; 
  OBJ Q_Concentrate (* terminal = "in_2"; manip = "1" *) "Desired flow rate of the concentrated sludge" :
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
  };

  parameters <-
  { 
  };
 
  state <-
  {
  OBJ DrySolids "Dry solid content (of the cake)" : Real := {: group <- "Operational" :};
  };
  
  equations <-
  {
   
   
   
   
   
   
   
   
   
  state.DrySolids = IF (state.Q_Concentrate_Actual == 0.0)
              THEN 0.0
            ELSE 100.0 * (state.Help_X_Sludge / (state.Q_Concentrate_Actual * parameters.rho_sludge));
   
   
  state.Q_Concentrate_Actual = IF (state.Q_In <= interface.Q_Concentrate)
                     THEN state.Q_In
                     ELSE interface.Q_Concentrate;
   
  state.Q_Permeate = state.Q_In - state.Q_Concentrate_Actual;
   
   
   
  state.f_Out = IF (state.Q_In <= interface.Q_Concentrate)
            THEN 0
            ELSE (state.Q_In - interface.Q_Concentrate) / state.Q_In ;
   
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowPermeate[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out;
  };
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowConcentrate[Comp_Index] =
         - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out);
  };
   
   
   
   
   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowPermeate[Comp_Index] = IF (state.Q_Concentrate_Actual == 0.0)
                         THEN - state.InFluxPerComponent[Comp_Index]
                       ELSE - state.InFluxPerComponent[Comp_Index] * (1-interface.e_X);
  };   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowConcentrate[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * interface.e_X;
  };
   
  interface.DS = state.DrySolids ;
  }; 
 
 :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sludge_dewatering/wwtp.base.sludge_dewatering.efficiencythickener.msl" 1
 


















CLASS EfficiencyThickener
  (* icon = "dewatering_unit" *)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge thickener based on dewatering efficiency";
  :};


# 149 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sludge_dewatering/wwtp.base.sludge_dewatering.efficiencycentrifuge.msl" 1
 


















CLASS EfficiencyCentrifuge
  (* icon = "centrifuge"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 150 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sludge_dewatering/wwtp.base.sludge_dewatering.efficiencybeltpress.msl" 1
 


















CLASS EfficiencyBeltPress
  (* icon = "beltpress"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 151 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sludge_dewatering.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sludge_dewatering/wwtp.sludge_dewatering.thickener.msl" 1
 







CLASS DS_Thickener
  (* icon = "dewatering_unit"; is_default = "true" *)
  "Dewatering unit"
  EXTENDS DS_DewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge thickener based on desired DS of the centrate";
  :};


CLASS DS_DewateringModel
 "Dewatering based on desired DS"
 EXTENDS SolidSeparationModel WITH
 {:

  interface <-
  {
   	OBJ DS (* terminal = "in_2"; manip = "1" *) "Dry solids" : Real := {: causality <- "CIN"; value <- 5 ; group <- "Operational" :};
	OBJ Q_Concentrate (* terminal = "in_2"; manip = "1" *) "Desired flow rate of the concentrated sludge" :FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
	OBJ e_X (* terminal = "out_2" *) "Separation efficiency (fraction of solids going to sludge flow)" : Fraction := {: causality <- "COUT" ; group <- "Operational" :}; 
	OBJ X_In (* terminal = "out_2" *) "TSS in the influent flow" : Concentration := {: causality <- "COUT" ; group <- "Operational" :};
	OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the centrate flow" : Concentration := {: causality <- "COUT" ; group <- "Operational" :};
	OBJ X_Permeate (* terminal = "out_2" *) "TSS in the permeate flow" : Concentration := {: causality <- "COUT" ; group <- "Operational" :};
  };

  state <-
  {
	OBJ help_Q_Conc (* hidden = "1" *) "Working variable for flow rate in the centrate flow" : FlowRate ;
	OBJ help_X_Conc (* hidden = "1" *) "Working variable for TSS in the centrate flow" : MassFlux ;
	OBJ help_X_In (* hidden = "1" *) "Working variable for TSS in the influent flow" : MassFlux ;
	OBJ X_Conc (* hidden = "1" *) "Working variable for TSS in the centrate flow" : MassFlux ;
	 
 
  };
  
  equations <-
  {
	 
	state.help_Q_Conc = IF (state.Q_In <= interface.Q_Concentrate)
		THEN state.Q_In
		ELSE interface.Q_Concentrate ;
	state.Q_Concentrate_Actual = - state.X_Conc / ((interface.DS / 100) * parameters.rho_sludge) ;
	 
	 
	state.Q_Permeate = state.Q_In - state.Q_Concentrate_Actual ;

	state.f_Out = IF (state.Q_In <= 0.0) THEN 0.0 ELSE (state.Q_In - state.Q_Concentrate_Actual) / state.Q_In ;
	
	state.help_X_Conc = - (interface.DS / 100) * state.help_Q_Conc * parameters.rho_sludge ;
	state.X_Conc = IF (- state.help_X_Conc >= state.help_X_In)
		THEN - 0.99 * state.help_X_In
		ELSE state.help_X_Conc ;
	 
	 
	{FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
		interface.OutflowPermeate[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out ; };
	 
	{FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
		interface.OutflowConcentrate[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out) ; };
	 
	 
	
	state.help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
		(interface.Inflow[Comp_Index]) * parameters.F_TSS_COD);
	
	 
	 
	



	 
	 
	{FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
		interface.OutflowPermeate[Comp_Index] = IF (state.Q_Concentrate_Actual == 0.0)
			THEN - state.InFluxPerComponent[Comp_Index]
			ELSE - state.InFluxPerComponent[Comp_Index] * (1 - interface.e_X) ; };   
	 
	 
	{FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
		interface.OutflowConcentrate[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * interface.e_X ; };

	 
  interface.e_X = IF (state.help_X_In <= 0.0) THEN 0.0 ELSE - state.X_Conc / state.help_X_In ; 
  interface.X_In = state.help_X_In / state.Q_In ; 
  interface.X_Concentrate = IF (state.Q_Concentrate_Actual <= 0.0) THEN 0.0 ELSE - state.X_Conc / state.Q_Concentrate_Actual ; 
  interface.X_Permeate = IF (state.Q_Permeate <= 0.0) THEN 0.0 ELSE (state.help_X_In + state.X_Conc) / state.Q_Permeate ;
  }; 
 
 :};



# 153 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.sludge_dewatering.msl" 2




# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl" 1
 














 





CLASS VolumeVector = Volume[NrOfLayers;];

 CLASS AtomicBiofilm "The base equations for the Biofilm"
     SPECIALISES PhysicalDAEModelType :=
   {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal
       := {: causality <- "CIN" ; group <- "Influent":};
   OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal
       := {: causality <- "COUT" ; group <- "Effluent":};
   };
   
   parameters <- 
   {  
   OBJ Stoichiometry (* hidden = "1" *) "stoichiometry of the reactions" :
         PhysicalQuantityType[NrOfReactions;][NrOfComponents;];
   };

   independent <-
   {
   OBJ t "Time": Time := {: group <- "Time" :};
   };

   state <-
   {  
   OBJ Kla_Actual "Gas transfer coefficient" : OxygenTransferCoefficient := {: group <- "Operational" :};     
   OBJ Temp_Actual "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   OBJ Kinetics_Biofilm (* hidden = "1" *) "Kinetics of the biological processes within the biofilm" :
          Rate[NrOfReactions;][NrOfLayers;];
   OBJ Kinetics (* hidden = "1" *) "Kinetics of the biological processes in the bulk liquid" :
          Rate[NrOfReactions;];
   OBJ ConversionTermPerComponent (* hidden = "1" *) "Reaction term in the bulk liquid phase" : Rate[NrOfComponents;];   
    
   OBJ C_Biofilm "Concentration of each component per biofilm layer" : LayerConcentrationMatrix
          := {: group <- "Concentration" :};
   OBJ M_Biofilm "Mass of each component per biofilm layer" : Mass[NrOfComponents;][NrOfLayers;]

   := [{: value <- 4500 :}, {: value <- 0.01 :}, {: value <- 0.01 :},
   {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 0.01 :} ,
   {: value <- 0.01 :}, {: value <- 0.01 :},
   {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 1000 :},
   {: value <- 100 :}, {: value <- 0.01 :}, {: value <- 0.01 :}; ]

# 76 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl"

# 86 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl"
















;
   OBJ C "Concentration of each component in the bulk liquid": ConcentrationVector
          := {: group <- "Concentration" :};     
   OBJ V "Volume of the bulk liquid phase" : Volume:= {: group <- "Operational" :};
   };
 
   :};

 CLASS AtomicConversionBiofilm EXTENDS AtomicBiofilm WITH
   {:
    
   
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 15.000000; :}; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; unit <- "1/d"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 5000.000000; :}; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; unit <- "m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.state.msl" 1
 

    OBJ K_X_Temp (* *) "K_X at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ b_A_Temp (* *) "b_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H_Temp (* *) "b_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_a_Temp (* *) "k_a at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_h_Temp (* *) "k_h at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_A_Temp (* *) "mu_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H_Temp (* *) "mu_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[AerGrowthHetero][S_S] := - 1 / (parameters.Y_H);
    parameters.Stoichiometry[AerGrowthHetero][S_O] := - (1 - parameters.Y_H) / parameters.Y_H;
    parameters.Stoichiometry[AerGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AerGrowthHetero][S_ALK] := - parameters.i_X_B / 14;
    parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AnGrowthHetero][S_S] := - 1 / parameters.Y_H;
    parameters.Stoichiometry[AnGrowthHetero][S_NO] := - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
    parameters.Stoichiometry[AnGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
    parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AerGrowthAuto][S_O] := - (4.57 - parameters.Y_A) / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NH] := - parameters.i_X_B - 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_ALK] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
    parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
    parameters.Stoichiometry[DecayOfHetero][X_BH] := - 1;
    parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[DecayOfAuto][X_BA] := - 1;
    parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] := - 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.000000 / 14.000000;
    parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrg][X_S] := - 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] := - 1;
    parameters.Stoichiometry[Aeration][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;
    state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A, state.Temp_Actual - parameters.Temp_Ref);
    state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H, state.Temp_Actual - parameters.Temp_Ref);
    state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H, state.Temp_Actual - parameters.Temp_Ref);

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthAuto] = state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
    state.Kinetics[AerGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
    state.Kinetics[Aeration] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonOfSolOrgN] = state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
    state.Kinetics[AnGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
    state.Kinetics[DecayOfAuto] = state.b_A_Temp * state.C[X_BA];
    state.Kinetics[DecayOfHetero] = state.b_H_Temp * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrg] = state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrgN] = (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);

# 55 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NH];
    interface.NO3 = state.C[S_NO];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA]));
    interface.OfflineTKN = (state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.OnlineCOD = (state.C[S_S] + state.C[S_I] + state.C[X_BH] + state.C[X_BA] + state.C[X_S] + state.C[X_I] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 59 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 2


































# 113 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl" 2

   :};

 CLASS AtomicConversionBiofilmBulk EXTENDS AtomicConversionBiofilm WITH
{:
   
  
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.layer.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASM1TempConversionModel.layer.body.msl" 1
 

















   interface <-
   {
 
   };

   parameters <-
   {
 
   };

   state <-
   {
    
    
    
   };

   initial <-
   {
 
   };

   equations <-
   {
   
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASM1TempConversionModel.layer.kinetics.msl" 1
 
















    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;

  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerGrowthHetero][Layer_Index] = state.mu_H_Temp * (state.C_Biofilm[S_S][Layer_Index] / (parameters.K_S + state.C_Biofilm[S_S][Layer_Index])) * (state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NH][Layer_Index] / (parameters.K_NH_H + state.C_Biofilm[S_NH][Layer_Index])) * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnGrowthHetero][Layer_Index] = state.mu_H_Temp * (state.C_Biofilm[S_S][Layer_Index] / (parameters.K_S + state.C_Biofilm[S_S][Layer_Index])) * (parameters.K_OH / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NO][Layer_Index] / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index])) * (state.C_Biofilm[S_NH][Layer_Index] / (parameters.K_NH_H + state.C_Biofilm[S_NH][Layer_Index])) * parameters.n_g * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerGrowthAuto][Layer_Index] = state.mu_A_Temp * (state.C_Biofilm[S_NH][Layer_Index] / (parameters.K_NH + state.C_Biofilm[S_NH][Layer_Index])) * (state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OA + state.C_Biofilm[S_O][Layer_Index])) * state.C_Biofilm[X_BA][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[DecayOfHetero][Layer_Index] = state.b_H_Temp * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[DecayOfAuto][Layer_Index] = state.b_A_Temp * state.C_Biofilm[X_BA][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AmmonOfSolOrgN][Layer_Index] = state.k_a_Temp * state.C_Biofilm[S_ND][Layer_Index] * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[HydrolOfEntrOrg][Layer_Index] = state.k_h_Temp * (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index]) / (state.K_X_Temp + (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index])) * ((state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NO][Layer_Index] / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index]))) * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[HydrolOfEntrOrgN][Layer_Index] = (state.k_h_Temp * (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index]) / (state.K_X_Temp + (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index])) * ((state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NO][Layer_Index] / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index]))) * state.C_Biofilm[X_BH][Layer_Index]) * (state.C_Biofilm[X_ND][Layer_Index] / state.C_Biofilm[X_S][Layer_Index]);
  };
  
  

# 43 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASM1TempConversionModel.layer.body.msl" 2

 
   };
   


# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.layer.body.msl" 2


















# 119 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl" 2

:};


CLASS BaseBiofilm1D EXTENDS AtomicConversionBiofilmBulk WITH
{:

  interface <-  
  {
    OBJ Kla (* terminal = "in_2"; manip = "1" *) "Gas transfer coefficient for oxygen" : 
      OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 750 ; group <- "Operational" :}; 
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
    OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
      : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  }; 

  parameters <- 
 {  
 OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolume[NrOfComponents;];
  
  
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.BiofilmsDiffusivity.msl" 1
 















 OBJ D_x "Diffusivity coefficient for biomass" : Diffusivity := {: value <- 1e-10 ; group <- "Transport" :};
 OBJ D_i "Diffusivity coefficient" : Diffusivity[NrOfComponents;] 
 
 
   :=[{: value <- 1.0e-10 ; group <- "Transport":},{: value <- 1.0e-4 ;group <- "Transport":} , {: value <- 5.8e-5 ;group <- "Transport":},
   {: value <- 2.2e-4 ;group <- "Transport":} ,{: value <- 1.7e-4 ;group <- "Transport":} , {: value <- 1.7e-4 ;group <- "Transport":} ,
   {: value <- 1.4e-4 ;group <- "Transport":} ,{: value <- 2.2e-4 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} ,
   {: value <- 0 ;group <- "Transport":} ,{: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} ,
   {: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":}; ] 
 
 
# 36 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.BiofilmsDiffusivity.msl"

 
 
# 46 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.BiofilmsDiffusivity.msl"









 
 
# 64 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.BiofilmsDiffusivity.msl"

 ;
# 142 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl" 2

 OBJ dcmin (* hidden = "1" *) "Min concentration gradient that results in diffusion": Concentration := {: value <- 1E-6 ; group <- "System" :};
  
  
 OBJ d_ini "Initial biofilm thickness" : Length := {: value <- 0.0002 ; group <- "System" :};
 OBJ d_max "Maximum biofilm thickness" : Length := {: value <- 0.0005 ; group <- "Dimension" :};
 OBJ d_min (* hidden = "0" *) "Min biofilm thickness" : Length := {: value <- 5e-7 ; group <- "Dimension" :};
 OBJ A (* fixed = "1" *) "Total biofilm surface area" : Area := {: value <- 400; group <- "Dimension" :};
 OBJ eta "Porosity of the biofilm" : Ratio := {:value <- 1.0 ; group <- "Transport" :};
 OBJ deltao "Boundary layer" : Length := {:value <- 1E-5 ; group <- "Transport" :};
 OBJ rho "Biofilm density" : Density := {:value <- 40000 ;group <- "System" :};
 OBJ rho_layer (* hidden = "1" *) "Biofilm density of a layer": Density[NrOfLayers;] := {: group <- "System" :}; 
  
 OBJ k_At "Coefficient for attachment of particulates" : RateConstant:= {:value <- 0.1 ;group <- "Transport" :}; 
 OBJ k_detach "Factor of proportionality for the detachment controller": Real := {: value <- 1E5 ; group <- "System" :};
  
  
 OBJ V_R (* fixed = "1" *) "volume of the reactor" : Volume := {: value <- 1.0 ; group <- "Dimension" :};
 OBJ L "Length of the reactor" : Length := {:value <- 1.0 ; group <- "Dimension" :};
 OBJ H "Height of the reactor" : Length := {:value <- 1.0 ;group <- "Dimension" :};
 OBJ W "Width of reactor" : Length := {:value <- 1.0 ;group <- "Dimension" :};
  
  
 OBJ fc_real (* hidden = "1" *) "Portion of the reactor volume occupied by the solid support for the biofilm (true)" : Ratio := {: group <- "Dimension" :} ;
 OBJ fc (* hidden = "1" *) "Portion of the reactor volume occupied by the solid support for the biofilm (apparent)" : Ratio := {: value<- 0.5; group <- "Dimension" :} ;
 OBJ area_sp (* hidden = "1" *) "Specific surface area" : SpecificAreaVolume := {: value<- 80; group <- "System" :};
 OBJ Vc_real (* hidden = "1"; fixed = "1" *) "(true) volume of the carrier" : Volume := {: value <- 0.5 ; group <- "Dimension" :} ;
 OBJ Vc (* hidden = "1"; fixed = "1" *) "(apparent) volume of the carrier" : Volume := {: value <- 1 ; group <- "Dimension" :} ;

    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 };
 
 state <-
 {    
 OBJ S_Sat (* hidden ="1" *) "Saturation concentration" : Concentration[NrOfComponents;];
  
 OBJ InFluxPerComponent (* hidden = "1" *) "Fluxes of all components through the process unit" : MassFluxVector; 
 OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
 OBJ Q_In "Influent flow rate" : FlowRate:= {: group <- "Operational" :};
  
 OBJ Total_Mass "Total mass of the biofilm ": Mass:= {: group <- "Mass" :};
 OBJ Mass_Layer "Mass of each component per layer" : Mass[NrOfLayers;] := {: group <- "Mass" :};  
 
 OBJ M "Mass of each component in the bulk liquid": MassVector   
 
   :=[{: value <- 4500 :}, {: value <- 10 :}, {: value <- 10 :},
   {: value <- 10 :}, {: value <- 10 :}, {: value <- 10 :} ,
   {: value <- 10 :}, {: value <- 10 :},
   {: value <- 10 :}, {: value <- 10 :}, {: value <- 100 :},
   {: value <- 100 :}, {: value <- 10 :}, {: value <- 10 :}; ]
 
 
# 202 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl"

 
# 212 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl"

 






 







 ;
  
 OBJ V_biofilm "Volume of the biofilm" : Volume:= {: group <- "Operational" :};
 OBJ V_layer "Volume of each biofilm layer" : VolumeVector := {: group <- "System" :}; 
  
  
 OBJ Detach_Term (* hidden = "1" *) "Detachment of each biofilm component": MassFluxVector := {: group <- "Transport" :};
 OBJ Reaction_Term_Biofilm (* hidden = "1" *) "Reaction term in the biofilm matrix" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_Term_Biofilm (* hidden = "1" *) "Diffustion term in the biofilm matrix" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_In (* hidden = "1" *) "Diffustion between layer 1 and bulk liquid" : Rate[NrOfComponents;];
 OBJ Diffusion_Through_Up (* hidden = "1" *) "Upward diffustion in layers 2 to ButOne" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_Through_Down (* hidden = "1" *) "Downward diffustion in layers 2 to Last" : Rate[NrOfComponents;][NrOfLayers;];
  
  
 OBJ u_Dt "Velocity of biofilm growth" : LayerVelocityVector := {: group <- "System" :};
 OBJ d "Thickness of the biofilm" : Length:= {: group <- "Operational" :};
 OBJ d_layer "Thickness of each layer": LengthVector := {: group <- "System" :};  
 OBJ d_layer_calc (* hidden = "1" *) "Thickness of each layer" : LengthVector := {: group <- "System" :};
 OBJ delta (* hidden = "1" *) "Boundary layer for each component" : Length[NrOfComponents;]:= {: group <- "Transport" :};
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
 };
 
 initial <-
 {
 parameters.WWTPSpecificVolume[H2O] := 1e-6;
   state.Integ_AE = 0.0 ;
 };

 equations <-
 {
  
 state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow[IndexOfSolvent] ;
 
 { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.InFluxPerComponent[Comp_Index] =
      SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
      In_Terminal[Comp_Index] ; };
  
  
  
 
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.Mass_Layer[Layer_Index] =
      SUMOVER Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
      state.M_Biofilm[Comp_Index][Layer_Index] ; };
 
 




 




 {state.Total_Mass = SUMOVER Layer_Index IN {1 .. NrOfLayers}: state.Mass_Layer[Layer_Index] ;};
  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.d_layer_calc[Layer_Index] =
          state.Mass_Layer[Layer_Index]/(parameters.A * parameters.rho_layer[Layer_Index]) ; };
  
  
  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.d_layer[Layer_Index] =
        IF (state.d_layer_calc[Layer_Index] >= (parameters.d_min/NrOfLayers))
           THEN state.d_layer_calc[Layer_Index]
           ELSE parameters.d_min/NrOfLayers ; };
  
  
  
 state.d = SUMOVER Layer_Index IN {1 .. NrOfLayers} : state.d_layer[Layer_Index] ;
  
  
  
  
  
  
 state.V = (parameters.V_R - parameters.Vc_real) - state.V_biofilm ;
 
 {FOREACH Layer_Index IN {1 .. NrOfLayers}: state.V_layer[Layer_Index] = parameters.A * state.d_layer[Layer_Index] ; };
 
 {state.V_biofilm = SUMOVER Layer_Index IN {1 .. NrOfLayers} : state.V_layer[Layer_Index] ; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}: state.delta[Comp_Index] = parameters.deltao ;};
  
  
 state.Kla_Actual = interface.Kla ;
 
      state.S_Sat[S_O] = state.S_O_Saturation;
 
  
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.ConversionTermPerComponent[Comp_Index] =
      SUMOVER Reaction_Index IN {1 .. NrOfReactions} :
      (state.Kinetics[Reaction_Index] * parameters.Stoichiometry[Reaction_Index][Comp_Index]) * state.V ; };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      state.Reaction_Term_Biofilm[Comp_Index][Layer_Index] =
      SUMOVER Reaction_Index IN {1 .. NrOfReactions} :
      (state.Kinetics_Biofilm[Reaction_Index][Layer_Index] * parameters.Stoichiometry[Reaction_Index][Comp_Index]) ; }; };
  
 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
      (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index])+
      (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}: Out_Terminal[Comp_Index]);};
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_In[Comp_Index][1] =
          IF (fabs(state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1]) > parameters.dcmin && (state.delta[Comp_Index] > 0.0))
           THEN parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
           ELSE 0.0 ;  };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayersButOne} :
      state.Diffusion_Through_Down[Comp_Index][Layer_Index] =
          IF (fabs(state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) > parameters.dcmin && (state.d_layer[Layer_Index] > 0.0))
           THEN parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
           ELSE 0.0 ; }; };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {2 .. NrOfLayers} :
      state.Diffusion_Through_Up[Comp_Index][Layer_Index] =
          IF (fabs(state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) > parameters.dcmin && (state.d_layer[Layer_Index] > 0.0))
           THEN parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1]
           ELSE 0.0 ; }; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_Term_Biofilm[Comp_Index][1] =
        state.Diffusion_In[Comp_Index][1] - state.Diffusion_Through_Down[Comp_Index][1] ; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      state.Diffusion_Term_Biofilm[Comp_Index][Layer_Index] =
        state.Diffusion_Through_Up[Comp_Index][Layer_Index] - state.Diffusion_Through_Down[Comp_Index][Layer_Index] ; }; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_Term_Biofilm[Comp_Index][NrOfLayers] = state.Diffusion_Through_Up[Comp_Index][NrOfLayers] ; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.C[Comp_Index] = IF (state.V > 0.0)
      THEN state.M[Comp_Index] / state.V
      ELSE 0.0 ;};
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      state.C_Biofilm[Comp_Index][Layer_Index] =
      IF (state.V_layer[Layer_Index] > 0.0)
      THEN state.M_Biofilm[Comp_Index][Layer_Index] / state.V_layer[Layer_Index]
      ELSE 0.0 ; }; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      state.Detach_Term[Comp_Index] =
      SUMOVER Layer_Index IN {1 .. NrOfLayers} :
      (state.u_Dt[Layer_Index] * parameters.A * state.C_Biofilm[Comp_Index][Layer_Index]) ; };
 
 
  
 DERIV(state.M[IndexOfSolvent], [independent.t]) = 0.0 ; 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      DERIV(state.M[Comp_Index], [independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index]
      + state.ConversionTermPerComponent[Comp_Index]
 
      - parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
      ; };  
{FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV(state.M[Comp_Index], [independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index]
      + state.ConversionTermPerComponent[Comp_Index]
      - parameters.k_At * state.V * state.C[Comp_Index]
      + state.Detach_Term[Comp_Index] ; };  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      DERIV (state.M_Biofilm[IndexOfSolvent][Layer_Index], [independent.t])=0.0 ; };
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
        DERIV (state.M_Biofilm[Comp_Index][1], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][1] * state.V_layer[1]
 
      + parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
      - parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index] [1] - state.C_Biofilm[Comp_Index] [2]) * parameters.A / state.d_layer[1]
      ; };
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][1], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][1] * state.V_layer[1]
      + parameters.k_At * state.V * state.C[Comp_Index]
      - state.u_Dt[1] * parameters.A * state.C_Biofilm[Comp_Index][1]
      - parameters.D_x * (state.C_Biofilm[Comp_Index][1] - state.C_Biofilm[Comp_Index][2]) * parameters.A / state.d_layer[1] ; }; 
  
 {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
      DERIV (state.M_Biofilm[Comp_Index][Layer_Index], [independent.t]) =
          state.Reaction_Term_Biofilm [Comp_Index][Layer_Index] * state.V_layer[Layer_Index]
 
      + parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1]
      - parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
      ; }; };
 
 {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][Layer_Index], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][Layer_Index] * state.V_layer[Layer_Index]
      - state.u_Dt[Layer_Index]* parameters.A * state.C_Biofilm[Comp_Index][Layer_Index]
      - parameters.D_x * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
      + parameters.D_x * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1] ; }; };
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
      DERIV (state.M_Biofilm[Comp_Index][NrOfLayers], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][NrOfLayers] * state.V_layer[NrOfLayers]
 
      + parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][NrOfLayersButOne] - state.C_Biofilm[Comp_Index][NrOfLayers]) * parameters.A / state.d_layer[NrOfLayersButOne]
      ;};
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][NrOfLayers], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][NrOfLayers] * state.V_layer[NrOfLayers]
      - state.u_Dt[NrOfLayers]* parameters.A * state.C_Biofilm[Comp_Index][NrOfLayers]
      + parameters.D_x * (state.C_Biofilm[Comp_Index][NrOfLayersButOne] - state.C_Biofilm[Comp_Index][NrOfLayers]) * parameters.A / state.d_layer[NrOfLayersButOne] ; };
  
  
 interface.Outflow[IndexOfSolvent] = - interface.Inflow[IndexOfSolvent] ;
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      interface.Outflow[Comp_Index] = - state.Q_In * state.C[Comp_Index] ; };

    state.Temp_Actual = interface.Temp;

 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
  DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
  interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 
 }; 
 
:};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/biofilm/wwtp.base.biofilms.mbbr.msl" 1
 


















CLASS MBBR (* icon = "mbbr"; is_default = "true" *)
 "A model for an MBBR unit, based on the biofilm model by Van Hulle and Vanrolleghem"
 EXTENDS BaseBiofilm1D WITH
 {:
    
    comments <- "A model for an MBBR unit. Detachment when d>dmax and proportional to (d-dmax)^2";
    interface <-
    {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
     
    OBJ OUR_bf (* terminal = "out_2" *) "Oxygen Uptake Rate in biofilm" : Real := {: causality <- "COUT"; unit <- "g/(m3.d)" ; group <- "Measurement data" :};
    OBJ OUR_tot (* terminal = "out_2" *) "Oxygen Uptake Rate in biofilm and bulk phase" : Real := {: causality <- "COUT"; unit <- "g/(m3.d)" ;group <- "Measurement data" :};
    };
    parameters <- 
    {  
       OBJ f_solid "Fraction of the solid support to the total volume of the reactor" : Ratio := {:value <- 0.05 ; group <- "Dimension" :} ;
     OBJ A_Sp_C "(carrier) Specific surface area" : SpecificAreaVolume := {:value <- 400 ; group <- "System" :};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
    };
    
      state <-
    {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
    };
     
    initial <-
    {
      
     parameters.fc = parameters.f_solid ;
     parameters.fc_real = parameters.f_solid ;
     parameters.area_sp = parameters.A_Sp_C ;
      
      
     parameters.V_R = parameters.L * parameters.W * parameters.H ;
     parameters.Vc_real = parameters.fc_real * parameters.V_R ;
     parameters.Vc = parameters.fc * parameters.V_R ;
      
     parameters.A = parameters.area_sp * parameters.Vc ;
      
      
     {FOREACH Layer_Index IN {1 .. NrOfLayers}:
          parameters.rho_layer[Layer_Index]=parameters.eta*parameters.rho ; };
      
     state.M[IndexOfSolvent] = ((parameters.V_R - parameters.Vc_real) - (parameters.A*parameters.d_ini)) / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

   state.Integ_ME = 0.0 ;
 };

    equations <-
    {
     
    {FOREACH Layer_Index IN {1 .. NrOfLayers} : state.u_Dt[Layer_Index] =
           IF ( state.d_layer_calc[Layer_Index] <= (parameters.d_max/NrOfLayers) )
            THEN 0.0
          ELSE parameters.k_detach * pow(( state.d_layer_calc[Layer_Index] - (parameters.d_max/NrOfLayers) ),2) ; 
       };

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
    
     
    interface.OUR_bf = - 1 * (SUMOVER Layer_Index IN {1 .. NrOfLayers}: state.Reaction_Term_Biofilm[S_O][Layer_Index]); 
    interface.OUR_tot = interface.OUR_ASU + interface.OUR_bf ;
          
    }; 

 :};


# 472 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/biofilm/wwtp.base.biofilms.ifaspointsettler.msl" 1
 


















CLASS IFASPointSettler (* class = "ifas"; is_default = "true" *) SPECIALISES CoupledModelType :=
{:

  comments <- "A model for an IFAS unit. Detachment when d>dmax and proportional to (d-dmax)^2";

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- CIN ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- COUT ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- COUT ; group <- "Underflow" :};
     
    OBJ Kla (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 750 ; group <- "Operational" :};
    
    OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature of the activated sludge" : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
    
    OBJ Q_Under (* terminal = "in_2"; manip = "1" *) "Underflow flow rate" : FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ Q_Excess (* terminal = "in_2"; manip = "1" *) "Excess sludge flow rate" : FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    
    OBJ DO (* terminal = "out_3" *) "Dissolved oxygen concentration" : DissolvedOxygen := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ NH4 (* terminal = "out_3" *) "Ammonium concentration" : Concentration := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ NO3 (* terminal = "out_3" *) "Nitrate+Nitrite concentration" :Concentration := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ TSS (* terminal = "out_3" *) "Total suspended solids" :Concentration := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ V_ASU (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ OUR_ASU (* terminal = "out_3" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ NUR (* terminal = "out_3" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ NPR (* terminal = "out_3" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ AUR (* terminal = "out_3" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ Kla_ASU (* terminal = "out_3" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Sensor data" :};
    
    
    OBJ OnlineCOD (* terminal = "out_3" *) "Chemical Oxygen Demand" :Concentration := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ OfflineBOD (* terminal = "out_3" *) "Biological Oxygen Demand" :Concentration := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ OnlineTN (* terminal = "out_3" *) "Total nitrogen concentration" :Concentration := {: causality <- "COUT" ; group <- "Sensor data" :};
    OBJ OfflineTKN (* terminal = "out_3" *) "Total Kjeldal nitrogen concentration" :Concentration := {: causality <- "COUT" ; group <- "Sensor data" :};
    
    
# 63 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/biofilm/wwtp.base.biofilms.ifaspointsettler.msl"

    




    
     
    OBJ AerationEnergy (* terminal = "out_3" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_3" *) "Aeration power" : Power := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_3" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_3" *) "Mixing power" : Power := {: causality <- "COUT"; group <- "Energy" :};
     
  };
  
  parameters <-
  {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.005 ; group <- "Settling" :};
  };

  sub_models <-
  {
    OBJ Tank_IFAS : MBBR;
    OBJ Settler_IFAS : SecondaryPointSettler;
    OBJ Loop_IFAS : DifferentialLoopBreaker;
    OBJ Well_IFAS : TwoCombiner;
    OBJ ExcessSludge_IFAS : AbsTwoSplitter;
  };

  coupling <-
  {
     
    connect(interface.Kla, sub_models.Tank_IFAS.interface.Kla),
    connect(interface.Temp, sub_models.Tank_IFAS.interface.Temp),
    connect(interface.Q_Under, sub_models.Settler_IFAS.interface.Q_Under),
    connect(interface.Q_Excess, sub_models.ExcessSludge_IFAS.interface.Q_Out2),
     
    sub_models.Settler_IFAS.parameters.f_ns.value := parameters.f_ns.value,
    
     
    connect(sub_models.Tank_IFAS.interface.AerationEnergy, interface.AerationEnergy),
    connect(sub_models.Tank_IFAS.interface.AerationPower, interface.AerationPower),
    connect(sub_models.Tank_IFAS.interface.MixingEnergy, interface.MixingEnergy),
    connect(sub_models.Tank_IFAS.interface.MixingPower, interface.MixingPower),
     
     
    connect(sub_models.Tank_IFAS.interface.DO, interface.DO),
    connect(sub_models.Tank_IFAS.interface.NH4, interface.NH4),
    connect(sub_models.Tank_IFAS.interface.NO3, interface.NO3),
    connect(sub_models.Tank_IFAS.interface.TSS, interface.TSS),
    connect(sub_models.Tank_IFAS.interface.V_ASU, interface.V_ASU),
    connect(sub_models.Tank_IFAS.interface.OUR_ASU, interface.OUR_ASU),
    connect(sub_models.Tank_IFAS.interface.NUR, interface.NUR),
    connect(sub_models.Tank_IFAS.interface.NPR, interface.NPR),
    connect(sub_models.Tank_IFAS.interface.AUR, interface.AUR),
    connect(sub_models.Tank_IFAS.interface.Kla_ASU, interface.Kla_ASU),
    
    connect(sub_models.Tank_IFAS.interface.OnlineCOD, interface.OnlineCOD),
    connect(sub_models.Tank_IFAS.interface.OfflineBOD, interface.OfflineBOD),
    connect(sub_models.Tank_IFAS.interface.OnlineTN, interface.OnlineTN),
    connect(sub_models.Tank_IFAS.interface.OfflineTKN, interface.OfflineTKN),
    
    
# 133 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/biofilm/wwtp.base.biofilms.ifaspointsettler.msl"

    




     
    connect(sub_models.Loop_IFAS.interface.Outflow, sub_models.Well_IFAS.interface.Inflow2),
    connect(sub_models.Tank_IFAS.interface.Outflow, sub_models.Settler_IFAS.interface.Inflow),
    connect(sub_models.Well_IFAS.interface.Outflow, sub_models.Tank_IFAS.interface.Inflow),
    connect(sub_models.Settler_IFAS.interface.Underflow, sub_models.ExcessSludge_IFAS.interface.Inflow),
    connect(sub_models.ExcessSludge_IFAS.interface.Outflow1, sub_models.Loop_IFAS.interface.Inflow),
    connect(interface.Inflow, sub_models.Well_IFAS.interface.Inflow1),
    connect(sub_models.ExcessSludge_IFAS.interface.Outflow2, interface.Underflow),
    connect(sub_models.Settler_IFAS.interface.Outflow, interface.Outflow),
  };

:};




 
# 473 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/biofilm/wwtp.base.biofilms.tricklingfilter1D.msl" 1
 


















CLASS TricklingFilter1D (* icon = "trickling_filter"; is_default = "true" *)
 "A model for a 1D-biofilm by Van Hulle and Vanrolleghem"
 EXTENDS BaseBiofilm1D WITH
 {:
    
    comments <- "A model for a trickling filter. Detachment when d>dmax and proportional to (d-dmax)^2";
    
     
    interface <-
    {
    OBJ OUR_bf (* terminal = "out_2" *) "Oxygen Uptake Rate in biofilm" : Real := {: causality <- "COUT"; unit <- "g/(m3.d)" ; group <- "Measurement data" :};
    OBJ OUR_tot (* terminal = "out_2" *) "Oxygen Uptake Rate in biofilm and bulk phase" : Real := {: causality <- "COUT"; unit <- "g/(m3.d)" ;group <- "Measurement data" :};
    };
    
    parameters <- 
    {  
       OBJ f_void "Void space of the media" : Ratio := {:value <- 0.5 ; group <- "Dimension" :} ;
     OBJ A_Sp_R "(reactor) Specific surface area" : SpecificAreaVolume := {:value <- 400 ; group <- "System" :};
    };
 
    initial <-
    {
     parameters.fc = 1.0 ;   
     parameters.fc_real = 1.0 - parameters.f_void ;
     parameters.area_sp = parameters.A_Sp_R ;
      
      
     parameters.V_R = parameters.L * parameters.W * parameters.H ;
     parameters.Vc_real = parameters.fc_real * parameters.V_R ;
     parameters.Vc = parameters.fc * parameters.V_R ;
      
     parameters.A = parameters.area_sp * parameters.fc * parameters.V_R ;
      
      
     {FOREACH Layer_Index IN {1 .. NrOfLayers}:
          parameters.rho_layer[Layer_Index]=parameters.eta*parameters.rho ; };
      
     state.M[IndexOfSolvent] = ((parameters.V_R - parameters.Vc_real) - (parameters.A*parameters.d_ini)) / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    };
 
    equations <-
    {
     
    {FOREACH Layer_Index IN {1 .. NrOfLayers} : state.u_Dt[Layer_Index] =
           IF ( state.d_layer_calc[Layer_Index] <= (parameters.d_max/NrOfLayers) )
            THEN 0.0
          ELSE parameters.k_detach * pow(( state.d_layer_calc[Layer_Index] - (parameters.d_max/NrOfLayers) ),2) ; };
    
     
    interface.OUR_bf = - 1 * (SUMOVER Layer_Index IN {1 .. NrOfLayers}: state.Reaction_Term_Biofilm[S_O][Layer_Index]); 
    interface.OUR_tot = interface.OUR_ASU + interface.OUR_bf ;
    
    }; 

 :};



# 474 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.biofilms.msl" 2





# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2



# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 1
 




















CLASS PressureDifference "A class for trans-membrane pressure"
SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "Pressure";
  unit      <- "Pa";
  interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF; :};
:};

CLASS FiltrationResistance SPECIALISES PhysicalQuantityType :=
{:
  quantity  <- "filtration resistance";
  unit      <- "1/m";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
:};


CLASS WWTPAtomicModelWithMembraneVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:

  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
  OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ OutflowConcentrate (* terminal = "out_3" *) "Concentrate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ A_0 (* terminal = "in_2"; manip = "1" *) "Initial membrane surface area" : Area := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
  };

  parameters <-
  {
  OBJ f_nr "Non-retainable fraction of suspended solids" : Fraction := {: value <- 0.000 ; group <- "Settling" :};
  };

  state <-
  {
  OBJ Q_Out_Membrane_Help (* hidden = "1" *) "Permeate flowrate" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Out_Membrane "Effluent flow rate through the membrane" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Concentrate "Concentrate flow rate" : FlowRate := {: group <- "Operational" :};
  };
  
  initial <-
  {
  };
 
  equations <-
  {
  state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow[IndexOfSolvent];

   
   
  state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

   
  {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
         state.C[Comp_Index] = IF (state.V == 0.0)
          THEN 0.0
        ELSE state.M[Comp_Index]/state.V ; };

  interface.OutflowConcentrate[IndexOfSolvent] = - state.Q_Concentrate / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
         interface.OutflowConcentrate[Comp_Index] = - state.C[Comp_Index] * state.Q_Concentrate ;};

  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
         interface.OutflowConcentrate[Comp_Index] = - state.C[Comp_Index] * state.Q_Concentrate * (1- parameters.f_nr) ; };
  };

 :};

 CLASS IdealMembraneVolumeClass EXTENDS WWTPAtomicModelWithMembraneVolume WITH
 {:
  interface <-  
  {
  OBJ T1 (* terminal = "in_2"; manip = "1" *) "Relaxation1 period" :   
      Time := {: causality <- "CIN" ; value <- 0.00008101851852 ; group <- "Operational" :};
  OBJ T2 (* terminal = "in_2"; manip = "1" *) "Filtration period" : 
      Time := {: causality <- "CIN" ; value <- 0.005208333 ; group <- "Operational" :};
  OBJ T3 (* terminal = "in_2"; manip = "1" *) "Relaxation2 period" : 
      Time := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ T4 (* terminal = "in_2"; manip = "1" *) "Backwashing period" : 
      Time := {: causality <- "CIN" ; value <- 0.000208333 ; group <- "Operational" :};
   
  OBJ J11 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation1 period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J12 (* terminal = "in_2"; manip = "1" *) "Filtration flux in filtration period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};   
  OBJ J13 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation2 period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J14 (* terminal = "in_2"; manip = "1" *) "Filtration flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ u14 (* terminal = "in_2"; manip = "1" *) "Backwash flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};

  };
  parameters <-
  {
  };

  state <-  
  {
  OBJ J1 "Average Filtration flux" : Velocity := {: group <- "Operational" :};   
  };
  initial <-
  {
  };
  
  equations <-
  {
  state.J1 =
      (interface.J11 * interface.T1 + interface.J12 * interface.T2 + interface.J13 * interface.T3 + (interface.J14 - interface.u14) * interface.T4 )
    / (interface.T1 + interface.T2 + interface.T3 + interface.T4);

  state.Q_Out_Membrane_Help = state.J1 * interface.A_0 ;     
  state.Q_Out = state.Q_Out_Membrane;
  
  interface.Outflow[IndexOfSolvent] = - state.Q_Out_Membrane / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
         interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out_Membrane; };

  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
         interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out_Membrane * parameters.f_nr; };
  };

 :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/internal_membrane/wwtp.base.internal_membrane.membraneideal.msl" 1
 


















CLASS MembraneIdeal
 (* icon = "membrane" *)
 "Simple membrane filtration model"
 EXTENDS IdealMembraneVolumeClass WITH
 {:

  comments <- "A model for an external membrane unit (fouling is not modelled)";

  interface <-
  {
    OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Permeate" :};
    OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Concentrate" :};
    OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };

  parameters <-
  {
  OBJ V_Tank "Tank volume " : Volume := {: value <- 100; group <- "Dimension" :};
  
  OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  
 
    OBJ TMP "Trans-membrane pressure" : PressureDifference := {: value <- 35000 ; group <- "Energy" :};
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
  };

  state <-
  {
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
  };
    
  initial <-
  {
  state.M[IndexOfSolvent] = parameters.V_Tank / parameters.WWTPSpecificVolume[IndexOfSolvent];
  state.Integ_PE_Membrane = 0.0 ;
  };

  equations <-
  {
  state.Q_Out_Membrane = IF ((state.Q_In - state.Q_Out_Membrane_Help) <= 0)
      THEN state.Q_In
    ELSE state.Q_Out_Membrane_Help;

  state.Q_Concentrate = IF ((state.Q_In - state.Q_Out_Membrane) <= 0)
      THEN 0
    ELSE state.Q_In - state.Q_Out_Membrane;

  
  interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
      (- interface.Outflow[Comp_Index]) * parameters.F_TSS_COD);
  interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
      (- interface.OutflowConcentrate[Comp_Index]) * parameters.F_TSS_COD);
  
   
  




 
     
  interface.PumpingPower = (state.Q_Out_Membrane * parameters.TMP / (3600000.0 * parameters.n_Pump_Membrane)) ;
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * parameters.TMP / (3600000.0 * parameters.n_Pump_Membrane);
 
 
  interface.PumpingEnergy = state.Integ_PE_Membrane;
  };

 :};


# 148 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2


CLASS InternalIdealMembraneVolumeModel EXTENDS IdealMembraneVolumeClass WITH
 {:

  interface <-
  {
  OBJ Overflow (* terminal = "out_4" *)"Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ Q_Pump (* terminal = "in_2"; manip = "1" *) "Concentrate flow rate" : 
      FlowRate := {: causality <- "CIN" ; group <- "Operational" :} ;
  };

  parameters <-
  {
  OBJ V_Min "Minimum allowed tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  OBJ V_Tank "Tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  };

  state <-
  {
  OBJ Q_Over "Overflow rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
  state.Q_Out_Membrane = IF (state.V > parameters.V_Min)
                 THEN state.Q_Out_Membrane_Help
             ELSE 0.0 ;

  state.Q_Concentrate = IF (state.V > parameters.V_Min)
      THEN interface.Q_Pump
    ELSE 0.0 ;

  state.Q_Over = IF (state.V > parameters.V_Tank)
      THEN
      IF (state.Q_In  >= (state.Q_Out_Membrane + state.Q_Concentrate))
         THEN state.Q_In - state.Q_Out_Membrane - state.Q_Concentrate
         ELSE 0.0
    ELSE 0.0 ;

  interface.Overflow[IndexOfSolvent] = - state.Q_Over / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      interface.Overflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Over ;};
  };

 :};
 
 
 CLASS InternalIdealMembraneVolumeConversionModel EXTENDS InternalIdealMembraneVolumeModel WITH
 {:
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
    OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
    OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 199 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2

 :};

  

 CLASS InternalIdealMembraneVolumeASMConversionModel EXTENDS InternalIdealMembraneVolumeConversionModel WITH
 {:
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 15.000000; :}; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; unit <- "1/d"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 5000.000000; :}; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; unit <- "m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.state.msl" 1
 

    OBJ K_X_Temp (* *) "K_X at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ b_A_Temp (* *) "b_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H_Temp (* *) "b_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_a_Temp (* *) "k_a at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_h_Temp (* *) "k_h at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_A_Temp (* *) "mu_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H_Temp (* *) "mu_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[AerGrowthHetero][S_S] := - 1 / (parameters.Y_H);
    parameters.Stoichiometry[AerGrowthHetero][S_O] := - (1 - parameters.Y_H) / parameters.Y_H;
    parameters.Stoichiometry[AerGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AerGrowthHetero][S_ALK] := - parameters.i_X_B / 14;
    parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AnGrowthHetero][S_S] := - 1 / parameters.Y_H;
    parameters.Stoichiometry[AnGrowthHetero][S_NO] := - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
    parameters.Stoichiometry[AnGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
    parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AerGrowthAuto][S_O] := - (4.57 - parameters.Y_A) / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NH] := - parameters.i_X_B - 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_ALK] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
    parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
    parameters.Stoichiometry[DecayOfHetero][X_BH] := - 1;
    parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[DecayOfAuto][X_BA] := - 1;
    parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] := - 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.000000 / 14.000000;
    parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrg][X_S] := - 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] := - 1;
    parameters.Stoichiometry[Aeration][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;
    state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A, state.Temp_Actual - parameters.Temp_Ref);
    state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H, state.Temp_Actual - parameters.Temp_Ref);
    state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H, state.Temp_Actual - parameters.Temp_Ref);

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthAuto] = state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
    state.Kinetics[AerGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
    state.Kinetics[Aeration] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonOfSolOrgN] = state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
    state.Kinetics[AnGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
    state.Kinetics[DecayOfAuto] = state.b_A_Temp * state.C[X_BA];
    state.Kinetics[DecayOfHetero] = state.b_H_Temp * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrg] = state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrgN] = (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);

# 55 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NH];
    interface.NO3 = state.C[S_NO];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA]));
    interface.OfflineTKN = (state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.OnlineCOD = (state.C[S_S] + state.C[S_I] + state.C[X_BH] + state.C[X_BA] + state.C[X_S] + state.C[X_I] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 59 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 2


































# 206 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2

 :};


CLASS InternalIdealMembraneVolumeClass
 EXTENDS InternalIdealMembraneVolumeASMConversionModel WITH
 {:
  
  interface <-
  {
  OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Permeate" :};
  OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Concentrate" :};
  };

  equations <-
  {
 
  
  interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
             (- interface.Outflow[Comp_Index]) / state.Q_Out_Membrane * parameters.F_TSS_COD);
  interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
           (- interface.OutflowConcentrate[Comp_Index]) / state.Q_Concentrate * parameters.F_TSS_COD);
  
   
 
  



 
  
# 246 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl"

  };

:};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/MBR/wwtp.base.mbr.mbrideal.msl" 1
 


















 CLASS MBRIdeal
 (* icon = "mbr" *)
 "Simple MBR filtration model"
 EXTENDS InternalIdealMembraneVolumeClass WITH
 {:
  comments <- "A model for an MBR unit (fouling is not modelled)";
  interface <-  
  {
   OBJ Kla (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Power := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };   
  
  parameters <-
  {
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
 
    OBJ TMP "Trans-membrane pressure" : PressureDifference := {: value <- 35000 ; group <- "Energy" :};
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate for the concentrate pump" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
    OBJ Integ_PE_Concentrate (* hidden = "1" *)"Integral Pumping energy for the concentrate pump" : ElectricalEnergy ;
  };
  
  initial <-
  {
  state.Integ_AE = 0.0 ;
  state.Integ_ME = 0.0 ;
  state.Integ_PE_Membrane = 0.0 ;
  state.Integ_PE_Concentrate = 0.0 ;
  };

  equations <-
  {
  state.Kla_Actual = interface.Kla;
  state.Temp_Actual = interface.Temp;

 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
  DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
  interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * parameters.TMP / (3600000.0 * parameters.n_Pump_Membrane);
 
 
  DERIV(state.Integ_PE_Concentrate,[independent.t])=  state.Q_Concentrate;
  interface.PumpingEnergy = state.Integ_PE_Membrane + parameters.F_Energy_FlowRate * state.Integ_PE_Concentrate;

     
  interface.PumpingPower = (parameters.F_Energy_FlowRate * state.Q_Concentrate +
    (state.Q_Out_Membrane * parameters.TMP / (3600000.0 * parameters.n_Pump_Membrane))) ;
  };
:};


# 251 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2


 CLASS FoulingMembraneVolumeClass EXTENDS WWTPAtomicModelWithMembraneVolume WITH
 {:

  interface <-
  {
  OBJ Inflow_Backwash (* terminal = "in_3" *) "Backwash" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   
  OBJ Q_Backwash_Control (* terminal = "out_2" *) "Backwash trigger" : Real := {: causality <- "COUT" ; group <- "Other measurements" :};
  OBJ P_TMP (* terminal = "out_2" *) "TMP" :  PressureDifference := {: causality <- "COUT" ; group <- "Other measurements" :};
  OBJ T1 (* terminal = "in_2"; manip = "1" *) "Relaxation1 period" : 
      Time := {: causality <- "CIN" ; value <- 0.00008101851852 ; group <- "Operational" :};
  OBJ T2 (* terminal = "in_2"; manip = "1" *) "Filtration period" : 
      Time := {: causality <- "CIN" ; value <- 0.005208333 ; group <- "Operational" :};
  OBJ T3 (* terminal = "in_2"; manip = "1" *) "Relaxation2 period" : 
      Time := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ T4 (* terminal = "in_2"; manip = "1" *) "Backwashing period" : Time := {: causality <- "CIN" ; value <- 0.000208333 ; group <- "Operational" :};
   
  OBJ J11 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation1 period" :    
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J12 (* terminal = "in_2"; manip = "1" *) "Filtration flux in filtration period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};   
  OBJ J13 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation2 period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J14 (* terminal = "in_2"; manip = "1" *) "Filtration flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
   
  OBJ u14 (* terminal = "in_2"; manip = "1" *) "Backwash flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};
  OBJ C_SMP (* terminal = "in_2"; manip = "1" *) "Concentration of Colloidal material" : 
      Concentration  := {: causality <- "CIN" ; value <- 100.0 ; group <- "Operational" :} ;
  };

  parameters <-
  {
  OBJ J_crit "Critical filtration flux" : Velocity := {: value <- 2.3 ; group <- "Operational" :};
  OBJ eta_20 (* hidden = "1" *) "Viscosity of the permeate at 20 degrees" : DynamicViscosity := {: value <- 1.16E-8 ; group <- "Operational" :};
  OBJ E_alfa "Factor for temperature correction of viscosity" : Real := {: value <- 1.94 ; group <- "Operational" :}; 
  OBJ E_beta "Factor for temperature correction of viscosity" : Real := {: value <- 4.80 ; group <- "Operational" :}; 
  OBJ E_gamma "Factor for temperature correction of viscosity" : Real := {: value <- 6.74 ; group <- "Operational" :}; 
   
  OBJ R_m "Membrane resistance" : FiltrationResistance := {: value <- 4.1E+11 ; group <- "Operational" :};
  OBJ R_alfa "Specific cake resistance" : Real := {: value <- 3.6E+12; unit <- "m/g"; interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:}; group <- "Operational" :}; 
  OBJ R_beta "Semi-empirical exponent for solid deposition"  : Real := {: value <- 3.5 ; group <- "Operational" :}; 
  OBJ sigma_X_TSS "Irreversibly blocked membrane area per unit of TSS" : Real := {: value <- 0.0003 ; group <- "Operational" :};
   
  };

  state <-
  {
  OBJ T "Complete cycle" : Time := {: group <- "Operational" :};
  OBJ t_rel (* hidden = "1" *) "Time relative to the beginning of each cycle" : Time ;
  OBJ Q_Backwash "Backwashing flowrate" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Out_Backwash "Excess flow of the backwash going to the outflow" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Backwash_Help (* hidden = "1" *) "Backwash flow based on the flux" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Backwash_Available "Available flow for backwash" : FlowRate := {: group <- "Operational" :};
  OBJ f_Out_Backwash (* hidden = "1" *) "fraction of the backwash flow going to the outflow" : Fraction := {: group <- "Operational" :};
  OBJ K_Temp (* hidden = "1" *) "Operating temperature" : KelvinTemperature ;
  OBJ eta_T "Viscosity of the permeate" : DynamicViscosity := {: group <- "Operational" :};
   
  OBJ R_c "(reversible) Cake resistance" : FiltrationResistance := {: group <- "Operational" :};
  OBJ R_irr "Irreversible resistance" : FiltrationResistance := {: group <- "Operational" :};
  OBJ R_tot "Total filtration resistance" : FiltrationResistance := {: group <- "Operational" :};
  OBJ A "Membrane surface area" : Area := {: group <- "Operational" :};
  OBJ A_Blocked "Blocked membrane surface area" : Area := {: group <- "Operational" :};
  OBJ Solids (* hidden = "1" *) "Solids concentration in the stream" : Concentration := {: group <- "Operational" :};
   
  OBJ TMP "Trans-membrane pressure" : PressureDifference := {: group <- "Operational" :};
  OBJ J_act "Actual filtration flux" : Velocity := {: group <- "Operational" :};
  OBJ J_app "Apparent filtration flux" : Velocity := {: group <- "Operational" :};
   
  OBJ C_cake "Concentration of total solids in the cake" : Concentration := {: group <- "Concentration" :};
  OBJ M_cake "Mass of the cake" : Mass := {: group <- "Mass" :};
   
  OBJ M_cake_Help (* hidden = "1" *) "Computed mass of the cake" : Mass := {: group <- "Mass" :};
  OBJ M_cake_cumul "Mass of the cake at the end of each cycle" : Mass := {: group <- "Mass" :};
  };

  initial <-
  {
  state.M_cake_cumul = 0.0 ;  
  state.M_cake_Help = 0.0 ;  
  state.A_Blocked = 0.0 ;  
  };
  
  equations <-
  {
  state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;
  
  state.t_rel = IF (independent.t < state.T)
      THEN independent.t
    ELSE independent.t - state.T * (floor(independent.t/state.T)) ;

  state.Q_Out_Membrane_Help = IF (state.t_rel < interface.T1)
      THEN interface.J11 * interface.A_0             
    ELSE
      IF (state.t_rel < (interface.T1 + interface.T2))
            THEN interface.J12 * interface.A_0         
          ELSE
            IF (state.t_rel < (interface.T1 + interface.T2 + interface.T3))
                  THEN interface.J13 * interface.A_0       
                ELSE interface.J14 * interface.A_0 ;     

  state.Q_Backwash_Help = IF (state.t_rel < interface.T1)
      THEN 0.0             
    ELSE
      IF (state.t_rel < (interface.T1 + interface.T2))
            THEN 0.0         
          ELSE
            IF (state.t_rel < (interface.T1 + interface.T2 + interface.T3))
                  THEN 0.0       
                      ELSE interface.u14 * interface.A_0 ;     

  state.Q_Backwash_Available = IF (interface.Inflow_Backwash[IndexOfSolvent] <= 0.0)
      THEN 0.0
    ELSE parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow_Backwash[IndexOfSolvent];
  
  state.Q_Backwash = IF (state.Q_Backwash_Available <= state.Q_Backwash_Help)
      THEN state.Q_Backwash_Available
    ELSE state.Q_Backwash_Help;

   
  state.Q_Out_Backwash = state.Q_Backwash_Available - state.Q_Backwash ;
   
  state.f_Out_Backwash = IF (state.Q_Backwash_Available == 0.0)
      THEN 0.0
    ELSE state.Q_Out_Backwash / state.Q_Backwash_Available; 

  state.Q_Out = state.Q_Out_Membrane + state.Q_Out_Backwash;
  
 

   
   
  state.eta_T = parameters.eta_20 * exp(- parameters.E_alfa - parameters.E_beta * (293/state.K_Temp)
      + parameters.E_gamma * pow(293/state.K_Temp, 2) ) ;
   
   
   
   
  DERIV(state.A_Blocked, [independent.t]) = parameters.sigma_X_TSS * interface.C_SMP * state.Q_Out_Membrane ;
  state.A = interface.A_0 - state.A_Blocked;
   
   
  state.R_irr = parameters.R_m * (interface.A_0/state.A - 1) ;
   
   
  state.J_act = state.Q_Out_Membrane / state.A ;
  state.J_app = IF (state.t_rel < interface.T1)
      THEN 0.0                                   
    ELSE
      IF (state.t_rel < (interface.T1 + interface.T2))
            THEN state.Q_Out_Membrane / interface.A_0            
          ELSE
            IF (state.t_rel < (interface.T1 + interface.T2 + interface.T3))
                  THEN 0.0                           
                ELSE - state.Q_Backwash / interface.A_0 ;    
   
   
  state.C_cake = state.Solids * pow((state.J_act/parameters.J_crit), parameters.R_beta) ;
  DERIV(state.M_cake_Help,[independent.t]) = state.C_cake * state.Q_Out_Membrane ;
  state.M_cake_cumul = IF (state.t_rel <= (interface.T1+interface.T2+interface.T3))
      THEN previous(state.M_cake_cumul)
    ELSE state.M_cake_Help ;
  state.M_cake = fabs(state.M_cake_cumul - state.M_cake_Help) ;
   
  state.R_c = parameters.R_alfa * state.M_cake / interface.A_0 ;
   
   
  state.R_tot = parameters.R_m + state.R_irr + state.R_c ;
   
   
  state.TMP = state.eta_T * state.J_app * state.R_tot ;
   
  interface.Outflow[IndexOfSolvent] = - (state.Q_Out_Membrane + state.Q_Out_Backwash) / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
         interface.Outflow[Comp_Index] = - (state.C[Comp_Index] * state.Q_Out_Membrane + state.f_Out_Backwash * interface.Inflow_Backwash[Comp_Index]); };

  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
         interface.Outflow[Comp_Index] = - (state.C[Comp_Index] * state.Q_Out_Membrane * parameters.f_nr + state.f_Out_Backwash * interface.Inflow_Backwash[Comp_Index]); };

   
  interface.P_TMP = state.TMP ;
  interface.Q_Backwash_Control = state.Q_Backwash_Help ;
  };

 :};

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/internal_membrane/wwtp.base.internal_membrane.membranewithfouling.msl" 1
 


















 CLASS MembraneWithFouling
 (* icon = "membrane"; is_default = "true" *)
 "Membrane filtration model extended with the computation of the TMP"
 EXTENDS FoulingMembraneVolumeClass WITH
 {:

  comments <- "A model for an external membrane unit, subjected to fouling (the trans-membrane pressure is computed)";

  interface <-
  {
  OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Permeate" :};
  OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Concentrate" :};
  OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)   "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
  OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };

  parameters <-
  {
  OBJ V_Tank "Tank volume " : Volume := {: value <- 100; group <- "Dimension" :};
  
  OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  
 
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ n_Pump_Backwash "Pump efficiency of the backwash pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
    OBJ Integ_PE_Backwash (* hidden = "1" *)"Integral Pumping energy for the backwash pump" : ElectricalEnergy ;
  };

  initial <-
  {
  state.M[IndexOfSolvent] = parameters.V_Tank / parameters.WWTPSpecificVolume[IndexOfSolvent]; 
  state.Integ_PE_Membrane = 0.0 ;
  state.Integ_PE_Backwash = 0.0 ;
  };

  equations <-
  {
  state.K_Temp = interface.Temp + 273 ;

  state.Q_Out_Membrane = IF ((state.Q_In + state.Q_Backwash - state.Q_Out_Membrane_Help) < 0.0)
      THEN state.Q_In + state.Q_Backwash
    ELSE state.Q_Out_Membrane_Help;

  state.Q_Concentrate = IF ((state.Q_In + state.Q_Backwash - state.Q_Out_Membrane) < 0.0)
      THEN 0.0
    ELSE state.Q_In + state.Q_Backwash - state.Q_Out_Membrane;

  
  state.Solids = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: state.C[Comp_Index] * parameters.F_TSS_COD );
  
  


   
  
  interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (- interface.Outflow[Comp_Index]) * parameters.F_TSS_COD);
  interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (- interface.OutflowConcentrate[Comp_Index]) * parameters.F_TSS_COD);
  
   
  




 
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * state.TMP / (3600000.0 * parameters.n_Pump_Membrane);
  DERIV(state.Integ_PE_Backwash,[independent.t])=  state.Q_Backwash * state.TMP / (3600000.0 * parameters.n_Pump_Backwash);
 
 
  interface.PumpingEnergy = state.Integ_PE_Membrane + state.Integ_PE_Backwash;
   
     
    interface.PumpingPower = (state.Q_Out_Membrane * state.TMP / (3600000.0 * parameters.n_Pump_Membrane) +
      state.Q_Backwash * state.TMP / (3600000.0 * parameters.n_Pump_Backwash)) ;
  };

 :};
  


# 442 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2


  
  
  
  
  
 CLASS InternalFoulingMembraneVolumeModel EXTENDS FoulingMembraneVolumeClass WITH
 {:

  interface <-
  {
  OBJ Overflow (* terminal = "out_4" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ Q_Pump (* terminal = "in_2"; manip = "1" *) "Concentrate flow rate" : FlowRate := {: causality <- "CIN" ; group <- "Operational" :} ;
  };

  parameters <-
  {
  OBJ V_Min "Minimum allowed tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  OBJ V_Tank "Tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  };

  state <-
  {
  OBJ Q_Over "Overflow rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
  state.Q_Out_Membrane = IF (state.V > parameters.V_Min)
      THEN state.Q_Out_Membrane_Help
    ELSE 0.0 ;

  state.Q_Concentrate = IF (state.V > parameters.V_Min)
      THEN interface.Q_Pump
    ELSE 0.0 ;

  state.Q_Over = IF (state.V > parameters.V_Tank)
      THEN
      IF ((state.Q_In + state.Q_Backwash) >= (state.Q_Out_Membrane + state.Q_Concentrate))
         THEN state.Q_In + state.Q_Backwash - state.Q_Out_Membrane - state.Q_Concentrate
         ELSE 0.0
    ELSE 0.0 ;

  interface.Overflow[IndexOfSolvent] = - state.Q_Over / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      interface.Overflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Over ; };

  };

 :};
 

 
 CLASS InternalFoulingMembraneVolumeConversionModel EXTENDS InternalFoulingMembraneVolumeModel WITH
 {:
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
    OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
    OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 499 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2

 :};
 
  

 CLASS InternalFoulingMembraneVolumeASMConversionModel EXTENDS InternalFoulingMembraneVolumeConversionModel WITH
 {:
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 15.000000; :}; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; unit <- "1/d"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- 5000.000000; :}; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; unit <- "m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_NH (* *) "Ammonia Half-Saturation Coefficient For Autotrophic Biomass" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_NH_H (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: unit <- "g/m3"; value <- 0.05; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_NO (* *) "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; interval <- {: lowerBound <- 0.000000; upperBound <- 2.000000; :}; group <- "Kinetic"; :};
    OBJ K_OA (* *) "Oxygen Half-Saturation Coefficient For Autotrophic Biomass" : OxygenHalfSatCoeffForAutotr := {: unit <- "gO2/m3"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_OH (* *) "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass" : OxygenHalfSatCoeffForHetero := {: unit <- "gO2/m3"; value <- 0.2; interval <- {: lowerBound <- 0.000000; upperBound <- 10.000000; :}; group <- "Kinetic"; :};
    OBJ K_S (* *) "Half-Saturation Coefficient For Heterotrophic Biomass" : HalfSatCoeffForHetero := {: unit <- "gCOD/m3"; value <- 20.0; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ K_X (* *) "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; interval <- {: lowerBound <- 0.000000; upperBound <- 100.000000; :}; group <- "Kinetic"; :};
    OBJ Temp_Ref (* *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: unit <- "degC"; value <- 20.0; interval <- {: lowerBound <- -273.15; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ Y_A (* *) "Yield For Autotrophic Biomass" : YieldForAutotrophicBiomass := {: unit <- "gCOD/gN"; value <- 0.24; interval <- {: lowerBound <- 0.000000; upperBound <- 4.57; :}; group <- "Stoichiometry"; :};
    OBJ Y_H (* *) "Yield For Heterotrophic Biomass" : YieldForHeterotrophicBiomass := {: unit <- "gCOD/gCOD"; value <- 0.67; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ b_A (* *) "Decay Coefficient For Autotrophic Biomass" : DecayCoeffAutotr := {: unit <- "1/d"; value <- 0.15; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ b_H (* *) "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {: unit <- "1/d"; value <- 0.62; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ f_P (* *) "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: unit <- "-"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Stoichiometry"; :};
    OBJ i_N_S_I (* *) "Mass of nitrogen per mass of inert soluble COD" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ i_X_P (* *) "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; interval <- {: lowerBound <- 0.000000; upperBound <- 0.2; :}; group <- "Composition parameters"; :};
    OBJ k_a (* *) "Maximum Specific Ammonification Rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; interval <- {: lowerBound <- 0.000000; upperBound <- 0.25; :}; group <- "Kinetic"; :};
    OBJ k_h (* *) "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.0; interval <- {: lowerBound <- 0.000000; upperBound <- 25.000000; :}; group <- "Kinetic"; :};
    OBJ mu_A (* *) "Maximum Specific Growth Rate For Autotrophic Biomass" : MaxSpecifGrowthRateAutotr := {: unit <- "1/d"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 5.000000; :}; group <- "Kinetic"; :};
    OBJ mu_H (* *) "Maximum Specific Growth Rate For Heterotrophic Biomass" : MaxSpecifGrowthRateHetero := {: unit <- "1/d"; value <- 6.0; interval <- {: lowerBound <- 0.000000; upperBound <- 20.000000; :}; group <- "Kinetic"; :};
    OBJ n_g (* *) "Correction Factor For Anoxic Growth Of Heteritrophs" : CorrectionFactor := {: unit <- "-"; value <- 0.8; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ n_h (* *) "Correction Factor For Anoxic Hydrolysis" : CorrectionFactor := {: unit <- "-"; value <- 0.4; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Kinetic"; :};
    OBJ theta_K_X (* *) "Temperature correction factor for K_X" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_A (* *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_b_H (* *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_a (* *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_k_h (* *) "Temperature correction factor for k_h" : Real := {: value <- 1.116; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_A (* *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ theta_mu_H (* *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.state.msl" 1
 

    OBJ K_X_Temp (* *) "K_X at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; value <- 0.0; interval <- {: lowerBound <- 0.000000; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ b_A_Temp (* *) "b_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ b_H_Temp (* *) "b_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_a_Temp (* *) "k_a at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ k_h_Temp (* *) "k_h at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_A_Temp (* *) "mu_A at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};
    OBJ mu_H_Temp (* *) "mu_H at the system temperature" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetic"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[AerGrowthHetero][S_S] := - 1 / (parameters.Y_H);
    parameters.Stoichiometry[AerGrowthHetero][S_O] := - (1 - parameters.Y_H) / parameters.Y_H;
    parameters.Stoichiometry[AerGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AerGrowthHetero][S_ALK] := - parameters.i_X_B / 14;
    parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AnGrowthHetero][S_S] := - 1 / parameters.Y_H;
    parameters.Stoichiometry[AnGrowthHetero][S_NO] := - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
    parameters.Stoichiometry[AnGrowthHetero][S_NH] := - parameters.i_X_B;
    parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
    parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
    parameters.Stoichiometry[AerGrowthAuto][S_O] := - (4.57 - parameters.Y_A) / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_NH] := - parameters.i_X_B - 1 / parameters.Y_A;
    parameters.Stoichiometry[AerGrowthAuto][S_ALK] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
    parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
    parameters.Stoichiometry[DecayOfHetero][X_BH] := - 1;
    parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[DecayOfAuto][X_BA] := - 1;
    parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
    parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] := - 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
    parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.000000 / 14.000000;
    parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrg][X_S] := - 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
    parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] := - 1;
    parameters.Stoichiometry[Aeration][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;
    state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A, state.Temp_Actual - parameters.Temp_Ref);
    state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H, state.Temp_Actual - parameters.Temp_Ref);
    state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H, state.Temp_Actual - parameters.Temp_Ref);

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthAuto] = state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
    state.Kinetics[AerGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
    state.Kinetics[Aeration] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonOfSolOrgN] = state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
    state.Kinetics[AnGrowthHetero] = state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
    state.Kinetics[DecayOfAuto] = state.b_A_Temp * state.C[X_BA];
    state.Kinetics[DecayOfHetero] = state.b_H_Temp * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrg] = state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
    state.Kinetics[HydrolOfEntrOrgN] = (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);

# 55 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NH];
    interface.NO3 = state.C[S_NO];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA]));
    interface.OfflineTKN = (state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.OnlineCOD = (state.C[S_S] + state.C[S_I] + state.C[X_BH] + state.C[X_BA] + state.C[X_S] + state.C[X_I] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) + parameters.i_X_P * (state.C[X_P] + state.C[X_I]) + parameters.i_N_S_I * state.C[S_I]);
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 59 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1Temp/wwtp.VolumeASM1TempConversionModel.body.msl" 2

  };

# 18 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.VolumeASMConversionModel.body.msl" 2


































# 506 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2

 :};

 CLASS InternalFoulingMembraneVolumeClass EXTENDS InternalFoulingMembraneVolumeASMConversionModel WITH
 {:
  
  interface <-
  {
  OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Other measurements" :};
  OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Other measurements" :};
  };
  
  equations <-
  {
 
  
    state.Solids = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: state.C[Comp_Index] * parameters.F_TSS_COD );
  
 
  


 
  
   interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
             (- interface.Outflow[Comp_Index]) / (state.Q_Out_Membrane + state.Q_Out_Backwash) * parameters.F_TSS_COD);
   interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
               (- interface.OutflowConcentrate[Comp_Index]) / state.Q_Concentrate * parameters.F_TSS_COD);
  
   
 
  



 
  
# 556 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl"

  };

 :};

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/MBR/wwtp.base.mbr.mbrwithfouling.msl" 1
 


















 CLASS MBRWithFouling
 (* icon = "mbr"; is_default = "true" *)
 "MBR model extended with the computation of the TMP"
 EXTENDS InternalFoulingMembraneVolumeClass WITH
 {:
  comments <- "A model for an MBR unit, subjected to fouling (the trans-membrane pressure is computed)";
  interface <-  
  {
   OBJ Kla (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ OTR_Energy (* terminal = "in_2"; manip = "1" *) "Oxygen transfer rate per energy input" : TransferRateEnergy := {: causality <- "CIN" ; value <- 1800 ; group <- "Operational" :}; 
   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingPower (* terminal = "out_2" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };   
  
  parameters <-
  {
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};
 
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ n_Pump_Backwash "Pump efficiency of the backwash pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate for the concentrate pump" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
    OBJ Integ_PE_Backwash (* hidden = "1" *)"Integral Pumping energy for the backwash pump" : ElectricalEnergy ;
    OBJ Integ_PE_Concentrate (* hidden = "1" *)"Integral Pumping energy for the concentrate pump" : ElectricalEnergy ;
  };
  
  initial <-
  {
  state.Integ_AE = 0.0 ;
  state.Integ_ME = 0.0 ;
  state.Integ_PE_Membrane = 0.0 ;
  state.Integ_PE_Backwash = 0.0 ;
  state.Integ_PE_Concentrate = 0.0 ;
  };

  equations <-
  {
  state.Temp_Actual = interface.Temp;
  state.K_Temp = interface.Temp + 273 ;
  state.Kla_Actual = interface.Kla;
 
     
    interface.AerationPower = (1 / interface.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
  DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
  interface.AerationEnergy = (1 / interface.OTR_Energy) * state.Integ_AE ; 

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated == 1)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

     
    interface.MixingPower = state.ME_Instant ;
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * state.TMP / (3600000.0 * parameters.n_Pump_Membrane);
  DERIV(state.Integ_PE_Backwash,[independent.t])=  state.Q_Backwash * state.TMP / (3600000.0 * parameters.n_Pump_Backwash);
 
 
  DERIV(state.Integ_PE_Concentrate,[independent.t])=  state.Q_Concentrate;
  interface.PumpingEnergy = state.Integ_PE_Membrane + state.Integ_PE_Backwash + parameters.F_Energy_FlowRate * state.Integ_PE_Concentrate;

     
  interface.PumpingPower = (state.Q_Out_Membrane * state.TMP / (3600000.0 * parameters.n_Pump_Membrane) +
    state.Q_Backwash * state.TMP / (3600000.0 * parameters.n_Pump_Backwash) + parameters.F_Energy_FlowRate * state.Q_Concentrate) ;
  };

:};



# 561 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.internal_membrane.msl" 2





# 56 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.ADM1.msl" 1
 















 







# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.extra.definitionsADM1.msl" 1



TYPE ADM1IonComponents = ENUM { S_ac_ion, S_bu_ion, S_pro_ion, S_va_ion, S_hco3_ion, S_nh3 };

TYPE ADM1IonReactions = ENUM {dissociation_va, dissociation_bu, dissociation_pro, dissociation_ac, hco3_co2, ammonia_production, };

OBJ ADM1NrOfIonComponents : Integer := Cardinality(ADM1IonComponents);

CLASS ADM1IonConcentrationVector = kmolConcentration[ADM1NrOfIonComponents;];


# 25 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.ADM1.msl" 2


CLASS ADM1ConcVector = Concentration[ADM1NrOfComponents;];
CLASS ADM1IonConcVector = MolConcentration[ADM1NrOfIonComponents;];


 
CLASS ADM1_Digester EXTENDS ADM1_DigesterConversionModel WITH
{:

  comments <- "ADM1 model for anaerobic digestion according to BSM2. This is different from the STR       implementation in terms of the Hill functions used for inhibition and the alternative simple equation       for the gas flow calculation. This implementation uses an algebraic model to calculate S_H for speeding       up calculations (DAE2 - both pH and H2 are calculated algebraically)";



      
  interface <-
  {
     
    OBJ AD_pH (* is_favorite = "1"; terminal = "out_4" *) "pH in the digester" : pH := {: causality <- "COUT"; group <- "Data" :};
    OBJ AD_T (* terminal = "out_4" *) "Measured temperature" : CelsiusTemperature := {: causality <- "COUT"; group <- "Data" :};
    OBJ Gas_p_ch4 (* is_favorite = "1"; terminal = "out_4" *) "Methane partial pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "Data" :};
    OBJ Gas_p_h2 (* terminal = "out_4" *) "Hydrogen partial pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "Data" :};
    OBJ Gas_p_co2 (* is_favorite = "1"; terminal = "out_4" *) "CO2 partial pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "Data" :};
    OBJ Gas_p_tot (* terminal = "out_4" *) "Total headspace pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "Data" :};
    OBJ Gas_Q (* is_favorite = "1"; terminal = "out_4" *) "Biogas flow rate" : FlowRate := {: causality <- "COUT"; group <- "Data" :};
    OBJ AD_V_liq (* terminal = "out_4" *) "Liquor volume" : Volume := {: causality <- "COUT"; group <- "Data" :};
    OBJ AD_V_tot (* terminal = "out_4" *) "Total volume" : Volume := {: causality <- "COUT"; group <- "Data" :};
     
     
    OBJ AD_C (* terminal = "out_4" *) "Vector containing masses for components of ADM1" : ADM1ConcVector := {: causality <- "COUT"; group <- "Concentration" :};
    OBJ AD_C_Ion (* terminal = "out_4" *) "Vector containing masses for all ion components of ADM1" : ADM1IonConcVector := {: causality <- "COUT"; group <- "Concentration" :};
  };
  
  parameters <-
  {
    OBJ K_p "Gas flow constant": Real := {: value <- 5e4; group <- "System" :};
    OBJ P_atm "Pressure of atmosphere" : Pressure := {: value <- 1.013; unit <- "bar"; group <- "Operational" :};
  };
  
  state <-
  {
     
    OBJ P_headspace "Total pressure in the gas phase" : Pressure := {: unit <- "bar"; group <- "Operational" :};
    OBJ p_ch4 "CH4 partial pressure" : Pressure := {: unit <- "bar"; group <- "Operational" :};
    OBJ p_co2 "CO2 partial pressure" : Pressure := {: unit <- "bar"; group <- "Operational" :};
    OBJ p_h2 "H2 partial pressure" : Pressure := {: unit <- "bar"; group <- "Operational" :};
    OBJ p_h2o "Water partial pressure" : Pressure := {: unit <- "bar"; group <- "Operational" :};
     
  };

  equations <-
  {
     
    state.P_headspace = state.p_co2 + state.p_h2 + state.p_ch4 + state.p_h2o;
    state.p_ch4 = (state.C[G_CH4] * parameters.R * state.help_T_op / 64.0);
    state.p_co2 = (state.C[G_CO2] * parameters.R * state.help_T_op);
    state.p_h2 = (state.C[G_H2] * parameters.R * state.help_T_op / 16.0);
    state.p_h2o = 0.0313 * exp(5290*(1.0/parameters.T_Ref - 1.0/state.help_T_op));
     

	   
	  state.Q_Gas = IF ((state.P_headspace - parameters.P_atm) * parameters.K_p <= 0.0) THEN 0.0
	     ELSE (state.P_headspace - parameters.P_atm) * parameters.K_p ;
  
    state.C_Ion[S_nh3] = (state.C[S_INN] - state.S_nh4_ion) ;
    state.C_Ion[S_hco3_ion] = MSLU_HCO_ion(state.Ka_ic, state.C[S_IC], state.S_h_ion) ;
    state.C_Ion[S_ac_ion] = MSLU_ac_ion(parameters.Ka_ac, state.C[S_ac], state.S_h_ion) ;
    state.C_Ion[S_pro_ion] = MSLU_pro_ion(parameters.Ka_pro, state.C[S_pro], state.S_h_ion) ;
    state.C_Ion[S_bu_ion] = MSLU_bu_ion(parameters.Ka_bu, state.C[S_bu], state.S_h_ion) ;
    state.C_Ion[S_va_ion] = MSLU_va_ion(parameters.Ka_va, state.C[S_va], state.S_h_ion) ;
    
    state.C_h2 = MSLUNewtonRaphson_h2(state.Q_In, parameters.V_liq, interface.Inflow[S_h2], previous(state.C_h2),
      parameters.Y_su, parameters.f_h2_su, state.Kinetics[uptake_su], parameters.Y_aa, parameters.f_h2_aa,
      state.Kinetics[uptake_aa], parameters.Y_fa, parameters.km_fa, state.C[S_fa], parameters.Ks_fa,state.C[X_fa],
      state.I_pH_bac, state.I_NH_limit, parameters.KI_h2_fa, parameters.Y_c4, parameters.km_c4, state.C[S_va],
      parameters.Ks_c4, state.C[X_c4], state.C[S_bu], parameters.KI_h2_c4, parameters.Y_pro, parameters.km_pro, 
      state.C[S_pro], parameters.Ks_pro, state.C[X_pro], parameters.KI_h2_pro, parameters.km_h2, parameters.Ks_h2,
      state.C[X_h2], state.I_pH_h2, parameters.kla, state.KH_h2, state.p_h2);

    interface.AD_pH = state.pH_;
    interface.AD_T = interface.T_op ;  
    interface.Gas_p_ch4 = state.p_ch4;
    interface.Gas_p_h2 = state.p_h2;
    interface.Gas_p_co2 = state.p_co2;
    interface.Gas_p_tot = state.P_headspace;
    interface.Gas_Q = state.Q_Gas * (state.P_headspace / parameters.P_atm);
    interface.AD_V_liq = parameters.V_liq ;
    interface.AD_V_tot = parameters.V_liq + parameters.V_gas ;
     
    {FOREACH Comp_Index IN {1 .. ADM1NrOfComponents}: interface.AD_C[Comp_Index] = state.C[Comp_Index] * 1000 ; };
    {FOREACH Comp_Index IN {1 .. ADM1NrOfIonComponents}: interface.AD_C_Ion[Comp_Index] = state.C_Ion[Comp_Index] * 1000 ; };
  };

:};

CLASS ADM1_DigesterConversionModel EXTENDS DigesterConversionModel WITH
{:

  
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1Model.interface.msl" 1
 

    OBJ T_op (*manip = "1"; terminal = "in_2"; *) "Operating temperature" : CelsiusTemperature := {: causality <- "CIN"; value <- 35.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Operational"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.parameters.msl" 1
 

    OBJ C_SI (* *) "Carbon content of soluble inert COD" : CarbonContentPerUnitCOD := {: value <- 0.03; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_XI (* *) "Carbon content of particulate inert COD" : CarbonContentPerUnitCOD := {: value <- 0.03; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_Xc (* *) "Carbon content of complex particulate COD" : CarbonContentPerUnitCOD := {: value <- 0.02786; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_aa (* *) "Carbon content of amino acids" : CarbonContentPerUnitCOD := {: value <- 0.03; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_ac (* *) "Carbon content of acetate" : CarbonContentPerUnitCOD := {: value <- 0.0313; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_biom (* *) "Carbon content of biomass" : CarbonContentPerUnitCOD := {: value <- 0.0313; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_bu (* *) "Carbon content of butyrate" : CarbonContentPerUnitCOD := {: value <- 0.025; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_ch (* *) "Carbon content of carbohydrates" : CarbonContentPerUnitCOD := {: value <- 0.0313; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_ch4 (* *) "Carbon content of methane" : CarbonContentPerUnitCOD := {: value <- 0.0156; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_fa (* *) "Carbon content of long chain fatty acids" : CarbonContentPerUnitCOD := {: value <- 0.0217; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_li (* *) "Carbon content of lipids" : CarbonContentPerUnitCOD := {: value <- 0.022; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_pr (* *) "Carbon content of proteines" : CarbonContentPerUnitCOD := {: value <- 0.03; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_pro (* *) "Carbon content of propionate" : CarbonContentPerUnitCOD := {: value <- 0.0268; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_su (* *) "Carbon content of sugars" : CarbonContentPerUnitCOD := {: value <- 0.0313; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ C_va (* *) "Carbon content of valerate" : CarbonContentPerUnitCOD := {: value <- 0.024; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Carbon"; :};
    OBJ KI_h2_c4 (* *) "Hydrogen inhibitory concentration for C4 degrading organisms" : Real := {: unit <- "kgCOD/m3"; value <- 1E-005; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : inhibition"; :};
    OBJ KI_h2_fa (* *) "Hydrogen inhibitory concentration for FA degrading organisms" : Real := {: unit <- "kgCOD/m3"; value <- 5E-006; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : inhibition"; :};
    OBJ KI_h2_pro (* *) "Inhibitory hydrogen concentration for propionate degrading organisms" : Real := {: unit <- "kgCOD/m3"; value <- 3.5E-006; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : inhibition"; :};
    OBJ KI_nh3_ac (* *) "Inhibitory free ammonia concentration for acetate degrading organisms" : Real := {: unit <- "M"; value <- 0.0018; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : inhibition"; :};
    OBJ Ka_ac (* *) "Acetate acidity constant" : Real := {: unit <- "M"; value <- 1.74e-5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ Ka_bu (* *) "Butyrate acidity constant" : Real := {: unit <- "M"; value <- 1.51e-5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ Ka_pro (* *) "Propionate acidity constant" : Real := {: unit <- "M"; value <- 1.32e-5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ Ka_va (* *) "Valerate acidity constant" : Real := {: unit <- "M"; value <- 1.38e-5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ Ks_IN (* *) "Inorganic nitrogen concentration at which growth ceases" : Real := {: unit <- "M"; value <- 0.0001; group <- "Kinetics : uptake rates"; :};
    OBJ Ks_aa (* *) "Half saturation constant for amino acid degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.3; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ Ks_ac (* *) "Half saturation constant for acetate degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.15; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ Ks_c4 (* *) "Half saturation constant for butyrate and valerate degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.2; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ Ks_fa (* *) "Half saturation constant for long chain fatty acids degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.4; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ Ks_h2 (* *) "Half saturation constant for uptake of hydrogen" : Real := {: unit <- "kgCOD/m3"; value <- 7E-006; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ Ks_pro (* *) "Half saturation constant for propionate degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.1; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ Ks_su (* *) "Half saturation constant for monosaccharide degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ N_SI (* *) "Nitrogen content of soluble inert COD" : NitrogenContentPerUnitCOD := {: value <- 0.00428571428571429; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Nitrogen"; :};
    OBJ N_XI (* *) "Nitrogen content of particulate inert COD" : NitrogenContentPerUnitCOD := {: value <- 0.00428571428571429; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Nitrogen"; :};
    OBJ N_Xc (* *) "Nitrogen content of particulate degradable COD" : NitrogenContentPerUnitCOD := {: value <- 0.00268571428571429; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Nitrogen"; :};
    OBJ N_aa (* *) "Nitrogen content of amino acids" : NitrogenContentPerUnitCOD := {: value <- 0.007; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Nitrogen"; :};
    OBJ N_biom (* *) "Nitrogen content of  biomass" : NitrogenContentPerUnitCOD := {: value <- 0.00571428571428571; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Nitrogen"; :};
    OBJ R (* hidden = "1"; *) "Gas law constant" : Real := {: unit <- "bar/M/K"; value <- 0.08314; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; :};
    OBJ T_Ref (* hidden = "1"; *) "Reference temperature" : KelvinTemperature := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; :};
    OBJ Y_aa (* *) "Yield of biomass on uptake of amino acids" : Ratio := {: value <- 0.08; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Yields"; :};
    OBJ Y_ac (* *) "Yield of biomass on uptake of acetate" : Ratio := {: value <- 0.05; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Yields"; :};
    OBJ Y_c4 (* *) "Yield of biomass on uptake of valerate or butyrate" : Ratio := {: value <- 0.06; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Yields"; :};
    OBJ Y_fa (* *) "Yield of biomass on uptake of long chain fatty acids" : Ratio := {: value <- 0.06; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Yields"; :};
    OBJ Y_h2 (* *) "Yield of biomass on uptake of elemental hydrogen" : Ratio := {: value <- 0.06; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Yields"; :};
    OBJ Y_pro (* *) "Yield of biomass on uptake of propionate" : Ratio := {: value <- 0.04; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Yields"; :};
    OBJ Y_su (* *) "Yield of biomass on uptake of monosaccharides" : Ratio := {: value <- 0.1; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Yields"; :};
    OBJ f_SI_xc (* *) "Yield of soluble inerts from disintegration of complex particulates" : Ratio := {: value <- 0.1; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_XI_xc (* *) "Yield of particulate inerts from disintegration of complex particulates" : Ratio := {: value <- 0.2; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_ac_aa (* *) "Yield of acetate from amino acid degradation" : Ratio := {: value <- 0.4; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_ac_su (* *) "Yield of acetate from sugar degradation" : Ratio := {: value <- 0.41; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_bu_aa (* *) "Yield of butyrate from amino acid degradation" : Ratio := {: value <- 0.26; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_bu_su (* *) "Yield of butyrate from monosaccharide degradation" : Ratio := {: value <- 0.13; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_ch_xc (* *) "Yield of carbohydrates from disintegration of complex particulates" : Ratio := {: value <- 0.2; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_fa_li (* *) "Yield of long chain fatty acids (as opposed to glycerol) from lipids" : Ratio := {: value <- 0.95; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_h2_aa (* *) "Yield of hydrogen from amino acid degradation" : Ratio := {: value <- 0.06; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_h2_su (* *) "Yield of hydrogen from monosaccharide degradation" : Ratio := {: value <- 0.19; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_li_xc (* *) "Yield of lipids from disintegration of complex particulates" : Ratio := {: value <- 0.3; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_pr_xc (* *) "Yield of proteins from disintegration of complex particulates" : Ratio := {: value <- 0.2; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_pro_aa (* *) "Yield of propionate from amino acid degradation" : Ratio := {: value <- 0.05; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_pro_su (* *) "Yield of propionate from monosaccharide degradation" : Ratio := {: value <- 0.27; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ f_va_aa (* *) "Yield of valerate from amino acid degradation" : Ratio := {: value <- 0.23; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Stoichiometry - Fractions"; :};
    OBJ kdec_xaa (* *) "Decay rate for amino acid degrading organisms" : DecayCoefficient := {: value <- 0.02; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : decay"; :};
    OBJ kdec_xac (* *) "Decay rate for acetate degrading organisms" : DecayCoefficient := {: value <- 0.02; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : decay"; :};
    OBJ kdec_xc4 (* *) "Decay rate for butyrate and valerate degrading organisms" : DecayCoefficient := {: value <- 0.02; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : decay"; :};
    OBJ kdec_xfa (* *) "Decay rate for long chain fatty acid degrading organisms" : DecayCoefficient := {: value <- 0.02; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : decay"; :};
    OBJ kdec_xh2 (* *) "Decay rate for hydrogen degrading organisms" : DecayCoefficient := {: value <- 0.02; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : decay"; :};
    OBJ kdec_xpro (* *) "Decay rate for propionate degrading organisms" : DecayCoefficient := {: value <- 0.02; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : decay"; :};
    OBJ kdec_xsu (* *) "Decay rate for monosaccharide degrading organisms" : DecayCoefficient := {: value <- 0.02; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : decay"; :};
    OBJ kdis (* *) "Complex particulate disintegration first order rate constant" : RateConstant := {: value <- 0.5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : disintegration"; :};
    OBJ khyd_ch (* *) "Carbohydrate hydrolysis first order rate constant" : RateConstant := {: value <- 10.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : hydrolysis"; :};
    OBJ khyd_li (* *) "Lipid hydrolysis first order rate constant" : RateConstant := {: value <- 10.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : hydrolysis"; :};
    OBJ khyd_pr (* *) "Protein hydrolysis first order rate constant" : RateConstant := {: value <- 10.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : hydrolysis"; :};
    OBJ kla (* *) "Gas liquid transfer coefficient" : OxygenTransferCoefficient := {: value <- 200.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Operational"; :};
    OBJ km_aa (* *) "Maximum uptake rate amino acid degrading organisms" : MaxUptakeRate := {: value <- 50.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ km_ac (* *) "Maximum uptake rate for acetate degrading organisms" : MaxUptakeRate := {: value <- 8.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ km_c4 (* *) "Maximum uptake rate for c4 degrading organisms" : MaxUptakeRate := {: value <- 20.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ km_fa (* *) "Maximum uptake rate for long chain fatty acid degrading organisms" : MaxUptakeRate := {: value <- 6.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ km_h2 (* *) "Maximum uptake rate for hydrogen degrading organisms" : MaxUptakeRate := {: value <- 35.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ km_pro (* *) "Maximum uptake rate for propionate degrading organisms" : MaxUptakeRate := {: value <- 13.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ km_su (* *) "Maximum uptake rate for monosaccharide degrading organisms" : MaxUptakeRate := {: value <- 30.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ mode (* is_favorite = "1"; *) "Fixed (0) vs. dynamic (1) pH" : Integer := {: value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 1.0; :}; group <- "Operational"; :};
    OBJ pH_ac_ll (* *) "pH level at which there is full inhibition of acetate degradation" : pH := {: value <- 6.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ pH_ac_ul (* *) "pH level at which there is no inhibition of acetate degrading organisms" : pH := {: value <- 7.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ pH_bac_ll (* *) "pH level at which there is full inhibition" : pH := {: value <- 4.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ pH_bac_ul (* *) "pH level at which there is no inhibition" : pH := {: value <- 5.5; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ pH_h2_ll (* *) "H level at which there is full inhibition of hydrogen degrading organisms" : pH := {: value <- 5.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ pH_h2_ul (* *) "pH level at which there is no inhibition of hydrogen degrading organisms" : pH := {: value <- 6.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : uptake rates"; :};
    OBJ pHss (* is_favorite = "1"; *) "Estimated pH at steady-state (for initialisation)" : Real := {: value <- 7.27; interval <- {: lowerBound <- 1.0; upperBound <- 13.0; :}; group <- "Operational"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.state.msl" 1
 

    OBJ I_NH_limit (* *) "Function to limit growth due to lack of inorganic nitrogen" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ I_h2_c4 (* *) "Hydrogen inhibition for C4+ degradation" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ I_h2_fa (* *) "Hydrogen inhibition for LCFA degradation" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ I_h2_pro (* *) "Hydrogen inhibition for propionate" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ I_nh3_ac (* *) "NH3 inhibition of acetoclastic methanogenesis" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ I_pH_ac (* *) "pH inhibition of acetate degrading organisms" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ I_pH_bac (* *) "pH inhibition of acetogens and acidogens" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ I_pH_h2 (* *) "pH inhibition of hydrogen degrading organisms" : InhibitionTerm := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics : Inhibition"; :};
    OBJ KH_ch4 (* *) "Henry's law constant (T-dep) for CH4" : Ratio := {: group <- "System"; :};
    OBJ KH_co2 (* *) "Henry's law constant (T-dep) for CO2" : Ratio := {: group <- "System"; :};
    OBJ KH_h2 (* *) "Henry's coefficient for H2 with temperature correction" : Ratio := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ Ka_ic (* *) "Inorganic carbon acidity constant" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ Ka_in (* *) "Inorganic nitrogen acidity constant" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ Kw (* *) "Water acidity constant" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "System"; :};
    OBJ S_co2 (* *) "Carbon dioxide" : MolConcentration := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ S_h_ion (* *) "Hydrogen ion" : MolConcentration := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ S_nh4_ion (* *) "Ammonium ion" : MolConcentration := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Concentration"; :};
    OBJ charge_balance (* *) "Left hand-side of charge balance" : Real := {: group <- "Concentration"; :};
    OBJ help_T_op (* hidden = "1"; *) "Temperature" : KelvinTemperature := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; :};
    OBJ n_ac (* *) "state needed in Hill function" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics"; :};
    OBJ n_bac (* *) "state needed in Hill function" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics"; :};
    OBJ n_h2 (* *) "state needed in Hill function" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics"; :};
    OBJ pHLim_ac (* hidden = "1"; *) "state needed in Hill function" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics"; :};
    OBJ pHLim_bac (* hidden = "1"; *) "state needed in Hill function" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics"; :};
    OBJ pHLim_h2 (* hidden = "1"; *) "state needed in Hill function" : Real := {: value <- 0.0; interval <- {: lowerBound <- -INF; upperBound <- +INF; :}; group <- "Kinetics"; :};
    OBJ pH_ (* *) "pH" : pH := {: group <- "Operational"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.body.msl" 2

  };

  initial <-
  {
     

    parameters.T_Ref := 25 + 273.15;

     

    state.n_ac := 3.0 / (parameters.pH_ac_ul - parameters.pH_ac_ll);
    state.n_bac := 3.0 / (parameters.pH_bac_ul - parameters.pH_bac_ll);
    state.n_h2 := 3.0 / (parameters.pH_h2_ul - parameters.pH_h2_ll);
    state.pHLim_ac := pow(10,(-(parameters.pH_ac_ul + parameters.pH_ac_ll)/2.0));
    state.pHLim_bac := pow(10,(-(parameters.pH_bac_ul + parameters.pH_bac_ll)/2.0));
    state.pHLim_h2 := pow(10,(-(parameters.pH_h2_ul + parameters.pH_h2_ll)/2.0));

     

         
         
         
        state.S_h_ion = pow(10, -parameters.pHss) ;
        

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.stoichiometry.msl" 1
 

    parameters.Stoichiometry[decay_aa][S_INN] := parameters.N_biom - parameters.N_Xc;
    parameters.Stoichiometry[decay_aa][S_IC] := parameters.C_biom - parameters.C_Xc;
    parameters.Stoichiometry[decay_aa][X_aa] := -1;
    parameters.Stoichiometry[decay_aa][X_c] := 1;
    parameters.Stoichiometry[decay_ac][S_INN] := parameters.N_biom - parameters.N_Xc;
    parameters.Stoichiometry[decay_ac][S_IC] := parameters.C_biom - parameters.C_Xc;
    parameters.Stoichiometry[decay_ac][X_ac] := -1;
    parameters.Stoichiometry[decay_ac][X_c] := 1;
    parameters.Stoichiometry[decay_c4][S_INN] := parameters.N_biom - parameters.N_Xc;
    parameters.Stoichiometry[decay_c4][S_IC] := parameters.C_biom - parameters.C_Xc;
    parameters.Stoichiometry[decay_c4][X_c] := 1;
    parameters.Stoichiometry[decay_c4][X_c4] := -1;
    parameters.Stoichiometry[decay_fa][S_INN] := parameters.N_biom - parameters.N_Xc;
    parameters.Stoichiometry[decay_fa][S_IC] := parameters.C_biom - parameters.C_Xc;
    parameters.Stoichiometry[decay_fa][X_c] := 1;
    parameters.Stoichiometry[decay_fa][X_fa] := -1;
    parameters.Stoichiometry[decay_h2][S_INN] := parameters.N_biom - parameters.N_Xc;
    parameters.Stoichiometry[decay_h2][S_IC] := parameters.C_biom - parameters.C_Xc;
    parameters.Stoichiometry[decay_h2][X_c] := 1;
    parameters.Stoichiometry[decay_h2][X_h2] := -1;
    parameters.Stoichiometry[decay_pro][S_INN] := parameters.N_biom - parameters.N_Xc;
    parameters.Stoichiometry[decay_pro][S_IC] := parameters.C_biom - parameters.C_Xc;
    parameters.Stoichiometry[decay_pro][X_c] := 1;
    parameters.Stoichiometry[decay_pro][X_pro] := -1;
    parameters.Stoichiometry[decay_su][S_INN] := parameters.N_biom - parameters.N_Xc;
    parameters.Stoichiometry[decay_su][S_IC] := parameters.C_biom - parameters.C_Xc;
    parameters.Stoichiometry[decay_su][X_c] := 1;
    parameters.Stoichiometry[decay_su][X_su] := -1;
    parameters.Stoichiometry[dis][S_INN] := parameters.N_Xc -parameters.f_XI_xc * parameters.N_XI -parameters.f_SI_xc * parameters.N_SI -parameters.f_pr_xc * parameters.N_aa;
    parameters.Stoichiometry[dis][S_IC] := parameters.C_Xc - parameters.f_ch_xc * parameters.C_ch - parameters.f_SI_xc * parameters.C_SI - parameters.f_pr_xc * parameters.C_pr -  parameters.f_XI_xc * parameters.C_XI - parameters.f_li_xc * parameters.C_li;
    parameters.Stoichiometry[dis][S_Inert] := parameters.f_SI_xc;
    parameters.Stoichiometry[dis][X_c] := -1;
    parameters.Stoichiometry[dis][X_ch] := parameters.f_ch_xc;
    parameters.Stoichiometry[dis][X_Inert] := parameters.f_XI_xc;
    parameters.Stoichiometry[dis][X_li] := parameters.f_li_xc;
    parameters.Stoichiometry[dis][X_pr] := parameters.f_pr_xc;
    parameters.Stoichiometry[hyd_ch][S_IC] := parameters.C_ch - parameters.C_su;
    parameters.Stoichiometry[hyd_ch][S_su] := 1;
    parameters.Stoichiometry[hyd_ch][X_ch] := -1;
    parameters.Stoichiometry[hyd_li][S_IC] := (parameters.f_fa_li - 1) * parameters.C_su - parameters.f_fa_li * parameters.C_fa + parameters.C_li;
    parameters.Stoichiometry[hyd_li][S_fa] := parameters.f_fa_li;
    parameters.Stoichiometry[hyd_li][S_su] := 1 - parameters.f_fa_li;
    parameters.Stoichiometry[hyd_li][X_li] := -1;
    parameters.Stoichiometry[hyd_pr][S_IC] := parameters.C_aa - parameters.C_pr;
    parameters.Stoichiometry[hyd_pr][S_aa] := 1;
    parameters.Stoichiometry[hyd_pr][X_pr] := -1;
    parameters.Stoichiometry[uptake_aa][S_INN] := parameters.N_aa - parameters.Y_aa * parameters.N_biom;
    parameters.Stoichiometry[uptake_aa][S_IC] := parameters.C_aa - (1-parameters.Y_aa) * parameters.f_ac_aa * parameters.C_ac - (1-parameters.Y_aa) * parameters.f_bu_aa * parameters.C_bu -(1 -parameters.Y_aa) * parameters.f_pro_aa * parameters.C_pro -(1-parameters.Y_aa) * parameters.f_va_aa * parameters.C_va - parameters.Y_aa * parameters.C_biom;
    parameters.Stoichiometry[uptake_aa][S_h2] := (1 - parameters.Y_aa) * parameters.f_h2_aa;
    parameters.Stoichiometry[uptake_aa][S_aa] := -1;
    parameters.Stoichiometry[uptake_aa][S_ac] := (1 - parameters.Y_aa) * parameters.f_ac_aa;
    parameters.Stoichiometry[uptake_aa][S_bu] := (1 - parameters.Y_aa) * parameters.f_bu_aa;
    parameters.Stoichiometry[uptake_aa][S_pro] := (1 - parameters.Y_aa) * parameters.f_pro_aa;
    parameters.Stoichiometry[uptake_aa][S_va] := (1 - parameters.Y_aa) * parameters.f_va_aa;
    parameters.Stoichiometry[uptake_aa][X_aa] := parameters.Y_aa;
    parameters.Stoichiometry[uptake_ac][S_INN] := -parameters.N_biom * parameters.Y_ac;
    parameters.Stoichiometry[uptake_ac][S_IC] := parameters.C_ac - parameters.Y_ac * parameters.C_biom - (1 - parameters.Y_ac) * parameters.C_ch4;
    parameters.Stoichiometry[uptake_ac][S_ch4] := 1-parameters.Y_ac;
    parameters.Stoichiometry[uptake_ac][S_ac] := -1;
    parameters.Stoichiometry[uptake_ac][X_ac] := parameters.Y_ac;
    parameters.Stoichiometry[uptake_bu][S_INN] := -parameters.N_biom * parameters.Y_c4;
    parameters.Stoichiometry[uptake_bu][S_IC] := parameters.C_bu - (1 - parameters.Y_c4) * 0.8 * parameters.C_ac - parameters.Y_c4 * parameters.C_biom;
    parameters.Stoichiometry[uptake_bu][S_h2] := (1 - parameters.Y_c4 ) * 0.2;
    parameters.Stoichiometry[uptake_bu][S_ac] := (1 - parameters.Y_c4) * 0.8;
    parameters.Stoichiometry[uptake_bu][S_bu] := -1;
    parameters.Stoichiometry[uptake_bu][X_c4] := parameters.Y_c4;
    parameters.Stoichiometry[uptake_fa][S_INN] := -parameters.N_biom * parameters.Y_fa;
    parameters.Stoichiometry[uptake_fa][S_IC] := parameters.C_fa - (1 - parameters.Y_fa) * 0.7 * parameters.C_ac - parameters.Y_fa * parameters.C_biom;
    parameters.Stoichiometry[uptake_fa][S_h2] := (1 - parameters.Y_fa) * 0.3;
    parameters.Stoichiometry[uptake_fa][S_ac] := (1 - parameters.Y_fa) * 0.7;
    parameters.Stoichiometry[uptake_fa][S_fa] := -1;
    parameters.Stoichiometry[uptake_fa][X_fa] := parameters.Y_fa;
    parameters.Stoichiometry[uptake_h2][S_INN] := -parameters.N_biom * parameters.Y_h2;
    parameters.Stoichiometry[uptake_h2][S_IC] := -parameters.Y_h2 * parameters.C_biom - (1 - parameters.Y_h2) * parameters.C_ch4;
    parameters.Stoichiometry[uptake_h2][S_ch4] := 1 - parameters.Y_h2;
    parameters.Stoichiometry[uptake_h2][S_h2] := -1;
    parameters.Stoichiometry[uptake_h2][X_h2] := parameters.Y_h2;
    parameters.Stoichiometry[uptake_pro][S_INN] := -parameters.N_biom * parameters.Y_pro;
    parameters.Stoichiometry[uptake_pro][S_IC] := parameters.C_pro - (1 - parameters.Y_pro) * 0.57 * parameters.C_ac -parameters.Y_pro * parameters.C_biom;
    parameters.Stoichiometry[uptake_pro][S_h2] := (1 - parameters.Y_pro) * 0.43;
    parameters.Stoichiometry[uptake_pro][S_ac] := (1 - parameters.Y_pro) * 0.57;
    parameters.Stoichiometry[uptake_pro][S_pro] := -1;
    parameters.Stoichiometry[uptake_pro][X_pro] := parameters.Y_pro;
    parameters.Stoichiometry[uptake_su][S_INN] := -parameters.N_biom * parameters.Y_su;
    parameters.Stoichiometry[uptake_su][S_IC] := parameters.C_su - (1 - parameters.Y_su) * parameters.f_ac_su * parameters.C_ac -(1 - parameters.Y_su) * parameters.f_pro_su * parameters.C_pro - (1 - parameters.Y_su) * parameters.f_bu_su * parameters.C_bu - parameters.Y_su * parameters.C_biom;
    parameters.Stoichiometry[uptake_su][S_h2] := (1 - parameters.Y_su) * parameters.f_h2_su;
    parameters.Stoichiometry[uptake_su][S_ac] := (1 - parameters.Y_su) * parameters.f_ac_su;
    parameters.Stoichiometry[uptake_su][S_bu] := (1 - parameters.Y_su) * parameters.f_bu_su;
    parameters.Stoichiometry[uptake_su][S_pro] := (1 - parameters.Y_su) * parameters.f_pro_su;
    parameters.Stoichiometry[uptake_su][S_su] := -1;
    parameters.Stoichiometry[uptake_su][X_su] := parameters.Y_su;
    parameters.Stoichiometry[uptake_va][S_INN] := -parameters.N_biom * parameters.Y_c4;
    parameters.Stoichiometry[uptake_va][S_IC] := parameters.C_va - (1 - parameters.Y_c4) * 0.54 * parameters.C_pro - parameters.Y_c4 * parameters.C_biom - (1 - parameters.Y_c4) * 0.31 * parameters.C_ac;
    parameters.Stoichiometry[uptake_va][S_h2] := (1 - parameters.Y_c4) * 0.15;
    parameters.Stoichiometry[uptake_va][S_ac] := (1 - parameters.Y_c4) * 0.31;
    parameters.Stoichiometry[uptake_va][S_pro] := (1 - parameters.Y_c4) * 0.54;
    parameters.Stoichiometry[uptake_va][S_va] := -1;
    parameters.Stoichiometry[uptake_va][X_c4] := parameters.Y_c4;
    parameters.Stoichiometry[transfer_co2][S_IC_liq] := -1;
    parameters.Stoichiometry[transfer_co2][G_CO2] := 1;
    parameters.Stoichiometry[transfer_h2][S_h2_liq] := -1;
    parameters.Stoichiometry[transfer_h2][G_H2] := 1;
    parameters.Stoichiometry[transfer_ch4][S_ch4_liq] := -1;
    parameters.Stoichiometry[transfer_ch4][G_CH4] := 1;

# 43 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.I_NH_limit = IF (state.C[S_INN] < 0.00000001) THEN 0 ELSE 1 / (parameters.Ks_IN / state.C[S_INN] + 1);
    state.I_h2_c4 = 1 / (state.C_h2 / parameters.KI_h2_c4 + 1);
    state.I_h2_fa = 1 / (state.C_h2 / parameters.KI_h2_fa + 1);
    state.I_h2_pro = 1 / ( state.C_h2 / parameters.KI_h2_pro + 1);
    state.I_nh3_ac = 1 / (state.C_Ion[S_nh3] / parameters.KI_nh3_ac + 1);
    state.I_pH_ac = pow(state.pHLim_ac,state.n_ac)/(pow(state.S_h_ion,state.n_ac)+pow(state.pHLim_ac ,state.n_ac));
    state.I_pH_bac = pow(state.pHLim_bac,state.n_bac)/(pow(state.S_h_ion,state.n_bac)+pow(state.pHLim_bac ,state.n_bac));
    state.I_pH_h2 = pow(state.pHLim_h2,state.n_h2)/(pow(state.S_h_ion,state.n_h2)+pow(state.pHLim_h2 ,state.n_h2));
    state.KH_ch4 = 0.0014 * exp(-14240/(parameters.R*100)*(1/parameters.T_Ref - 1/state.help_T_op));
    state.KH_co2 = 0.035 * exp(-19410/(parameters.R*100)*(1/parameters.T_Ref - 1/state.help_T_op));
    state.KH_h2 = 7.8e-4 * exp(-4180/(parameters.R*100)*(1/parameters.T_Ref - 1/state.help_T_op));
    state.Ka_ic = pow(10,-6.35)*(exp(7646*(1/parameters.T_Ref - 1/state.help_T_op)/(100*parameters.R)));
    state.Ka_in = pow(10,-9.25)*(exp(51965*(1/parameters.T_Ref - 1/state.help_T_op)/(100*parameters.R)));
    state.Kw = pow(10,-14)*(exp(55900*(1/parameters.T_Ref - 1/state.help_T_op)/(100*parameters.R)));
    state.S_co2 = state.C[S_IC] - state.C_Ion[S_hco3_ion];
    state.S_nh4_ion = MSLU_NH_ion(state.Ka_in,state.C[S_INN],state.S_h_ion);
    state.charge_balance = state.S_h_ion + state.C[S_cat] + state.S_nh4_ion - state.C[S_an] - state.Kw/state.S_h_ion - state.C_Ion[S_hco3_ion] - state.C_Ion[S_ac_ion]/64.0 - state.C_Ion[S_pro_ion]/112.0 - state.C_Ion[S_bu_ion]/160.0 - state.C_Ion[S_va_ion]/208.0;
    state.help_T_op = interface.T_op + 273.15;
    state.pH_ = -log10(state.S_h_ion);

     

        state.S_h_ion = IF (parameters.mode > 0.0) THEN MSLUNewtonRaphson_pH(state.Ka_in, state.Ka_ic, parameters.Ka_ac, parameters.Ka_bu, parameters.Ka_va, parameters.Ka_pro, state.Kw, state.C[S_INN], state.C[S_IC], state.C[S_ac], state.C[S_bu], state.C[S_va], state.C[S_pro], state.C[S_cat], state.C[S_an], previous(state.S_h_ion))
          ELSE pow(10, -parameters.pHss) ;
        

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.kinetics.msl" 1
 

    state.Kinetics[decay_aa] = parameters.kdec_xaa * state.C[X_aa];
    state.Kinetics[decay_ac] = parameters.kdec_xac * state.C[X_ac];
    state.Kinetics[decay_c4] = parameters.kdec_xc4 * state.C[X_c4];
    state.Kinetics[decay_fa] = parameters.kdec_xfa * state.C[X_fa];
    state.Kinetics[decay_h2] = parameters.kdec_xh2 * state.C[X_h2];
    state.Kinetics[decay_pro] = parameters.kdec_xpro * state.C[X_pro];
    state.Kinetics[decay_su] = parameters.kdec_xsu * state.C[X_su];
    state.Kinetics[dis] = parameters.kdis * state.C[X_c];
    state.Kinetics[hyd_ch] = parameters.khyd_ch * state.C[X_ch];
    state.Kinetics[hyd_li] = parameters.khyd_li * state.C[X_li];
    state.Kinetics[hyd_pr] = parameters.khyd_pr * state.C[X_pr];
    state.Kinetics[transfer_ch4] = parameters.kla * (state.C[S_ch4] - state.KH_ch4 * state.C[G_CH4] * parameters.R * state.help_T_op);
    state.Kinetics[transfer_co2] = parameters.kla * (state.S_co2 - state.KH_co2 * state.C[G_CO2] * parameters.R * state.help_T_op);
    state.Kinetics[transfer_h2] = parameters.kla * (state.C_h2 - state.KH_h2 * state.C[G_H2] * parameters.R * state.help_T_op);
    state.Kinetics[uptake_aa] = parameters.km_aa * state.C[X_aa] * state.C[S_aa] /(parameters.Ks_aa + state.C[S_aa]) * state.I_pH_bac * state.I_NH_limit;
    state.Kinetics[uptake_ac] = parameters.km_ac * state.C[X_ac] * state.C[S_ac] / (parameters.Ks_ac + state.C[S_ac]) * state.I_pH_ac * state.I_nh3_ac * state.I_NH_limit;
    state.Kinetics[uptake_bu] = parameters.km_c4 * state.C[X_c4] * state.C[S_bu] / (parameters.Ks_c4 + state.C[S_bu]) * state.C[S_bu] / (state.C[S_bu] + state.C[S_va] + 0.000001) * state.I_pH_bac * state.I_h2_c4 * state.I_NH_limit;
    state.Kinetics[uptake_fa] = parameters.km_fa * state.C[X_fa] * state.C[S_fa] / (parameters.Ks_fa + state.C[S_fa]) * state.I_pH_bac * state.I_h2_fa * state.I_NH_limit;
    state.Kinetics[uptake_h2] = parameters.km_h2 * state.C[X_h2] * state.C_h2 / (parameters.Ks_h2 + state.C_h2) * state.I_pH_h2 * state.I_NH_limit;
    state.Kinetics[uptake_pro] = parameters.km_pro * state.C[X_pro] * state.C[S_pro] / (parameters.Ks_pro + state.C[S_pro]) * state.I_pH_bac * state.I_h2_pro * state.I_NH_limit;
    state.Kinetics[uptake_su] = parameters.km_su * state.C[X_su] * state.C[S_su] / (parameters.Ks_su + state.C[S_su]) * state.I_pH_bac * state.I_NH_limit;
    state.Kinetics[uptake_va] = parameters.km_c4 * state.C[X_c4] * state.C[S_va] / (parameters.Ks_c4 + state.C[S_va]) * state.C[S_va] / (state.C[S_va] + state.C[S_bu] + 0.000001) * state.I_pH_bac * state.I_h2_c4 * state.I_NH_limit;

# 78 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1Model.sensors.msl" 1
 


# 82 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ADM1/wwtp.VolumeADM1ConversionModel.body.msl" 2

  };

# 123 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.ADM1.msl" 2


:};

CLASS DigesterConversionModel EXTENDS BaseDigester WITH
{:

  parameters <- 
  { 
    OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[ADM1NrOfReactions;][ADM1NrOfComponents,];
  };

  state <- 
  { 
    OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[ADM1NrOfReactions;];
 
  };

  equations <- 
  {
     
    state.ConversionTermPerComponent[S_INN] = SUMOVER Reaction_Index IN {1 .. ADM1NrOfReactions}:
      (parameters.Stoichiometry[Reaction_Index][S_INN] * state.Kinetics[Reaction_Index]) * parameters.V_liq ;
     
    state.ConversionTermPerComponent[S_IC] = parameters.Stoichiometry[transfer_co2][S_IC_liq] * state.Kinetics[transfer_co2] * parameters.V_liq +
      (SUMOVER Reaction_Index IN {1 .. ADM1NrOfReactions}:
      (parameters.Stoichiometry[Reaction_Index][S_IC] * state.Kinetics[Reaction_Index]) * parameters.V_liq) ;

    state.ConversionTermPerComponent[S_ch4] = parameters.Stoichiometry[transfer_ch4][S_ch4_liq] * state.Kinetics[transfer_ch4] * parameters.V_liq +
      (SUMOVER Reaction_Index IN {1 .. ADM1NrOfReactions}:
      (parameters.Stoichiometry[Reaction_Index][S_ch4] * state.Kinetics[Reaction_Index]) * parameters.V_liq) ;

    {FOREACH Comp_Index IN {S_aa .. S_cat} :
    state.ConversionTermPerComponent[Comp_Index] = SUMOVER Reaction_Index IN {1 .. ADM1NrOfReactions}:
      (parameters.Stoichiometry[Reaction_Index][Comp_Index] * state.Kinetics[Reaction_Index]) * parameters.V_liq ; };
    
     
    {FOREACH Comp_Index IN {G_CO2 .. G_CH4} :
    state.ConversionTermPerComponent[Comp_Index] = SUMOVER Reaction_Index IN {transfer_co2 .. transfer_ch4}:
      (parameters.Stoichiometry[Reaction_Index][Comp_Index] * state.Kinetics[Reaction_Index]) * parameters.V_liq ; };
  };

:};

CLASS BaseDigester SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" :  ADM1ConcTerminal := {: causality <- "CIN"; unit <- "kg/m3"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : ADM1ConcTerminal := {: causality <- "COUT"; unit <- "kg/m3"; group <- "Concentrate" :};
 
     
    OBJ Gas_Outflow (* terminal = "out_3" *) "Gasflow" : ADM1GasConcTerminal := {: causality <- "COUT"; group <- "Data" :};
  };
  
  parameters <-
  {
    OBJ V_liq (* is_favorite = "1";  *) "Volume of liquid in the reactor" : Volume := {: value <- 3400; group <- "Dimension"; :};
    OBJ V_gas (* is_favorite = "1";  *) "Volume of gas in the reactor" : Volume := {: value <- 300; group <- "Dimension"; :};
    OBJ f_X_Out "Fraction of solids that leaves the reactor" : Fraction := {: value <- 1.0; group <- "Operational" :};
  };
  
  state <-
  {
    OBJ M "Vector containing masses for all the components" : ADM1MassVector := [{: value <- 3400000:}, 
 
    {: value <- 10 :}, {: value <- 10 :}, {: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.0001 :}, {: value <- 0.1 :},
 
    {: value <- 0.0001 :}, {: value <- 0.1 :}, {: value <- 0.1 :},
 
    {: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.1 :},
 
    {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :},
 
    {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :},
 
    {: value <- 0.1 :}, {: value <- 100 :},
    {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 10 :} ; ] ;  

    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": ADM1MassFluxVector;
    OBJ OutFluxPerComponent (* hidden = "1" *) "Vector containing outgoing fluxes for all the components": ADM1MassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversion terms for all the components": ADM1MassFluxVector;
     
    OBJ C "Vector containing concentrations for all the components" : ADM1ConcentrationVector := {: group <- "Concentration" :};
    OBJ C_Ion "Vector containing masses for all ion components" : ADM1IonConcentrationVector := {: group <- "Concentration" :};
    OBJ C_h2 "Hydrogen concentration" : Concentration := {: group <- "Concentration" :};
     



    
    OBJ Q_In (* hidden = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational"; :};
    OBJ Q_Gas "Gas flow rate" : FlowRate := {: group <- "Effluent" :};
    OBJ SRT "Sludge age" : Time := {: group <- "Operational" :};
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };
  
  initial <-
  {
    state.M[H2O] = 1000 * parameters.V_liq ;    
  };
  
  equations <-
  {
	   
	  state.SRT = IF (state.Q_In <= 0.0) THEN 0.0 ELSE (parameters.V_liq / state.Q_In) / parameters.f_X_Out ;

     
	  state.Q_In = interface.Inflow[H2O] ;

	  {FOREACH Comp_Index IN {S_INN .. S_cat}:
	     state.InFluxPerComponent[Comp_Index] = interface.Inflow[Comp_Index] * state.Q_In ; };
	   
	  state.InFluxPerComponent[H2O]= state.Q_In * 1000 ;

     
     
    {FOREACH Comp_Index IN {S_INN .. S_ch4}:
        state.OutFluxPerComponent[Comp_Index] = (state.C[Comp_Index]) * state.Q_In ; };
     
    state.OutFluxPerComponent[S_h2] = (state.C_h2) * state.Q_In ;
     
    {FOREACH Comp_Index IN {S_aa .. S_va}:
        state.OutFluxPerComponent[Comp_Index] = (state.C[Comp_Index]) * state.Q_In ; };
     
    state.OutFluxPerComponent[S_an] = (state.C[S_an]) * state.Q_In ;
    state.OutFluxPerComponent[S_cat] = (state.C[S_cat]) * state.Q_In ;
     
    {FOREACH Comp_Index IN {G_CO2 .. G_CH4}:
        state.OutFluxPerComponent[Comp_Index] = (state.C[Comp_Index]) * state.Q_Gas ; };
        
     
     
    {FOREACH Comp_Index IN {X_aa .. X_su}:
        state.OutFluxPerComponent[Comp_Index] = parameters.f_X_Out * ((state.C[Comp_Index]) * state.Q_In) ; };
    
     
	  state.C[ADM1IndexOfSolvent] = 1000;
	  
    {FOREACH Comp_Index IN {S_INN .. S_ch4}: state.C[Comp_Index] = state.M[Comp_Index] / parameters.V_liq ; };
    
    {FOREACH Comp_Index IN {S_aa .. S_cat}: state.C[Comp_Index] = state.M[Comp_Index] / parameters.V_liq ; };
    
    {FOREACH Comp_Index IN {G_CO2 .. G_CH4} : state.C[Comp_Index] = state.M[Comp_Index] / parameters.V_gas ; };

     
    {FOREACH Comp_Index IN {S_INN .. S_ch4}: DERIV(state.M[Comp_Index],[independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.OutFluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index] ; };

    DERIV(state.M[S_h2],[independent.t]) = 0;
    
    {FOREACH Comp_Index IN {S_aa .. X_su}: DERIV(state.M[Comp_Index],[independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.OutFluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index] ; };

    {FOREACH Comp_Index IN {S_an .. S_cat}: DERIV(state.M[Comp_Index],[independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.OutFluxPerComponent[Comp_Index] ; };
    
    {FOREACH Comp_Index IN {G_CO2 .. G_CH4} : DERIV(state.M[Comp_Index],[independent.t]) =
      - state.OutFluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index] ; };

     
     
    interface.Outflow[H2O] = state.Q_In;  
    {FOREACH Comp_Index IN {S_INN .. S_ch4_liq}:
        interface.Outflow[Comp_Index] = state.C[Comp_Index] ; };

    interface.Outflow[S_h2] = state.C_h2 ; 
  
    {FOREACH Comp_Index IN {S_aa .. S_cat}:
        interface.Outflow[Comp_Index] = state.C[Comp_Index] ; };

    {FOREACH Comp_Index IN {G_CO2 .. G_CH4}:
        interface.Gas_Outflow[Comp_Index-30] = state.C[Comp_Index] ; };
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/anaerobic_digestion_unit/wwtp.digester.adm1.msl" 1
 




















CLASS FixVolumeADU (* icon = "anaerobic_digester"; is_default = "true" *)
SPECIALISES CoupledModelType :=
{:

  
  comments <- "ADM1 model for anaerobic digestion according to BSM2, including the interface transformers from and to ASM1";
  
  



  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     
    OBJ pH_AS (* terminal = "in_2"; manip = "1" *) "pH of the activated sludge": pH :={: causality <- "CIN"; value <- 7; group <- "Operational" :};
     
    OBJ pH_AD (* terminal = "in_2"; manip = "1" *) "pH of the digester": pH :={: causality <- "CIN"; value <- 6.8; group <- "Operational" :};
    OBJ T_op (* terminal = "in_2"; manip = "1" *) "Operating temperature": CelsiusTemperature := {: causality <- "CIN"; value <- 35; group <- "Operational" :};
    OBJ Gas_Outflow (* terminal = "out_3" *) "Biogas" : ADM1GasConcTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ AD_C (* terminal = "out_4" *) "Concentration of soluble and particulate components in the digester" : ADM1ConcVector := {: causality <- "COUT"; group <- "Concentration" :};
    OBJ AD_C_Ion (* terminal = "out_4" *) "Concentration of ionic species in the digester" : ADM1IonConcVector := {: causality <- "COUT"; group <- "Concentration" :};
    OBJ AD_pH (* is_favorite = "1"; terminal = "out_4" *) "pH in the digester" : pH := {: causality <- "COUT"; group <- "System" :};
    OBJ Gas_p_ch4 (* is_favorite = "1"; terminal = "out_4" *) "Methane partial pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "System" :};
    OBJ Gas_p_h2 (* terminal = "out_4" *) "Hydrogen partial pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "System" :};
    OBJ Gas_p_co2 (* is_favorite = "1"; terminal = "out_4" *) "CO2 partial pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "System" :};
    OBJ Gas_p_tot (* terminal = "out_4" *) "Total headspace pressure" : Pressure := {: unit <- "bar"; causality <- "COUT"; group <- "System" :};
    OBJ Gas_Q (* is_favorite = "1"; terminal = "out_4" *) "Biogas flow rate" : FlowRate := {: causality <- "COUT"; group <- "System" :};
  };

  parameters <-
  {
    OBJ mode (* is_favorite = "1"; *) "Fixed (0) vs. dynamic (1) pH" : Integer := {: value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 1.0; :}; group <- "Operational"; :};
    OBJ pHss (* is_favorite = "1"; *) "Estimated pH at steady-state (for initialisation)" : Real := {: value <- 7.27; interval <- {: lowerBound <- 1.0; upperBound <- 13.0; :}; group <- "Operational"; :};
    OBJ C_aa "Carbon content of amino acids" : CarbonContentPerUnitCOD := {: value <- 0.03; group <- "Stoichiometry" :};
    OBJ C_pr "Carbon content of proteines" : CarbonContentPerUnitCOD := {: value <- 0.03; group <- "Stoichiometry" :};
    OBJ C_ac "Carbon content of acetate" : CarbonContentPerUnitCOD := {: value <- 0.0313; group <- "Stoichiometry" :};
    OBJ C_biom "Carbon content of biomass" : CarbonContentPerUnitCOD := {: value <- 0.0313; group <- "Stoichiometry" :};
    OBJ C_bu "Carbon content of butyrate" : CarbonContentPerUnitCOD := {: value <- 0.025; group <- "Stoichiometry" :};
    OBJ C_ch4 "Carbon content of methane" : CarbonContentPerUnitCOD := {: value <- 0.0156; group <- "Stoichiometry" :};
    OBJ C_fa "Carbon content of long chain fatty acids" : CarbonContentPerUnitCOD := {: value <- 0.0217; group <- "Stoichiometry" :};
    OBJ C_li "Carbon content of lipids" : CarbonContentPerUnitCOD := {: value <- 0.022; group <- "Stoichiometry" :};
    OBJ C_pro "Carbon content of propionate" : CarbonContentPerUnitCOD := {: value <- 0.0268; group <- "Stoichiometry" :};
    OBJ C_SI "Carbon content of soluble inert COD" : CarbonContentPerUnitCOD := {: value <- 0.03; group <- "Stoichiometry" :};
    OBJ C_su "Carbon content of sugars" : CarbonContentPerUnitCOD := {: value <- 0.0313; group <- "Stoichiometry" :};
    OBJ C_ch "Carbon content of carbohydrates" : CarbonContentPerUnitCOD := {: value <- 0.0313; group <- "Stoichiometry" :};
    OBJ C_va "Carbon content of valerate" : CarbonContentPerUnitCOD := {: value <- 0.024; group <- "Stoichiometry" :};
    OBJ C_Xc "Carbon content of complex particulate COD" : CarbonContentPerUnitCOD := {: value <- 0.02786; group <- "Stoichiometry" :};
    OBJ C_XI "Carbon content of particulate inert COD" : CarbonContentPerUnitCOD := {: value <- 0.03; group <- "Stoichiometry" :};
    OBJ N_aa "Nitrogen content of amino acids" : NitrogenContentPerUnitCOD := {: value <- 0.007; group <- "Stoichiometry" :};
    OBJ N_biom "Nitrogen content of  biomass" : NitrogenContentPerUnitCOD := {: value <- 0.00571428571428571; group <- "Stoichiometry" :};
    OBJ N_SI "Nitrogen content of soluble inert COD" : NitrogenContentPerUnitCOD := {: value <- 0.00428571428571429; group <- "Stoichiometry" :};
    OBJ N_Xc "Nitrogen content of particulate degradable COD" : NitrogenContentPerUnitCOD := {: value <- 0.00268571428571429; group <- "Stoichiometry" :};
    OBJ N_XI "Nitrogen content of particulate inert COD" : NitrogenContentPerUnitCOD := {: value <- 0.00428571428571429; group <- "Stoichiometry" :};
    OBJ f_ac_su "Yield of acetate from sugar degradation" : Ratio := {: value <- 0.41; group <- "Stoichiometry" :};
    OBJ f_ac_aa "Yield of acetate from amino acid degradation" : Ratio := {: value <- 0.4; group <- "Stoichiometry" :};
    OBJ f_bu_aa "Yield of butyrate from amino acid degradation" : Ratio := {: value <- 0.26; group <- "Stoichiometry" :};
    OBJ f_ch_xc "Yield of carbohydrates from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
    OBJ f_fa_li "Yield of long chain fatty acids (as opposed to glycerol) from lipids" : Ratio := {: value <- 0.95; group <- "Stoichiometry" :};
    OBJ f_h2_aa "Yield of hydrogen from amino acid degradation" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
    OBJ f_pro_aa "Yield of propionate from amino acid degradation" : Ratio := {: value <- 0.05; group <- "Stoichiometry" :};
    OBJ f_pro_su "Yield of propionate from monosaccharide degradation" : Ratio := {: value <- 0.27; group <- "Stoichiometry" :};
    OBJ f_pr_xc "Yield of proteins from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
    OBJ f_SI_xc "Yield of soluble inerts from disintegration of complex particulates" : Ratio := {: value <- 0.1; group <- "Stoichiometry" :};
    OBJ f_va_aa "Yield of valerate from amino acid degradation" : Ratio := {: value <- 0.23; group <- "Stoichiometry" :};
    OBJ f_XI_xc "Yield of particulate inerts from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
    OBJ f_bu_su "Yield of butyrate from monosaccharide degradation" : Ratio := {: value <- 0.13; group <- "Stoichiometry" :};
    OBJ f_h2_su "Yield of hydrogen from monosaccharide degradation" : Ratio := {: value <- 0.19; group <- "Stoichiometry" :};
    OBJ f_li_xc "Yield of lipids from disintegration of complex particulates" : Ratio := {: value <- 0.3; group <- "Stoichiometry" :};
    OBJ Y_aa "Yield of biomass on uptake of amino acids" : Ratio := {: value <- 0.08; group <- "Stoichiometry" :};
    OBJ Y_ac "Yield of biomass on uptake of acetate" : Ratio := {: value <- 0.05; group <- "Stoichiometry" :};
    OBJ Y_c4 "Yield of biomass on uptake of valerate or butyrate" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
    OBJ Y_fa "Yield of biomass on uptake of long chain fatty acids" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
    OBJ Y_h2 "Yield of biomass on uptake of elemental hydrogen" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
    OBJ Y_pro "Yield of biomass on uptake of propionate" : Ratio := {: value <- 0.04; group <- "Stoichiometry" :};
    OBJ Y_su "Yield of biomass on uptake of monosaccharides" : Ratio := {: value <- 0.1; group <- "Stoichiometry" :};
    OBJ pH_ac_ll "pH level at which there is full inhibition of acetate degradation" : pH := {: value <- 6; group <- "Kinetics" :};
    OBJ pH_ac_ul "pH level at which there is no inhibition of acetate degrading organisms" : pH := {: value <- 7; group <- "Kinetics" :};
    OBJ pH_bac_ll "pH level at which there is full inhibition" : pH := {: value <- 4; group <- "Kinetics" :};
    OBJ pH_bac_ul "pH level at which there is no inhibition" : pH := {: value <- 5.5; group <- "Kinetics" :};
    OBJ pH_h2_ll "pH level at which there is full inhibition of hydrogen degrading organisms" : pH := {: value <- 5; group <- "Kinetics" :};
    OBJ pH_h2_ul "pH level at which there is no inhibition of hydrogen degrading organisms" : pH := {: value <- 6; group <- "Kinetics" :};
    OBJ KI_h2_fa "Hydrogen inhibitory concentration for FA degrading organisms" : Real := {: unit <- "kgCOD/m3"; value <- 5E-6; group <- "Kinetics" :};
    OBJ KI_h2_c4 "Hydrogen inhibitory concentration for C4 degrading organisms" : Real := {: unit <- "kgCOD/m3"; value <- 1E-5; group <- "Kinetics" :};
    OBJ KI_h2_pro "Inhibitory hydrogen concentration for propionate degrading organisms" : Real := {: unit <- "kgCOD/m3"; value <- 3.5E-6; group <- "Kinetics" :};
    OBJ KI_nh3_ac "Inhibitory free ammonia concentration for acetate degrading organisms" : Real := {: unit <- "kgCOD/m3"; value <- 0.0018; group <- "Kinetics" :};
    OBJ kdec_xaa "Decay rate for amino acid degrading organisms" : DecayCoefficient := {: value <- 0.02; group <- "Kinetics" :};
    OBJ kdec_xac "Decay rate for acetate degrading organisms" : DecayCoefficient := {: value <- 0.02; group <- "Kinetics" :};
    OBJ kdec_xc4 "Decay rate for butyrate and valerate degrading organisms" : DecayCoefficient := {: value <- 0.02; group <- "Kinetics" :};
    OBJ kdec_xfa "Decay rate for long chain fatty acid degrading organisms" : DecayCoefficient := {: value <- 0.02; group <- "Kinetics" :};
    OBJ kdec_xh2 "Decay rate for hydrogen degrading organisms" : DecayCoefficient := {: value <- 0.02; group <- "Kinetics" :};
    OBJ kdec_xpro "Decay rate for propionate degrading organisms" : DecayCoefficient := {: value <- 0.02; group <- "Kinetics" :};
    OBJ kdec_xsu "Decay rate for monosaccharide degrading organisms" : DecayCoefficient := {: value <- 0.02; group <- "Kinetics" :};
    OBJ kdis "Complex particulate disintegration first order rate constant" : RateConstant := {: value <- 0.5; group <- "Kinetics" :};
    OBJ khyd_ch "Carbohydrate hydrolysis first order rate constant" : RateConstant := {: value <- 10; group <- "Kinetics" :};
    OBJ khyd_li "Lipid hydrolysis first order rate constant" : RateConstant := {: value <- 10; group <- "Kinetics" :};
    OBJ khyd_pr "Protein hydrolysis first order rate constant" : RateConstant := {: value <- 10; group <- "Kinetics" :};
    
    OBJ kla "Gas liquid transfer coefficient" : OxygenTransferCoefficient := {: value <- 200; group <- "Operational" :};
    OBJ km_aa "Maximum uptake rate amino acid degrading organisms" : MaxUptakeRate := {: value <- 50; group <- "Kinetics" :};
    OBJ km_ac "Maximum uptake rate for acetate degrading organisms" : MaxUptakeRate := {: value <- 8; group <- "Kinetics" :};
    OBJ km_c4 "Maximum uptake rate for c4 degrading organisms" : MaxUptakeRate := {: value <- 20; group <- "Kinetics" :};
    OBJ km_fa "Maximum uptake rate for long chain fatty acid degrading organisms" : MaxUptakeRate := {: value <- 6; group <- "Kinetics" :};
    OBJ km_h2 "Maximum uptake rate for hydrogen degrading organisms" : MaxUptakeRate := {: value <- 35; group <- "Kinetics" :};
    OBJ km_pro "Maximum uptake rate for propionate degrading organisms" : MaxUptakeRate := {: value <- 13; group <- "Kinetics" :};
    OBJ km_su "Maximum uptake rate for monosaccharide degrading organisms" : MaxUptakeRate := {: value <- 30; group <- "Kinetics" :};
    OBJ Ks_aa "Half saturation constant for amino acid degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.3; group <- "Kinetics" :};
    OBJ Ks_ac "Half saturation constant for acetate degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.15; group <- "Kinetics" :};
    OBJ Ks_c4 "Half saturation constant for butyrate and valerate degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.2; group <- "Kinetics" :};
    OBJ Ks_fa "Half saturation constant for long chain fatty acids degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.4; group <- "Kinetics" :};
    OBJ Ks_h2 "Half saturation constant for uptake of hydrogen" : Real := {: unit <- "kgCOD/m3"; value <- 7E-6; group <- "Kinetics" :};
    OBJ Ks_IN "Inorganic nitrogen concentration at which growth ceases" : Real := {: unit <- "M"; value <- 0.0001; group <- "Kinetics" :};
    OBJ Ks_pro "Half saturation constant for propionate degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.1; group <- "Kinetics" :};
    OBJ Ks_su "Half saturation constant for monosaccharide degradation" : Real := {: unit <- "kgCOD/m3"; value <- 0.5; group <- "Kinetics" :};
    OBJ K_p "gas flow constant" : Real := {: value <- 50000; group <- "System" :};
    OBJ P_atm "Pressure of atmosphere" : Pressure := {: unit <- "bar"; value <- 1.013; group <- "Operational" :};
 
 
    OBJ V_gas "Volume of gas in the reactor" : Volume := {: value <- 300; group <- "Operational" :};
    OBJ V_liq "Volume of liquid in the reactor" : Volume := {: value <- 3400; group <- "Operational" :};
    OBJ f_X_Out "Fraction of the anaerobic particulate matter that leaves the reactor" : PhysicalQuantityType := {: value <- 1; group <- "Operational" :};
    OBJ naa "Nitrogen content of amino acids (gN/gCOD)" : NitrogenContentPerUnitCOD := {: value <- 0.098; group <- "Stoichiometry" :};
    OBJ nbac "nitrogen content of biomass (gN/gCOD)" : Fraction := {: value <- 0.08; group <- "Stoichiometry" :};
    OBJ nxc "nitrogen content of composites (gN/gCOD)" : Fraction := {: value <- 0.0376; group <- "Stoichiometry" :};
    OBJ nxi "nitrogen content of XI and XP (same in AS and AD) (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
    OBJ nsi "nitrogen content of SI in ASM (gN/gCOD)" : Fraction := {: value <- 0; group <- "Stoichiometry" :};
    OBJ nsi_adm "nitrogen content of SI in ADM (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
    OBJ T_ref "Reference temperature (i.e. 25degC)" : CelsiusTemperature := {: value <- 25; group <- "Operational" :};
    OBJ Ka_ac (* hidden ="1" *) "acetate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.74e-5 :}; 
    OBJ Ka_bu (* hidden ="1" *) "butyrate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.5e-5 :};
    OBJ Ka_pro (* hidden ="1" *) "propionate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.32e-5 :};
    OBJ Ka_va (* hidden ="1" *) "valerate acidity constant without temperature correction" : Real := {: unit <- "M"; value <- 1.38e-5 :};
    


    




  };

  sub_models <-
  {
     
    OBJ Tank : ADM1_Digester ;
    
    OBJ Trans_In : ASM1toADM1 ;
    OBJ Trans_Out : ADM1toASM1 ;
    
    



  };

  coupling <-
  {
    connect(interface.Inflow, sub_models.Trans_In.interface.Inflow),
    connect(sub_models.Trans_In.interface.Outflow, sub_models.Tank.interface.Inflow),
    connect(sub_models.Tank.interface.Outflow, sub_models.Trans_Out.interface.Inflow),
    connect(sub_models.Trans_Out.interface.Outflow, interface.Outflow),
    
    sub_models.Trans_In.parameters.Ka_ac.value := parameters.Ka_ac.value,
    sub_models.Tank.parameters.Ka_ac.value := parameters.Ka_ac.value,
    sub_models.Trans_Out.parameters.Ka_ac.value := parameters.Ka_ac.value,

    sub_models.Trans_In.parameters.Ka_bu.value := parameters.Ka_bu.value,
    sub_models.Tank.parameters.Ka_bu.value := parameters.Ka_bu.value,
    sub_models.Trans_Out.parameters.Ka_bu.value := parameters.Ka_bu.value,

    sub_models.Trans_In.parameters.Ka_pro.value := parameters.Ka_pro.value,
    sub_models.Tank.parameters.Ka_pro.value := parameters.Ka_pro.value,
    sub_models.Trans_Out.parameters.Ka_pro.value := parameters.Ka_pro.value,

    sub_models.Trans_In.parameters.Ka_va.value := parameters.Ka_va.value,
    sub_models.Tank.parameters.Ka_va.value := parameters.Ka_va.value,
    sub_models.Trans_Out.parameters.Ka_va.value := parameters.Ka_va.value,

    





    sub_models.Tank.parameters.pHss.value := parameters.pHss.value,
    sub_models.Tank.parameters.mode.value := parameters.mode.value,

    sub_models.Tank.parameters.C_aa.value := parameters.C_aa.value,
    sub_models.Tank.parameters.C_pr.value := parameters.C_pr.value,
    sub_models.Tank.parameters.C_ac.value := parameters.C_ac.value,
    sub_models.Tank.parameters.C_biom.value := parameters.C_biom.value,
    sub_models.Tank.parameters.C_bu.value := parameters.C_bu.value,
    sub_models.Tank.parameters.C_ch4.value := parameters.C_ch4.value,
    sub_models.Tank.parameters.C_fa.value := parameters.C_fa.value,
    sub_models.Tank.parameters.C_li.value := parameters.C_li.value,
    sub_models.Tank.parameters.C_pro.value := parameters.C_pro.value,
    sub_models.Tank.parameters.C_SI.value := parameters.C_SI.value,
    sub_models.Tank.parameters.C_su.value := parameters.C_su.value,
    sub_models.Tank.parameters.C_ch.value := parameters.C_ch.value,
    sub_models.Tank.parameters.C_va.value := parameters.C_va.value,
    sub_models.Tank.parameters.C_Xc.value := parameters.C_Xc.value,
    sub_models.Tank.parameters.C_XI.value := parameters.C_XI.value,
    sub_models.Tank.parameters.N_aa.value := parameters.N_aa.value,
    sub_models.Tank.parameters.N_biom.value := parameters.N_biom.value,
    sub_models.Tank.parameters.N_SI.value := parameters.N_SI.value,
    sub_models.Tank.parameters.N_Xc.value := parameters.N_Xc.value,
    sub_models.Tank.parameters.N_XI.value := parameters.N_XI.value,
    sub_models.Tank.parameters.f_ac_su.value := parameters.f_ac_su.value,
    sub_models.Tank.parameters.f_ac_aa.value := parameters.f_ac_aa.value,
    sub_models.Tank.parameters.f_bu_aa.value := parameters.f_bu_aa.value,
    sub_models.Tank.parameters.f_ch_xc.value := parameters.f_ch_xc.value,
    sub_models.Tank.parameters.f_fa_li.value := parameters.f_fa_li.value,
    sub_models.Tank.parameters.f_h2_aa.value := parameters.f_h2_aa.value,
    sub_models.Tank.parameters.f_pro_aa.value := parameters.f_pro_aa.value,
    sub_models.Tank.parameters.f_pro_su.value := parameters.f_pro_su.value,
    sub_models.Tank.parameters.f_pr_xc.value := parameters.f_pr_xc.value,
    sub_models.Tank.parameters.f_SI_xc.value := parameters.f_SI_xc.value,
    sub_models.Tank.parameters.f_va_aa.value := parameters.f_va_aa.value,
    sub_models.Tank.parameters.f_XI_xc.value := parameters.f_XI_xc.value,
    sub_models.Tank.parameters.f_bu_su.value := parameters.f_bu_su.value,
    sub_models.Tank.parameters.f_h2_su.value := parameters.f_h2_su.value,
    sub_models.Tank.parameters.f_li_xc.value := parameters.f_li_xc.value,
    sub_models.Tank.parameters.Y_aa.value := parameters.Y_aa.value,
    sub_models.Tank.parameters.Y_ac.value := parameters.Y_ac.value,
    sub_models.Tank.parameters.Y_c4.value := parameters.Y_c4.value,
    sub_models.Tank.parameters.Y_fa.value := parameters.Y_fa.value,
    sub_models.Tank.parameters.Y_h2.value := parameters.Y_h2.value,
    sub_models.Tank.parameters.Y_pro.value := parameters.Y_pro.value,
    sub_models.Tank.parameters.Y_su.value := parameters.Y_su.value,
    sub_models.Tank.parameters.pH_ac_ll.value := parameters.pH_ac_ll.value,
    sub_models.Tank.parameters.pH_ac_ul.value := parameters.pH_ac_ul.value,
    sub_models.Tank.parameters.pH_bac_ll.value := parameters.pH_bac_ll.value,
    sub_models.Tank.parameters.pH_bac_ul.value := parameters.pH_bac_ul.value,
    sub_models.Tank.parameters.pH_h2_ll.value := parameters.pH_h2_ll.value,
    sub_models.Tank.parameters.pH_h2_ul.value := parameters.pH_h2_ul.value,
    sub_models.Tank.parameters.KI_h2_fa.value := parameters.KI_h2_fa.value,
    sub_models.Tank.parameters.KI_h2_c4.value := parameters.KI_h2_c4.value,
    sub_models.Tank.parameters.KI_h2_pro.value := parameters.KI_h2_pro.value,
    sub_models.Tank.parameters.KI_nh3_ac.value := parameters.KI_nh3_ac.value,
    sub_models.Tank.parameters.kdec_xaa.value := parameters.kdec_xaa.value,
    sub_models.Tank.parameters.kdec_xac.value := parameters.kdec_xac.value,
    sub_models.Tank.parameters.kdec_xc4.value := parameters.kdec_xc4.value,
    sub_models.Tank.parameters.kdec_xfa.value := parameters.kdec_xfa.value,
    sub_models.Tank.parameters.kdec_xh2.value := parameters.kdec_xh2.value,
    sub_models.Tank.parameters.kdec_xpro.value := parameters.kdec_xpro.value,
    sub_models.Tank.parameters.kdec_xsu.value := parameters.kdec_xsu.value,
    sub_models.Tank.parameters.kdis.value := parameters.kdis.value,
    sub_models.Tank.parameters.khyd_ch.value := parameters.khyd_ch.value,
    sub_models.Tank.parameters.khyd_li.value := parameters.khyd_li.value,
    sub_models.Tank.parameters.khyd_pr.value := parameters.khyd_pr.value,
    sub_models.Tank.parameters.kla.value := parameters.kla.value,
    sub_models.Tank.parameters.km_aa.value := parameters.km_aa.value,
    sub_models.Tank.parameters.km_ac.value := parameters.km_ac.value,
    sub_models.Tank.parameters.km_c4.value := parameters.km_c4.value,
    sub_models.Tank.parameters.km_fa.value := parameters.km_fa.value,
    sub_models.Tank.parameters.km_h2.value := parameters.km_h2.value,
    sub_models.Tank.parameters.km_pro.value := parameters.km_pro.value,
    sub_models.Tank.parameters.km_su.value := parameters.km_su.value,
    sub_models.Tank.parameters.Ks_aa.value := parameters.Ks_aa.value,
    sub_models.Tank.parameters.Ks_ac.value := parameters.Ks_ac.value,
    sub_models.Tank.parameters.Ks_c4.value := parameters.Ks_c4.value,
    sub_models.Tank.parameters.Ks_fa.value := parameters.Ks_fa.value,
    sub_models.Tank.parameters.Ks_h2.value := parameters.Ks_h2.value,
    sub_models.Tank.parameters.Ks_IN.value := parameters.Ks_IN.value,
    sub_models.Tank.parameters.Ks_pro.value := parameters.Ks_pro.value,
    sub_models.Tank.parameters.Ks_su.value := parameters.Ks_su.value,
    sub_models.Tank.parameters.K_p.value := parameters.K_p.value,
    sub_models.Tank.parameters.P_atm.value := parameters.P_atm.value,
 
    sub_models.Tank.parameters.V_gas.value := parameters.V_gas.value,
    sub_models.Tank.parameters.V_liq.value := parameters.V_liq.value,
    sub_models.Tank.parameters.f_X_Out.value := parameters.f_X_Out.value,
    sub_models.Trans_In.parameters.naa.value := parameters.naa.value,
    sub_models.Trans_Out.parameters.naa.value := parameters.naa.value,
    sub_models.Trans_In.parameters.nbac.value := parameters.nbac.value,
    sub_models.Trans_Out.parameters.nbac.value := parameters.nbac.value,
    sub_models.Trans_In.parameters.nxc.value := parameters.nxc.value,
    sub_models.Trans_Out.parameters.nxc.value := parameters.nxc.value,
    sub_models.Trans_In.parameters.nxi.value := parameters.nxi.value,
    sub_models.Trans_Out.parameters.nxi.value := parameters.nxi.value,
    sub_models.Trans_In.parameters.nsi.value := parameters.nsi.value,
    sub_models.Trans_Out.parameters.nsi.value := parameters.nsi.value,
    sub_models.Trans_In.parameters.nsi_adm.value := parameters.nsi_adm.value,
    sub_models.Trans_Out.parameters.nsi_adm.value := parameters.nsi_adm.value,
    sub_models.Trans_In.parameters.T_ref.value := parameters.T_ref.value,
    sub_models.Trans_Out.parameters.T_ref.value := parameters.T_ref.value,

    




 
 
 
    connect(interface.pH_AS, sub_models.Trans_In.interface.pH_as),
    connect(interface.pH_AS, sub_models.Trans_Out.interface.pH_as),
     
    connect(interface.pH_AD, sub_models.Trans_In.interface.AD_pH),
    connect(interface.pH_AD, sub_models.Trans_Out.interface.AD_pH),
    connect(interface.T_op, sub_models.Trans_In.interface.T_op),
    connect(interface.T_op, sub_models.Trans_Out.interface.T_op),
    connect(interface.T_op, sub_models.Tank.interface.T_op),

    connect(sub_models.Tank.interface.Gas_Outflow, interface.Gas_Outflow),
    connect(sub_models.Tank.interface.AD_C, interface.AD_C),
    connect(sub_models.Tank.interface.AD_C_Ion, interface.AD_C_Ion),
    connect(sub_models.Tank.interface.AD_pH, interface.AD_pH),
    connect(sub_models.Tank.interface.Gas_p_ch4, interface.Gas_p_ch4),
    connect(sub_models.Tank.interface.Gas_p_co2, interface.Gas_p_co2),
    connect(sub_models.Tank.interface.Gas_p_h2, interface.Gas_p_h2),
    connect(sub_models.Tank.interface.Gas_p_tot, interface.Gas_p_tot),
    connect(sub_models.Tank.interface.Gas_Q, interface.Gas_Q),    
  };

:};




# 306 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.ADM1.msl" 2






# 58 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 1
 















 
 
 
 




CLASS DataTreatment "Data Treatment" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A general model for signal treatment";
    interface <-
    {
	 	OBJ u (* terminal = "in_1" *) "Signal input" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ y_M (* terminal = "out_1" *) "Output signal" : Real := {: causality <- "COUT" ; group <- "Measurement data" :};    
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
	state <-
    {
		OBJ signal (* hidden = "1" *) "Dummy variable to store the signal": Real ;
    };
	equations <-
    {
		 
		state.signal = interface.u ;  
    };
  :};

  
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/data_treatment/wwtp.base.datatreatment.response_time.msl" 1
 














 
 
 
 
 




CLASS Response_Time
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding response time to a signal";
    parameters <-
    {
		OBJ T90 "Response time" : Time := {: value <- 0.00694444444444444 ; group <- "System" :};
		OBJ n "Order for the response time (2-8)" : Integer := {: value <- 2 ; interval  <- {: lowerBound <- 1; upperBound <- 8 :}; group <- "System" :};
    };
    state <-
    {
		OBJ signal_response1 (* hidden = "1" *) "variable for 1st order response time output": Real ;
		OBJ signal_response2 (* hidden = "1" *) "variable for 2nd order response time output": Real ;
		OBJ signal_response3 (* hidden = "1" *) "variable for 3rd order response time output": Real ;
		OBJ signal_response4 (* hidden = "1" *) "variable for 4th order response time output": Real ;
		OBJ signal_response5 (* hidden = "1" *) "variable for 5th order response time output": Real ;
		OBJ signal_response6 (* hidden = "1" *) "variable for 6th order response time output": Real ;
		OBJ signal_response7 (* hidden = "1" *) "variable for 7th order response time output": Real ;
		OBJ signal_response8 (* hidden = "1" *) "variable for 8th order response time output": Real ;
		 
 		OBJ Tau "Time constant" : Time := {: value <- 0.00006944444444 ; group <- "System" :};  
    };
    initial <-
    {
		 
		 
		 
		state.Tau = IF (parameters.n==1) THEN parameters.T90/2.3247
			ELSE IF (parameters.n==2) THEN parameters.T90/3.89
				 ELSE IF (parameters.n==3) THEN parameters.T90/5.3336
				 	  ELSE IF (parameters.n==4) THEN parameters.T90/6.6902
					  	   ELSE IF (parameters.n==5) THEN parameters.T90/8.0031
						   		ELSE IF (parameters.n==6) THEN parameters.T90/9.2680
									 ELSE IF (parameters.n==7) THEN parameters.T90/10.5357
									 	  ELSE parameters.T90/11.7724;
		 
		 
		 
    };
    equations <-
    {
		 
		DERIV(state.signal_response1,[independent.t]) = -(1/state.Tau)*(state.signal_response1 - state.signal);
		DERIV(state.signal_response2,[independent.t]) = -(1/state.Tau)*(state.signal_response2 - state.signal_response1);
		DERIV(state.signal_response3,[independent.t]) = -(1/state.Tau)*(state.signal_response3 - state.signal_response2);
		DERIV(state.signal_response4,[independent.t]) = -(1/state.Tau)*(state.signal_response4 - state.signal_response3);
		DERIV(state.signal_response5,[independent.t]) = -(1/state.Tau)*(state.signal_response5 - state.signal_response4);
		DERIV(state.signal_response6,[independent.t]) = -(1/state.Tau)*(state.signal_response6 - state.signal_response5);
		DERIV(state.signal_response7,[independent.t]) = -(1/state.Tau)*(state.signal_response7 - state.signal_response6);
		DERIV(state.signal_response8,[independent.t]) = -(1/state.Tau)*(state.signal_response8 - state.signal_response7);
		
		interface.y_M = IF (parameters.n==1) THEN state.signal_response1
			ELSE IF (parameters.n==2) THEN state.signal_response2
				 ELSE IF (parameters.n==3) THEN state.signal_response3
				 	  ELSE IF (parameters.n==4)	THEN state.signal_response4
					  	   ELSE IF (parameters.n==5) THEN state.signal_response5
						   		ELSE IF (parameters.n==6) THEN state.signal_response6
									 ELSE IF (parameters.n==7) THEN state.signal_response7
									 	  ELSE state.signal_response8;
    };
  :};
  

CLASS Base_RT21 "Base class for a 2nd-order Response-Time smoothing action for 1 signal" SPECIALISES PhysicalDAEModelType :=
{:
  
  comments <- "Base class for a 2nd-order Response-Time smoothing action for 1 signal" ;

  interface <-
  {
    OBJ u1 (* terminal = "out_1" *) "Output signal no.1" : Real := {: causality <- "COUT" ; group <- "Control action" :};
  };

  parameters <-
  {
  	OBJ T90 (* hidden = "1" *) "Response time" : Time := {: value <- 0.00694444444444444 ; group <- "System" :};
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ Help_u1 (* hidden = "1" *) "Ideal output without smoothening": Real ;
    OBJ Help_RT11 (* hidden = "1" *) "variable for 1st order response time output": Real ;
		OBJ Help_RT21 (* hidden = "1" *) "variable for 2nd order response time output": Real ;
     
 		OBJ Tau (* hidden = "1" *) "Time constant" : Time := {: value <- 0.00006944444444 ; group <- "System" :};  
  };

  initial <-
  {
    state.Tau = parameters.T90/3.89 ;
  };

  equations <-
  {
     
		DERIV(state.Help_RT11,[independent.t]) = - (1 / state.Tau) * (state.Help_RT11 - state.Help_u1) ;
		DERIV(state.Help_RT21,[independent.t]) = - (1 / state.Tau) * (state.Help_RT21 - state.Help_RT11) ;

    interface.u1 = state.Help_RT21 ;
  };

:};



# 49 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/data_treatment/wwtp.base.datatreatment.delay.msl" 1
 














 
 
 
 
 




CLASS Delay
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding delay to a signal";
    parameters <-
    {
		OBJ t_Delay "Delay time" : Time := {: value <- 0 ; group <- "System" :};
    };
    state <-
    {
		OBJ temp (* hidden = "1" *) "dummy variable for initialisation" : Real ;
		OBJ ID (* hidden = "1" *) "dummy variable for buffer ID" : Integer ;
		OBJ Signal_Delay (* hidden = "1" *) "dummy variable for signal that is retrieved from buffer": Real ;
		OBJ Delta_t  "Time to get a value from the buffer" : Time:= {: group <- "System" :};
    };
    initial <-
    {
		 
		state.ID = MSLUBufferCreate(state.Signal_Delay, 0);
    };
    equations <-
    {
		 
		 
		 
		state.temp = MSLUBufferPut(state.ID, independent.t, state.signal);
		state.Delta_t = independent.t - parameters.t_Delay;
		state.Signal_Delay = MSLUBufferGet(state.ID,state.Delta_t);
		interface.y_M = state.Signal_Delay ;   
    };
  :};
  

# 50 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/data_treatment/wwtp.base.datatreatment.noise.msl" 1
 















 
 
 
 




CLASS Noise
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal, using random values sampled from a normal distribution";
    parameters <-
    {
		OBJ Percent_YMax "Percentage of the measuring range to define the standard deviation of the noise (%)" : Real := {: value <- 2.5 ; group <- "System" :};
		OBJ Noise_Sample_Time "Noise sampling interval": Time := {: value <- 0.000694444444444 ; group <- "System" :};
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
    };
    state <-
    {
		OBJ signal_noise (* hidden = "1" *) "Dummy variable to store the noisy signal": Real:= {: group <- "System" :};
		OBJ Noise "Random number sampled from Normal Distribution N(0,1)" : Real:= {: group <- "System" :};
		OBJ rand "Random number in the range [0,1[ sampled from Uniform distribution" : Real:= {: group <- "System" :};
		OBJ prev_nst (* hidden = "1" *) "Previous noise sampling time" : Real ;
		OBJ flag_noise (* hidden = "1" *)"Boolean variable related to a timer": Boolean ;
		OBJ Noise_Level "Noise level (Std Dev of the noise signal)" : Real := {: group <- "System" :};
    };
    initial <-
    {
		state.prev_nst = 0;
		 
		state.Noise_Level = parameters.Percent_YMax/100 * parameters.YMax;
    };
    equations <-
    {
		 
		 
		state.flag_noise = IF (independent.t > (previous(state.prev_nst) + parameters.Noise_Sample_Time)) THEN 1
			ELSE 0 ;

		state.rand = IF (state.flag_noise) THEN MSLUGetRandom()
			ELSE IF (independent.t == 0) THEN MSLUGetRandom()
				 ELSE previous(state.rand) ;

		state.prev_nst = IF (state.flag_noise) THEN previous(state.prev_nst) + parameters.Noise_Sample_Time
			ELSE previous(state.prev_nst) ;

		 
		 
		state.Noise = MSLU_normal_cdf_inv(state.rand,0,1);
		
		 
		interface.y_M = state.Noise*state.Noise_Level+state.signal ;
    };
    
  :};
  

# 51 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/data_treatment/wwtp.base.datatreatment.noise_file.msl" 1
 














 
 
 
 
 




CLASS Noise_File
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal using an input file";
    interface <-
    {
		OBJ u_file (* terminal = "in_2" *) "Signal input for noise file" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};  
    };
    parameters <-
    {
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
		OBJ Noise_Percent "Noise level (%)" : Real := {: value <- 2.5 ; group <- "System" :};  
    };
    state <-
    {
		OBJ Noise_Level "Noise level" : Real:= {: group <- "System" :};
    };
    initial <-
    {
		state.Noise_Level = parameters.Noise_Percent/100 * parameters.YMax ;
    };
    equations <-
    {
		interface.y_M = interface.u_file*state.Noise_Level + state.signal ; 
    };
  :};
  

# 52 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/data_treatment/wwtp.base.datatreatment.sample_and_hold.msl" 1
 














 
 
 
 
 




CLASS Sample_and_Hold
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for obtaining discrete signal: Zero Order Hold. Sample and Hold (SAH)";
    parameters <-
    {
		OBJ T_interval "Sampling interval": Time := {: value <- 0.00347222222222 ; group <- "System" :};  
    };
    state <-
    {
		OBJ signal_SAH (* hidden = "1" *) "dummy variable for concentration of sample and hold": Real ;
		OBJ prev_SAHst (* hidden = "1" *) "previous SAH sampling time" : Real ;
		OBJ flag_SAH (* hidden = "1" *) "flag for the sampling time": Boolean ;
    };
    initial <-
    {
		state.prev_SAHst = 0;
		state.flag_SAH = 0;
		state.signal_SAH= 0;  
    };
    equations <-
    {
		 
		state.prev_SAHst = IF (independent.t - previous(state.prev_SAHst) <= (parameters.T_interval)) THEN  previous(state.prev_SAHst)
			ELSE  previous(state.prev_SAHst) + parameters.T_interval;   

		state.flag_SAH = IF  (state.prev_SAHst != previous(state.prev_SAHst)) THEN  1
			ELSE  0;    
  
		 
		state.signal_SAH = IF (state.flag_SAH) THEN previous(state.signal)
			ELSE IF (independent.t == 0) THEN previous(state.signal)
				 ELSE previous(state.signal_SAH) ;
      
		 
		interface.y_M = state.signal_SAH ;
    };
  :};
  

# 53 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/data_treatment/wwtp.base.datatreatment.saturation_range.msl" 1
 














 
 
 
 
 




CLASS Saturation_Range
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding saturation to the signal";
    parameters <-
    {
		OBJ uMin "Minimum level for the signal" : Real := {: value <- 0 ; group <- "System" :};
		OBJ uMax "Minimum level for the signal" : Real := {: value <- 10 ; group <- "System" :};
    };
    equations <-
    {
		interface.u = IF (state.signal < parameters.uMin) THEN parameters.uMin
			ELSE IF (state.signal > parameters.uMax) THEN parameters.uMax
				 ELSE state.signal ;
    };
  :};
  

# 54 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/data_treatment/wwtp.datatreatment.average.msl" 1
 














 



CLASS MovingAverage
  (* icon = "data_treatment" *)
  "Computes the moving average of a signal"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model to compute the moving average of a signal";

    interface <-
    {
	OBJ T_Window (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Moving window": Time := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    };

    state <-
    {
	OBJ ID (* hidden = "1" *) "dummy variable for buffer ID" : Real ;
	OBJ temp (* hidden = "1" *) "dummy variable for initialisation" : Real ;
	OBJ Signal_Out (* hidden = "1" *) "dummy variable for signal that is retrieved from buffer": Real ;
    };
	
    initial <-
    {
	state.ID = MSLUBufferCreate(interface.T_Window, 0.001);
    };
	
    equations <-
    {
    state.temp = MSLUBufferPut(state.ID, independent.t, state.signal);
    state.Signal_Out = MSLUBufferGetMean(state.ID);
	interface.y_M = state.Signal_Out ;   
    };
	
  :};
  

# 57 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.data_treatment.msl" 2

  
  


# 61 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.aeration.msl" 1
 



















CLASS Aerator_Base "Base model for aeration" SPECIALISES PhysicalDAEModelType :=
{:

  comments <- "Base model for aeration" ;

  interface <-
  {
    OBJ O2_tank (* terminal = "in_1" *) "DO concentration in the aeration tank" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ Kla (* terminal = "out_1" *) "Computed Oxygen Transfer Coefficient" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ Vol_tank (* terminal = "in_2"; manip = "1" *) "Volume of the aeration tank" : Volume := {: causality <- "CIN" ; value <- 1000 ; group <- "Measurement data" :};
    OBJ T_water (* terminal = "in_2"; manip = "1" *) "Water temperature": CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Local conditions" :};
    OBJ T_air (* terminal = "in_2"; manip = "1" *) "Air temperature": CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Local conditions" :};
  };

  independent <-
  {
    OBJ t "Time" : Time := {: group <- "Time" :};
  };

  parameters <-
  {
		OBJ P_st_atm (* hidden = "1" *) "Standard atmospheric pressure": Pressure := {: value <- 101325 :};
    OBJ R_Gas (* hidden = "1" *) "Universal gas constant" : Real := {: unit <- "J/(mol*K)"; value <- 8.314510; :};
    OBJ H "Altitude": Length := {: value <- 10 ; group <- "Conditions" :};
  };
  
  state <-
  {
    OBJ O2_sat "Oxygen saturation (T-water-dependent)": Concentration := {: group <- "Conditions" :};
		OBJ P_atm (* hidden = "1" *) "Atmospheric pressure": Pressure := {: group <- "Conditions" :};
		OBJ MVol_air (* hidden = "1" *) "Molar volume of air (m3 air / mol air)": Real ;
  };

  initial <- 
  {
  	state.P_atm := -12 * parameters.H + parameters.P_st_atm ;  
  	 
  	state.MVol_air := parameters.R_Gas * (interface.T_air + 273.15) / (state.P_atm) ;  
  };

  equations <-
  {
    state.O2_sat = 14.65 - 0.41 * interface.T_water + 0.00799 * pow(interface.T_water,2) - 0.0000778 * pow(interface.T_water,3) ;
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/aeration/wwtp.irvine_carbon_footprint.msl" 1
 














 
 
 




   
   
CLASS Irvine_wCarbon_Footprint
  (* icon = "aerator" ; is_default = "true" *)
  "Irvine aeration model with carbon footprint" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A model that computes the Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
		OBJ O2_tank (* terminal = "in_1" *) "Actual oxygen concentration in the aeration tank" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ Vol_tank (* terminal = "in_1" *) "Volume of the aeration tank" : Volume := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ Kla (* terminal = "out_1" *) "Oxygen Transfer Coefficient" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
		OBJ O2_rsat_ave (* terminal = "out_1" *) "Average oxygen saturation f(T_water; Depth) for fine bubble aeration" : Concentration := {: causality <- "COUT" ; group <- "Control action" :};
		OBJ SRT (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge age" : Time := {: causality <- "CIN" ; value <- 6.5 ; group <- "Operational" :};   
		OBJ Q_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Air flow rate under Standard Conditions": FlowRate := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
    };
    parameters <- 
    {
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/s2)": Real := {: value <- 9.82 :};
		OBJ R_gas (* hidden = "1" *) "Universal gas constant (J/(mol*K))" : Real := {: value <- 8.314510 :};
		OBJ M_air (* hidden = "1" *) "Molar mass of air (g/mol)" : Real := {: value <- 28.97 :};

		OBJ T_water "Temperature of the water": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ T_air "Temperature of the air": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ H "Altitude": Length := {: value <- 10 ; group <- "Operational" :};
		OBJ Rho_air "Air density": Concentration := {: value <- 1230 ; group <- "Operational" :};
		OBJ O2_sat20 "Oxygen saturation of water under Standard Conditions and no salts": Concentration := {: value <- 10.50 ; group <- "Operational" :};
		OBJ SOTE "Standard Oxygen Transfer Efficiency per unit depth": Real := {: value <- 6 ; group <- "Operational"; interval <- {: lowerBound <- 0; upperBound <- 10 ; :}; :};

		OBJ Rho_sludge "Sludge density": Concentration := {: value <- 1000000 ; group <- "Sludge" :}; 
		OBJ Beta "Empirical factor": Real := {: value <- 0.98 ; group <- "Sludge" :};
		OBJ Phi "Empirical factor": Real := {: value <- 1.024 ; group <- "Sludge" :};

		OBJ P_st_atm (* hidden = "1" *) "Standard atmospheric pressure": Pressure := {: value <- 101325; group <- "Local conditions" :};
		OBJ P_vapour_ref "Vapour pressure": Pressure := {: value <- 2334; group <- "Local conditions" :};
		OBJ O2_air "O2 conc. in the atmosphere (%)": Real := {: value <- 20.85 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		OBJ CO2_air "CO2 conc. in the atmosphere (%)": Real := {: value <- 0.03 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};

		OBJ Depth "Depth of the (fine bubble) aerator": Length := {: value <- 6 ; group <- "Tank geometry" :};
		OBJ A_sp "Specific area of the diffusers": Area := {: value <- 2 ; group <- "Tank geometry" :};
		OBJ Nd "Number of diffusers": Real := {: value <- 504 ; group <- "Tank geometry"; interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :}; :};
		
		OBJ A "Empirical factor": Real := {: value <- 5.717 ; group <- "Aeration model" :};
		OBJ B "Empirical factor": Real := {: value <- 6.815 ; group <- "Aeration model" :};
		OBJ f "Fraction of tank depth (from surface) at which pressure corresponds to the average saturation concentration": Real := {: value <- 0.44 ; group <- "Aeration model" :};
		 
		OBJ P_out "Total pressure loss in the aeration system": Pressure := {: value <- 80000; group <- "Power consumption" :};
		OBJ Lambda "Empirical constant for air": Real := {: value <- 1.395 ; group <- "Power consumption" :};
		OBJ Epsilon "Efficiency of the motor": Real := {: value <- 0.58 ; group <- "Power consumption"; interval <- {: lowerBound <- 0; upperBound <- 1; :}; :};
		OBJ fCO2 "CO2 production per unit of energy (kg/kWh)": Real := {: value <- 0.718 ; group <- "Power consumption" :};
		OBJ T_in "Inlet temperature": CelsiusTemperature := {: value <- 20 ; group <- "Power consumption" :};
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    state <- 
    {
		OBJ P_atm "Atmospheric pressure": Pressure := {: group <- "Local conditions" :};
		OBJ P_vapour "Vapour pressure": Pressure := {: group <- "Local conditions" :};
		OBJ O2_rsat "Oxygen saturation at the water temperature": Concentration := {: group <- "Local conditions" :};

		OBJ help_SOTE (* hidden = "1" *) "Standard Oxygen Transfer Efficiency (%)": Real := {: group <- "Operational"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		
		OBJ Alpha "Empirical factor ": Real := {: group <- "Operational" :};
		OBJ AlphaSOTE "Oxygen transfer efficiency for new aerators": Real := {: group <- "Aeration" :};
		OBJ SOTR "Standard Oxygen Transfer Rate": MassFlux := {: group <- "Aeration" :};
		OBJ OTR "Oxygen Transfer Rate (under field conditions)": MassFlux := {: group <- "Aeration" :};
		OBJ	OTR_sp "Specific Oxygen Transfer Rate": OxygenUptakeRate := {: group <- "Aeration" :};
		OBJ OTE "Oxygen Transfer Efficiency (under field conditions)": Real := {: group <- "Aeration"; interval <- {: lowerBound <- 0; upperBound <- 1; :}; :};
		OBJ MRi "Mole ratio of oxygen that enters air and off gas (%)": Real := {: group <- "Aeration" :};
		OBJ MRe "Mole ratio of oxygen that leaves aeration tank (%)": Real := {: group <- "Aeration" :};
		OBJ Qn "Normalized air flow": Real := {: group <- "Aeration" :};
		OBJ help_P_bottom (* hidden = "1" *) "Pressure differential at the bottom of the tank": Pressure := {: group <- "Site" :};

		 
		OBJ Load_CO2 "CO2 production": MassFlux := {: group <- "Power consumption" :};
		OBJ Power_blowers "Power of the blowers" : Power := {: group <- "Power consumption" :};
		OBJ Emission_CO2 "Overall CO2 emission" : Mass := {: group <- "Power consumption" :} ;
		OBJ Consumption "Overall electrical energy (kWh)" : ElectricalEnergy := {: group <- "Power consumption" :} ;
		OBJ Chi (* hidden = "1" *) "Characteristic number": Real ;
    };

    initial <- 
    {
		state.P_atm = -12 * parameters.H + parameters.P_st_atm ;
		state.help_SOTE = parameters.SOTE * parameters.Depth ;
		state.MRi = parameters.O2_air/(100.0 - parameters.O2_air - parameters.CO2_air);
		state.P_vapour = pow(10, 0.6979 + 0.02618 * parameters.T_air)* 133.33;
    };
	
    equations <- 
    {
		 
		state.Qn = interface.Q_air / (24*3600*(parameters.A_sp * parameters.Nd * parameters.Depth)) ;
		state.Chi = IF (state.Qn == 0.0) THEN 0.0 ELSE interface.SRT/state.Qn ;
	
		state.AlphaSOTE = IF (state.Chi == 0.0) THEN 0.0 ELSE (parameters.A * log10(state.Chi) - parameters.B)/100.0 ;
		 
		state.Alpha = state.AlphaSOTE / state.help_SOTE * 100 ;

		 
		state.MRe =  state.MRi*(1-state.OTE);
		state.OTE = state.AlphaSOTE *
			(parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) / parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));

		 
		state.help_P_bottom = (parameters.Rho_sludge/1000.0) * parameters.g * parameters.Depth;
		state.O2_rsat = 14.65 - 0.41 * (parameters.T_water) + 0.00799 * pow(parameters.T_water,2) - 0.0000778 * pow(parameters.T_water,3);
		interface.O2_rsat_ave = parameters.O2_sat20 * (state.help_P_bottom * parameters.f + state.P_atm - state.P_vapour)/ (parameters.P_st_atm - parameters.P_vapour_ref);

		 
		state.SOTR =  interface.Q_air * (parameters.Rho_air)  * (state.help_SOTE/100) * (parameters.O2_air/100);
		state.OTR = state.Alpha * state.SOTR * (parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) /parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));

    interface.Kla = IF ((parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) * interface.Vol_tank <= 0.0) THEN (0.0)
      ELSE state.OTR/((parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) * interface.Vol_tank) ;

		state.OTR_sp = state.OTR /(interface.Vol_tank);
		
		 
		state.Power_blowers = (parameters.Rho_air * (interface.Q_air/(24.0*3600.0)) * parameters.R_gas * (parameters.T_in + 273.15))/(parameters.M_air * parameters.Epsilon) * (parameters.Lambda/(parameters.Lambda-1)) * (pow(((parameters.P_out + parameters.P_st_atm)/parameters.P_st_atm),((parameters.Lambda-1)/parameters.Lambda)) - 1) ;
		state.Load_CO2 = state.Power_blowers * parameters.fCO2 ;
		DERIV(state.Consumption, [independent.t]) = 24 * state.Power_blowers / 1000 ;
		DERIV(state.Emission_CO2, [independent.t]) = state.Load_CO2 ;
    };

  :};


# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.aeration.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/aeration/wwtp.surface_aerator.msl" 1
 














 



 
CLASS Surface_Aerator (* icon = "aerator" *)
"Basic model for surface aeration"
SPECIALISES PhysicalDAEModelType :=
  {:
  
  comments <- "Surface aeration model";
  interface <-
  {
  OBJ O2_tank (* terminal = "in_1" *) "DO concentration in the aeration tank" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
  OBJ Kla (* terminal = "out_1" *) "Computed Oxygen Transfer Coefficient" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
  OBJ Vol_tank (* terminal = "in_2"; manip = "1" *) "Volume of the aeration tank" : Volume := {: causality <- "CIN" ; value <- 1000 ; group <- "Measurement data" :};
  OBJ P (* terminal = "in_2"; manip = "1" *) "Power input": Power := {: causality <- "CIN" ; value <- 500000.0 ; group <- "Operational" :};
  OBJ T_water (* terminal = "in_2"; manip = "1" *) "Water temperature": CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Local conditions" :};
  };

  parameters <-
  {
  OBJ AE "Aeration efficiency (kgO2/kWh)": Real := {: value <- 0.8; group <- "Energy" :};
  };
  
  independent <-
  {
  OBJ t "Time" : Time := {: group <- "Time" :};
  };
  
  state <-
  {
  OBJ O2_sat "Oxygen saturation (water temperature-dependent)": Concentration := {: group <- "Aeration" :};
  OBJ AerationEnergy "Energy consumption for aeration, integral" : ElectricalEnergy := {: group <- "Energy" :} ;
  };
  
  equations <-
  {
  state.O2_sat = 14.65 - 0.41 * interface.T_water + 0.00799 * pow(interface.T_water,2) - 0.0000778 * pow(interface.T_water,3) ;
  DERIV(state.AerationEnergy, [independent.t]) = interface.P / 1000 * 24;
  interface.Kla = parameters.AE * interface.P / (state.O2_sat - interface.O2_tank) / interface.Vol_tank * 24;
  };
  
  :};


# 72 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.aeration.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/aeration/wwtp.aerator.ideal.msl" 1
 




















CLASS Aerator_Ideal (* icon = "aerator" *) "Basic model for aeration: simplistic approach"
EXTENDS Aerator_Base WITH
{:

  comments <- "Basic model for aeration: simplistic approach" ;

  interface <-
  {
		OBJ Q_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Air flow rate under Standard Conditions": FlowRate := {: causality <- "CIN" ; value <- 35000 ; group <- "Operational" :};
  };

  parameters <-
  {
    OBJ AE "Aeration efficiency (kgO2/kWh)": Real := {: value <- 0.8; group <- "Energy" :};
		OBJ O2_air (* hidden = "1" *) "O2 fraction in air": Fraction := {: value <- 0.2085 :};
		OBJ MW_O2 (* hidden = "1" *) "Molar weight of oxygen": Real := {: value <- 32.0 :};
  };

  state <-
  {
    OBJ AerationEnergy "Energy consumption for aeration, integral" : ElectricalEnergy := {: group <- "Energy" :} ;
    OBJ Help_Q_O2 (* hidden = "1" *) "Mass flow of oxygen": Real := {: unit <- "g/d"; group <- "Conditions" :};
    OBJ Help_P (* hidden = "1" *) "Power input": Power := {: group <- "Energy" :};
		OBJ	M_O2 (* hidden = "1" *) "Mass of oxygen per unit volume of air": Concentration := {: group <- "Conditions" :};
  };

  equations <-
  {
    DERIV(state.AerationEnergy, [independent.t]) = state.Help_P / 1000 * 24;

    state.Help_Q_O2 = interface.Q_air * state.M_O2 ;

    state.Help_P = state.Help_Q_O2 / (parameters.AE * 24) ;
    
    state.M_O2 = (parameters.O2_air / state.MVol_air) * parameters.MW_O2 ;
    
    interface.Kla = IF ((state.O2_sat - interface.O2_tank) * interface.Vol_tank > 0.0) THEN state.Help_Q_O2 / ((state.O2_sat - interface.O2_tank) * interface.Vol_tank) ELSE 0.0 ;
  };

:};



# 75 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.aeration.msl" 2




# 62 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.samplers.msl" 1
 














 





CLASS Sampler2 "Basic model for sampling devices" EXTENDS Sampler WITH
{:
      
  state <-
  {
    OBJ flag_samp_time "Beginning (time) of each aliquot" : Boolean := {: group <- "Sampling" :};
    OBJ t_fmod (* hidden = "1" *) "Fraction of aliquot volume collected over time (that is insufficient to make a full aliquot)" : Real := {: group <- "Sampling" :};
    OBJ Help_frequency (* hidden = "1" *) "Sampling frequency for each aliquot" : Time ;
  };
  
  initial <-
  {
    state.n_samples = 0;
  };

  equations <-
  {
    state.flag_samp_time = IF (state.flag_samp_per == True) THEN
      IF ((state.t_fmod < previous(state.t_fmod)) || previous(state.flag_samp_per) == False) THEN True ELSE False
    ELSE IF (previous(state.flag_samp_per) == True) THEN True ELSE False ;

    state.t_fmod = IF (independent.t >= parameters.t_start) THEN
      fmod(((independent.t - parameters.t_start) / state.Help_frequency), 1)
      ELSE 0;
  };
  
:};


CLASS Sampler "Basic model for sampling devices" SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  {
    OBJ y_M (* terminal = "in_1" *) "Quantity to be measured with the sampler" : Concentration := {: causality <- "CIN"; group <- "Measurement data" :};
    OBJ Q (* terminal = "in_1" *) "Flow rate" : FlowRate := {: causality <- "CIN"; group <- "Measurement data" :};
    OBJ u (* terminal = "out_1" *) "Measured quantity" : Real := {: causality <- "COUT" :};
  };
  
  independent <- 
  {
    OBJ t "Time": Time ;
  };
  
  parameters <- 
  {
    OBJ t_start "Start time for sampling" : Time := {: value <- 0 ; group <- "Sampling" :};
    OBJ t_stop "Stop time for sampling" : Time := {: value <- 1 ; group <- "Sampling" :};
    OBJ Help_dt (* hidden = "1" *) "delta-t that compensates for 1st sampling period in which measurement is zero" : Time := {: value <- 0.0 :};
    OBJ unit_cost "Cost of analysis per sample" : Euro := {: value <- 50 ; group <- "Cost" :};
    OBJ frequency "Sampling frequency" : Time := {: value <- 1 ; group <- "Sampling" :};
	  OBJ Detection_limit "Detection limit" : Concentration := {: value <- 0.1 ; group <- "Sampling" :};
  };
  
  state <-
  {
    OBJ flag_samp_per (* hidden = "1" *) "True if time is in the sampling period" : Boolean := {: group <- "Sampling" :};
    OBJ Q_in "Influent flow rate" : FlowRate := {: group <- "Sampling" :};
    OBJ C_meas "Measured concentration" : Concentration := {: group <- "Sampling" :};
    OBJ L_meas "Measured load" : MassFlux := {: group <- "Sampling" :};
    OBJ Cost "Total sampling cost" : Euro := {: group <- "Cost" :};
    OBJ n_samples "Cumulated number of aliquots collected over sampling period" : Integer := {: group <- "Sampling" :};
    OBJ n_comp_samples "Cumulated number of composite samples over sampling period" : Integer := {: group <- "Sampling" :};
     
    OBJ n_samples_bottle_temp "Cumulated number of aliquots collected in each composite sample" : Integer := {: group <- "Sampling" :};
  };
  
  
  equations <-
  {
    state.flag_samp_per = IF ((independent.t >= parameters.t_start) && (independent.t <= parameters.t_stop + parameters.Help_dt)) THEN True ELSE False ;

    state.Q_in = interface.Q ;
     
    interface.u = state.C_meas ;

    state.Cost = parameters.unit_cost * state.n_comp_samples ;
  };

:};
 

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sampler/wwtp.sampler.flow_proportional.msl" 1
 














 




 
CLASS Flow_proportional (* icon = "sampler" *)
"Flow proportional sampler with time-based emptying of bottle(s)" SPECIALISES Sampler :=
{:

  parameters <-
  {
    OBJ Flow_Min "Minimum flow above which sampling starts" : FlowRate := {: value <- 0 ; group <- "Sampling" :};
    OBJ V_sample "Volume of each sample" : Volume := {: value <- 0.0001 ; group <- "Sampling" :};
    OBJ V_frequency "Volume of water between each sample; must be >= V_sample" : Volume := {: value <- 100 ; group <- "Sampling" :};
    OBJ T "Time frame for average calculation" : Time := {: value <- 1.0 ; group <- "Operational":};
  };
  
  state <-
  {
    OBJ V_through "Cumulated flow (volume) through the sampler, between start and stop" : Volume := {: group <- "Sampling" :};
    OBJ n_samples_bottle (* hidden = "1" *) "Cumulated number of aliquots collected over sampling period (updated at step time = frequency)" : Integer := {: group <- "Sampling" :};
    OBJ C_comp_meas (* hidden = "1" *) "Measured concentration in the composite sample BEFORE full bottle" : Concentration := {: group <- "Sampling" :};
    OBJ t1 "Start time for filling bottle" : Time := {: group <- "Sampling" :};
    OBJ t2 "Stop time for filling bottle" : Time := {: group <- "Sampling" :};
    OBJ C_avg_meas "Measured average concentration (over time T)" : Concentration := {: group <- "Sampling" :};
  };
  
  initial <-
  {
    state.flag_samp_per = 0;
    state.V_through = 0;
    state.n_samples = 0;
    state.n_samples_bottle = 0;
    state.n_samples_bottle_temp = 0;
    state.C_comp_meas = 0;
     
    parameters.Help_dt = 0.0 ;
  };
  
  equations <-
  {
    DERIV(state.C_avg_meas,[independent.t]) = (state.C_meas - state.C_avg_meas) / parameters.T ;
        
    state.V_through = IF (state.flag_samp_per == True) THEN
      IF (state.Q_in >= parameters.Flow_Min) THEN previous(state.V_through) + state.Q_in * (independent.t - previous(independent.t))
      ELSE previous(state.V_through)
    ELSE 0 ;
    
    state.n_samples = IF (state.flag_samp_per == True) THEN
  	   
      IF (state.V_through >= (parameters.V_frequency * (previous(state.n_samples) + 1))) THEN previous(state.n_samples) + 1
      ELSE previous(state.n_samples)
    ELSE 0 ;
    
    state.n_samples_bottle = IF (state.n_comp_samples > previous(state.n_comp_samples)) THEN state.n_samples
      ELSE previous(state.n_samples_bottle) ;
    
    state.n_comp_samples = IF (floor((independent.t - parameters.t_start) / parameters.frequency) > 0) THEN floor((independent.t - parameters.t_start) / parameters.frequency) ELSE 0;
    
    state.n_samples_bottle_temp = state.n_samples - state.n_samples_bottle;
    
    state.C_comp_meas = IF (state.flag_samp_per == True) THEN
      IF (state.n_comp_samples == previous(state.n_comp_samples)) THEN
        IF (state.n_samples == previous(state.n_samples)) THEN	previous(state.C_comp_meas)
        ELSE (previous(state.C_comp_meas) * (state.n_samples_bottle_temp - 1) + interface.y_M) / (state.n_samples_bottle_temp)
      ELSE 0
    ELSE 0 ;
    
    state.C_meas = IF (state.flag_samp_per == True) THEN
      IF (state.n_comp_samples > previous(state.n_comp_samples)) THEN
        IF (previous(state.C_comp_meas) < parameters.Detection_limit) THEN parameters.Detection_limit / 2
 
        ELSE previous(state.C_comp_meas) 
      ELSE previous(state.C_meas)
    ELSE 0 ;
    
    state.t1 = IF (state.flag_samp_per == True) THEN
    IF (state.n_comp_samples > previous(state.n_comp_samples)) THEN previous(state.t2)
    ELSE previous(state.t1)
    ELSE parameters.t_start;
    
    state.t2 = IF (state.flag_samp_per == True) THEN
    IF (state.n_comp_samples > previous(state.n_comp_samples)) THEN independent.t
    ELSE previous(state.t2)
    ELSE parameters.t_start;
    
    state.L_meas = IF ((state.t2 - state.t1) > 0) THEN
      state.C_meas * parameters.V_sample * state.n_samples_bottle_temp / (state.t2 - state.t1)
    ELSE 0 ;
  };

:};



# 104 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.samplers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sampler/wwtp.sampler.grab.msl" 1
 














 




CLASS Grab (* icon = "sampler" *) "Grab sampler" EXTENDS Sampler2 WITH
{:
  
  initial <-
  {
    state.Help_frequency = parameters.frequency ;
     
    parameters.Help_dt = 0.0 ;
  };
  
  equations <-
  {
    state.n_samples = IF ((state.flag_samp_time == True) && (previous(state.flag_samp_time) == False))
    THEN (previous(state.n_samples) + 1)
    ELSE previous(state.n_samples);
    
     
    state.C_meas = IF (state.flag_samp_per == True) THEN
      IF (state.flag_samp_time < previous(state.flag_samp_time)) THEN
        IF (interface.y_M < parameters.Detection_limit) THEN parameters.Detection_limit / 2 ELSE interface.y_M
      ELSE previous(state.C_meas)
    ELSE 0 ;
    
    state.L_meas = state.C_meas * state.Q_in;
    
    state.n_comp_samples = state.n_samples;
  };

:};



# 105 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.samplers.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/sampler/wwtp.sampler.time_proportional.msl" 1
 














 




CLASS Time_proportional (* icon = "sampler" *) "Time-proportional sampler" EXTENDS Sampler2 WITH
{:

  parameters <-
  {
    OBJ V_bottles "Volume of composite sample" : Volume := {: value <- 0.002 ; group <- "Sampling" :};
    OBJ V_sample "Volume of each aliquot; must be <= V_bottles" : Volume := {: value <- 0.0001 ; group <- "Sampling" :};
     
    OBJ n_samples_bottle "Number of aliquots collected for each composite" : Integer := {: group <- "Sampling" :};
  };
  
  state <-
  {
    OBJ C_comp_meas (* hidden = "1" *) "Measured concentration in the composite sample BEFORE full bottle" : Concentration ;
  };
  
  initial <-
  {
    parameters.n_samples_bottle = floor(parameters.V_bottles / parameters.V_sample);
    state.n_samples_bottle_temp = 0;
    state.C_comp_meas = 0;
     
    state.Help_frequency = parameters.frequency / parameters.n_samples_bottle + 0.0 ;
    parameters.Help_dt = state.Help_frequency + 0.0 ;
  };
  
  equations <-
  {
    state.n_samples = IF (state.flag_samp_per == True) THEN
      IF (state.flag_samp_time == True) THEN previous(state.n_samples) + 1
      ELSE previous(state.n_samples) 
    ELSE 0 ;     
    
    state.n_comp_samples = floor(state.n_samples / parameters.n_samples_bottle);
    
     
     
     
     
    state.n_samples_bottle_temp = state.n_samples - state.n_comp_samples * parameters.n_samples_bottle ;
    
    state.C_comp_meas = IF (state.flag_samp_per == True) THEN
      IF (state.n_comp_samples == previous(state.n_comp_samples)) THEN
        IF (state.n_samples == previous(state.n_samples)) THEN previous(state.C_comp_meas)
        ELSE (previous(state.C_comp_meas) * (state.n_samples_bottle_temp - 1) + interface.y_M) / (state.n_samples_bottle_temp)
      ELSE 0
    ELSE 0;
    
     
    state.C_meas = IF (state.flag_samp_per == True) THEN
      IF (state.n_comp_samples > previous(state.n_comp_samples)) THEN
        IF (previous(state.C_comp_meas) < parameters.Detection_limit) THEN parameters.Detection_limit / 2
        ELSE (previous(state.C_comp_meas) * (parameters.n_samples_bottle - 1) + interface.y_M) / (parameters.n_samples_bottle)
      ELSE previous(state.C_meas)
    ELSE 0 ;

    state.L_meas = 0;  
  };

:};



# 106 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.samplers.msl" 2




# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.UCTAD.msl" 1
 















 




# 147 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.UCTAD.msl"



# 66 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.transformers.msl" 1
 




















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/transformers\\wwtp.transformers.ADM1.msl" 1
 



















CLASS Base_ASMtoADM1 "Base ASM- to IWA ADM1 transformer" SPECIALISES PhysicalDAEModelType :=
{:

  comments <- "Base ASM- to IWA ADM1 transformer" ;
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow in flux" : InWWTPTerminal  := {: causality <- "CIN"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : ADM1ConcTerminal := {: causality <- "COUT"; unit <- "kg/m3"; group <- "Effluent" :};
     
    OBJ AD_pH (* terminal = "in_2"; manip = "1" *) "pH of the digester": Real:={: causality <- "CIN"; value <- 6.8; group <- "Operational" :};
    OBJ pH_as (* terminal = "in_2"; manip = "1" *) "pH of the activated sludge": Real:={: causality <- "CIN"; value <- 7; group <- "Operational" :};
    OBJ T_op (* terminal = "in_2"; manip = "1" *) "Operating temperature": CelsiusTemperature := {: causality <- "CIN"; value <- 35; group <- "Operational" :};
  };
  
  parameters <-
  {
     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components" : SpecificVolumeVector;
     
    OBJ naa "Nitrogen content of amino acids (gN/gCOD)" : NitrogenContentPerUnitCOD := {: value <- 0.098; group <- "Stoichiometry" :};  
     
     
    OBJ nbac "nitrogen content of biomass (gN/gCOD)" : Fraction := {: value <- 0.08; group <- "Stoichiometry" :}; 
    OBJ nxc "nitrogen content of composites (gN/gCOD)" : Fraction := {: value <- 0.0376; group <- "Stoichiometry" :}; 
    OBJ nxi "nitrogen content of XI and XP (same in AS and AD) (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :}; 
    OBJ nsi "nitrogen content of SI in ASM (gN/gCOD)" : Fraction := {: value <- 0.00; group <- "Stoichiometry" :};
    OBJ nsi_adm "nitrogen content of SI in ADM (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
     
    OBJ frlixs "lipid fraction of non-nitrogenous Xs" : Fraction := {: value <- 0.7; group <- "Stoichiometry" :};
    OBJ frxs "anaerobically degradable fraction of biomass" : Fraction := {: value <- 0.68; group <- "Stoichiometry" :};
    OBJ frlixb "lipid fraction of non-nitrogenous XBA, XBH COD" : Fraction := {: value <- 0.4; group <- "Stoichiometry":};
    OBJ fdegrade "Fraction of X_BH and X_BA (ASM1) that is biodegradable in anaerobic conditions" : Fraction := {: value <- 0.0; group <- "ASM1 -> ADM1" :};
     
    OBJ T_ref "Reference temperature (ie 25 degC)": CelsiusTemperature := {: value <- 25; group <- "Operational":};
    OBJ help_TK_ref (* hidden = "1" *) "Reference temperature (K)": Real ;
     
    OBJ R (* hidden = "1" *) "Gas law constant" : Real := {: unit <- "bar/M/K"; value <- 0.08314; :};
     
    OBJ Ka_ac "acetate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.74e-5; group <- "System":}; 
    OBJ Ka_bu "butyrate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.5e-5; group <- "System":};
    OBJ Ka_pro "propionate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.32e-5; group <- "System":};
    OBJ Ka_va "valerate acidity constant without temperature correction" : Real := {: unit <- "M"; value <- 1.38e-5; group <- "System":};
    
    OBJ pKa_ac (* hidden = "1"; fixed = "1" *) "Acetate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.76 :}; 
    OBJ pKa_bu (* hidden = "1"; fixed = "1" *) "Butyrate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.82 :};
    OBJ pKa_pro (* hidden = "1"; fixed = "1" *) "Propionate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.88 :};
    OBJ pKa_va (* hidden = "1"; fixed = "1" *) "Valerate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.86 :};
     
     
     
  };
  
  initial <-
  {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
    parameters.help_TK_ref = parameters.T_ref + 273.15;
    parameters.pKa_ac = - log10(parameters.Ka_ac) ;
    parameters.pKa_bu = - log10(parameters.Ka_bu) ;
    parameters.pKa_pro = - log10(parameters.Ka_pro) ;
    parameters.pKa_va = - log10(parameters.Ka_va) ;
  };
  
  independent <- 
  {
  OBJ t "Time" : Time := {: group <- "Time" :};
  };
  
  state <-
  {
     
    OBJ InflowConcentration "Inflow" : WWTPConcTerminal  := {: group <- "Influent" :};
     
    OBJ COD_Demand "the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
    OBJ temp1 "first COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
    OBJ temp2 "Second COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
    OBJ temp3 "Third COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
    OBJ temp4 "Fourth COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
    
    OBJ S_S_reduced "reduced from the influent value to compensate for the incoming electron acceptors": Concentration:= {: group <- "Concentration" :};
    OBJ S_ND_reduced_1 "reduced from the influent value to compensate for the incoming electron acceptors (O2 and NO3)": Concentration:= {: group <- "Concentration" :};
    OBJ S_ND_reduced_2 "reduced after mapping of Ss to amino acids": Concentration:= {: group <- "Concentration" :};
    OBJ S_ND_reduced_3 "reduced after mapping of Si": Concentration:= {: group <- "Concentration" :};
    OBJ X_S_reduced "reduced from the influent value to compensate for the incoming electron acceptors if needed after S_S reduction" : Concentration:= {: group <- "Concentration" :};
    OBJ X_ND_reduced_1 "reduced from the influent value to compensate for the incoming electron acceptors if needed after S_S reduction" : Concentration:= {: group <- "Concentration" :};
    OBJ X_ND_reduced_2 "reduced after mapping of remaining COD" : Concentration:= {: group <- "Concentration" :};
    OBJ X_ND_reduced_3 "reduced after mapping of biomass" : Concentration:= {: group <- "Concentration" :};
    OBJ X_ND_reduced_4 "reduced after mapping of Si" : Concentration:= {: group <- "Concentration" :};
    OBJ X_BH_reduced "reduced from the influent value to compensate for the incoming electron acceptors if needed after X_S reduction": Concentration:= {: group <- "Concentration" :};
    
    OBJ X_BA_reduced "reduced from the influent value to compensate for the incoming electron acceptors if needed after XBH_S reduction": Concentration:= {: group <- "Concentration" :};
    
    



    OBJ inertS "temporary state for calculation of inert solubles": Concentration:= {: group <- "Concentration" :};
    OBJ S_NH_changed_1 "changed NH4 concentration when biomass is used to compensate for incoming electron acceptors ": Concentration:= {: group <- "Concentration" :};
    OBJ S_NH_changed_2 "changed NH4 concentration for compensating denitrification": Concentration:= {: group <- "Concentration" :};
    OBJ S_NH_changed_3 "changed NH4 concentration after mapping of Si": Concentration:= {: group <- "Concentration" :};
    OBJ S_NH_den_1 "ammonium correction from SND after denitrification":Concentration:= {: group <- "Concentration" :};
    OBJ S_NH_den_2 "ammonium correction from XND after denitrification":Concentration:= {: group <- "Concentration" :};
    
    OBJ ReqCODs "Required Saa in ADM1 (as if all Saa Nitrogen is corresponding to Snd from ASM1)" : Concentration:= {: group <- "Concentration" :};
    OBJ biomass "total incoming biomass"  : Concentration:= {: group <- "Concentration" :};
    OBJ biomass_nobio "biomass not anaerobically degradable"  : Concentration:= {: group <- "Concentration" :};
    OBJ biomass_bioN "nitrogen part of biological degradable biomass"  : Concentration:= {: group <- "Concentration" :};
    OBJ prot_XS "Proteins in XS" : Concentration:= {: group <- "Concentration" :};
    OBJ prot_biom "Proteins in biomass (X_BA + X_BH)" : Concentration:= {: group <- "Concentration" :};
    OBJ li_XS "Lipids in XS" : Concentration:= {: group <- "Concentration" :};
    OBJ li_biom "Lipids in biomass (X_BA + X_BH)" : Concentration:= {: group <- "Concentration" :};
    OBJ ch_XS "Carbohydrates in XS" : Concentration:= {: group <- "Concentration" :};
    OBJ ch_biom "Carbohydrates in biomass (X_BA + X_BH)" : Concentration:= {: group <- "Concentration" :};
    OBJ su_from_ss "Sugars created from Ss": Concentration:= {: group <- "Concentration" :};
    OBJ su_from_si "Sugars created from Si": Concentration:= {: group <- "Concentration" :};
    
    OBJ Snh_release "SNH released during NO3 removal" : Concentration:= {: group <- "Concentration" :};
    
    OBJ COD_in "Incoming COD to the interface": Concentration:= {: group <- "Concentration" :};
    OBJ COD_out "Outgoing COD from the interface": Concentration:= {: group <- "Concentration" :};
    OBJ COD_balance "difference between COD in and out": Real:= {: group <- "Concentration" :};
    OBJ N_in "Incoming N to the interface": Concentration:= {: group <- "Concentration" :};
    OBJ N_out "Outgoing N from the interface": Concentration:= {: group <- "Concentration" :};
    OBJ N_balance "difference between N in and out": Real:= {: group <- "Balance" :};
    OBJ degradability "degradability of the digester influent": Fraction:= {: group <- "Balance" :};
    
    OBJ alfa_ac "acetate charge": Real:= {: group <- "Balance" :};
    OBJ alfa_pro "propionate charge": Real:= {: group <- "Balance" :};
    OBJ alfa_bu "butyrate charge": Real:= {: group <- "Balance" :};
    OBJ alfa_va "valerate charge": Real:= {: group <- "Balance" :};
    OBJ alfa_in_adm "inorganic nitrogen charge in digester": Real:= {: group <- "Balance" :}; 
    OBJ alfa_ic "inorganic carbon charge": Real:= {: group <- "Balance" :};
    OBJ alfa_nh "ammonium charge": Real:= {: group <- "Balance" :};
    
    OBJ alfa_no "nitrate charge": Real:= {: group <- "Balance" :};
    
    



    OBJ alfa_alk "alkalinity charge": Real:= {: group <- "Balance" :};
    OBJ alfa_in_as "inorganic nitrogen charge in the activated sludge": Real:= {: group <- "Balance" :};
    OBJ cat_an "cations minus anions": Real:= {: group <- "Balance" :};
    
    OBJ pKa_in "Inorganic nitrogen acidity constant" : Real:= {: group <- "System" :};
    OBJ pKa_ic "Inorganic carbon acidity constant" : Real:= {: group <- "System" :};
    OBJ pKw "Water acidity constant" : Real:= {: group <- "System" :};
    
    OBJ help_TK_op (* hidden = "1" *) "Operational temperature (K)": Real ;
 


  };
  
  equations <-
  {
   
  {state.InflowConcentration[IndexOfSolvent] = interface.Inflow[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];}; 
  
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
  state.InflowConcentration[Comp_Index] = IF (state.InflowConcentration[IndexOfSolvent] == 0)
  THEN 0
  ELSE interface.Inflow[Comp_Index] / state.InflowConcentration[IndexOfSolvent] ;};
  
   
   
  interface.Outflow[H2O] = state.InflowConcentration[H2O];    
 

























































































  
    interface.Outflow[S_aa] = IF(state.S_S_reduced <= state.ReqCODs)     
      THEN state.S_S_reduced/1000    
      ELSE state.ReqCODs/1000;       
 


































































































  
    interface.Outflow[S_Inert] = state.inertS/1000;
 
















































  
    interface.Outflow[S_su] = (state.su_from_si + state.su_from_ss)/1000;
    interface.Outflow[X_ch] = (state.ch_XS + state.ch_biom)/1000;
    interface.Outflow[X_pr] = (state.prot_XS + state.prot_biom)/1000;
    interface.Outflow[X_li] = (state.li_XS + state.li_biom)/1000;
  
     
     
     
    interface.Outflow[S_INN]= (state.S_ND_reduced_3+state.X_ND_reduced_4+state.S_NH_changed_3) / 14000 ;
    
     
    
     
    interface.Outflow[S_ch4] = 0;
    interface.Outflow[S_h2]=0;
    interface.Outflow[S_ac]=0;
    interface.Outflow[S_bu]=0;
    interface.Outflow[S_fa]=0;
    interface.Outflow[S_pro]=0;
    interface.Outflow[X_c]=0;
    interface.Outflow[S_va]=0;
    interface.Outflow[X_aa]=0;
    interface.Outflow[X_c4]=0;
    interface.Outflow[X_ac]=0;
    interface.Outflow[X_fa]=0;
    interface.Outflow[X_h2]=0;
    interface.Outflow[X_pro]=0;
    interface.Outflow[X_su]=0;

 












  
     
    state.COD_out = interface.Outflow[S_aa] + interface.Outflow[S_su] + interface.Outflow[S_Inert] +
      interface.Outflow[X_c] + interface.Outflow[X_ch] + interface.Outflow[X_pr] + interface.Outflow[X_li] +
      interface.Outflow[X_Inert];  
    
     
    state.COD_balance = state.COD_in - state.COD_Demand - state.COD_out * 1000;
 












  
     
    state.N_out = (interface.Outflow[S_aa] + interface.Outflow[X_pr])*parameters.naa + interface.Outflow[S_INN]*14 + 
      (interface.Outflow[S_Inert] + interface.Outflow[X_Inert]) * parameters.nxi;
 








  
     
    state.degradability = (interface.Outflow[S_aa] + interface.Outflow[S_su] + interface.Outflow[X_ch] + interface.Outflow[X_pr] 
      + interface.Outflow[X_li])/state.COD_out;
    
    state.help_TK_op = interface.T_op + 273.15;
    
     
    state.pKa_in = 9.25-log10(exp(51965*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
    state.pKa_ic = 6.35-log10(exp(7646*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
    state.pKw = 14-log10(exp(55900*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
    
     
    state.alfa_ac = (-1/(1+pow(10,parameters.pKa_ac-interface.AD_pH)))/64.0;           
    state.alfa_pro = (-1/(1+pow(10,parameters.pKa_pro-interface.AD_pH)))/112.0;
    state.alfa_bu = (-1/(1+pow(10,parameters.pKa_bu-interface.AD_pH)))/160.0; 
    state.alfa_va = (-1/(1+pow(10,parameters.pKa_va-interface.AD_pH)))/208.0;
    state.alfa_in_adm = pow(10,state.pKa_in-interface.AD_pH)/(1+pow(10,state.pKa_in-interface.AD_pH)); 
    state.alfa_ic = (-1/(1+pow(10,(state.pKa_ic-interface.AD_pH))));
    state.alfa_in_as = pow(10,state.pKa_in-interface.pH_as)/(1+pow(10,state.pKa_in-interface.pH_as));
    state.alfa_nh = 1.0/14000.0;
     
    state.alfa_alk = -1.0/1000.0;  
 













     
    state.cat_an = interface.Outflow[S_ac] * state.alfa_ac + interface.Outflow[S_pro] * state.alfa_pro +
      interface.Outflow[S_bu]*state.alfa_bu + interface.Outflow[S_va] * state.alfa_va + interface.Outflow[S_INN] * state.alfa_in_adm +
      interface.Outflow[S_IC] * state.alfa_ic + pow(10,-interface.AD_pH) - pow(10,-state.pKw+interface.AD_pH) ;
    
    interface.Outflow[S_an] = IF(state.cat_an > 0) THEN 0 ELSE -state.cat_an ;
    
    interface.Outflow[S_cat] = IF(state.cat_an > 0) THEN state.cat_an ELSE 0 ;
  };

:};


CLASS Base_ADM1toASM "Base ADM1 to ASM- transformer" SPECIALISES PhysicalDAEModelType :=
{:

  comments <- "Base ADM1 to ASM- transformer";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : ADM1ConcTerminal  := {: causality <- "CIN"; unit <- "kg/m3"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT"; group <- "Effluent" :};
     
    OBJ AD_pH (* terminal = "in_2"; manip = "1" *) "pH of the digester": Real:={: causality <- "CIN"; value <- 6.8; group <- "Operational" :};
    OBJ pH_as (* terminal = "in_2"; manip = "1" *) "pH of the activated sludge": Real:={: causality <- "CIN"; value <- 7; group <- "Operational" :};
    OBJ T_op (* terminal = "in_2"; manip = "1" *) "Operating temperature": CelsiusTemperature := {: causality <- "CIN"; value <- 35; group <- "Operational" :};
  };

  parameters <-
  {
    OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components" : SpecificVolumeVector;
    
     
    OBJ fdegrade_AS "Fraction of ADM Xi that is biodegradable in aerobic conditions" : Fraction := {: value <- 0.0; group <- "ADM1->ASM1" :};
    OBJ naa "Nitrogen content of amino acids_gN/gCOD " : NitrogenContentPerUnitCOD := {: value <- 0.098; group <- "Stoichiometry" :};
    OBJ nbac "nitrogen content of biomass (gN/gCOD)" : Fraction := {: value <- 0.08; group <- "Stoichiometry" :};
    OBJ nsi "nitrogen content of SI in ASM (gN/gCOD)" : Fraction := {: value <- 0.00; group <- "Stoichiometry" :};
    OBJ nsi_adm "nitrogen content of SI in ADM (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
    OBJ nxc "nitrogen content of composite material and X_P (gN/gCOD)" : Fraction := {: value <- 0.0376; group <- "Stoichiometry" :};
    OBJ nxi "nitrogen content of XI and XP (same in AS and AD) (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :}; 
     
     
    OBJ Ka_ac "acetate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.74e-5; group <- "System":}; 
    OBJ Ka_bu "butyrate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.5e-5; group <- "System":};
    OBJ Ka_pro "propionate acidity constant without temperature correction_M" : Real := {: unit <- "M"; value <- 1.32e-5; group <- "System":};
    OBJ Ka_va "valerate acidity constant without temperature correction" : Real := {: unit <- "M"; value <- 1.38e-5; group <- "System":};
    OBJ Ka_co2 "CO2 acidity constant with temperature correction_M" : Real := {: unit <- "M"; value <- 4.94e-7; group <- "System":};
    OBJ Ka_h2o "water acidity constant with temperature correction" : Real := {: unit <- "M"; value <- 2.08e-14; group <- "System":};
    OBJ Ka_nh4 "NH4+ acidity constant with temperature correction" : Real := {: unit <- "M"; value <- 1.11e-9; group <- "System":};
     
     
    OBJ i_X_e "Mass of nitrogen per mass of COD in products formed and inert particulates(ASM1)" : MassOfNitrogenPerMassOfCODInProdFromBiomass :=
    {: value <- 0.0580; group <- "Stoichiometry" :};  
    OBJ pKa_ac (* hidden = "1"; fixed = "1" *) "Acetate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.76 :}; 
    OBJ pKa_bu (* hidden = "1"; fixed = "1" *) "Butyrate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.82 :};
    OBJ pKa_pro (* hidden = "1"; fixed = "1" *) "Propionate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.88 :};
    OBJ pKa_va (* hidden = "1"; fixed = "1" *) "Valerate acidity constant (temperature correction can be ignored)" : Real:= {: unit <- "M"; value <- 4.86 :};

    OBJ T_ref "Reference temperature (ie 25 degC)": CelsiusTemperature:={: value <- 25; group <- "Operational":};
    OBJ help_TK_ref (* hidden = "1" *) "Reference temperature (K)": Real ;
     
    OBJ R (* hidden = "1" *) "Gas law constant" : Real := {: unit <- "bar/M/K"; value <- 0.08314; :};
     
    OBJ frxs_AS "aerobically degradable fraction of biomass" : Fraction := {: value <- 0.79; group <- "Stoichiometry" :};
  };

  initial <-
  {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
    parameters.help_TK_ref = parameters.T_ref + 273.15;
    parameters.pKa_ac = - log10(parameters.Ka_ac) ;
    parameters.pKa_bu = - log10(parameters.Ka_bu) ;
    parameters.pKa_pro = - log10(parameters.Ka_pro) ;
    parameters.pKa_va = - log10(parameters.Ka_va) ;
  };
  
  independent <- 
  {
    OBJ t "Time": Time:= {: group <- "Time" :} ;
  };
  
  state <-
  {
    OBJ OutflowConcentration "Outflow" : WWTPConcTerminal := {: group <- "Effluent" :};
     
    OBJ S_h_ion "Hydrogen ion_M" : MolConcentration :={: group <- "Concentration" :};
    OBJ S_nh4_i"amonium molar concentration" : MolConcentration :={: group <- "Concentration" :};
    OBJ S_hco3_i"bicarbonate ion molar concentration" : MolConcentration :={: group <- "Concentration" :};
     
    OBJ alfa_ac "acetate charge": Real :={: group <- "Stoichiometry" :};
    OBJ alfa_pro "propionate charge": Real :={: group <- "Stoichiometry" :};
    OBJ alfa_bu "butyrate charge": Real :={: group <- "Stoichiometry" :};
    OBJ alfa_va "valerate charge": Real :={: group <- "Stoichiometry" :};
    OBJ alfa_in_adm "inorganic nitrogen charge in digester": Real :={: group <- "Stoichiometry" :};
    OBJ alfa_ic "inorganic carbon charge": Real :={: group <- "Stoichiometry" :};
    OBJ alfa_nh "ammonium charge": Real :={: group <- "Stoichiometry" :};
    
    OBJ alfa_no "nitrate charge": Real:={: group <- "Stoichiometry" :};
    
    



    OBJ alfa_alk "alkalinity charge": Real :={: group <- "Stoichiometry" :};
    OBJ alfa_in_as "inorganic nitrogen charge in the activated sludge": Real :={: group <- "Stoichiometry" :};
    OBJ cat_an "cations minus anions": Real :={: group <- "Stoichiometry" :};
     
    OBJ pKa_in "Inorganic nitrogen acidity constant" : Real :={: group <- "System" :};
    OBJ pKa_ic "Inorganic carbon acidity constant" : Real :={: group <- "System" :};
    OBJ pKw "Water acidity constant" : Real :={: group <- "System" :};
     
    OBJ COD_in "Incoming COD to the interface": Concentration :={: group <- "Concentration" :};
    OBJ COD_out "Outgoing COD from the interface": Concentration :={: group <- "Concentration" :};
    OBJ COD_balance "difference between COD in and out": Real :={: group <- "System" :};
    OBJ N_in "Incoming N to the interface": Concentration :={: group <- "Concentration" :};
    OBJ N_out "Outgoing N from the interface": Concentration :={: group <- "Concentration" :};
    OBJ N_balance "difference between N in and out": Real :={: group <- "System" :};
     
    OBJ biomass "total incoming biomass"  : Concentration :={: group <- "Concentration" :};
    OBJ biomass_nobio "biomass not anaerobically degradable"  : Concentration :={: group <- "Concentration" :};
    OBJ biomass_bioN "nitrogen part of biological degradable biomass"  : Concentration :={: group <- "Concentration" :}; 
     
    OBJ COD_remain "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ COD_remain_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ X_P_temp "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :}; 
    OBJ XS_temp "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ XS_temp2 "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ biomass_nobio_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};   
    OBJ biomass_bioN_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ S_INN_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :}; 
    OBJ inertX "temp state for inerts mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ noninertX "temp state for inerts mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ inertS "temp state for inerts mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ S_INN_reduced2 "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
    OBJ help_TK_op (* hidden = "1" *) "Operational temperature (K)" : Real ;
  };
  
  equations <-
  {
     
    {interface.Outflow[IndexOfSolvent] = - state.OutflowConcentration[IndexOfSolvent] 
    / parameters.WWTPSpecificVolume[IndexOfSolvent] ;}; 
    
    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Outflow[Comp_Index] = - state.OutflowConcentration[Comp_Index] * 
    state.OutflowConcentration[IndexOfSolvent];};

     
     
     
    state.OutflowConcentration[H2O] = interface.Inflow[H2O];
    
     
    state.biomass = 1000 * (interface.Inflow[X_su] + interface.Inflow[X_aa] + interface.Inflow[X_fa] +
      interface.Inflow[X_c4] + interface.Inflow[X_pro] + interface.Inflow[X_ac] + interface.Inflow[X_h2]) ;
    state.biomass_nobio = state.biomass * (1-parameters.frxs_AS) ;  
    state.biomass_bioN = parameters.nbac * state.biomass - state.biomass_nobio * parameters.nxi ;  
    state.COD_remain = 0 ;

    state.X_P_temp = IF (state.biomass_bioN < 0)   
      THEN state.biomass*parameters.nbac/parameters.nxi ELSE state.biomass_nobio ;
      
    state.biomass_nobio_reduced = IF (state.biomass_bioN < 0) THEN state.X_P_temp ELSE state.biomass_nobio ;
    
    state.biomass_bioN_reduced = IF (state.biomass_bioN < 0) THEN 0 ELSE state.biomass_bioN ;

    state.XS_temp = IF ((state.biomass_bioN_reduced/parameters.nxc) <= (state.biomass - state.biomass_nobio)) THEN     
      IF (interface.Inflow[S_INN] * 14000 / parameters.nxc > (state.biomass - state.biomass_nobio - state.biomass_bioN_reduced / parameters.nxc))  
        THEN state.biomass - state.biomass_nobio ELSE state.biomass_bioN_reduced / parameters.nxc
      ELSE state.biomass - state.biomass_nobio ;       

    state.S_INN_reduced = interface.Inflow[S_INN] + state.biomass * parameters.nbac / 14000.0 -
      state.X_P_temp * parameters.nxi / 14000.0 - (state.XS_temp + state.XS_temp2) * parameters.nxc / 14000.0 ;

     
    state.inertX = (1 - parameters.fdegrade_AS) * interface.Inflow[X_Inert] * 1000 ;
    state.noninertX = parameters.fdegrade_AS * interface.Inflow[X_Inert] * 1000 ;

     
    state.inertS = IF (interface.Inflow[S_Inert] * parameters.nsi_adm < interface.Inflow[S_Inert] * parameters.nsi) THEN     
      IF (state.S_INN_reduced * 14 < interface.Inflow[S_Inert] * parameters.nsi)     
        THEN interface.Inflow[S_Inert] * parameters.nsi_adm / parameters.nsi + state.S_INN_reduced * 14 / parameters.nsi
        ELSE interface.Inflow[S_Inert]
      ELSE interface.Inflow[S_Inert] ;

    state.S_INN_reduced2 = IF (interface.Inflow[S_Inert] * parameters.nsi_adm < interface.Inflow[S_Inert] * parameters.nsi) THEN     
      IF (state.S_INN_reduced * 14 < interface.Inflow[S_Inert] * parameters.nsi) THEN 0.0      
      ELSE state.S_INN_reduced - interface.Inflow[S_Inert] * (1 - parameters.nsi_adm / parameters.nsi) * parameters.nsi / 14.0 
      ELSE state.S_INN_reduced + interface.Inflow[S_Inert] * (parameters.nsi_adm - parameters.nsi) / 14.0 ;  

     
    
     
     
    
     
    
     
    
     












    
     
     
    
    state.help_TK_op = interface.T_op + 273.15;

     
    state.pKa_in = 9.25-log10(exp(51965*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
    state.pKa_ic = 6.35-log10(exp(7646*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
    state.pKw = 14-log10(exp(55900*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
    
     
    
     
    state.alfa_ac = (-1/(1+pow(10,parameters.pKa_ac-interface.AD_pH)))/64.0;           
    state.alfa_pro = (-1/(1+pow(10,parameters.pKa_pro-interface.AD_pH)))/112.0;
    state.alfa_bu = (-1/(1+pow(10,parameters.pKa_bu-interface.AD_pH)))/160.0; 
    state.alfa_va = (-1/(1+pow(10,parameters.pKa_va-interface.AD_pH)))/208.0;
    state.alfa_in_adm = pow(10,state.pKa_in-interface.AD_pH)/(1+pow(10,state.pKa_in-interface.AD_pH)); 
    state.alfa_ic = (-1/(1+pow(10,(state.pKa_ic-interface.AD_pH))));
    state.alfa_in_as = pow(10,state.pKa_in-interface.pH_as)/(1+pow(10,state.pKa_in-interface.pH_as));
    state.alfa_nh = 1.0/14000.0;
     
    state.alfa_alk = -1.0/1000.0;

     
    
     
    state.COD_in = interface.Inflow[S_aa] + interface.Inflow[S_su] + interface.Inflow[S_fa] + interface.Inflow[S_va] +
      interface.Inflow[S_bu] + interface.Inflow[S_pro] + interface.Inflow[S_ac] + interface.Inflow[S_h2] +
      interface.Inflow[S_ch4] + interface.Inflow[S_Inert] + interface.Inflow[X_c]
      + interface.Inflow[X_ch] + interface.Inflow[X_pr] + interface.Inflow[X_li] + interface.Inflow[X_Inert]
      + state.biomass/1000.0;  

     
    state.COD_balance = state.COD_in * 1000 - state.COD_out - (interface.Inflow[S_h2] + interface.Inflow[S_ch4]) * 1000 ;      

     
    state.N_in =  state.biomass/1000.0 * parameters.nbac + interface.Inflow[X_c] * parameters.nxc +
      (interface.Inflow[S_aa] + interface.Inflow[X_pr]) * parameters.naa +  interface.Inflow[S_INN] * 14 + 
      interface.Inflow[S_Inert] * parameters.nsi_adm + interface.Inflow[X_Inert] * parameters.nxi ;
     
    state.N_balance = state.N_in * 1000 - state.N_out ;    
  };

:};



# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/transformers\\wwtp.transformers.ADM1.ASM1.msl" 1
 



















CLASS ASM1toADM1 "ASM1 & ASMG1 to IWA ADM1 anaerobic model states flow transformer for use in BSM2"
EXTENDS Base_ASMtoADM1 WITH
{:

  comments <- "Transforms a ASM1 or ASMG1 influent to a ADM1 anaerobic influent type";

  parameters <-
  {
    



  };
  
  initial <-
  {
    


  };
  
  state <-
  {
    


     
  };
  
  equations <-
  {
   
   
  
    state.COD_Demand = state.InflowConcentration[S_O] + 2.86 * state.InflowConcentration[S_NO] ;
  
  



  
   
    state.temp1=state.InflowConcentration[S_S];
    state.temp2=state.InflowConcentration[S_S]+state.InflowConcentration[X_S];
    state.temp3=state.InflowConcentration[S_S]+state.InflowConcentration[X_S]+state.InflowConcentration[X_BH];
  
  state.temp4=state.InflowConcentration[S_S]+state.InflowConcentration[X_S]+state.InflowConcentration[X_BH]+state.InflowConcentration[X_BA];
  
  



  
    state.S_S_reduced=  
  IF(state.COD_Demand > state.temp1)
      THEN 0                                           
      ELSE state.InflowConcentration[S_S] - state.COD_Demand;   
                      
    state.X_S_reduced=  
  IF(state.COD_Demand > state.temp2)
      THEN 0
      ELSE 
       IF (state.COD_Demand > state.temp1)
          THEN state.InflowConcentration[X_S] - state.COD_Demand + state.InflowConcentration[S_S]
          ELSE state.InflowConcentration[X_S];
  
    state.X_BH_reduced= 
  IF(state.COD_Demand > state.temp3)
      THEN 0
      ELSE 
        IF (state.COD_Demand > state.temp2)
           THEN state.InflowConcentration[X_BH] - state.COD_Demand + state.InflowConcentration[S_S] +state.InflowConcentration[X_S]
           ELSE state.InflowConcentration[X_BH];
                      
  
    state.X_BA_reduced = IF(state.COD_Demand > state.temp4) THEN 0 	  
  	ELSE IF (state.COD_Demand > state.temp3) THEN
  		 state.InflowConcentration[X_BA] - state.COD_Demand + state.InflowConcentration[S_S]
  		 + state.InflowConcentration[X_S] + state.InflowConcentration[X_BH]
  		 ELSE state.InflowConcentration[X_BA] ;                 
  
  
# 114 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/transformers\\wwtp.transformers.ADM1.ASM1.msl"

  
   
  
  state.S_NH_changed_1 = state.InflowConcentration[S_NH] + parameters.nbac *
  		(state.InflowConcentration[X_BA] - state.X_BA_reduced + state.InflowConcentration[X_BH] - state.X_BH_reduced);                     
  
  





  
   
   
    state.S_ND_reduced_1= state.InflowConcentration[S_ND];
   
   
   
  state.X_ND_reduced_1=  state.InflowConcentration[X_ND];
   
   
   
  
   
    state.ReqCODs = state.InflowConcentration[S_ND] / parameters.naa;
  


    state.su_from_ss = 
  IF(state.S_S_reduced <= state.ReqCODs)
       THEN 0
       ELSE (state.S_S_reduced-state.ReqCODs);   
  
    state.S_ND_reduced_2 = 
    IF(state.S_S_reduced <= state.ReqCODs)
     THEN state.S_ND_reduced_1 - state.S_S_reduced*parameters.naa    
     ELSE 0;   
  
   
  
    state.S_NH_den_1 = 
  IF (state.InflowConcentration[S_S] == 0)
     THEN state.InflowConcentration[S_ND]
     ELSE (state.InflowConcentration[S_S]- state.S_S_reduced)*state.InflowConcentration[S_ND]/state.InflowConcentration[S_S];
  
    state.S_NH_den_2 = 
  IF (state.InflowConcentration[X_S] == 0)
     THEN state.InflowConcentration[X_ND]
     ELSE (state.InflowConcentration[X_S]- state.X_S_reduced)*state.InflowConcentration[X_ND]/state.InflowConcentration[X_S];    
  
    state.S_NH_changed_2=state.S_NH_changed_1; 
  
   
   
   
    state.prot_XS = 
  IF(state.X_S_reduced <= state.X_ND_reduced_1 / parameters.naa)   
     THEN state.X_S_reduced   
     ELSE state.X_ND_reduced_1 / parameters.naa;   
    
  state.X_ND_reduced_2=  
  IF(state.X_S_reduced <= state.X_ND_reduced_1 / parameters.naa)  
     THEN state.X_ND_reduced_1 - state.X_S_reduced*parameters.naa
     ELSE 0;
  
  
  state.biomass = state.InflowConcentration[X_BA] + state.InflowConcentration[X_BH] ;
  
  


  
  state.biomass_nobio=state.biomass*(1-parameters.frxs);
  state.biomass_bioN=parameters.nbac*state.biomass - state.biomass_nobio*parameters.nxi;
  state.prot_biom = 
  IF (state.biomass_bioN / parameters.naa <= (state.biomass - state.biomass_nobio)) 
     THEN  
       IF(state.X_ND_reduced_2 / parameters.naa > (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa))  
         THEN state.biomass_bioN / parameters.naa + (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa)  
       ELSE state.biomass_bioN / parameters.naa + state.X_ND_reduced_2 / parameters.naa  
     ELSE state.biomass - state.biomass_nobio;
   
   state.X_ND_reduced_3=  
   IF (state.biomass_bioN / parameters.naa <= (state.biomass - state.biomass_nobio)) 
      THEN 
     IF (state.X_ND_reduced_2 / parameters.naa > (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa))
        THEN state.X_ND_reduced_2 - (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa)*parameters.naa
      ELSE 0
    ELSE state.X_ND_reduced_2 + state.biomass*parameters.nbac - state.biomass_nobio*parameters.nxi - (state.biomass - state.biomass_nobio)*parameters.naa;
   
   
    state.ch_XS = IF(state.X_S_reduced <= state.prot_XS)
                THEN 0
          ELSE  (state.X_S_reduced - state.prot_XS)*(1 - parameters.frlixs);
  state.ch_biom = IF(parameters.frxs * state.biomass <= state.prot_biom)  
                  THEN 0
          ELSE (parameters.frxs * state.biomass - state.prot_biom) * (1 - parameters.frlixb);
  
   
    state.li_XS = IF(state.X_S_reduced < state.prot_XS)
                THEN 0
          ELSE  (state.X_S_reduced - state.prot_XS)*parameters.frlixs;
  state.li_biom = IF(parameters.frxs * state.biomass < state.prot_biom)  
                  THEN 0
          ELSE (parameters.frxs * state.biomass - state.prot_biom) * parameters.frlixb;     
  
   
   
  interface.Outflow[X_Inert] = 
  ((1-parameters.fdegrade)*(state.InflowConcentration[X_P] +state.InflowConcentration[X_I]) 
  + state.biomass_nobio)/1000;
   
   
    state.inertS =
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN
      IF (state.S_NH_changed_2 <(state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm)
       THEN state.InflowConcentration[S_I]*parameters.nsi/parameters.nsi_adm + state.S_ND_reduced_2/parameters.nsi_adm + state.X_ND_reduced_3/parameters.nsi_adm + state.S_NH_changed_2/parameters.nsi_adm
       ELSE state.InflowConcentration[S_I]
     ELSE state.InflowConcentration[S_I]     
     ELSE state.InflowConcentration[S_I]  
   ELSE state.InflowConcentration[S_I];
  


   
    state.S_ND_reduced_3=
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN  0  
     ELSE state.S_ND_reduced_2 - (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm))*parameters.nsi_adm  
   ELSE state.S_ND_reduced_2 + state.InflowConcentration[S_I]*(parameters.nsi-parameters.nsi_adm);
  
    state.X_ND_reduced_4=
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN 0
     ELSE state.X_ND_reduced_3 - (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm     
     ELSE state.X_ND_reduced_3  
   ELSE state.X_ND_reduced_3;
  
    state.S_NH_changed_3=
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN
      IF (state.S_NH_changed_2 <(state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm)
       THEN 0
       ELSE state.S_NH_changed_2 - (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm
     ELSE state.S_NH_changed_2     
     ELSE state.S_NH_changed_2  
   ELSE state.S_NH_changed_2; 
  
   
  state.su_from_si = 
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN
      IF (state.S_NH_changed_2 <(state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm)
       THEN (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm-state.S_NH_changed_2/parameters.nsi_adm)
       ELSE 0
     ELSE 0    
     ELSE 0  
   ELSE 0;
    
  
    
   
   
  
  state.COD_in = state.InflowConcentration[S_I] + state.InflowConcentration[S_S] +
  	state.InflowConcentration[X_I] + state.InflowConcentration[X_S] + state.InflowConcentration[X_BH] +
  	state.InflowConcentration[X_BA] + state.InflowConcentration[X_P] ;
  
  




  
   
   
  
  state.N_in = state.InflowConcentration[S_NO] + state.InflowConcentration[S_NH] + state.InflowConcentration[S_ND]
  		+ state.InflowConcentration[X_ND] + parameters.nbac * ( state.InflowConcentration[X_BH] + state.InflowConcentration[X_BA])
  		+ parameters.nsi * state.InflowConcentration[S_I] + parameters.nxi * (state.InflowConcentration[X_P] + state.InflowConcentration[X_I]);
  
  





  
   
  
  state.N_balance = state.N_in - state.InflowConcentration[S_NO] - state.N_out * 1000;
  
  




     
    
    state.alfa_no = -1.0/14000.0;
    
    



  
   
   
   interface.Outflow[S_IC] = (((state.InflowConcentration[S_ALK] * state.alfa_alk + state.InflowConcentration[S_NH] * state.alfa_nh
   			+ state.InflowConcentration[S_NO] * state.alfa_no) - (interface.Outflow[S_ac] * state.alfa_ac + interface.Outflow[S_pro] * state.alfa_pro
  		+ interface.Outflow[S_bu] * state.alfa_bu + interface.Outflow[S_va] * state.alfa_va + interface.Outflow[S_INN] * state.alfa_in_adm)) / state.alfa_ic) ; 
   
   





  };

:};
 
 
CLASS ADM1toASM1 "ADM1 to ASM1 & ASMG1 anaerobic model states flow transformer"
EXTENDS Base_ADM1toASM WITH
 {:
  
  comments <- "Transforms a ADM1 influent to a ASM1 or ASMG1 anaerobic influent type";
  
  parameters <-
  {
    



  };
  
  initial <-
  {
    


  };

  equations <-
  {
    state.OutflowConcentration[X_P]= state.X_P_temp; 

    state.OutflowConcentration[X_S] = (interface.Inflow[X_c] + interface.Inflow[X_ch] + interface.Inflow[X_pr] +
      interface.Inflow[X_li]) * 1000 + state.XS_temp ;

    state.OutflowConcentration[X_I] = state.inertX ;
  
    state.OutflowConcentration[S_I] =  state.inertS*1000;
    state.OutflowConcentration[S_NH] = state.S_INN_reduced2*14000 ;   

     
    state.OutflowConcentration[S_S] = (interface.Inflow[S_su] + interface.Inflow[S_aa] + interface.Inflow[S_fa] +
      interface.Inflow[S_va] + interface.Inflow[S_bu] + interface.Inflow[S_pro] + interface.Inflow[S_ac]) * 1000 ;                                          

     
    state.OutflowConcentration[S_ND] = parameters.naa * interface.Inflow[S_aa] *1000;
    
    state.OutflowConcentration[X_ND] = parameters.nxc*(state.XS_temp) + (parameters.nxc * interface.Inflow[X_c] +
      parameters.naa * interface.Inflow[X_pr])*1000 ;

    state.OutflowConcentration[S_O]= 0; 
    state.OutflowConcentration[S_NO]= 0;
    




    state.OutflowConcentration[X_BH]= 0;
    
    state.OutflowConcentration[X_BA]= 0;              
    
    



    
    
    state.OutflowConcentration[S_ALK]= ((interface.Inflow[S_ac]*state.alfa_ac
      + interface.Inflow[S_pro]*state.alfa_pro + interface.Inflow[S_bu]*state.alfa_bu
      + interface.Inflow[S_va]*state.alfa_va + interface.Inflow[S_INN]*state.alfa_in_adm
      + interface.Inflow[S_IC]*state.alfa_ic) - (state.OutflowConcentration[S_NH]*state.alfa_nh
      + state.OutflowConcentration[S_NO]*state.alfa_no)) / state.alfa_alk ;
    
    







     
    
    state.alfa_no = -1.0/14000.0;
    
    




     
     
    
    state.COD_out = state.OutflowConcentration[S_I] + state.OutflowConcentration[S_S]
      + state.OutflowConcentration[X_I] + state.OutflowConcentration[X_S]
      + state.OutflowConcentration[X_BH] + state.OutflowConcentration[X_BA]
      + state.OutflowConcentration[X_P];
    
    





                             
     
    
    state.N_out = state.OutflowConcentration[S_NO] + state.OutflowConcentration[S_NH]
      + state.OutflowConcentration[S_ND] + state.OutflowConcentration[X_ND]
      + parameters.nbac * ( state.OutflowConcentration[X_BH] + state.OutflowConcentration[X_BA])
      + parameters.nsi*state.OutflowConcentration[S_I] + parameters.nxi * (state.OutflowConcentration[X_P]
      + state.OutflowConcentration[X_I]);
    
    







  };

 :};



# 807 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/transformers\\wwtp.transformers.ADM1.msl" 2









# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.transformers.msl" 2







# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/transformers\\wwtp.transformers.Siegrist.msl" 1
 




















CLASS ASM1ToSiegrist "ASM1 to Siegrist anaerobic model states flow transformer"
SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "ASM1 to Siegrist anaerobic model states flow transformer";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal  := {: causality <- "CIN"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : SiegristWWTPTerminal := {: causality <- "COUT"; group <- "Effluent" :};
  };

  parameters <-
  {
     
    OBJ SiegristSpecificVolume (* hidden = "1" *) "Specific volume for all Siegrist components" : SiegristSpecificVolumeVector ;
    OBJ pH_In "pH of incoming wastewater" : pH := {: value <- 7.0 ; group <- "Influent characterization" :};
    OBJ S_H_In (* hidden = "0" *) "Proton concentration in incoming wastewater" : MolConcentration := {: group <- "Influent characterization" :};
    OBJ Keq_CO2 (* hidden = "1" *) "Equilibrium constant for CO2" : PhysicalQuantityType := {: unit <- "mol.m-3"; interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :}; :};
     
     
    OBJ i_X_B "Mass of N per mass of COD in biomass (ASM1)" : Fraction := {: value <- 0.086 ; group <- "Conversion factors" :};
    OBJ i_X_P "Mass of N per mass of COD in products formed (ASM1)" : Fraction := {: value <- 0.04 ; group <- "Conversion factors" :};
    OBJ i_S_AS "Mass of N per mass of COD in Amino Acids (S_AS)" : Fraction := {: value <- 0.040 ; group <- "Conversion factors" :};
    OBJ i_X_S_An "Mass of N per mass of COD in slowly biodegradable matter (X_S)" : Fraction := {: value <- 0.020 ; group <- "Conversion factors" :};
    OBJ i_X_An "Mass of N per mass of COD in anaerobic biomass" : Fraction := {: value <- 0.080 ; group <- "Conversion factors" :};
    OBJ i_X_IN "Mass of N per mass of COD in inert particulates" : Fraction := {: value <- 0.040 ; group <- "Conversion factors" :};
    OBJ f_AC_S "Acetate (S_AC) fraction of S_S" : Fraction := {: value <- 0.30 ; group <- "Conversion factors" :};
    OBJ f_PRO_S "Propionate (S_PRO) fraction of S_S" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_AS_S "Amino Acids and sugar (S_AS) fraction of S_S" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_XS_I "X_I fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_XS_H "X_BH fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.08 ; group <- "Conversion factors" :};
    OBJ f_XS_A "X_BA fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.92 ; group <- "Conversion factors" :};
    OBJ f_XS_P "X_P fraction that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};
    OBJ f_AS_H "Fraction of X_BH that are capable of fermenting" : Fraction := {: value <- 0.50 ; group <- "Conversion factors" :};
  };

  initial <-
  {
    parameters.SiegristSpecificVolume[H2O] := 0.000001 ;
    state.f_FA_S := 1 - (parameters.f_AC_S + parameters.f_PRO_S + parameters.f_AS_S) ;
    state.f_X_IN_H := 1 - (parameters.f_XS_H + parameters.f_AS_H);
    parameters.S_H_In := (pow(10, - parameters.pH_In)) * 1e+3;
  };

  independent <- 
  {
    OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <- 
  {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all ASM components" : MassFluxVector ;
    OBJ Help_InFlux_SS (* hidden = "1" *) "Incoming S_S after oxidizing with S_O and S_NO" : MassFlux ;
    OBJ InFlux_SS (* hidden = "1" *) "Influx of S_S after correction for oxidizing with incoming S_O and S_NO" : MassFlux;
    OBJ InFlux_XS (* hidden = "1" *) "Influx of X_S after correction for oxidizing with incoming S_O and S_NO" : MassFlux;
     
    OBJ f_FA_S "Calculated fraction of S_S that are Fatty Acids" : Fraction := {: group <- "Conversion factors" :};
     
    OBJ f_X_IN_H "Calculated fraction of X_BH that becomes X_IN in the digester" : Fraction := {: group <- "Conversion factors" :}; 
  };

  equations <- 
  {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
        SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };

     
    interface.Outflow[H2O] = - state.InFluxPerComponent[IndexOfSolvent] ;

     
    interface.Outflow[S_H2] = 0 ;
    interface.Outflow[S_CH4] = 0 ;

     
     
     

    interface.Outflow[S_H] =  - parameters.S_H_In * (parameters.SiegristSpecificVolume[H2O] * state.InFluxPerComponent[IndexOfSolvent]);

    interface.Outflow[S_CO2] = - (parameters.S_H_In / (parameters.S_H_In + parameters.Keq_CO2)) * state.InFluxPerComponent[S_ALK];

    interface.Outflow[S_HCO3] = - (parameters.Keq_CO2 / (parameters.S_H_In + parameters.Keq_CO2)) * state.InFluxPerComponent[S_ALK];

     
     
     

    interface.Outflow[S_NH4] = - ( state.InFluxPerComponent[S_NH] + state.InFluxPerComponent[S_ND] + state.InFluxPerComponent[X_ND] +
      parameters.i_X_B * (state.InFluxPerComponent[X_BH] + state.InFluxPerComponent[X_BA]) + parameters.i_X_P * (state.InFluxPerComponent[X_P] +
      state.InFluxPerComponent[X_I]) + parameters.i_S_AS * interface.Outflow[S_AS] + parameters.i_X_S_An * interface.Outflow[X_S] +
      parameters.i_X_An * interface.Outflow[X_AS] + parameters.i_X_IN * interface.Outflow[X_IN] );
    
     
     
    state.Help_InFlux_SS = state.InFluxPerComponent[S_S] - state.InFluxPerComponent[S_O] - (4.57 * state.InFluxPerComponent[S_NO]) ;
    
    state.InFlux_SS = IF (state.Help_InFlux_SS < 0) THEN 0 ELSE state.Help_InFlux_SS ;
    
    state.InFlux_XS = IF (state.Help_InFlux_SS < 0) THEN state.InFluxPerComponent[X_S] + state.Help_InFlux_SS
      ELSE state.InFluxPerComponent[X_S] ;

     
    interface.Outflow[S_AC] = - parameters.f_AC_S * state.InFlux_SS;
    interface.Outflow[S_PRO] = - parameters.f_PRO_S * state.InFlux_SS;
    interface.Outflow[S_AS] = - parameters.f_AS_S * state.InFlux_SS;
    interface.Outflow[S_FA] = state.f_FA_S * state.InFlux_SS;

     
    interface.Outflow[S_IN] = - state.InFluxPerComponent[S_I] ;

     
    interface.Outflow[X_S] =  - (state.InFlux_XS + parameters.f_XS_I * state.InFluxPerComponent[X_I] + parameters.f_XS_H *
      state.InFluxPerComponent[X_BH] + parameters.f_XS_A * state.InFluxPerComponent[X_BA] + parameters.f_XS_P * state.InFluxPerComponent[X_P] );

     
    interface.Outflow[X_AS] = - parameters.f_AS_H * state.InFluxPerComponent[X_BH] ;

     
    interface.Outflow[X_FA] = 0;
    interface.Outflow[X_PRO] = 0;
    interface.Outflow[X_AC] = 0;
    interface.Outflow[X_H2] = 0;

     
    interface.Outflow[X_IN] = - ( (1 - parameters.f_XS_I) * state.InFluxPerComponent[X_I] + state.f_X_IN_H * state.InFluxPerComponent[X_BH] +
      (1 - parameters.f_XS_A) * state.InFluxPerComponent[X_BA] + (1 - parameters.f_XS_P) * state.InFluxPerComponent[X_P] );

  };

:};



CLASS SiegristToASM1 "Siegrist anaerobic model to ASM1  states flow transformer"
SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "Siegrist anaerobic model to ASM1  states flow transformer";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : SiegristWWTPTerminal  := {: causality <- "CIN"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT"; group <- "Effluent" :};
  };

  parameters <-
  {
    OBJ i_X_B "Mass of N per mass of COD in biomass (ASM1)" : Fraction := {: value <- 0.086 ; group <- "Conversion factors" :};
    OBJ i_X_P "Mass of N per mass of COD in products formed (ASM1)" : Fraction := {: value <- 0.04 ; group <- "Conversion factors" :};
    OBJ i_S_AS "Mass of N per mass of COD in Amino Acids (S_AS)" : Fraction := {: value <- 0.040 ; group <- "Conversion factors" :};
    OBJ i_X_S_An "Mass of N per mass of COD in slowly biodegradable matter (X_S)" : Fraction := {: value <- 0.020 ; group <- "Conversion factors" :};
    OBJ i_X_An "Mass of N per mass of COD in anaerobic biomass" : Fraction := {: value <- 0.080 ; group <- "Conversion factors" :};
    OBJ i_X_IN "Mass of N per mass of COD in inert particulates" : Fraction := {: value <- 0.040 ; group <- "Conversion factors" :};
    OBJ f_P_An "Fraction of anaerobic biomass that leads to inert matter" : Fraction := {: value <- 0.08 ; group <- "Conversion factors" :};
    OBJ f_H_AS "Fraction of fermenting biomass that are heterotrophs" : Fraction := {: value <- 0.50 ; group <- "Conversion factors" :};
  };

  independent <- 
  {
    OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <- 
  {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all ASM components" : SiegristMassFluxVector ;
  };

  equations <- 
  {
    {FOREACH Comp_Index IN {1 .. SiegristNrOfComponents}: state.InFluxPerComponent[Comp_Index] =
        SUMOVER Siegrist_Terminal IN {SelectByType(interface, SiegristWWTPTerminal)}: (Siegrist_Terminal[Comp_Index]) ; };

     
    interface.Outflow[H2O] = - state.InFluxPerComponent[IndexOfSolvent] ;

     

     
    interface.Outflow[S_I] = - state.InFluxPerComponent[S_IN] ;

     
    interface.Outflow[S_S] = state.InFluxPerComponent[S_AC] + state.InFluxPerComponent[S_PRO] + state.InFluxPerComponent[S_AS] + state.InFluxPerComponent[S_FA] ;

     
    interface.Outflow[S_O] = 0.0 ;
    interface.Outflow[S_NO] = 0.0 ;

     
    interface.Outflow[S_NH] = state.InFluxPerComponent[S_NH4];

     
    interface.Outflow[S_ND] = parameters.i_S_AS * state.InFluxPerComponent[S_AS];

     
     
    interface.Outflow[S_ALK] = state.InFluxPerComponent[S_HCO3] + state.InFluxPerComponent[S_CO2] ;

     
    interface.Outflow[X_I] = state.InFluxPerComponent[X_IN];

     
    interface.Outflow[X_BH] = parameters.f_H_AS * state.InFluxPerComponent[X_AS];

     
    interface.Outflow[X_P] = parameters.f_P_An * (SUMOVER Comp_Index IN {X_AS .. X_H2}: (state.InFluxPerComponent[Comp_Index])) ;

     
    interface.Outflow[X_S] = state.InFluxPerComponent[X_S] + (1 - (parameters.f_P_An + parameters.f_H_AS)) * state.InFluxPerComponent[X_AS] +
      (1 - parameters.f_P_An) * (SUMOVER Comp_Index IN {X_FA .. X_H2}: (state.InFluxPerComponent[Comp_Index])) ;

     
    interface.Outflow[X_BA] = 0.0 ;

     
     
     
    interface.Outflow[X_ND] = parameters.i_X_S_An * state.InFluxPerComponent[X_S] + parameters.i_X_IN * state.InFluxPerComponent[X_IN] +
      parameters.i_X_An * (SUMOVER Comp_Index IN {X_AS .. X_H2}: (state.InFluxPerComponent[Comp_Index])) - parameters.i_X_P * (interface.Outflow[X_I]
      + interface.Outflow[X_P]) - parameters.i_X_B * (interface.Outflow[X_BH] + interface.Outflow[X_BA]) ;

  };

:};




# 29 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.transformers.msl" 2











# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/CEPT/wwtp.cept.msl" 1
 















 




# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/CEPT/wwtp.primary_clarifier.cept_takacs.msl" 1
 















 






 CLASS CEPT_Takacs
 (* icon = "primary_clarifier" *)
 EXTENDS PST_Takacs_PropagateSolubles_Base WITH
{:

   parameters <- 
   {     
    OBJ v0_min "Minimum value of the maximum theoretical settling velocity" : Velocity := {: value <- 100 ; group <- "Settling" :};
    OBJ v0_max "Maximum value of the maximum theoretical settling velocity" : Velocity := {: value <- 300 ; group <- "Settling" :};
    OBJ exp_v0 "Hill exponent for v0" : Real := {: value <- 1 ; group <- "Settling" :};
    OBJ K_alum_v0 "Hill saturation constant for v0" : Concentration := {: value <- 30 ; group <- "Settling" :};
    OBJ f_ns_min "Minimum value of the non-settleable fraction" : Fraction := {: value <- 0.2 ; group <- "Settling" :};
    OBJ f_ns_max "Maximum value of the non-settleable fraction" : Fraction := {: value <- 0.4 ; group <- "Settling" :};
    OBJ exp_f_ns "Hill exponent for f_ns" : Real := {: value <- 1 ; group <- "Settling" :};
    OBJ K_alum_f_ns "Hill saturation constant for v0" : Concentration := {: value <- 30 ; group <- "Settling" :};
   };

   state <-
   {
	  OBJ v0 (* hidden = "1" *) "Maximum theoretical settling velocity" : LayerVelocityVector := {: group <- "Settling" :};
	  OBJ f_ns "Non-settleable fraction" : Fraction := {: group <- "Settling" :};
	  OBJ S_ALK_Inlet "Incoming concentration of S_ALK" : Concentration := {: group <- "Concentration" :};
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : LayerVelocityVector ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : LayerVelocityVector ;
   };

  equations <-
   {
	  
	 	state.S_ALK_Inlet = IF(state.Q_In == 0)
	 		THEN 0
	 		ELSE state.InFluxPerComponent[S_ALK] / state.Q_In ;	 
 
	  
	     {
	   state.f_ns =
       parameters.f_ns_max - (parameters.f_ns_max - parameters.f_ns_min)*
	 											( pow(state.S_ALK_Layer[1] , parameters.exp_f_ns) / ( pow(parameters.K_alum_f_ns , parameters.exp_f_ns) + pow(state.S_ALK_Layer[1] , parameters.exp_f_ns))) ;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN state.f_ns * state.SolidConcentration 
      ELSE state.f_ns * state.SolidFlux_In / state.Q_In ;

	  
	 { FOREACH Layer_Index IN {1 .. NrOfLayers}:
		 	     state.v0[Layer_Index] =	parameters.v0_min + (parameters.v0_max - parameters.v0_min)*
	 																		( pow(state.S_ALK_Layer[Layer_Index] , parameters.exp_v0) /
	 																					( pow(parameters.K_alum_v0 , parameters.exp_v0) + pow(state.S_ALK_Layer[Layer_Index] , parameters.exp_v0))) ;
	  };

	  
	 { FOREACH Layer_Index IN {1 .. NrOfLayers}:
		 	     state.v0_P[Layer_Index] =	state.v0[Layer_Index] * exp(parameters.r_P * state.X_Min);
	  };	

	  
	 { FOREACH Layer_Index IN {1 .. NrOfLayers}:
						state.v0_H[Layer_Index] =  state.v0[Layer_Index] * exp(parameters.r_H * state.X_Min); 
	  };	 

   };

:};





# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/CEPT/wwtp.cept.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/CEPT/wwtp.dosing_units.cept_alkalinity.msl" 1
 















 







 CLASS CEPT_Alkalinity
 (* icon = "dosing_unit_alkalinity" *)
 "A dosing unit model for the addition of alkalinity"
 EXTENDS DosingUnit_Base WITH
 {:
 
  comments <- "A dosing unit model for the addition of alkalinity";

  interface <-
  {
   OBJ C_final (* terminal = "in_1"; manip = "1" *) "Concentration in the PST (dry mass)" : Concentration := {: causality <- "CIN"; value <- 30 ; group <- "Operational" :};
   OBJ Q_water_in (* terminal = "in_1"; manip = "1" *) "Flow rate at the inlet" : FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
   OBJ Q_Dose (* terminal = "out_2" *) "Flow rate of the solution" : FlowRate := {: causality <- "COUT" ; group <- "Operational" :};
   OBJ M_Alk (* terminal = "out_2" *) "Amount of alkalinity dosed" : MassFlux := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ Q_Alk (* terminal = "out_2" *) "Flow rate of alkalinity dosed" : FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  equations <-
  {
    
   state.Help_QDose = interface.Q_Dose ;



  interface.Outflow[S_ALK] = - interface.Q_Dose * interface.C_Dose ;

   interface.M_Alk = interface.Q_Dose * interface.C_Dose ;
   interface.Q_Alk = interface.Q_Dose ;
   
   interface.Q_Dose = interface.C_final * interface.Q_water_in / interface.C_Dose ;
  };

 :};







# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/primary_clarifier/CEPT/wwtp.cept.msl" 2




# 70 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.oxidation_ditch.msl" 1
 




















CLASS Carrousel_Unit
  (* icon = "carrousel_unit" *)
  "Coupled model for a single AS unit within a carrousel/oxydation ditch. It incorporates an ASU tank and a controlled internal recycle."
  SPECIALISES CoupledModelType :=
  {:
  comments <- "Coupled model for a single AS unit within a carrousel/oxydation ditch. It incorporates an ASU tank and a controlled internal recycle.";

  interface <-
  {
	 
	OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
	OBJ Outflow1 (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	OBJ InflowInternal (* terminal = "in_3" *) "Inflow from internal recycle" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
	OBJ InflowSludge (* terminal = "in_4" *) "Inflow from sludge recycle" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
	OBJ Outflow2 (* terminal = "out_3" *) "Outflow to internal recycle" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	 
	OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	
	OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature of the activated sludge" : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
	
	OBJ Q_In (* terminal = "in_2"; manip = "1" *) "Influent flow rate" : FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};   
	OBJ R (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Internal split (to 2nd outflow)" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
 
 
 
 
  OBJ DO (* terminal = "out_2"; is_favorite = "1" *) "DO concentration" : DissolvedOxygen := {: causality <- "COUT" ; group <- "Sensors" :};
  };

  parameters <-
  {
    OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension"; :};
  };

  sub_models <-
  {
    OBJ ASTank "Activated sludge unit" : FixVolumeASU ;
    OBJ IR "Ratio Controller" : ConstantRatio;
    OBJ Combi "Three combiner" : ThreeCombiner;
    OBJ Split "Two flow splitter" : AbsTwoSplitter;
  };

  coupling <-
  {
    sub_models.ASTank.parameters.Vol.value := parameters.Vol.value,

    connect(sub_models.Combi.interface.Outflow, sub_models.ASTank.interface.Inflow),
    connect(sub_models.ASTank.interface.Outflow, sub_models.Split.interface.Inflow),
    connect(sub_models.IR.interface.u, sub_models.Split.interface.Q_Out2),

     
	connect(interface.Inflow, sub_models.Combi.interface.Inflow2),
     
	connect(interface.InflowInternal, sub_models.Combi.interface.Inflow1),
     
	connect(interface.InflowSludge, sub_models.Combi.interface.Inflow3),
     
	connect(sub_models.Split.interface.Outflow1, interface.Outflow1),
     
	connect(sub_models.Split.interface.Outflow2, interface.Outflow2),

    connect(interface.Temp, sub_models.ASTank.interface.Temp),
    connect(interface.Kla, sub_models.ASTank.interface.Kla),
    connect(interface.Q_In, sub_models.IR.interface.y_M),
    connect(interface.R, sub_models.IR.interface.ConstantRatio),



    connect(sub_models.ASTank.interface.DO, interface.DO),

  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/oxidation_ditch/wwtp.oxidation.ditch.04.msl" 1
 




















CLASS Oxidation_Ditch_04
  (* icon = "oxidation_ditch" *)
  "Oxidation ditch with 4 compartments"
  SPECIALISES CoupledModelType :=
  {:
  comments <- "Oxidation ditch with 4 compartments";

  interface <-
  {
	 
	OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
	OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	OBJ InflowSludge (* terminal = "in_4" *) "Sludge recycle" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Sludge Inflow" :};
	 
	OBJ Kla1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "KLa in compartment no.1" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	OBJ Kla2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "KLa in compartment no.2" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	OBJ Kla3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "KLa in compartment no.3" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	OBJ Kla4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "KLa in compartment no.4" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	
	OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature of the activated sludge" : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
	
	OBJ R (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Internal recirculation ratio" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
	 
	OBJ DO1 (* terminal = "out_2"; is_favorite = "1" *) "DO concentration in compartment no.1" : DissolvedOxygen := {: causality <- "COUT" ; group <- "Sensors" :};
	OBJ DO2 (* terminal = "out_2"; is_favorite = "1" *) "DO concentration in compartment no.2" : DissolvedOxygen := {: causality <- "COUT" ; group <- "Sensors" :};
	OBJ DO3 (* terminal = "out_2"; is_favorite = "1" *) "DO concentration in compartment no.3" : DissolvedOxygen := {: causality <- "COUT" ; group <- "Sensors" :};
	OBJ DO4 (* terminal = "out_2"; is_favorite = "1" *) "DO concentration in compartment no.4" : DissolvedOxygen := {: causality <- "COUT" ; group <- "Sensors" :};
  };

  parameters <-
  {
	OBJ Vol1 (* is_favorite = "1" *) "Volume of compartment no.1:" : Volume := {: value <- 1000 ; group <- "Dimension" :};
	OBJ Vol2 (* is_favorite = "1" *) "Volume of compartment no.2:" : Volume := {: value <- 1000 ; group <- "Dimension" :};
	OBJ Vol3 (* is_favorite = "1" *) "Volume of compartment no.3:" : Volume := {: value <- 1000 ; group <- "Dimension" :};
	OBJ Vol4 (* is_favorite = "1" *) "Volume of compartment no.4:" : Volume := {: value <- 1000 ; group <- "Dimension" :};
	OBJ RAS_In (* is_favorite = "1" *) "RAS in compartment no.:" : Integer := {: value <- 1 ; interval <- {: lowerBound <- 1; upperBound <- 4 :}; group <- "Operational" :};
	OBJ Outflow_Out (* is_favorite = "1" *) "Outflow in compartment no.:" : Integer := {: value <- 2 ; interval <- {: lowerBound <- 1; upperBound <- 4 :}; group <- "Operational" :};
  };

  sub_models <-
  {
    OBJ COMP_1 "Carrousel unit" : Carrousel_Unit ;
    OBJ COMP_2 "Carrousel unit" : Carrousel_Unit ;
    OBJ COMP_3 "Carrousel unit" : Carrousel_Unit ;
    OBJ COMP_4 "Carrousel unit" : Carrousel_Unit ;
    OBJ Loop_1 "Loop breaker" : DifferentialLoopBreaker ;
    OBJ Sensor_In "Multiprobe sensor" : MultiSensor ;
    OBJ Master "Master control" : Ctl_Carrousel_04 ;
  };

  coupling <-
  {
     
	sub_models.COMP_1.parameters.Vol.value := parameters.Vol1.value,
	sub_models.COMP_2.parameters.Vol.value := parameters.Vol2.value,
	sub_models.COMP_3.parameters.Vol.value := parameters.Vol3.value,
	sub_models.COMP_4.parameters.Vol.value := parameters.Vol4.value,
     
	sub_models.Master.parameters.Outflow_Out.value := parameters.Outflow_Out.value,
     
	sub_models.Master.parameters.RAS_In.value := parameters.RAS_In.value,
     
	connect(interface.Inflow, sub_models.Sensor_In.interface.Inflow),
    connect(sub_models.Sensor_In.interface.Outflow, sub_models.COMP_1.interface.Inflow),
     
    connect(sub_models.COMP_1.interface.Outflow1, sub_models.COMP_2.interface.Inflow),
	connect(sub_models.COMP_2.interface.Outflow1, sub_models.COMP_3.interface.Inflow),
    connect(sub_models.COMP_3.interface.Outflow1, sub_models.COMP_4.interface.Inflow),
	connect(sub_models.COMP_4.interface.Outflow2, sub_models.Loop_1.interface.Inflow),
    connect(sub_models.Loop_1.interface.Outflow, sub_models.COMP_1.interface.InflowInternal),
	connect(interface.R, sub_models.COMP_4.interface.R),
	 
	connect(sub_models.COMP_1.interface.Outflow2, sub_models.Master.interface.OutflowInternal1),
	connect(sub_models.COMP_2.interface.Outflow2, sub_models.Master.interface.OutflowInternal2),
	connect(sub_models.COMP_3.interface.Outflow2, sub_models.Master.interface.OutflowInternal3),
	connect(sub_models.COMP_4.interface.Outflow1, sub_models.Master.interface.Outflow4),
	 
	connect(sub_models.Master.interface.Outflow, interface.Outflow),

     
    connect(interface.InflowSludge, sub_models.Master.interface.InflowSludge),
	connect(sub_models.Master.interface.InflowSludge1, sub_models.COMP_1.interface.InflowSludge),
	connect(sub_models.Master.interface.InflowSludge2, sub_models.COMP_2.interface.InflowSludge),
	connect(sub_models.Master.interface.InflowSludge3, sub_models.COMP_3.interface.InflowSludge),
	connect(sub_models.Master.interface.InflowSludge4, sub_models.COMP_4.interface.InflowSludge),

	 
	connect(sub_models.Master.interface.R1, sub_models.COMP_1.interface.R),
	connect(sub_models.Master.interface.R2, sub_models.COMP_2.interface.R),
	connect(sub_models.Master.interface.R3, sub_models.COMP_3.interface.R),
	 
	connect(sub_models.Sensor_In.interface.y_Q, sub_models.COMP_1.interface.Q_In),
    connect(sub_models.Sensor_In.interface.y_Q, sub_models.COMP_2.interface.Q_In),
    connect(sub_models.Sensor_In.interface.y_Q, sub_models.COMP_3.interface.Q_In),
    connect(sub_models.Sensor_In.interface.y_Q, sub_models.COMP_4.interface.Q_In),
	 
    connect(interface.Kla1, sub_models.COMP_1.interface.Kla),
    connect(interface.Kla2, sub_models.COMP_2.interface.Kla),
    connect(interface.Kla3, sub_models.COMP_3.interface.Kla),
    connect(interface.Kla4, sub_models.COMP_4.interface.Kla),
     
    connect(interface.Temp, sub_models.COMP_1.interface.Temp),
    connect(interface.Temp, sub_models.COMP_2.interface.Temp),
    connect(interface.Temp, sub_models.COMP_3.interface.Temp),
    connect(interface.Temp, sub_models.COMP_4.interface.Temp),
     
  	connect(sub_models.COMP_1.interface.DO, interface.DO1),
  	connect(sub_models.COMP_2.interface.DO, interface.DO2),
  	connect(sub_models.COMP_3.interface.DO, interface.DO3),
  	connect(sub_models.COMP_4.interface.DO, interface.DO4),
  };

:};



CLASS Ctl_Carrousel_04
  "Sets the split flow of compartments 1,2,3 ................................................."
  SPECIALISES PhysicalDAEModelType :=
  {:
  comments <- "Sets the split flow of compartments 1,2,3 .................................................";

  interface <-
  {
	 
	OBJ OutflowInternal1 (* hidden = "0" *) "(Internal) outflow of compartment no.1" : OutWWTPTerminal := {: causality <- "CIN" ; group <- "Effluent No.1" :};
	OBJ OutflowInternal2 (* hidden = "0" *) "(Internal) outflow of compartment no.2" : OutWWTPTerminal := {: causality <- "CIN" ; group <- "Effluent No.2" :};
	OBJ OutflowInternal3 (* hidden = "0" *) "(Internal) outflow of compartment no.3" : OutWWTPTerminal := {: causality <- "CIN" ; group <- "Effluent No.3" :};
	OBJ Outflow4 (* hidden = "0" *) "Outflow of compartment no.4" : OutWWTPTerminal := {: causality <- "CIN" ; group <- "Effluent No.4" :};
	OBJ Outflow (* hidden = "0" *) "Outflow of compartment X" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	 
	OBJ InflowSludge (* hidden = "0" *) "Sludge recycle" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Sludge Inflow" :};
	OBJ InflowSludge1 (* hidden = "0" *) "RAS to compartment no.1" : InWWTPTerminal := {: causality <- "COUT" ; group <- "Sludge Inflow No.1" :};
	OBJ InflowSludge2 (* hidden = "0" *) "RAS to compartment no.2" : InWWTPTerminal := {: causality <- "COUT" ; group <- "Sludge Inflow No.2" :};
	OBJ InflowSludge3 (* hidden = "0" *) "RAS to compartment no.3" : InWWTPTerminal := {: causality <- "COUT" ; group <- "Sludge Inflow No.3" :};
	OBJ InflowSludge4 (* hidden = "0" *) "RAS to compartment no.4" : InWWTPTerminal := {: causality <- "COUT" ; group <- "Sludge Inflow No.4" :};

	OBJ R1 (* hidden = "0" *) "Split from compartment no.1" : Real := {: causality <- "COUT" ; group <- "Operational" :};
	OBJ R2 (* hidden = "0" *) "Split from compartment no.2" : Real := {: causality <- "COUT" ; group <- "Operational" :};
	OBJ R3 (* hidden = "0" *) "Split from compartment no.3" : Real := {: causality <- "COUT" ; group <- "Operational" :};
  };

  parameters <-
  {
	OBJ RAS_In (* hidden = "0" *) "RAS to compartment no." : Integer := {: value <- 1 ; interval <- {: lowerBound <- 0; upperBound <- 4 :}; group <- "Operational" :};
	OBJ Outflow_Out (* hidden = "1" *) "Outflow in compartment no.:" : Integer := {: value <- 4 ; interval <- {: lowerBound <- 1; upperBound <- 4 :}; group <- "Operational" :};
  };

  independent <-
  {
	OBJ t "Time"  : Time := {: group <- "Time" :}; 
  };

  equations <-
  {
     
	 
	 
	interface.R1 = IF (parameters.Outflow_Out == 1) THEN 1.0 ELSE 0.0 ;
	interface.R2 = IF (parameters.Outflow_Out == 2) THEN 1.0 ELSE 0.0 ;
	interface.R3 = IF (parameters.Outflow_Out == 3) THEN 1.0 ELSE 0.0 ;

	{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: interface.Outflow[Comp_Index] =
      IF (parameters.Outflow_Out == 4) THEN - interface.Outflow4[Comp_Index]
      	 ELSE IF (parameters.Outflow_Out == 3) THEN - interface.OutflowInternal3[Comp_Index]
      	 	  ELSE IF (parameters.Outflow_Out == 2) THEN - interface.OutflowInternal2[Comp_Index]
      	 	  	   ELSE - interface.OutflowInternal1[Comp_Index] ; };

	{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: interface.InflowSludge1[Comp_Index] =
      IF (parameters.RAS_In == 1) THEN - interface.InflowSludge[Comp_Index]
      	 ELSE 0.0 ; };

	{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: interface.InflowSludge2[Comp_Index] =
      IF (parameters.RAS_In == 2) THEN - interface.InflowSludge[Comp_Index]
      	 ELSE 0.0 ; };

	{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: interface.InflowSludge3[Comp_Index] =
      IF (parameters.RAS_In == 3) THEN - interface.InflowSludge[Comp_Index]
      	 ELSE 0.0 ; };

	{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: interface.InflowSludge4[Comp_Index] =
      IF (parameters.RAS_In == 4) THEN - interface.InflowSludge[Comp_Index]
      	 ELSE 0.0 ; };
  };
 
 :};



# 97 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.oxidation_ditch.msl" 2




# 72 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2


 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/filter/wwtp.filter.rauch.msl" 1
 




















 
 
 
 
 
 
 

 
 
 
 





CLASS Rauch (* class = "trickling_filter" *) "Rauch Model for Biofilm Systems"
SPECIALISES PhysicalDAEModelType :=
 {:

  comments <- "Rauch Model for Biofilm Systems" ;

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
    OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature" : CelsiusTemperature  := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :}; 
  };

  parameters <- 
  {
    OBJ V_R "Volume of the reactor" : Volume := {: value <- 1000.0 ; group <- "Dimension" :};
    OBJ A_R "Section of the reactor" : Area := {: value <- 400.0 ; group <- "Dimension" :};
    OBJ H_R (* fixed = "1" *) "Height of the reactor" : Length := {: value <- 2.5 ; group <- "Dimension" :} ;    
    OBJ A_sp "Specific surface area" : SpecificAreaVolume := {: value<- 100; group <- "Dimension" :};
    OBJ f_vol "Fraction of the total volume occupied by the support material" : Fraction := {: value<- 0.05 ; group <- "Dimension" :};
 
    OBJ A_B (* fixed = "1" *) "Area for biofilm growth" : Area := {: value <- 5000.0 ; group <- "Dimension" :};
    
    OBJ L_init "Initial biofilm thickness" : Length := {: value <- 100e-6; group <- "Biofilm" :} ;
     
    OBJ L_max "Maximum biofilm thickness" : Length := {: value <- 10e-3; group <- "Biofilm" :} ;
    OBJ rho "Biofilm density" : Density := {: value <- 50000; group <- "Biofilm" :} ;
     
    OBJ fh_init "Initial fraction of heterotrophs" : Fraction := {: value <- 0.4; group <- "System" :} ;
    OBJ fa_init "Initial fraction of autotrophs" : Fraction := {: value <- 0.05; group <- "System" :} ;
    OBJ fs_init "Initial fraction of hydrolysible particulates" : Fraction := {: value <- 0.15; group <- "System" :} ;
    OBJ fph_init "Initial fraction of decay products (hetero)" : Fraction := {: value <- 0.32; group <- "System" :} ;
    OBJ fpa_init "Initial fraction of decay products (auto)" : Fraction := {: value <- 0.04; group <- "System" :} ;
    OBJ fi_init "Initial fraction of inerts" : Fraction := {: value <- 0.04; group <- "System" :} ;
    OBJ MND_Biomass_init "Initial fraction of particulate N" : Fraction := {: value <- 0.05; group <- "System" :} ;
    
    OBJ mu_h "Growth rate of heterotrophs" : GrowthRate := {: value <- 6; group <- "Kinetics" :};
    OBJ mu_hh "Growth rate of heterotrophs (anoxic)" : GrowthRate := {: value <- 4; group <- "Kinetics" :} ;
    OBJ mu_a "Growth rate of autotrophs" : GrowthRate := {: value <- 0.8; group <- "Kinetics" :} ;
    OBJ b_h "Decay coefficient for heterotrophs" : DecayCoefficient := {: value <- 0.6; group <- "Kinetics" :} ;
    OBJ b_a "Decay coefficient for autotrophs" : DecayCoefficient := {: value <- 0.4; group <- "Kinetics" :} ;
     
    OBJ k_h "Coefficient for hydrolysis of slowly biod. mat." : Rate := {: value <- 3.0; group <- "Kinetics" :} ;
    OBJ k_a "Coefficient for ammonification of Snd" : Rate := {: value <- 0.08; group <- "Kinetics" :} ;
    
    OBJ DiSo "Diffusion coefficient for So" : Diffusivity := {: value <- 2.1e-4; group <- "Diffusivity" :};
    OBJ DiSs "Diffusion coefficient for Ss" : Diffusivity := {: value <- 0.58e-4; group <- "Diffusivity" :};
    OBJ DiSnh "Diffusion coefficient for Snh" : Diffusivity := {: value <- 1.8e-4; group <- "Diffusivity" :};
    OBJ DiSno "Diffusion coefficient for Sno" : Diffusivity := {: value <- 1.0e-4; group <- "Diffusivity" :};

    OBJ ktemp "Coefficient for temp. dependency of growth" : CorrectionFactor := {: value <- 1 :};
    OBJ Y_h "Heterotrophic yield coefficient" : Yield := {: value <- 0.67; group <- "Kinetics" :};
    OBJ Y_a "Autotrophic yield coefficient" : Yield := {: value <- 0.24; group <- "Kinetics" :};
    OBJ fp "Fraction of biomass leading to inert decay prod." : Fraction := {: value <- 0.08; group <- "Kinetics" :};
    OBJ vs "Settling velocity of part. in liquid" : Velocity := {: value <- 0.0; group <- "Settling" :}; 
    OBJ ixh "Nitrogen in heterotrophic biomass" : Fraction := {:value <- 0.086; group <- "Composition parameters" :};
    OBJ ixa "Nitrogen in autotrophic biomass" : Fraction := {:value <- 0.086; group <- "Composition parameters" :}; 
    OBJ kdt "Coefficient for detachment" : CorrectionFactor := {: value <- 0.1; group <- "Kinetics" :}; 
    OBJ So_sat "Oxygen saturation concentration" : Concentration := {: value <- 8; group <- "System" :};
  };

  independent <-
  {
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ V "Water volume" : Volume := {: group <- "Dimension" :} ;
    OBJ V_B "Biofilm volume" : Volume := {: group <- "System" :} ;
     
    OBJ Q_In "Influent flow rate" : FlowRate:= {: group <- "Operation" :} ;
    OBJ MH "Mass of heterotrophs / bulk volume" : Concentration:= {: group <- "Concentration" :} ;
    OBJ MA "Mass of autotrophs / bulk volume" : Concentration:= {: group <- "Concentration" :} ;
    OBJ MS "Mass of hydrolysible material / bulk volume" : Concentration:= {: group <- "Concentration" :} ;
    OBJ MPH "Mass of decay prod. (het.) / bulk volume" : Concentration:= {: group <- "Concentration" :} ;
    OBJ MPA "Mass of decay prod. (auto.) / bulk volume" : Concentration:= {: group <- "Concentration" :} ;
    OBJ MI "Mass of inerts / bulk volume" : Concentration:= {: group <- "Concentration" :} ;
    OBJ MND "Mass of part N / bulk volume" : Concentration:= {: group <- "Concentration" :} ;
    OBJ Xh "Concentration of heterotrophs in bulk" : Concentration := {: value <- 20; group <- "Concentration bulk" :};
    OBJ Xa "Concentration of autotrophs in bulk" : Concentration := {: value <- 5; group <- "Concentration bulk" :};
    OBJ Xs "Concentration of hydrolysible mat. in bulk" : Concentration := {: value <- 10; group <- "Concentration bulk" :};
    OBJ Xp "Concentration of decay prod. in bulk" : Concentration := {: value <- 5; group <- "Concentration bulk" :};
    OBJ Xi "Concentration of inerts in bulk" : Concentration := {: value <- 5; group <- "Concentration bulk" :};
    OBJ Xnd "Concentration of particulate N in bulk" : Concentration := {: value <- 2; group <- "Concentration bulk" :};
    
    OBJ Mh "Mass of part heterotrophs" : Mass := {: group <- "Composition" :} ;
    OBJ Ma "Mass of part autotrophs" : Mass := {: group <- "Composition" :} ;
    OBJ Ms "Mass of hydrolysible material" : Mass := {: group <- "Composition" :} ;
    OBJ Mph "Mass of decay prod. (het.)" : Mass := {: group <- "Composition" :} ;
    OBJ Mpa "Mass of decay prod. (aut.)" : Mass := {: group <- "Composition" :} ;
    OBJ Mi "Mass of inerts" : Mass := {: group <- "Composition" :} ;
    OBJ Mnd "Mass of part N" : Mass := {: group <- "Composition" :} ;
    OBJ L "Biofilm thickness" : Length := {: group <- "System" :} ;
    OBJ fh "Fraction of heterotrophs" : Fraction := {: group <- "Composition" :};
    OBJ fa "Fraction of autotrophs" : Fraction := {: group <- "Composition" :};
    OBJ fs "Fraction of hydrolysible material" : Fraction := {: group <- "Composition" :};
    OBJ fi "Fraction of inerts" : Fraction := {: group <- "Composition" :};
    OBJ fph "Fraction of decay prod. (het.)" : Fraction := {: group <- "Composition" :};
    OBJ fpa "Fraction of decay prod. (auto.)" : Fraction := {: group <- "Composition" :};
    OBJ MND_Biomass "Fraction of particulate N" : Fraction := {: group <- "Composition" :};
    OBJ Xh_b (* hidden = "1" *) "Virtual concentration of heterotrophs in biofilm" : Concentration := {: group <- "Concentrations" :};
    OBJ Xa_b (* hidden = "1" *) "Virtual concentration of autotrophs in biofilm" : Concentration := {: group <- "Concentrations" :};
    OBJ Xs_b (* hidden = "1" *) "Virtual concentration of hydrolysible mat. in biofilm" : Concentration := {: group <- "Concentrations" :};
    OBJ pr1 (* hidden = "1" *) "Aerobic heterotrophic growth rate" : Rate;
    OBJ pr2 (* hidden = "1" *) "Anoxic heterotrophic growth rate" : Rate;
    OBJ pr3 (* hidden = "1" *) "Aerobic autotrophic growth rate" : Rate;
    OBJ r1 (* hidden = "1" *) "Oxygen conversion rate" : Rate;
    OBJ r2 (* hidden = "1" *) "Ss conversion rate" : Rate;
    OBJ r3 (* hidden = "1" *) "Sno conversion rate" : Rate;
    OBJ r4 (* hidden = "1" *) "Snh conversion rate" : Rate;
    OBJ r1l (* hidden = "1" *) "Oxic lower zone without Ss, only nitrification rate" : Rate;
    OBJ r2l (* hidden = "1" *) "Lower zone denitrification only rate" : Rate;
    OBJ r4l (* hidden = "1" *) "Lower zone nitrification and denitrification rate" : Rate;
    OBJ Sno "Nitrate nitrogen concentration": Concentration := {:value <- 5 ; group <- "Concentrations" :};
    OBJ So "DO concentration": Concentration := {:value <- 3 ; group <- "Concentrations" :};
    OBJ Ss "Readily biodegradable substrate ": Concentration := {:value <- 50 ; group <- "Concentrations" :};;
    OBJ Snh "Ammonia nitrogen concentration": Concentration := {:value <- 10 ; group <- "Concentrations" :};
    OBJ Snd "Organic nitrogen concentration": Concentration := {:value <- 2 ; group <- "Concentrations" :};
    OBJ Si "Soluble non-biodegradable COD": Concentration := {:value <- 30 ; group <- "Concentrations" :};
    OBJ beta1 (* hidden = "1" *) "Penetration fraction for So": Fraction;
    OBJ beta2 (* hidden = "1" *) "Penetration fraction for Ss": Fraction;
    OBJ beta3 (* hidden = "1" *) "Penetration fraction for Sno": Fraction;
    OBJ beta3_help (* hidden = "1" *) "Penetration fraction for Sno (work variable)": Fraction;
    OBJ beta4 (* hidden = "1" *) "Penetration fraction for Snh": Fraction;
    OBJ beta1l (* hidden = "1" *) "Lower zone penetration fraction for So": Fraction;
    OBJ beta1l_help (* hidden = "1" *) "Lower zone penetration fraction for So (work variable)": Fraction;
    OBJ beta2l (* hidden = "1" *) "Lower zone penetration fraction for Ss": Fraction;
    OBJ beta2l_help (* hidden = "1" *) "Lower zone penetration fraction for Ss (work variable)": Fraction;
    OBJ beta4l (* hidden = "1" *) "Lower zone penetration fraction for Snh": Fraction;
    OBJ beta4l_helpa (* hidden = "1" *) "Lower zone penetration fraction for Snh (work variable 1)": Fraction;
    OBJ beta4l_helpb (* hidden = "1" *) "Lower zone penetration fraction for Snh (work variable 2)": Fraction;
    OBJ phih "Active fraction of heterotrophs (aer.)": Fraction := {: group <- "System" :};
    OBJ phia "Active fraction of autotrophs": Fraction := {: group <- "System" :};
    OBJ phihh "Active fraction of heterotrophs (an.)": Fraction := {: group <- "System" :};
    OBJ pr_1 (* hidden = "1" *) "Het. growth (aer.)": Rate := {: group <- "Kinetics" :};
    OBJ pr_2 (* hidden = "1" *) "Het. growth (an.)": Rate := {: group <- "Kinetics" :};
    OBJ pr_3 (* hidden = "1" *) "Aut. growth": Rate := {: group <- "Kinetics" :};
    OBJ pr_4 (* hidden = "1" *) "Het. decay": Rate := {: group <- "Kinetics" :};
    OBJ pr_5 (* hidden = "1" *) "Aut. decay": Rate := {: group <- "Kinetics" :};
    OBJ pr_6 (* hidden = "1" *) "Hydrolysis MS": Rate := {: group <- "Kinetics" :};
    OBJ pr_7 (* hidden = "1" *) "Attachment Xh": Rate := {: group <- "Kinetics" :};
    OBJ pr_8 (* hidden = "1" *) "Attachment Xa": Rate := {: group <- "Kinetics" :};
    OBJ pr_9 (* hidden = "1" *) "Attachment Xs": Rate := {: group <- "Kinetics" :};
    OBJ pr_10 (* hidden = "1" *) "Attachment Xp to Mph": Rate := {: group <- "Kinetics" :};
    OBJ pr_11 (* hidden = "1" *) "Attachment Xp to Mpa": Rate := {: group <- "Kinetics" :};
    OBJ pr_12 (* hidden = "1" *) "Attachment Xi to Mi": Rate := {: group <- "Kinetics" :};
    OBJ pr_13 (* hidden = "1" *) "Attachment Xnd": Rate := {: group <- "Kinetics" :};
    OBJ pr_14 (* hidden = "1" *) "Hydrolysis of MND": Rate := {: group <- "Kinetics" :};
    OBJ pr_15 (* hidden = "1" *) "Ammonification of Snd": Rate := {: group <- "Kinetics" :};
    OBJ r_1 (* hidden = "1" *) "Rate So": Rate := {: group <- "Kinetics" :};
    OBJ r_2 (* hidden = "1" *) "Rate Ss": Rate := {: group <- "Kinetics" :};
    OBJ r_3 (* hidden = "1" *) "Rate Sno": Rate := {: group <- "Kinetics" :};
    OBJ r_4 (* hidden = "1" *) "Rate Snh": Rate := {: group <- "Kinetics" :};
    OBJ r_5 (* hidden = "1" *) "Rate MH": Rate := {: group <- "Kinetics" :};
    OBJ r_6 (* hidden = "1" *) "Rate MA": Rate := {: group <- "Kinetics" :};
    OBJ r_7 (* hidden = "1" *) "Rate MS": Rate := {: group <- "Kinetics" :};
    OBJ r_8 (* hidden = "1" *) "Rate MPH": Rate := {: group <- "Kinetics" :};
    OBJ r_9 (* hidden = "1" *) "Rate MPA": Rate := {: group <- "Kinetics" :};
    OBJ r_10 (* hidden = "1" *) "Rate MI": Rate := {: group <- "Kinetics" :};
    OBJ r_11 (* hidden = "1" *) "Rate Xh": Rate := {: group <- "Kinetics" :};
    OBJ r_12 (* hidden = "1" *) "Rate Xa": Rate := {: group <- "Kinetics" :};
    OBJ r_13 (* hidden = "1" *) "Rate Xs": Rate := {: group <- "Kinetics" :};
    OBJ r_14 (* hidden = "1" *) "Rate Xp": Rate := {: group <- "Kinetics" :};
    OBJ r_15 (* hidden = "1" *) "Rate Xi": Rate := {: group <- "Kinetics" :};
    OBJ r_16 (* hidden = "1" *) "Rate Snd": Rate := {: group <- "Kinetics" :};
    OBJ r_17 (* hidden = "1" *) "Rate MND": Rate := {: group <- "Kinetics" :};
    OBJ r_18 (* hidden = "1" *) "Rate Xnd": Rate := {: group <- "Kinetics" :};
 
    OBJ u_f "Biofilm surface velocity": Velocity := {: group <- "System" :};
    OBJ kd "Biomass loss due to detachment" : Velocity := {: group <- "Detachment" :};
  };
    
  initial <-
  {
     
    state.MH := (parameters.L_init * parameters.A_B * parameters.rho * parameters.fh_init ) / (parameters.V_R - (parameters.V_R * parameters.f_vol) - (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init)) ;
    state.MA := (parameters.L_init * parameters.A_B * parameters.rho * parameters.fa_init ) / (parameters.V_R - (parameters.V_R * parameters.f_vol)- (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init)) ;
    state.MS := (parameters.L_init * parameters.A_B * parameters.rho * parameters.fs_init ) / (parameters.V_R - (parameters.V_R * parameters.f_vol)- (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init)) ;
    state.MPH := (parameters.L_init * parameters.A_B * parameters.rho * parameters.fph_init ) / (parameters.V_R - (parameters.V_R * parameters.f_vol)- (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init)) ;
    state.MPA := (parameters.L_init * parameters.A_B * parameters.rho * parameters.fpa_init ) / (parameters.V_R - (parameters.V_R * parameters.f_vol)- (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init)) ;
    state.MI := (parameters.L_init * parameters.A_B * parameters.rho * parameters.fi_init ) / (parameters.V_R - (parameters.V_R * parameters.f_vol)- (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init)) ;    
    state.MND := (parameters.L_init * parameters.A_B * parameters.rho * parameters.MND_Biomass_init ) / (parameters.V_R - (parameters.V_R * parameters.f_vol) - (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init)) ;
    
 
    parameters.H_R := parameters.V_R / parameters.A_R ;
    parameters.A_B := parameters.A_sp * parameters.f_vol * parameters.V_R ;
    
     
    state.V = parameters.V_R - (parameters.V_R * parameters.f_vol) - (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init) ;
    
    state.V_B = (parameters.A_sp * parameters.f_vol * parameters.V_R * parameters.L_init) ;
  };

  equations <-
  {
    state.Q_In = 1E-06 * interface.Inflow[H2O] ;
    
     
    state.Mh = state.MH * previous(state.V) ;
    state.Ma = state.MA * previous(state.V) ;
    state.Ms = state.MS * previous(state.V) ;
    state.Mph = state.MPH * previous(state.V) ;
    state.Mpa = state.MPA * previous(state.V) ;
    state.Mi = state.MI * previous(state.V) ;
    state.Mnd = state.MND * previous(state.V) ;
  
     
    state.L = (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) / (parameters.rho * parameters.A_B) ;
    
    state.fh  = state.Mh / (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) ;
    state.fa  = state.Ma / (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) ;
    state.fs  = state.Ms / (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) ;
    state.fi  = state.Mi / (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) ;
    state.fph  = state.Mph / (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) ;
    state.fpa  = state.Mpa / (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) ;
    state.MND_Biomass = (state.Mnd) / (state.Mh + state.Ma + state.Ms + state.Mi + state.Mph + state.Mpa) ;

     
    state.V_B = state.L * parameters.A_B ;
     
    state.V = parameters.V_R - (parameters.V_R * parameters.f_vol) - state.V_B ;
  
     
    state.Xh_b = state.Mh / state.V_B ;
    state.Xa_b = state.Ma / state.V_B ;
    state.Xs_b = state.Ms / state.V_B ;
  
     
     
     
    state.pr1 = parameters.mu_h * exp(parameters.ktemp * (interface.Temp - 20)) * state.Xh_b ;  
     
    state.pr2 = parameters.mu_hh * exp(parameters.ktemp * (interface.Temp - 20)) * state.Xh_b ; 
     
    state.pr3 = parameters.mu_a * exp(parameters.ktemp * (interface.Temp - 20)) * state.Xa_b ;  
  
     
     
    state.r1 = (1 - parameters.Y_h) / parameters.Y_h * state.pr1 + (4.57 - parameters.Y_a) / parameters.Y_a * state.pr3 ;
     
    state.r2 = 1 / parameters.Y_h * state.pr1 ;
     
    state.r4 = parameters.ixh * state.pr1 + (1/parameters.Y_a + parameters.ixa) * state.pr3 ;

     
     
     
     
    state.r3 = IF (state.Sno > 0.0) THEN ((1 - parameters.Y_h) / (2.86 * parameters.Y_h)) * state.pr2      
      ELSE 0.0 ;             
  
     
     
     
    state.r2l = IF (state.Sno > 0.0) THEN 1 / parameters.Y_h * state.pr2  
      ELSE 0.0 ;             
  
     
     
    state.r4l =  IF ((state.beta1 <= state.beta2) && (state.beta1 <= state.beta4)) THEN     
      IF (state.Sno > 0.0) THEN parameters.ixh * state.pr2  
        ELSE 0.0               
         
         
      ELSE IF (state.beta4 <= state.beta2) THEN 0.0   
         
        ELSE (1 / parameters.Y_a + parameters.ixa) * state.pr3 ;

     
    state.r1l = (4.57 - parameters.Y_a) / parameters.Y_a * state.pr3 ;
     
    
     
  
     
    state.beta1 = IF (state.So <= 0.0) THEN 0.0
      ELSE IF (state.r1 <= 0.0) THEN 1.0
        ELSE IF ( (1 / state.L * sqrt(2 * parameters.DiSo * state.So / state.r1)) > 1) THEN 1.0
          ELSE 1 / state.L * sqrt(2 * parameters.DiSo * state.So / state.r1) ;
    
    state.beta2 = IF (state.Ss <= 0.0) THEN 0.0
      ELSE IF (state.r2 <= 0.0) THEN 1.0
        ELSE IF ( (1 / state.L * sqrt(2 * parameters.DiSs * state.Ss / state.r2)) > 1) THEN 1.0
          ELSE 1 / state.L * sqrt(2 * parameters.DiSs * state.Ss / state.r2) ;
    
    state.beta4 = IF (state.Snh <= 0.0) THEN 0.0
      ELSE IF (state.r4 <= 0) THEN 1.0
        ELSE IF( (1 / state.L * sqrt(2 * parameters.DiSnh * state.Snh / state.r4)) > 1) THEN 1.0
          ELSE 1 / state.L * sqrt(2 * parameters.DiSnh * state.Snh / state.r4 ) ;
    
     
    state.beta2l_help = IF (state.r2l > 0.0) THEN (((state.beta1 * state.L) * (state.beta1 * state.L) * (1 - state.r2 / state.r2l)) + (2 * parameters.DiSs * state.Ss / state.r2l))
      ELSE 1.0 ;
      
    state.beta2l = IF ((state.r2l > 0) && (state.beta2l_help >= 0.0) && (1 / state.L * sqrt(state.beta2l_help) < 1)) THEN 1 / state.L * sqrt(state.beta2l_help)
      ELSE 1.0 ;
    
    state.beta3_help = IF (state.r3 > 0.0) THEN (state.beta1 + 1 / state.L * sqrt(2 * parameters.DiSno * state.Sno / state.r3))
      ELSE 1.0 ;
    
    state.beta3 = IF ((state.r3 > 0.0) && (state.beta3_help >= 0.0)) THEN state.beta3_help
      ELSE 1.0 ;
    
    state.beta4l_helpa = IF (state.r4l > 0.0) THEN (((state.beta1 * state.L) * (state.beta1 * state.L) * (1 - state.r4 / state.r4l)) + (2 * parameters.DiSnh * state.Snh / state.r4l))
      ELSE 1.0 ;
    
    state.beta4l_helpb = IF (state.r4l > 0.0) THEN (((state.beta2 * state.L) * (state.beta2 * state.L) * (1 - state.r4 / state.r4l)) + (2 * parameters.DiSnh * state.Snh / state.r4l))
      ELSE 1.0 ;
      
    state.beta4l = IF ((state.beta1 <= state.beta2) && (state.beta1 <= state.beta4)) THEN
      IF ((state.r4l > 0) && (state.beta4l_helpa >= 0) && (1 / state.L * sqrt(state.beta4l_helpa) < 1)) THEN 1 / state.L * sqrt(state.beta4l_helpa)
        ELSE 1.0 
         
       
       
      ELSE IF ((state.r4l > 0) && (state.beta4l_helpb >= 0) && (1 / state.L * sqrt(state.beta4l_helpb) < 1)) THEN 1 / state.L * sqrt(state.beta4l_helpb)
        ELSE 1.0 ;
 
    state.beta1l_help = IF (state.r1l > 0.0) THEN (((state.beta2*state.L)*(state.beta2*state.L) * (1-state.r1/state.r1l)) + (2 * parameters.DiSo * state.So / state.r1l))
      ELSE 1.0 ;
    
    state.beta1l = IF ((state.r1l > 0.0) && (state.beta1l_help >= 0.0) && (1 / state.L * sqrt(state.beta1l_help) < 1)) THEN 1 / state.L * sqrt(state.beta1l_help)
      ELSE 1.0 ;
     
     
    state.phih = IF (state.beta1 == 1.0 && state.beta2 == 1.0 && state.beta4 == 1.0) THEN 1.0  
      ELSE IF (state.beta1 <= state.beta2 && state.beta1 <= state.beta4) THEN state.beta1  
        ELSE IF (state.beta4 <= state.beta2) THEN state.beta4  
          ELSE state.beta2 ;   
  
    state.phia = IF (state.beta1 == 1.0 && state.beta4 == 1.0) THEN 1.0   
      ELSE IF (state.beta1 <= state.beta2 && state.beta1 <= state.beta4) THEN state.beta1  
         
        ELSE IF (state.beta4 <= state.beta2) THEN state.beta4  
           
          ELSE IF (state.beta1 <= state.beta4l)  
           
            THEN state.beta1l  
            ELSE state.beta4l ;  
  
    state.phihh = IF (state.beta1 == 1.0) THEN 0.0  
      ELSE IF (state.beta1 <= state.beta2 && state.beta1 <= state.beta4) THEN  
        IF (state.Sno > 0.0) THEN  
          IF ((state.beta2l <= state.beta3) && (state.beta2l <= state.beta4l)) THEN state.beta2l - state.phih    
            ELSE IF (state.beta3 <= state.beta4l) THEN state.beta3 - state.phih   
              ELSE state.beta4l - state.phih  
        ELSE 0.0   
      ELSE 0.0 ;   
     
     
  
     
    state.pr_1  = parameters.mu_h * exp(parameters.ktemp*(interface.Temp-20)) * state.MH * state.phih ;      
    state.pr_2  = parameters.mu_hh* exp(parameters.ktemp*(interface.Temp-20)) * state.MH * state.phihh ;     
    state.pr_3  = parameters.mu_a * exp(parameters.ktemp*(interface.Temp-20)) * state.MA * state.phia ;      
    state.pr_4  = parameters.b_h * exp(parameters.ktemp*(interface.Temp-20)) * state.MH ;                   
    state.pr_5  = parameters.b_a * exp(parameters.ktemp*(interface.Temp-20)) * state.MA ;                   
    state.pr_6  = parameters.k_h * exp(parameters.ktemp*(interface.Temp-20)) * state.MS ;                   
    state.pr_7  = parameters.vs / parameters.H_R * (state.Xh) ;   
    state.pr_8  = parameters.vs / parameters.H_R * (state.Xa) ;   
    state.pr_9  = parameters.vs / parameters.H_R * (state.Xs) ;   
    state.pr_10 = parameters.vs / parameters.H_R * (state.Xp)*(state.Mph)/((state.Mph)+(state.Mpa)) ;   
    state.pr_11 = parameters.vs / parameters.H_R * (state.Xp)*(state.Mpa)/((state.Mph)+(state.Mpa)) ;   
    state.pr_12 = parameters.vs / parameters.H_R * (state.Xi) ;   
    state.pr_13 = parameters.vs / parameters.H_R * (state.Xnd) ;  
    state.pr_14 = state.pr_6 * state.MND / state.MS ;      
    state.pr_15 = parameters.k_a * exp(parameters.ktemp*(interface.Temp-20)) * state.Snd ;   

    state.r_1 = (- (1 - parameters.Y_h) / parameters.Y_h * state.pr_1 - (4.57 - parameters.Y_a) / parameters.Y_a * state.pr_3) ;  
    state.r_2 = (- 1 / parameters.Y_h * state.pr_1 - 1 / parameters.Y_h * state.pr_2 + state.pr_6) ;  
    state.r_3 = (- (1 - parameters.Y_h) / (2.86 * parameters.Y_h) * state.pr_2 + 1 / parameters.Y_a * state.pr_3) ;   
    state.r_4 = (- parameters.ixh * state.pr_1 - parameters.ixh * state.pr_2 - (1 / parameters.Y_a + parameters.ixa) * state.pr_3 + state.pr_15) ;   
    state.r_5 =  state.pr_1 + state.pr_2 - state.pr_4 + state.pr_7 ;  
    state.r_6 =  state.pr_3 - state.pr_5 + state.pr_8 ;     		   
    state.r_7  =  (1 - parameters.fp) * state.pr_4 + (1 - parameters.fp) * state.pr_5 - state.pr_6 + state.pr_9 ;  
    state.r_8  = parameters.fp * state.pr_4 + state.pr_10 ;        
    state.r_9  = parameters.fp * state.pr_5 + state.pr_11 ;        
    state.r_10 = state.pr_12 ;                                     
    state.r_11 = - state.pr_7 ;	 						                       
    state.r_12 = - state.pr_8 ;							                       
    state.r_13 = - state.pr_9 ;							                       
    state.r_14 = - state.pr_10 - state.pr_11 ;            		     
    state.r_15 = - state.pr_12 ;                                   
    state.r_16 = - state.pr_15 + state.pr_14 ;                     
    state.r_17 = - state.pr_14 + (parameters.ixh * (1-parameters.fp)) * state.pr_4 + (parameters.ixh * (1-parameters.fp)) * state.pr_5 ;  
    state.r_18 = - state.pr_13 ;                                   

     
     

     
    state.u_f = ((state.r_5 + state.r_6 + state.r_7 + state.r_8 + state.r_9 + state.r_10) * state.V/(parameters.A_B*parameters.rho)) ; 
    
     
    state.kd = IF ( state.u_f > 1E-06 ) THEN (state.u_f * (state.L / parameters.L_max)*(state.L / parameters.L_max)) ELSE 0.0 ;
    
    DERIV(state.So,[independent.t]) := interface.Inflow[S_O] / state.V - state.Q_In / state.V * ( state.So ) + interface.Kla * (parameters.So_sat - state.So) + state.r_1 ;
    
    DERIV(state.Ss,[independent.t]) := interface.Inflow[S_S] / state.V - state.Q_In / state.V * ( state.Ss ) + state.r_2 ;
    
    DERIV(state.Sno,[independent.t]) := interface.Inflow[S_NO] / state.V - state.Q_In / state.V * ( state.Sno ) + state.r_3 ;

    DERIV(state.Snh,[independent.t]) := interface.Inflow[S_NH] / state.V - state.Q_In / state.V * ( state.Snh ) + state.r_4 ;

    DERIV(state.MH,[independent.t]) = state.r_5 - state.kd * (parameters.A_B * parameters.rho) * state.fh / state.V ;
    DERIV(state.MA,[independent.t]) = state.r_6 - state.kd * (parameters.A_B * parameters.rho) * state.fa / state.V ;
    DERIV(state.MS,[independent.t]) = state.r_7 - state.kd * (parameters.A_B * parameters.rho) * state.fs / state.V ;
    DERIV(state.MPH,[independent.t]) = state.r_8 - state.kd * (parameters.A_B * parameters.rho) * state.fph / state.V ;
    
    DERIV(state.MPA,[independent.t]) = state.r_9 - state.kd * (parameters.A_B * parameters.rho) * state.fpa / state.V ;
    
    DERIV(state.MI,[independent.t]) = state.r_10 - state.kd * (parameters.A_B * parameters.rho) * state.fi / state.V ;
    
    DERIV(state.Xh,[independent.t]) := interface.Inflow[X_BH] / state.V - state.Q_In / state.V * ( state.Xh ) + state.r_11 + state.kd * (parameters.A_B * parameters.rho) * state.fh / state.V;

    DERIV(state.Xa,[independent.t]) = interface.Inflow[X_BA] / state.V - state.Q_In / state.V * ( state.Xa ) + state.r_12 + state.kd * (parameters.A_B * parameters.rho) * state.fa / state.V ;

    DERIV(state.Xs,[independent.t]) = interface.Inflow[X_S] / state.V - state.Q_In / state.V * ( state.Xs ) + state.r_13 + state.kd * (parameters.A_B * parameters.rho) * state.fs / state.V ;

    DERIV(state.Xp,[independent.t]) = interface.Inflow[X_P] / state.V - state.Q_In / state.V * ( state.Xp ) + state.r_14 + state.kd * (parameters.A_B * parameters.rho) * (state.fph + state.fpa) / state.V ;

    DERIV(state.Xi,[independent.t]) = interface.Inflow[X_I] / state.V - state.Q_In / state.V * ( state.Xi ) + state.r_15 + state.kd * (parameters.A_B * parameters.rho) * state.fi / state.V ;

    DERIV(state.Snd,[independent.t]) = interface.Inflow[S_ND] / state.V - state.Q_In / state.V * ( state.Snd ) + state.r_16 ;
    
    DERIV(state.MND,[independent.t]) = state.r_17 - state.kd * (parameters.A_B * parameters.rho) * state.MND_Biomass / state.V ;
    
    DERIV(state.Xnd,[independent.t]) = interface.Inflow[X_ND] / state.V - state.Q_In / state.V * ( state.Xnd ) + state.r_18 ;
    
    DERIV(state.Si,[independent.t]) = interface.Inflow[S_I] / state.V - state.Q_In / state.V * ( state.Si ) ;

    interface.Outflow[1] = - interface.Inflow[1] ;
    interface.Outflow[S_O] = - state.Q_In * state.So ;
    interface.Outflow[S_S] = - state.Q_In * state.Ss ;
    interface.Outflow[S_NO] = - state.Q_In * state.Sno ;
    interface.Outflow[S_NH] = - state.Q_In * state.Snh ;
    interface.Outflow[X_BH] = - state.Q_In * state.Xh ;
    interface.Outflow[X_BA] = - state.Q_In * state.Xa ;
    interface.Outflow[X_S] = - state.Q_In * state.Xs ;
    interface.Outflow[X_P] = - state.Q_In * state.Xp ;
    interface.Outflow[X_I] = - state.Q_In * state.Xi ;
    interface.Outflow[S_ND] = - state.Q_In * state.Snd ;
    interface.Outflow[X_ND] = - state.Q_In * state.Xnd ;
    interface.Outflow[S_I] = - state.Q_In * state.Si ;
    interface.Outflow[S_ALK] = - interface.Inflow[S_ALK];
  };

:};






# 76 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.disinfection.msl" 1
 



















CLASS DisinfectionEfficiency "Intermediate class to compute disinfection efficiency" EXTENDS Base_Disinfection WITH
{:

  comments <- "Intermediate class to compute disinfection efficiency";
  
  interface <-
  {
    OBJ EColi_Out (* terminal = "out_2"; is_favorite = "1" *) "E-coli count in the effluent" : Real := {: causality <- "COUT"; group <- "Operation"; :};
  };
  
  equations <-
  {
    state.r_EColi = IF (state.In_EColi > 0.0) THEN (state.In_EColi - interface.EColi_Out) / (state.In_EColi) ELSE 0.0 ;
  };

:};


CLASS Base_Disinfection "Base class for a generic disinfection model" EXTENDS WWTPAtomicModelWithoutVolume WITH
{:

  comments <- "Base class for a generic disinfection model";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ rho_EColi_WWTP (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "E-coli removal in the WWTP" : Fraction := {: value <- 0.95; causality <- "CIN"; group <- "Operation"; :};
    OBJ EColi_In (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "E-coli count in the influent (from unit upstream)" : Real := {: causality <- "CIN"; value <- -1.0 ; group <- "Operation"; :};
  };
  
  parameters <-
  {
    OBJ Vol "Volume" : Volume := {: value <- 25; group <- "Tank" :};
    OBJ EColi_Ave "Average E-coli count in the WWTP influent" : Real := {: value <- 1E07; group <- "Operation"; :};
  };
  
  state <-
  {
    OBJ HRT (* hidden = "1" *) "Contact time" : Time := {: group <- "Operation" :};
    OBJ In_EColi (* hidden = "1" *) "E-coli in the influent (calculated or retrieved)" : Concentration := {: group <- "Operation" :};
    OBJ r_EColi "Overall E-coli removal" : Real := {: group <- "Operation" :};    
  };
  
  equations <-
  {
     
    state.In_EColi = IF (interface.EColi_In >= 0.0) THEN interface.EColi_In
      ELSE parameters.EColi_Ave * (1 - interface.rho_EColi_WWTP) ; 
    
    state.HRT = IF (state.Q_In <= 0.0) THEN 0.0 ELSE (parameters.Vol / state.Q_In) ; 
    
    {FOREACH Comp_Index IN {1 .. NrOfComponents}: interface.Outflow[Comp_Index] = - interface.Inflow[Comp_Index] ;};
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/disinfection/wwtp.disinfection.uv.msl" 1
 



















CLASS UV_Simple (* icon = "disinfection_unit" *) "Basic UV disinfection model: inactivation is proportional to intensity and contact time" EXTENDS DisinfectionEfficiency WITH
{:

  comments <- "Basic UV disinfection model: inactivation is proportional to intensity and contact time" ;
  
  interface <-
  {
    OBJ UV_I (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "UV intensity (mW/cm2)" : Real := {: value <- 0.20; causality <- "CIN"; group <- "Operation"; :};
    OBJ UV_D (* terminal = "out_2"; is_favorite = "1" *) "Dose raggi UV (mJ/cm2)" : Real := {: causality <- "COUT"; group <- "Operation"; :};
  };
  
  parameters <-
  {
    OBJ k "Empirical coefficient" : Real := {: value <- 0.04; group <- "Model"; :};
  };
  
  equations <-
  {
    interface.UV_D = interface.UV_I * (state.HRT * 24 * 3600) ; 
  
    interface.EColi_Out = IF (state.HRT <= 1/86400) THEN 0.0 ELSE state.In_EColi * exp(- parameters.k * interface.UV_D) ; 
  };

:};



# 79 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.disinfection.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/disinfection/wwtp.disinfection.chlorine.msl" 1
 



















CLASS ChlorineInv (* icon = "disinfection_unit" *) "Reverse model: computes required Cl concentration to achieve desired EColi removal" EXTENDS Base_Disinfection WITH
{:

  comments <- "Reverse model: computes required Cl concentration to achieve desired EColi removal" ;
  
  interface <-
  {
    OBJ EColi_Out (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "E-coli in the effluent" : Concentration := {: value <- 240; causality <- "CIN"; group <- "Operation"; :};
    OBJ Cl_Tot (* terminal = "out_2"; is_favorite = "1" *) "Total concentration of chlorine" : Concentration := {: causality <- "COUT"; group <- "Operation"; :};
  };
  
  parameters <-
  {
    OBJ b "Empirical coefficient" : Real := {: value <- 4.0; group <- "Model"; :};
    OBJ n "Empirical coefficient" : Real := {: value <- 2.8; group <- "Model"; :};
    OBJ Cl_Imm "Immediate request of chlorine" : Concentration := {: value <- 4.0; interval <- {: lowerBound <- 0; upperBound <- 50.0 :} ; group <- "Operation"; :};
    OBJ Cl_Dec "Request of chlorine for decay" : Concentration := {: value <- 2.5; interval <- {: lowerBound <- 0; upperBound <- 20.0 :} ; group <- "Operation"; :};
  };
  
  state <-
  {
    OBJ Cl_R (* is_favorite = "1" *) "Residual chlorine" : Concentration := {: group <- "Operation"; :};
  };
  
  equations <-
  {
    state.Cl_R = IF (interface.EColi_Out <= 0.0 || state.In_EColi <= 0.0) THEN 0.0 ELSE pow(interface.EColi_Out / state.In_EColi, - 1 / parameters.n) * (parameters.b / (state.HRT * 60 * 24)) ; 
    
    interface.Cl_Tot = state.Cl_R + parameters.Cl_Imm + parameters.Cl_Dec ; 
  };

:};


CLASS Chlorine (* icon = "disinfection_unit"; is_default = "true" *) "Basic Cl disinfection model: inactivation based on residual chlorine and contact time (Selleck, 1978)" EXTENDS DisinfectionEfficiency WITH
{:

  comments <- "Basic Cl disinfection model: inactivation based on residual chlorine and contact time (Selleck, 1978)";
  
  interface <-
  {
    OBJ Cl_R (* terminal = "out_2"; is_favorite = "1" *) "Residual chlorine" : Concentration := {: causality <- "COUT"; group <- "Operation"; :};
  };
  
  parameters <-
  {
    OBJ b "Empirical coefficient" : Real := {: value <- 4.0; group <- "Model"; :};
    OBJ n "Empirical coefficient" : Real := {: value <- 2.8; group <- "Model"; :};
    OBJ Cl_Tot "Total concentration of chlorine" : Concentration := {: value <- 10.0; interval <- {: lowerBound <- 0; upperBound <- 50.0 :} ; group <- "Operation"; :};
    OBJ Cl_Imm "Immediate request of chlorine" : Concentration := {: value <- 4.0; interval <- {: lowerBound <- 0; upperBound <- 50.0 :} ; group <- "Operation"; :};
    OBJ Cl_Dec "Request of chlorine for decay" : Concentration := {: value <- 2.5; interval <- {: lowerBound <- 0; upperBound <- 20.0 :} ; group <- "Operation"; :};
  };
  
  equations <-
  {
    interface.Cl_R = parameters.Cl_Tot - (parameters.Cl_Imm + parameters.Cl_Dec) ;
    
     
    interface.EColi_Out = IF (interface.Cl_R * state.HRT <= 0.0) THEN 0.0 ELSE state.In_EColi * pow((interface.Cl_R * state.HRT * 60 * 24 / parameters.b), - parameters.n) ; 
  };

:};



# 80 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.disinfection.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/disinfection/wwtp.disinfection.paa.msl" 1
 



















 
CLASS PAA_02 (* icon = "disinfection_unit" *) "Log-inactivation model by Henao et al. (2018) accounting for suspended solids on peracetic acid decay and bacterial inactivation kinetics"
EXTENDS LogInactivation WITH
{:

  comments <- "Log-inactivation model by Henao et al. (2018) accounting for suspended solids on peracetic acid decay and bacterial inactivation kinetics" ;
  
  interface <-
  {
    OBJ C_PAA (* terminal = "in_2"; is_favorite = "1" *) "(initial) PAA concentration" : Concentration := {: causality <- "CIN"; value <- 10 ; group <- "Operation" :};
  };
  
  parameters <-
  {
    OBJ OD "Initial Oxidative Demand" : Concentration := {: value <- 0.01 ; group <- "Model TSS > 5" :};
    OBJ k "Empirical coefficient" : Real := {: value <- 0.005; group <- "Model TSS > 5"; :};
    
    OBJ k1 "Empirical coefficient" : Real := {: value <- 1.851; group <- "Model TSS < 5"; :};
    OBJ h "Empirical coefficient" : Real := {: value <- 6.335; group <- "Model TSS < 5"; :};
    OBJ n "Empirical coefficient" : Real := {: value <- 0.328; group <- "Model TSS < 5"; :};

    
    OBJ F_TSS_COD "Fraction TSS/COD" : Ratio := {: value <- 0.75 ; group <- "Conversion factors":};
    

    




  };
  
  state <-
  {
     OBJ D_PAA "Dose of PAA (g/m3.min)" : Real := {: group <- "Operation" :} ;
     OBJ In_TSS (* hidden = "0" *) "Solids concentration" : Concentration := {: group <- "Operation" :} ;
  };
  
  equations <-
  {
    state.In_TSS =
      
      IF (state.Q_In == 0) THEN 0.0 ELSE (interface.Inflow[X_BH] + interface.Inflow[X_BA] + interface.Inflow[X_S] + interface.Inflow[X_I] + interface.Inflow[X_P]) * parameters.F_TSS_COD / state.Q_In 
      
      


      


      


      






      


      ;

     
     
    state.D_PAA = IF (state.In_TSS < 5.0) THEN interface.C_PAA * state.HRT * 60 * 24
      ELSE (interface.C_PAA - parameters.OD) / parameters.k * (1 - exp(- parameters.k * state.HRT * 60 * 24)) ;
    
     
    state.dLog = - parameters.k1 * pow(state.D_PAA, parameters.n) * (1 / (1 + exp(parameters.h - state.D_PAA))) ;
  };

:};


CLASS PAA_01 (* icon = "disinfection_unit" *) "Modified S-Model (Profaizer, 1998)"
EXTENDS LogInactivation WITH
{:

  comments <- "Modified S-Model (Profaizer, 1998)" ;
  
  interface <-
  {
    OBJ C_PAA (* terminal = "out_2"; is_favorite = "1" *) "PAA concentration" : Concentration := {: causality <- "COUT"; group <- "Operation" :};
  };
  
  parameters <-
  {
    OBJ k "Empirical coefficient" : Real := {: value <- 4.0; group <- "Model"; :};
    OBJ h "Empirical coefficient" : Real := {: value <- 4.0; group <- "Model"; :};
    OBJ n "Empirical coefficient" : Real := {: value <- 2.8; group <- "Model"; :};
    OBJ m "Empirical coefficient" : Real := {: value <- 2.8; group <- "Model"; :};
  };
  
  equations <-
  {
     
    state.dLog = - parameters.k * pow(interface.C_PAA, parameters.n) / (1 + pow(parameters.h / (interface.C_PAA * state.HRT * 60 * 24), parameters.m)) ;
  };

:};


CLASS LogInactivation "Generic log-inactivation model" EXTENDS DisinfectionEfficiency WITH
{:

  comments <- "Generic log-inactivation model" ;
  
  state <-
  {
    OBJ dLog (* hidden="1" *) "log N/No" : Real := {: group <- ".." :};
  };
  
  equations <-
  {
    interface.EColi_Out = IF (state.In_EColi <= 1.0) THEN 1.0 ELSE pow(10, log10(state.In_EColi) + state.dLog) ;                                                 
  };

:};



# 81 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.disinfection.msl" 2




# 77 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.fractionators.msl" 1
 



















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/fractionators/wwtp.ASM1.fractionator.msl" 1
 



















CLASS InfluentFractionator (* icon = "fractionator"; is_default = "true" *)
"Influent fractionator for ASM1Temp" SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "Probabilistic interpretation of measurements as compositions in terms of ASM1 components";

  interface <-
  {
    OBJ COD (* terminal = "in_1"; manip = "1" *) "COD in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ COD_us (* terminal = "in_1"; manip = "1" *) "Unbiodegradable soluble COD in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ COD_up (* terminal = "in_1"; manip = "1" *) "Unbiodegradable particulate COD in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ COD_oho (* terminal = "in_1"; manip = "1" *) "Ordinary heterotrophic organism COD in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ TKN (* terminal = "in_1"; manip = "1" *) "TKN in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ TSS (* terminal = "in_1"; manip = "1" *) "TSS in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ FSA (* terminal = "in_1"; manip = "1" *) "FSA in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ COD_filtered (* terminal = "in_1"; manip = "1" *) "Filtered COD in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ TKN_filtered (* terminal = "in_1"; manip = "1" *) "Filtered TKN in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
     
    OBJ Alkalinity_In  (* terminal = "in_1"; manip = "1" *) "Alkalinity (mg CaCO3/L) in the influent" : Concentration := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ Q_In (* terminal = "in_1"; manip = "1" *) "Water" : FlowRate := {: causality <- "CIN"; group <- "Measurements" :};
    OBJ Influent_Load (* terminal = "out_1" *) "Influent load" : OutWWTPTerminal := {: causality <- "COUT"; group <- "Influent" :};	
  };
  
  parameters <-
  {
    OBJ Measurement_weight "Weights in least squares regression" : MeasurementVector :=
      [{: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :},
      {: value <- 1 :}, {: value <- 1 :}, {: value <- 1 :},{: value <- 1 :},{: value <- 1 :}] ;
    
    OBJ Estimate_weight "Weights in least squares regression" : MeasurementVector :=
      [{: value <- 0.2 :}, {: value <- 0.2:}, {: value <- 0.2:}, {: value <- 0.2:}, {: value <- 0.2:},
      {: value <- 0.2:},{: value <- 0.2:}, {: value <- 0.2:}, {: value <- 0.2:}, {: value <- 0.2:}] ;
      
    OBJ LowerLimit "Lower limits for fractionation components" : FractionationVector :=
      [{: value <- 20.0 :}, {: value <- 100.0 :}, {: value <- 5.0 :},  
      {: value <- 10.0 :}, {: value <- 40.0 :}, {: value <- 80.0 :},    
      {: value <- 1.0  :}, {: value <- 2.0:}] ;   
    
    OBJ UpperLimit "Upper limits for fractionation components" : FractionationVector :=
      [{: value <- 80.0 :}, {: value <- 500.0 :}, {: value <- 45.0 :},  
      {: value <- 60.0 :}, {: value <- 400.0 :}, {: value <- 900.0 :},    
      {: value <- 20.0  :}, {: value <- 20.0:}] ;   
    
    OBJ Measurement_factor (*  hidden = "1" ; fixed = "1" *) "Matrix coefficients" : FractionationCoefficients ;
    OBJ Time_const "Relaxation time constant for fitting" : Time := {: value <- 0.5 ; group <- "Fractionation" :} ;
    OBJ f_tss "Ratio of TSS to total COD" : Ratio  := {: value <- 1.05 ; group <- "Fractionation" :};
    OBJ f_oho "OHO fraction of total COD" : Ratio := {: value <- 0.1 ; group <- "Fractionation" :} ;
    OBJ f_codus "Unbiodegradable soluble fraction of total COD" : Ratio := {: value <- 0.095 ; group <- "Fractionation" :} ;
    OBJ f_codup "Unbiodegradable particulate COD" : Ratio := {: value <- 0.13 ; group <- "Fractionation" :} ;
    OBJ f_tkn "TKN ratio to total COD" : Ratio := {: value <- 0.1 ; group <- "Fractionation" :} ;
    OBJ f_fsa "FSA ratio to TKN" : Ratio := {: value <- 0.75 ; group <- "Fractionation" :} ;
    OBJ f_codf "Soluble fraction of total COD" : Ratio := {: value <- 0.2 ; group <- "Fractionation" :} ;
    OBJ f_tknf "Filtered TKN ratio to total COD" : Ratio := {: value <- 0.05 ; group <- "Fractionation" :} ;
    OBJ Temperature	"pH/Conductivity measurement temperature" : CelsiusTemperature	:= {: value <- 25 ; group <- "Kinetics" :}; 
    
    OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  }; 
  
  independent <-
  {
    OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {  
    OBJ Objective "Least squares objective function value" : Real := {: group <- "Objective" :} ;
    OBJ DerivativesDone (* hidden = "1" *) : Real ;
    OBJ Deriv_Fitted (* hidden = "1" *) "Derivatives" : FractionationVector := {: group <- "Fractionation" :} ;
    OBJ Matched (* hidden = "1" *) "Matched" : MeasurementVector := {: group <- "Fractionation" :} ;
    
    OBJ Measured "Input measurements" : MeasurementVector := {: group <- "Measurements" :} ;
    OBJ weight "Effective weight" : MeasurementVector := {: group <- "Measurements" :} ;
    OBJ OHO "OHO concentration" : Concentration := {: group <- "Measurements" :} ;
    OBJ Fitted_Flow "Flow measurement" : FlowRate := {: value <- 1000 ; group <- "Measurements" :} ;
    OBJ Fitted_Alkalinity "Alkalinity measurement (mg CaCO3/L)" : Concentration := {:  value <- 330.0 ; group <- "Measurements" :} ;
    
    OBJ Temp_Actual "Temperature" : CelsiusTemperature := {: group <- "Kinetics":};
    OBJ COD_predicted "COD value used for fractionation" : Concentration := {: group <- "Input" :};  
    OBJ TKN_predicted "TKN value used for fractionation" : Concentration := {: group <- "Input" :};  
    OBJ TSS_predicted "TSS value used for fractionation" : Concentration := {: group <- "Input" :};  
    
     
    OBJ Fitted "Components with concentrations fitted to measurements" : FractionationVector
      := [{: value <- 30.0 :}, {: value <- 270.0 :}, {: value <- 15.0 :},  
      {: value <- 45.0 :}, {: value <- 150.0 :}, {: value <- 300.0 :},    
      {: value <- 10.0  :}, {: value <- 10.0:}] ;   
  };

  initial <-
  {  
     
    parameters.Measurement_factor[_COD][s_I] = 1.0 ;
    parameters.Measurement_factor[_COD][s_S] = 1.0 ;
    parameters.Measurement_factor[_COD][x_I] = 1.0 ;
    parameters.Measurement_factor[_COD][x_S] = 1.0 ;
    parameters.Measurement_factor[_COD][x_BH] = 1.0 ;
    
     
    parameters.Measurement_factor[_TSS][x_I] = parameters.f_tss ;
    parameters.Measurement_factor[_TSS][x_S] = parameters.f_tss ;
    parameters.Measurement_factor[_TSS][x_BH] = parameters.f_tss ;
    
     
    parameters.Measurement_factor[_TKN][s_NH] = 1.0 ;
    parameters.Measurement_factor[_TKN][s_ND] = 1.0 ;
    parameters.Measurement_factor[_TKN][x_ND] = 1.0 ;
    parameters.Measurement_factor[_TKN][x_BH] = parameters.i_X_B ;
    
     
    parameters.Measurement_factor[_FSA][s_NH] = 1.0 ;
    
     
    parameters.Measurement_factor[_COD_filtered][s_I] = 1.0 ;
    parameters.Measurement_factor[_COD_filtered][s_S] = 1.0 ;
    
     
    parameters.Measurement_factor[_TKN_filtered][s_NH] = 1.0 ;
    parameters.Measurement_factor[_TKN_filtered][s_ND] = 1.0 ;
    
     
    parameters.Measurement_factor[_COD_us][s_I] = 1.0 ;
    
     
    parameters.Measurement_factor[_COD_up][x_I] = 1.0 ;
    
     
    parameters.Measurement_factor[_COD_oho][x_BH] = 1.0 ;
  };

  equations <-
  {
    state.Temp_Actual = parameters.Temperature ;
    
     
    state.Measured[_COD] = IF (interface.COD > 0.0 ) THEN interface.COD 
      ELSE IF (interface.TSS > 0.0) THEN interface.TSS / parameters.f_tss 
        ELSE 0.0 ; 
    state.weight[_COD] = IF (interface.COD > 0.0) THEN parameters.Measurement_weight[_COD]
      ELSE parameters.Estimate_weight[_COD] ;

    state.Measured[_TSS] = IF (interface.TSS > 0.0) THEN interface.TSS
      ELSE state.Measured[_COD] * parameters.f_tss ;
    state.weight[_TSS] = IF (interface.TSS > 0.0) THEN parameters.Measurement_weight[_TSS]
      ELSE parameters.Estimate_weight[_TSS] ;
        
    state.Measured[_TKN] = IF (interface.TKN > 0.0) THEN interface.TKN 
      ELSE IF (interface.FSA > 0.0) THEN interface.FSA / parameters.f_fsa 
        ELSE parameters.f_tkn * state.Measured[_COD] ;
    state.weight[_TKN] = IF (interface.TKN > 0.0) THEN parameters.Measurement_weight[_TKN]
      ELSE parameters.Estimate_weight[_TKN] ;   

    state.Measured[_COD_oho] = IF (interface.COD_oho > 0.0) THEN interface.COD_oho 
      ELSE state.Measured[_COD] * parameters.f_oho ;
     
    state.weight[_COD_oho] = IF (interface.COD_oho > 0.0) THEN parameters.Measurement_weight[_COD_oho]
      ELSE parameters.Estimate_weight[_COD_oho] ;

    state.Measured[_COD_us] = IF (interface.COD_us > 0.0) THEN interface.COD_us
      ELSE IF (interface.COD_filtered > 0.0) THEN interface.COD_filtered * parameters.f_codus / parameters.f_codf 
        ELSE state.Measured[_COD]* parameters.f_codus;
    state.weight[_COD_us] = IF (interface.COD_us > 0.0) THEN parameters.Measurement_weight[_COD_us]
      ELSE parameters.Estimate_weight[_COD_us] ;
    
    state.Measured[_COD_up] = IF (interface.COD_up > 0.0) THEN interface.COD_up
      ELSE IF ((interface.COD_filtered > 0.0) && (interface.COD > 0.0)) THEN (interface.COD - interface.COD_filtered) * parameters.f_codup / (1.0 - parameters.f_codf)  
        ELSE state.Measured[_COD]* parameters.f_codup;
    state.weight[_COD_up] = IF (interface.COD_up > 0.0) THEN parameters.Measurement_weight[_COD_up]
      ELSE parameters.Estimate_weight[_COD_up]  ;
    
    state.Measured[_FSA] = IF (interface.FSA > 0.0) THEN interface.FSA
      ELSE state.Measured[_TKN] * parameters.f_fsa ;
    state.weight[_FSA] = IF (interface.FSA > 0.0) THEN parameters.Measurement_weight[_FSA]
      ELSE parameters.Estimate_weight[_FSA]  ;
    
    state.Measured[_COD_filtered] = IF (interface.COD_filtered > 0.0) THEN interface.COD_filtered
      ELSE state.Measured[_COD]* parameters.f_codf;
    state.weight[_COD_filtered] = IF (interface.COD_filtered > 0.0) THEN parameters.Measurement_weight[_COD_filtered]
      ELSE parameters.Estimate_weight[_COD_filtered] ;
    
    state.Measured[_TKN_filtered] = IF(interface.TKN_filtered > 0.0) THEN interface.TKN_filtered
      ELSE state.Measured[_COD]* parameters.f_tknf ;
    state.weight[_TKN_filtered] = IF (interface.TKN_filtered > 0.0) THEN parameters.Measurement_weight[_TKN_filtered]
      ELSE parameters.Estimate_weight[_TKN_filtered] ;
    
    DERIV(state.Fitted_Flow,[independent.t]) = IF (interface.Q_In > 0.0)
      THEN (interface.Q_In - state.Fitted_Flow) / parameters.Time_const
      ELSE 0.0 ;
    
    DERIV(state.Fitted_Alkalinity,[independent.t]) = IF (interface.Alkalinity_In > 0.0) 
      THEN (interface.Alkalinity_In - state.Fitted_Alkalinity) / parameters.Time_const 
      ELSE 0.0 ; 
    
     
    state.DerivativesDone = MSLU_FractionationDerivatives(
      ref(parameters.Measurement_factor[1][1]), ref(state.Measured[1]), ref(state.weight[1]),
      ref(state.Fitted[1]), ref(parameters.LowerLimit[1]), ref(parameters.UpperLimit[1]),
      parameters.Time_const, NrMeasurements, NrFractionationComponents, ref(state.Objective),
      ref(state.Matched[1]),ref(state.Deriv_Fitted[1])) ;
    
    {FOREACH Comp_Index IN {1 .. NrFractionationComponents}:
      DERIV(state.Fitted[Comp_Index],[independent.t]) = state.Deriv_Fitted[Comp_Index] + state.DerivativesDone ; } ;

    interface.Influent_Load[H2O] = -1.0E06 * state.Fitted_Flow ;
    interface.Influent_Load[S_I] = -state.Fitted[s_I] * state.Fitted_Flow + state.DerivativesDone;
    interface.Influent_Load[S_S] = -state.Fitted[s_S] * state.Fitted_Flow + state.DerivativesDone;
    interface.Influent_Load[S_ND] = -state.Fitted[s_ND] * state.Fitted_Flow + state.DerivativesDone ;
    interface.Influent_Load[S_NH] = -state.Fitted[s_NH] * state.Fitted_Flow + state.DerivativesDone ;
    interface.Influent_Load[X_I] = -state.Fitted[x_I] * state.Fitted_Flow + state.DerivativesDone ;
    interface.Influent_Load[X_S] = -state.Fitted[x_S] * state.Fitted_Flow + state.DerivativesDone;
    interface.Influent_Load[X_BH] = -state.Fitted[x_BH] * state.Fitted_Flow + state.DerivativesDone ;
    interface.Influent_Load[X_ND] = -state.Fitted[x_ND] * state.Fitted_Flow + state.DerivativesDone ;
    interface.Influent_Load[S_ALK] = -state.Fitted_Alkalinity * state.Fitted_Flow + state.DerivativesDone ;
  } ;

:};


TYPE Measurements "The influent measurements considered in the ASM1 model"
= ENUM { _COD, _TKN, _TSS, _FSA, _COD_filtered, _TKN_filtered, _COD_us, _COD_up, _COD_oho, } ;

TYPE FractionationComponents "The model components used in fractionating measurements"
= ENUM { s_I, s_S, s_ND, s_NH, x_I, x_S, x_BH, x_ND, };

OBJ NrMeasurements : Integer := Cardinality(Measurements);
OBJ NrFractionationComponents : Integer := Cardinality(FractionationComponents);

TYPE MeasurementVector = Real[NrMeasurements;];
TYPE FractionationVector
"The variables containing fractionated component concentrations"
= Real[NrFractionationComponents;];

TYPE FractionationCoefficients
"The matrix of coefficients used in the fractionation"
= Real[NrMeasurements;][NrFractionationComponents,];


# 21 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.fractionators.msl" 2




# 79 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.pumps.msl" 1
 




















OBJ n "Number of interpolation points" : Integer := 21 ;
OBJ i "Temporary iteration variable, index of the component" : Integer ;


CLASS Switch "Switch: 1=on, 0=off"
SPECIALISES Integer :=
{:
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
:};
  

CLASS Pump_Base "A base model for a pump" SPECIALISES PhysicalDAEModelType :=
{:

  interface <- 
  {
    OBJ IsOn (* terminal = "in_2"; manip = "1" *) "Control signal: 0=off, 1=on" : Integer := {: causality <- "CIN" ; interval  <- {: lowerBound <- 0 ; upperBound <- 1 :}; value <- 1; group <- "Operational" :};
    OBJ Q_Op (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired operating flow rate" : FlowRate := {: causality <- "CIN" ; value <- 20000; group <- "Input" :};
     
    OBJ TSS (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "TSS concentration in the pumped liquid" : Concentration := {: causality <- "CIN" ; value <- 3000; group <- "Operational" :};
     
    OBJ Q_Out (* terminal = "out_2"; is_favorite = "1" *) "Actual flow rate" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ PumpingEnergy (* terminal = "out_2"; is_favorite = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PowerConsumption (* terminal = "out_2"; is_favorite = "1" *) "Actual power consumption" : Power := {: causality <- "COUT"; group <- "Energy" :};
  };

  parameters <- 
  {
    OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/s2)": Real := {: value <- 9.81 :};
    OBJ Rho_Water (* hidden = "1" *) "Density of water": Concentration := {: value <- 1.0E06 :};
    OBJ Rho_TSS (* hidden = "1" *) "Density of Suspended Solids": Concentration := {: value <- 1.25E06 :};
  };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ help_Q (* hidden = "1" *) "Actual flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ help_Energy (* hidden = "1" *) "Specific pumping energy consumption for pump" : EnergyForPumping := {: group <- "Energy" :};
    OBJ Rho_Fluid (* hidden = "1" *) "Density of the fluid to be pumped" : Density := {: group <- "Operational":};
    OBJ H_System "Total head losses of the system" : Length := {: group <- "Operational" :};
    OBJ Eta_Total "Total efficiency" : Fraction := {: group <- "Energy" :};
    OBJ H (* is_favorite = "1" *) "Operating head at Qout" : Length := {: group <- "Operational" :};
  };

  equations <-
  {
    state.Rho_Fluid = interface.TSS + (1 - interface.TSS / parameters.Rho_TSS) * parameters.Rho_Water ;  
    
    interface.Q_Out = state.help_Q ;
  
     
    state.help_Energy = state.Rho_Fluid * parameters.g * state.H * (0.27778 * 1E-09) ;

     
    interface.PowerConsumption = IF ((state.help_Q <= 0.0) || (state.Eta_Total <= 0.0)) THEN 0.0
      ELSE 1E3 * (state.help_Energy / state.Eta_Total) * state.help_Q / 24 ;
  };

:};


 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.generic.simpleq.msl" 1
 




















 
CLASS SimpleQ (* icon = "pump" *) "Basic pump model: fixed head (static + others)"
EXTENDS Pump_Base WITH
{:
  comments <- "Basic pump model: fixed head (static + others)";
  
  parameters <-
  {
    OBJ H_TS (* is_favorite = "1" *) "Static head loss": Length := {: value <- 5.0 ; group <- "Operational" :};
    OBJ H_F (* is_favorite = "1" *) "Friction and minor head loss": Length := {: value <- 1.0; group <- "Operational" :};
    OBJ Eta (* is_favorite = "1" *) "Efficiency of the pump": Fraction := {: value <- 0.667 ; group <- "Operational" :};
  };
  
  state <-
  {
    OBJ Integ_PE (* hidden = "1" *) "Integral Pumping energy for pump " : ElectricalEnergy ;
  };
  
  initial <-
  {
    state.Integ_PE = 0.0 ;
    state.H_System = parameters.H_TS + parameters.H_F ;
    state.Eta_Total = parameters.Eta ;  
  };
  
  equations <-
  {
    state.H = state.H_System ;
    state.help_Q = IF (interface.IsOn == 0) THEN 0.0 ELSE interface.Q_Op ;
    
     
    DERIV(state.Integ_PE,[independent.t])= (state.help_Energy / state.Eta_Total) * state.help_Q ;  
    interface.PumpingEnergy = state.Integ_PE ;
  };

:};



# 88 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.pumps.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.generic.q.msl" 1
 




















CLASS Generic_Q "A base model to calculate a generic pump's power consumption based on the flow rate Q"
EXTENDS Base_Generic_Q WITH  
{:

  interface <-
  {
    OBJ HeadLoss_Ext (* terminal = "in_2"; manip = "1" *) "Head loss due to external factors (optional)" : Length := {: causality <- "CIN" ; group <- "Operational" :};
    OBJ Elevation (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Elevation head to be overcome" : Length := {: causality <- "CIN" ; group <- "Operational" :};
  };

  parameters <- 
  {
     
    OBJ PipeDiameter "Diameter of pipes that conduct the pumped fluid" : Length := {: value <- 0.5 ; group <- "Head losses":};
    OBJ PipeLength "Length of pipes that conduct the pumped fluid" : Length := {: value <- 60.0 ; group <- "Head losses":};
    OBJ Epsilon "Absolute internal roughness of the pipes" : Length := {: value <- 0.00015 ; group <- "Head losses":};
     
    OBJ ViscosityWater "Dynamic viscosity of water" : DynamicViscosity := {: value <- 1.5972E-08 ; group <- "Head losses":};
     
    OBJ PipeLength_Equiv "Equivalent pipe length of elements causing minor losses (elbows, inlet, outlet, ...)" : Length := {: value <- 75.0 ; group <- "Head losses":};
    OBJ Friction_InLine "Head losses due to control valves, flow sensors, .." : Length := {: value <- 0.0 ; group <- "Head losses":};
  };
  
  state <-
  {
    OBJ help_Viscosity_k (* hidden = "1" *) "Dummy variable for calculations" : Real ;
    OBJ help_Viscosity_n (* hidden = "1" *) "Dummy variable for calculations" : Real ;
     
    OBJ IsThick (* hidden = "1" *) "0=Newtonian (water), 1=non-Newtonian (thick sludge)" : Integer := {: interval  <- {: lowerBound <- 0; upperBound <- 1 :} :};
    OBJ FluidViscosity "Dynamic viscosity of the pumped fluid" : DynamicViscosity := {: group <- "Head losses":};

    OBJ Q_Max "Maximum flow rate in the specified system" : FlowRate := {: group <- "Pump curve" :};
     
    OBJ Q_Min "Minimum flow rate in the specified system" : FlowRate := {: group <- "Pump curve" :};

    OBJ H_Pump "Operating head at Q_Out according to pump curve" : Length := {: group <- "Operational" :};
    
     
    OBJ Q_NoCtl_Duty (* hidden = "1" *) "Maximum flow rate" : FlowRate := {: group <- "Pump curve" :};
    OBJ H_NoCtl_Duty (* hidden = "1" *) "Operating head at max flow rate for the given pump and system" : Length := {: group <- "Pump curve" :};
    OBJ H_Pump_NoCtl (* hidden = "1" *) "Vector discretizing the pump curve: heads for n different flow rate values" : Length[21;] := {: group <- "_ H Pump no ctl" :};
    OBJ H_System_NoCtl (* hidden = "1" *) "Vector discretizing the system curve: heads for n different flow rate values" : Length[21;] := {: group <- "_ H System no ctl" :};
    
     
    OBJ Friction_NoCtl (* hidden = "1" *) "Darcy-Weisbach friction factor f (depending on the Reynolds number)" : Real[n;] := {: interval  <- {: lowerBound <- 0.0 :} :};
     
    OBJ FluidViscosity_NoCtl (* hidden = "1" *) "Dynamic viscosity vector of the pumped fluid at n different flow rate values" : DynamicViscosity[n;] ;
    OBJ ReynoldsNr_NoCtl (* hidden = "1" *) "Reynolds number of pipes that conduct the pumped fluid" : Real[n;] ;
     
    OBJ FluidVelocity_NoCtl (* hidden = "1" *) "Velocity of pumped fluid" : Velocity[n;] ;  
    OBJ Friction_Pipe_NoCtl (* hidden = "1" *) "Friction head losses due to flow through pipes" : Length[n;] ;
    OBJ Friction_MinorLosses_NoCtl (* hidden = "1" *) "Head losses due to elbows, inlet, outlet, .." : Length[n;] ;
     
    OBJ Friction "Darcy-Weisbach friction factor f (depending on the Reynolds number)" : Real := {: interval  <- {: lowerBound <- 0.0 :}; group <- "Head losses" :};
    OBJ ReynoldsNr "Reynolds number of the pipes" : Real := {: interval  <- {: lowerBound <- 0.0 :}; group <- "Head losses" :};
     
    OBJ FluidVelocity "Velocity of pumped fluid" : Velocity := {: group <- "Head losses" :};  
    OBJ Friction_Pipe "Friction head losses due to flow through pipes" : Length := {: group <- "Head losses" :};
    OBJ Friction_MinorLosses "Head losses due to elbows, inlet, outlet, .." : Length := {: group <- "Head losses" :};

    OBJ help_N (* hidden = "1" *) "Relative pump speed: actual pump speed / nominal pump speed" : Fraction ;
    OBJ help_Eta_Pump (* hidden = "1" *) "Efficiency of the pump" : Fraction := {: group <- "_ Energy" :};  
  };
  
  initial <-
  {
     
     
    { FOREACH i IN {1 .. n}: state.Q_NoCtl[i] := state.help_Q_3 / (n - 1) * (i - 1) ; };
    
     
    { FOREACH i IN {1 .. n}: state.H_Pump_NoCtl[i] :=
      state.PumpCurveCoeff_A - state.PumpCurveCoeff_B * pow(state.Q_NoCtl[i], state.PumpCurveCoeff_C) ; }; 
    
     
    { FOREACH i IN {1 .. n}: state.FluidVelocity_NoCtl[i] :=
      IF (state.Q_NoCtl[i] > 0.0) THEN state.Q_NoCtl[i] / (3.14 * pow(parameters.PipeDiameter,2) / 4) ELSE 1E-20 ; };
    
    state.Q_Min := 0.0 ;
  };
  
  equations <-
  {
    state.IsThick = IF (interface.TSS > 8000) THEN 1 ELSE 0 ;
     
    state.help_Viscosity_k = 0.001 * exp(2.0 * pow(interface.TSS/1000, 0.41)) ;
    state.help_Viscosity_n = 1 - 0.23 * pow((interface.TSS/1000), 0.37) ;  
    
     
    { FOREACH i IN {1 .. n}: state.FluidViscosity_NoCtl[i] =
      IF (state.IsThick == 0) THEN parameters.ViscosityWater
        ELSE (1/86400) * state.help_Viscosity_k * pow((0.75 + 0.25/state.help_Viscosity_n), state.help_Viscosity_n) *
          pow((8.0 * state.FluidVelocity_NoCtl[i]/86400 / parameters.PipeDiameter), state.help_Viscosity_n - 1) ; }; 
    
     
    { FOREACH i IN {1 .. n}: state.ReynoldsNr_NoCtl[i] =
      IF (state.FluidVelocity_NoCtl[i] <= 0.0) THEN 1E-20  
        ELSE IF (state.IsThick == 0) THEN parameters.Rho_Water/1000 * (state.FluidVelocity_NoCtl[i]/86400) * parameters.PipeDiameter / (state.FluidViscosity_NoCtl[i])  
          ELSE state.Rho_Fluid/1000 * (state.FluidVelocity_NoCtl[i]/86400) * parameters.PipeDiameter / state.FluidViscosity_NoCtl[i] ; };  
    
     
    { FOREACH i IN {1 .. n}: state.Friction_NoCtl[i] =
      IF (state.IsThick == 0) THEN 0.25 * pow(log10(parameters.Epsilon/(3.7 * parameters.PipeDiameter) + 5.74/pow(state.ReynoldsNr_NoCtl[i], 0.9)), -2)  
         
        ELSE IF (state.ReynoldsNr_NoCtl[i] <= 2400.0) THEN 4 * 16 / state.ReynoldsNr_NoCtl[i]
          ELSE 4 * 0.0792 * pow(state.help_Viscosity_n, 0.675) * pow(state.ReynoldsNr_NoCtl[i], -0.25); };  
    
    { FOREACH i IN {1 .. n}: state.Friction_Pipe_NoCtl[i] =
      state.Friction_NoCtl[i] * pow(state.FluidVelocity_NoCtl[i]/86400, 2) * parameters.PipeLength / parameters.PipeDiameter / 2 / 9.81 ; };
    
    { FOREACH i IN {1 .. n}: state.Friction_MinorLosses_NoCtl[i] = state.Friction_Pipe_NoCtl[i] * parameters.PipeLength_Equiv / parameters.PipeLength ; };
     
     
    { FOREACH i IN {1 .. n}: state.H_System_NoCtl[i] =
      state.Friction_Pipe_NoCtl[i] + state.Friction_MinorLosses_NoCtl[i] + parameters.Friction_InLine + interface.Elevation + interface.HeadLoss_Ext ; };

    state.H_NoCtl_Duty = IF ((state.H_Pump_NoCtl[1] > state.H_System_NoCtl[1]) && (state.H_Pump_NoCtl[2] <= state.H_System_NoCtl[2])) THEN
      ((state.H_Pump_NoCtl[1] * state.H_System_NoCtl[2] - state.H_Pump_NoCtl[2] * state.H_System_NoCtl[1]) / (state.H_System_NoCtl[2] - state.H_System_NoCtl[1] + state.H_Pump_NoCtl[1] - state.H_Pump_NoCtl[2]))
        ELSE IF (state.H_Pump_NoCtl[2] > state.H_System_NoCtl[2] && state.H_Pump_NoCtl[3] <= state.H_System_NoCtl[3]) THEN
          ((state.H_Pump_NoCtl[2] * state.H_System_NoCtl[3] - state.H_Pump_NoCtl[3] * state.H_System_NoCtl[2]) / (state.H_System_NoCtl[3] - state.H_System_NoCtl[2] + state.H_Pump_NoCtl[2] - state.H_Pump_NoCtl[3]))
            ELSE IF (state.H_Pump_NoCtl[3] > state.H_System_NoCtl[3] && state.H_Pump_NoCtl[4] <= state.H_System_NoCtl[4]) THEN
              ((state.H_Pump_NoCtl[3] * state.H_System_NoCtl[4] - state.H_Pump_NoCtl[4] * state.H_System_NoCtl[3]) / (state.H_System_NoCtl[4] - state.H_System_NoCtl[3] + state.H_Pump_NoCtl[3] - state.H_Pump_NoCtl[4]))
                  ELSE IF (state.H_Pump_NoCtl[4] > state.H_System_NoCtl[4] && state.H_Pump_NoCtl[5] <= state.H_System_NoCtl[5]) THEN
                    ((state.H_Pump_NoCtl[4] * state.H_System_NoCtl[5] - state.H_Pump_NoCtl[5] * state.H_System_NoCtl[4]) / (state.H_System_NoCtl[5] - state.H_System_NoCtl[4] + state.H_Pump_NoCtl[4] - state.H_Pump_NoCtl[5]))
                      ELSE IF (state.H_Pump_NoCtl[5] > state.H_System_NoCtl[5] && state.H_Pump_NoCtl[6] <= state.H_System_NoCtl[6]) THEN
      ((state.H_Pump_NoCtl[5] * state.H_System_NoCtl[6] - state.H_Pump_NoCtl[6] * state.H_System_NoCtl[5]) / (state.H_System_NoCtl[6] - state.H_System_NoCtl[5] + state.H_Pump_NoCtl[5] - state.H_Pump_NoCtl[6]))
        ELSE IF (state.H_Pump_NoCtl[6] > state.H_System_NoCtl[6] && state.H_Pump_NoCtl[7] <= state.H_System_NoCtl[7]) THEN
         ((state.H_Pump_NoCtl[6] * state.H_System_NoCtl[7] - state.H_Pump_NoCtl[7] * state.H_System_NoCtl[6]) / (state.H_System_NoCtl[7] - state.H_System_NoCtl[6] + state.H_Pump_NoCtl[6] - state.H_Pump_NoCtl[7]))
          ELSE IF (state.H_Pump_NoCtl[7] > state.H_System_NoCtl[7] && state.H_Pump_NoCtl[8] <= state.H_System_NoCtl[8]) THEN
            ((state.H_Pump_NoCtl[7] * state.H_System_NoCtl[8] - state.H_Pump_NoCtl[8] * state.H_System_NoCtl[7]) / (state.H_System_NoCtl[8] - state.H_System_NoCtl[7] + state.H_Pump_NoCtl[7] - state.H_Pump_NoCtl[8]))
              ELSE IF (state.H_Pump_NoCtl[8] > state.H_System_NoCtl[8] && state.H_Pump_NoCtl[9] <= state.H_System_NoCtl[9]) THEN
                ((state.H_Pump_NoCtl[8] * state.H_System_NoCtl[9] - state.H_Pump_NoCtl[9] * state.H_System_NoCtl[8]) / (state.H_System_NoCtl[9] - state.H_System_NoCtl[8] + state.H_Pump_NoCtl[8] - state.H_Pump_NoCtl[9]))
                  ELSE IF (state.H_Pump_NoCtl[9] > state.H_System_NoCtl[9] && state.H_Pump_NoCtl[10] <= state.H_System_NoCtl[10]) THEN
                    ((state.H_Pump_NoCtl[9] * state.H_System_NoCtl[10] - state.H_Pump_NoCtl[10] * state.H_System_NoCtl[9]) / (state.H_System_NoCtl[10] - state.H_System_NoCtl[9] + state.H_Pump_NoCtl[9] - state.H_Pump_NoCtl[10]))
                      ELSE IF (state.H_Pump_NoCtl[10] > state.H_System_NoCtl[10] && state.H_Pump_NoCtl[11] <= state.H_System_NoCtl[11]) THEN
      ((state.H_Pump_NoCtl[10] * state.H_System_NoCtl[11] - state.H_Pump_NoCtl[11] * state.H_System_NoCtl[10]) / (state.H_System_NoCtl[11] - state.H_System_NoCtl[10] + state.H_Pump_NoCtl[10] - state.H_Pump_NoCtl[11]))
        ELSE IF (state.H_Pump_NoCtl[11] > state.H_System_NoCtl[11] && state.H_Pump_NoCtl[12] <= state.H_System_NoCtl[12]) THEN
          ((state.H_Pump_NoCtl[11] * state.H_System_NoCtl[12] - state.H_Pump_NoCtl[12] * state.H_System_NoCtl[11]) / (state.H_System_NoCtl[12] - state.H_System_NoCtl[11] + state.H_Pump_NoCtl[11] - state.H_Pump_NoCtl[12]))
            ELSE IF (state.H_Pump_NoCtl[12] > state.H_System_NoCtl[12] && state.H_Pump_NoCtl[13] <= state.H_System_NoCtl[13]) THEN
             ((state.H_Pump_NoCtl[12] * state.H_System_NoCtl[13] - state.H_Pump_NoCtl[13] * state.H_System_NoCtl[12]) / (state.H_System_NoCtl[13] - state.H_System_NoCtl[12] + state.H_Pump_NoCtl[12] - state.H_Pump_NoCtl[13]))
                ELSE IF (state.H_Pump_NoCtl[13] > state.H_System_NoCtl[13] && state.H_Pump_NoCtl[14] <= state.H_System_NoCtl[14]) THEN
              		((state.H_Pump_NoCtl[13] * state.H_System_NoCtl[14] - state.H_Pump_NoCtl[14] * state.H_System_NoCtl[13]) / (state.H_System_NoCtl[14] - state.H_System_NoCtl[13] + state.H_Pump_NoCtl[13] - state.H_Pump_NoCtl[14]))
                    ELSE IF (state.H_Pump_NoCtl[14] > state.H_System_NoCtl[14] && state.H_Pump_NoCtl[15] <= state.H_System_NoCtl[15]) THEN
      ((state.H_Pump_NoCtl[14] * state.H_System_NoCtl[15] - state.H_Pump_NoCtl[15] * state.H_System_NoCtl[14]) / (state.H_System_NoCtl[15] - state.H_System_NoCtl[14] + state.H_Pump_NoCtl[14] - state.H_Pump_NoCtl[15]))
       ELSE IF (state.H_Pump_NoCtl[15] > state.H_System_NoCtl[15] && state.H_Pump_NoCtl[16] <= state.H_System_NoCtl[16]) THEN
          ((state.H_Pump_NoCtl[15] * state.H_System_NoCtl[16] - state.H_Pump_NoCtl[16] * state.H_System_NoCtl[15]) / (state.H_System_NoCtl[16] - state.H_System_NoCtl[15] + state.H_Pump_NoCtl[15] - state.H_Pump_NoCtl[16]))
              ELSE IF (state.H_Pump_NoCtl[16] > state.H_System_NoCtl[16] && state.H_Pump_NoCtl[17] <= state.H_System_NoCtl[17]) THEN
                  ((state.H_Pump_NoCtl[16] * state.H_System_NoCtl[17] - state.H_Pump_NoCtl[17] * state.H_System_NoCtl[16]) / (state.H_System_NoCtl[17] - state.H_System_NoCtl[16] + state.H_Pump_NoCtl[16] - state.H_Pump_NoCtl[17]))
                    ELSE IF (state.H_Pump_NoCtl[17] > state.H_System_NoCtl[17] && state.H_Pump_NoCtl[18] <= state.H_System_NoCtl[18]) THEN
      ((state.H_Pump_NoCtl[17] * state.H_System_NoCtl[18] - state.H_Pump_NoCtl[18] * state.H_System_NoCtl[17]) / (state.H_System_NoCtl[18] - state.H_System_NoCtl[17] + state.H_Pump_NoCtl[17] - state.H_Pump_NoCtl[18]))
        ELSE IF (state.H_Pump_NoCtl[18] > state.H_System_NoCtl[18] && state.H_Pump_NoCtl[19] <= state.H_System_NoCtl[19]) THEN
          ((state.H_Pump_NoCtl[18] * state.H_System_NoCtl[19] - state.H_Pump_NoCtl[19] * state.H_System_NoCtl[18]) / (state.H_System_NoCtl[19] - state.H_System_NoCtl[18] + state.H_Pump_NoCtl[18] - state.H_Pump_NoCtl[19]))
              ELSE IF (state.H_Pump_NoCtl[19] > state.H_System_NoCtl[19] && state.H_Pump_NoCtl[20] <= state.H_System_NoCtl[20]) THEN
               ((state.H_Pump_NoCtl[19] * state.H_System_NoCtl[20] - state.H_Pump_NoCtl[20] * state.H_System_NoCtl[19]) / (state.H_System_NoCtl[20] - state.H_System_NoCtl[19] + state.H_Pump_NoCtl[19] - state.H_Pump_NoCtl[20]))
                  ELSE IF (state.H_Pump_NoCtl[20] > state.H_System_NoCtl[20] && state.H_Pump_NoCtl[21] <= state.H_System_NoCtl[21]) THEN
      ((state.H_Pump_NoCtl[20] * state.H_System_NoCtl[21] - state.H_Pump_NoCtl[21] * state.H_System_NoCtl[20]) / (state.H_System_NoCtl[21] - state.H_System_NoCtl[20] + state.H_Pump_NoCtl[20] - state.H_Pump_NoCtl[21]))
        ELSE state.H_Pump_NoCtl[1];  
    
    state.Q_NoCtl_Duty = IF (state.H_Pump_NoCtl[n] > state.H_System_NoCtl[n]) THEN 0.0
      ELSE MSLUGetInterpolated(ref(state.H_System_NoCtl[1]), ref(state.Q_NoCtl[1]), n, state.H_NoCtl_Duty) ;
    
     
    state.FluidVelocity = state.help_Q / (3.14 * pow(parameters.PipeDiameter, 2) / 4.0);  
    
    state.FluidViscosity = IF (state.FluidVelocity <= 0) THEN parameters.ViscosityWater
      ELSE IF (state.IsThick == 0) THEN parameters.ViscosityWater
        ELSE (1/86400) * state.help_Viscosity_k * pow((0.75 + 0.25/state.help_Viscosity_n), state.help_Viscosity_n) *
          pow((8.0 * state.FluidVelocity/86400 / parameters.PipeDiameter), state.help_Viscosity_n - 1) ;
    
    state.ReynoldsNr = IF (state.FluidVelocity <= 0.0) THEN 1E-20  
      ELSE IF (state.IsThick == 0) THEN parameters.Rho_Water/1000 * (state.FluidVelocity/86400) * parameters.PipeDiameter / (state.FluidViscosity)  
        ELSE state.Rho_Fluid/1000 * (state.FluidVelocity/86400) * parameters.PipeDiameter / state.FluidViscosity ;  
    
    state.Friction = IF (state.IsThick == 0) THEN 0.25 * pow(log10(parameters.Epsilon/(3.7 * parameters.PipeDiameter) + 5.74/pow(state.ReynoldsNr, 0.9)), -2)  
      ELSE IF (state.ReynoldsNr <= 2400.0) THEN 4 * 16 / state.ReynoldsNr
        ELSE 4 * 0.0792 * pow(state.help_Viscosity_n, 0.675) * pow(state.ReynoldsNr, -0.25);  
    
    state.Friction_Pipe = state.Friction * pow(state.FluidVelocity/86400, 2) * parameters.PipeLength / parameters.PipeDiameter / 2 / 9.81 ; 
    
    state.Friction_MinorLosses = state.Friction_Pipe * parameters.PipeLength_Equiv / parameters.PipeLength ;
    
    state.H_System = state.Friction_Pipe + state.Friction_MinorLosses + parameters.Friction_InLine + interface.Elevation + interface.HeadLoss_Ext ;
    
     
    state.H_Pump = state.PumpCurveCoeff_A - state.PumpCurveCoeff_B * pow(state.help_Q, state.PumpCurveCoeff_C) ;
    
     
    state.help_Eta_Pump = - (parameters.Eta_Pump_Max - parameters.Eta_Pump_Min) / pow(parameters.Q_BEP, 2) * pow(state.help_Q/state.help_N, 2) +
      2 * (parameters.Eta_Pump_Max - parameters.Eta_Pump_Min) / parameters.Q_BEP * (state.help_Q/state.help_N) + parameters.Eta_Pump_Min ;  
    
    state.Eta_Pump = IF (state.help_Eta_Pump >= parameters.Eta_Pump_Min) THEN state.help_Eta_Pump ELSE parameters.Eta_Pump_Min ;  
    
     
     
     
 
 
  };

:};


 
CLASS Base_Pump_VFD "A base model for VFD-controlled centrifugal pumps" EXTENDS Base_Generic_Q WITH
{:

  interface <-
  {
     
 
    OBJ N (* terminal = "out_2" *) "Relative pump speed: actual pump speed / nominal pump speed" : Fraction := {: causality <- "COUT" ; group <- "Operational" :};
  };
  
  parameters <-
  {
     
    OBJ Eta_VFD_Max "Efficiency of the VFD at full speed (N = 1)" : Fraction := {: value <- 0.95 ; group <- "Efficiency":};
    OBJ Eta_VFD_Half "Efficiency of the VFD at half speed (N = 0.5)" : Fraction := {: value <- 0.89 ; group <- "Efficiency":};
     
    OBJ N_min "Minimum relative pump speed for VFD controlled pumps" : Fraction := {: value <- 0.60 ; group <- "Efficiency":};
    OBJ N_max "Maximum relative pump speed for VFD controlled pumps" : Fraction := {: value <- 1.0 ; group <- "Efficiency":};
  };
  
  state <-
  {
    OBJ Eta_VFD "Efficiency of the VFD" : Fraction := {: group <- "Energy" :};
  };
  
  equations <-
  {
     
    state.Eta_Pump = IF (interface.N <= 0.0) THEN 1.0
      ELSE - (parameters.Eta_Pump_Max - parameters.Eta_Pump_Min) / pow(parameters.Q_BEP, 2) * pow(state.help_Q/interface.N, 2) +
      2 * (parameters.Eta_Pump_Max - parameters.Eta_Pump_Min) / parameters.Q_BEP * (state.help_Q/interface.N) + parameters.Eta_Pump_Min ;  

    state.Eta_VFD = IF (interface.N <= 0.0) THEN 1.0
      ELSE (parameters.Eta_VFD_Max - parameters.Eta_VFD_Half) * (pow(interface.N, 4) - pow(0.5, 4)) / (pow(1.0, 4) - pow(0.5, 4)) + parameters.Eta_VFD_Half ;

    state.Eta_Total = state.Eta_Pump * parameters.Eta_motor * state.Eta_VFD ;  
  };

:};


 
CLASS Base_Generic_Q EXTENDS Pump_Characteristics WITH
{:

  parameters <-
  {
     
    OBJ Q_BEP "Flow rate at Best Efficiency Point" : FlowRate := {: value <- 1000 ; group <- "Efficiency":};
  };
  
  state <-
  {
     
    OBJ Q_NoCtl (* hidden = "1" *) "Dummy vector containing n different flow rate values" : FlowRate[n;] := {: group <- "_ Q no ctl" :};
  };
  
  initial <-
  {    
     
     
    { FOREACH i IN {1 .. n}: state.Q_NoCtl[i] := state.help_Q_3 / (n - 1) * (i - 1) ; };
  };

:};


CLASS Pump_Characteristics "some generic pump characteristics shared by different pump models"
EXTENDS Pump_Base WITH
{:

  interface <-
  {
     
    OBJ SpecificEnergy (* terminal = "out_2" *) "Specific energy consumption since start of simulation" : EnergyForPumping := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ PumpedVolume (* terminal = "out_2"; hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "COUT" ; group <- "Energy" :};
     
    OBJ PumpingEnergy_Ave (* terminal = "out_2" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "COUT" ; group <- "Energy" :};
  };
  
  parameters <- 
  {
     
    OBJ H_1 "Shutoff head (if unknown: -1 for automatic estimation based on H_2)" : Real := {: unit <- "m" ; interval  <- {: lowerBound <- - 1.0 :}; value <- -1.0 ; group <- "Pump curve":};
    OBJ Q_2 "Design flow rate" : FlowRate := {: value <- 10.0 ; group <- "Pump curve":};
    OBJ H_2 "Design head" : Length := {: value <- 10.0 ; group <- "Pump curve":};
    OBJ Q_3 "Some point (flow rate) on the pump curve (if unknown: -1.0 for automatic estimation based on Q_2)" : Real := {: unit <- "m3/d" ; interval  <- {: lowerBound <- - 1.0 :}; value <- -1.0 ; group <- "Pump curve":};
    OBJ H_3 "Some point (head) on the pump curve (if unknown: -1 for automatic estimation)" : Real := {: unit <- "m" ; interval  <- {: lowerBound <- - 1.0 :}; value <- -1.0 ; group <- "Pump curve":};

     
    OBJ Eta_motor "Efficiency of the motor" : Fraction := {: value <- 0.9 ; group <- "Efficiency":};
    OBJ Eta_Pump_Max "Maximum efficiency of the pump (at Q_BEP)" : Fraction := {: value <- 0.9 ; group <- "Efficiency":};
    OBJ Eta_Pump_Min "Minimum efficiency of the pump" : Fraction := {: value <- 0.0 ; group <- "Efficiency":};
  };
  
  state <-
  {
    OBJ PumpCurveCoeff_A (* hidden = "1" *) "Coefficient of the power-law to represent the pump curve" : Real := {: group <- "Operational" :};
    OBJ PumpCurveCoeff_B (* hidden = "1" *) "Coefficient of the power-law to represent the pump curve" : Real := {: group <- "Operational" :};
    OBJ PumpCurveCoeff_C (* hidden = "1" *) "Coefficient of the power-law to represent the pump curve" : Real := {: group <- "Operational" :};
    OBJ help_H_1 (* hidden = "1" *) "Shutoff head" : Length := {: group <- "Operational" :};
    OBJ help_Q_3 (* hidden = "1" *) "Some point (flow rate) on the pump curve" : FlowRate := {: group <- "Operational" :};
    OBJ help_H_3 (* hidden = "1" *) "Some point (head) on the pump curve" : Length := {: group <- "Operational" :};

    OBJ Eta_Pump "Efficiency of the pump" : Fraction := {: group <- "Energy" :};

     
    OBJ help_PumpedVolume (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume ;  
    OBJ help_EnergyConsumption (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy ;
  };
  
  initial <-
  {
     
    state.help_PumpedVolume := 0.0 ;
    state.help_EnergyConsumption := 0.0 ;
    
     
    state.help_H_1 := IF (parameters.H_1 <= -0.5) THEN 1.33 * parameters.H_2 ELSE parameters.H_1 ;
    state.help_Q_3 := IF (parameters.Q_3 <= -0.5) THEN 2.0 * parameters.Q_2 ELSE parameters.Q_3 ;
    state.help_H_3 := IF (parameters.H_3 <= -0.5) THEN 0.0 ELSE parameters.H_3 ;
    
     
    state.PumpCurveCoeff_A := IF (parameters.H_2 <= 0.0 || parameters.Q_2 <= 0.0) THEN 0.0 ELSE state.help_H_1 ;
    state.PumpCurveCoeff_B := IF (parameters.H_2 <= 0.0 || parameters.Q_2 <= 0.0) THEN 0.0
      ELSE (state.help_H_1 - state.help_H_3) * exp((log(state.help_Q_3) * log((state.help_H_1 - state.help_H_3)/(state.help_H_1 - parameters.H_2))) / (log(parameters.Q_2 / state.help_Q_3)));
    state.PumpCurveCoeff_C := IF (parameters.H_2 <= 0.0 || parameters.Q_2 <= 0.0) THEN 1.0
      ELSE - log((state.help_H_1 - state.help_H_3)/(state.help_H_1 - parameters.H_2)) / log(parameters.Q_2/state.help_Q_3);
     
  };
  
  equations <-
  {
     
    DERIV(state.help_PumpedVolume,[independent.t]) = state.help_Q ;
    
     
    DERIV(state.help_EnergyConsumption,[independent.t]) = interface.PowerConsumption * 24.0 / 1000 ;
    interface.SpecificEnergy = IF (state.help_PumpedVolume > 0.0) THEN state.help_EnergyConsumption / state.help_PumpedVolume ELSE 0.0 ;
    interface.PumpingEnergy = state.help_EnergyConsumption ;
    interface.PumpedVolume = state.help_PumpedVolume ;
     
  	interface.PumpingEnergy_Ave = IF (state.help_PumpedVolume > 0.0) THEN state.help_EnergyConsumption / state.help_PumpedVolume ELSE 0.0 ;
  };
    
:};


 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.centrifugal.q.throttling.msl" 1
 




















CLASS Centrifugal_Q_Throttling (* icon = "pump" *)
"A model to calculate a throttling valve controlled centrifugal pump's power consumption based on the flow rate Q"
EXTENDS Generic_Q WITH
{:
  comments <- "A model to calculate a throttling valve controlled centrifugal pump's power consumption based on the flow rate Q";
  
  equations <-
  {
    state.Q_Max = state.Q_NoCtl_Duty ;
    state.Q_Min = 0.0 ;
    
     
    state.help_Q = IF (interface.IsOn == 0) THEN 0.0
      ELSE IF (interface.Q_Op > state.Q_Max) THEN state.Q_Max
        ELSE interface.Q_Op ;
    
    state.H = IF (interface.IsOn == 0) THEN 0.0
      ELSE IF (interface.Q_Op > state.Q_Max) THEN state.H_NoCtl_Duty
        ELSE state.H_Pump ;
    
     
    state.help_N = 1.0 ;
    
    state.Eta_Total = state.Eta_Pump * parameters.Eta_motor ;
  };

:};



# 374 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.generic.q.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.centrifugal.q.vfd.msl" 1
 




















CLASS Centrifugal_Q_VFD (* icon = "pump"; is_default = "true" *)
"A model to calculate a centrifugal VFD-controlled pump's power consumption based on the flow rate Q"
EXTENDS Generic_Q WITH
{:
  comments <- "A model to calculate a centrifugal VFD-controlled pump's power consumption based on the flow rate Q";

  interface <-
  {
    OBJ N (* terminal = "out_2" *) "Relative pump speed: actual pump speed / nominal pump speed" : Fraction := {: causality <- "COUT" ; group <- "Operational" :};
  };

  parameters <- 
  {
     
    OBJ Eta_VFD_Max "Efficiency of the VFD at full speed (N = 1)" : Fraction := {: value <- 0.95 ; group <- "Efficiency":};
    OBJ Eta_VFD_Half "Efficiency of the VFD at half speed (N = 0.5)" : Fraction := {: value <- 0.89 ; group <- "Efficiency":};
    OBJ N_min "Minimum relative pump speed for VFD controlled pumps" : Fraction := {: value <- 0.60 ; group <- "Efficiency":};
    OBJ N_max "Maximum relative pump speed for VFD controlled pumps" : Fraction := {: value <- 1.0 ; group <- "Efficiency":};
  };

  state <-
  {
     
    OBJ Q_MinVFD_Duty "Minimum flow rate for VFD pumps operating at N=Nmin" : FlowRate := {: group <- "Operational" :};
    OBJ Q_MaxVFD_Duty "Maximum flow rate for VFD pumps operating at N=Nmax" : FlowRate := {: group <- "Operational" :};
    OBJ H_MinVFD_Duty "Operating head corresponding to Q_MinVFD_Duty for the given pump and system" : Length := {: group <- "Operational" :};
    OBJ H_MaxVFD_Duty "Operating head corresponding to Q_MaxVFD_Duty for the given pump and system" : Length := {: group <- "Operational" :};

    OBJ H_PumpCurve_MinVFD (* hidden = "1" *) "Dummy vector discretizing the pump curve for N=Nmin, containing the heads for n different flow rate values" : Length[n;] := {: group <- "Operational" :};
    OBJ H_PumpCurve_MaxVFD (* hidden = "1" *) "Dummy vector discretizing the pump curve for N=Nmax, containing the heads for n different flow rate values" : Length[n;] := {: group <- "Operational" :};
    OBJ Nvector (* hidden = "1" *) "Dummy vector containing n different RelativePumpSpeed values" : Fraction[n;] := {: group <- "Operational" :};
    OBJ Hvector (* hidden = "1" *) "Dummy vector containing the heads for n different RelativePumpSpeed values" : Length[n;] := {: group <- "Operational" :};
    OBJ Eta_VFD "Efficiency of the VFD" : Fraction := {: group <- "Energy" :};
     
    OBJ Dummy1 (* hidden = "1" *) "Dummy var 1" : Real ;
    OBJ Dummy2 (* hidden = "1" *) "Dummy var 2" : Real ;
  };

  initial <-
  {
     
     
    { FOREACH i IN {1 .. n}: state.Nvector[i] =
      parameters.N_min + (parameters.N_max - parameters.N_min) * (i - 1) / (n - 1) ; };  
    
     
    { FOREACH i IN {1 .. n}: state.H_PumpCurve_MinVFD[i] = IF (parameters.N_min <= 0.0) THEN 0.0
      ELSE state.PumpCurveCoeff_A * pow(parameters.N_min,2) - state.PumpCurveCoeff_B * pow(parameters.N_min,(2 - state.PumpCurveCoeff_C)) * pow(state.Q_NoCtl[i], state.PumpCurveCoeff_C) ; };
       
    
    { FOREACH i IN {1 .. n}: state.H_PumpCurve_MaxVFD[i] = IF (state.Q_NoCtl[i] <= 0.0) THEN state.PumpCurveCoeff_A * pow(parameters.N_max,2)
      ELSE state.PumpCurveCoeff_A * pow(parameters.N_max,2) - state.PumpCurveCoeff_B * pow(parameters.N_max,(2 - state.PumpCurveCoeff_C)) * pow(state.Q_NoCtl[i], state.PumpCurveCoeff_C) ; };
       
  };

  equations <-
  {
     
    state.H_MinVFD_Duty = IF (state.H_PumpCurve_MinVFD[1] > state.H_System_NoCtl[1] && state.H_PumpCurve_MinVFD[2] <= state.H_System_NoCtl[2]) THEN ((state.H_PumpCurve_MinVFD[1] * state.H_System_NoCtl[2] - state.H_PumpCurve_MinVFD[2] * state.H_System_NoCtl[1]) / (state.H_System_NoCtl[2] - state.H_System_NoCtl[1] + state.H_PumpCurve_MinVFD[1] - state.H_PumpCurve_MinVFD[2])) ELSE  
      IF (state.H_PumpCurve_MinVFD[2] > state.H_System_NoCtl[2] && state.H_PumpCurve_MinVFD[3] <= state.H_System_NoCtl[3]) THEN ((state.H_PumpCurve_MinVFD[2] * state.H_System_NoCtl[3] - state.H_PumpCurve_MinVFD[3] * state.H_System_NoCtl[2]) / (state.H_System_NoCtl[3] - state.H_System_NoCtl[2] + state.H_PumpCurve_MinVFD[2] - state.H_PumpCurve_MinVFD[3])) ELSE  
        IF (state.H_PumpCurve_MinVFD[3] > state.H_System_NoCtl[3] && state.H_PumpCurve_MinVFD[4] <= state.H_System_NoCtl[4]) THEN ((state.H_PumpCurve_MinVFD[3] * state.H_System_NoCtl[4] - state.H_PumpCurve_MinVFD[4] * state.H_System_NoCtl[3]) / (state.H_System_NoCtl[4] - state.H_System_NoCtl[3] + state.H_PumpCurve_MinVFD[3] - state.H_PumpCurve_MinVFD[4])) ELSE  
          IF (state.H_PumpCurve_MinVFD[4] > state.H_System_NoCtl[4] && state.H_PumpCurve_MinVFD[5] <= state.H_System_NoCtl[5]) THEN ((state.H_PumpCurve_MinVFD[4] * state.H_System_NoCtl[5] - state.H_PumpCurve_MinVFD[5] * state.H_System_NoCtl[4]) / (state.H_System_NoCtl[5] - state.H_System_NoCtl[4] + state.H_PumpCurve_MinVFD[4] - state.H_PumpCurve_MinVFD[5])) ELSE  
            IF (state.H_PumpCurve_MinVFD[5] > state.H_System_NoCtl[5] && state.H_PumpCurve_MinVFD[6] <= state.H_System_NoCtl[6]) THEN ((state.H_PumpCurve_MinVFD[5] * state.H_System_NoCtl[6] - state.H_PumpCurve_MinVFD[6] * state.H_System_NoCtl[5]) / (state.H_System_NoCtl[6] - state.H_System_NoCtl[5] + state.H_PumpCurve_MinVFD[5] - state.H_PumpCurve_MinVFD[6])) ELSE  
              IF (state.H_PumpCurve_MinVFD[6] > state.H_System_NoCtl[6] && state.H_PumpCurve_MinVFD[7] <= state.H_System_NoCtl[7]) THEN ((state.H_PumpCurve_MinVFD[6] * state.H_System_NoCtl[7] - state.H_PumpCurve_MinVFD[7] * state.H_System_NoCtl[6]) / (state.H_System_NoCtl[7] - state.H_System_NoCtl[6] + state.H_PumpCurve_MinVFD[6] - state.H_PumpCurve_MinVFD[7])) ELSE  
                IF (state.H_PumpCurve_MinVFD[7] > state.H_System_NoCtl[7] && state.H_PumpCurve_MinVFD[8] <= state.H_System_NoCtl[8]) THEN ((state.H_PumpCurve_MinVFD[7] * state.H_System_NoCtl[8] - state.H_PumpCurve_MinVFD[8] * state.H_System_NoCtl[7]) / (state.H_System_NoCtl[8] - state.H_System_NoCtl[7] + state.H_PumpCurve_MinVFD[7] - state.H_PumpCurve_MinVFD[8])) ELSE  
                  IF (state.H_PumpCurve_MinVFD[8] > state.H_System_NoCtl[8] && state.H_PumpCurve_MinVFD[9] <= state.H_System_NoCtl[9]) THEN ((state.H_PumpCurve_MinVFD[8] * state.H_System_NoCtl[9] - state.H_PumpCurve_MinVFD[9] * state.H_System_NoCtl[8]) / (state.H_System_NoCtl[9] - state.H_System_NoCtl[8] + state.H_PumpCurve_MinVFD[8] - state.H_PumpCurve_MinVFD[9])) ELSE  
      IF (state.H_PumpCurve_MinVFD[9] > state.H_System_NoCtl[9] && state.H_PumpCurve_MinVFD[10] <= state.H_System_NoCtl[10]) THEN ((state.H_PumpCurve_MinVFD[9] * state.H_System_NoCtl[10] - state.H_PumpCurve_MinVFD[10] * state.H_System_NoCtl[9]) / (state.H_System_NoCtl[10] - state.H_System_NoCtl[9] + state.H_PumpCurve_MinVFD[9] - state.H_PumpCurve_MinVFD[10])) ELSE  
        IF (state.H_PumpCurve_MinVFD[10] > state.H_System_NoCtl[10] && state.H_PumpCurve_MinVFD[11] <= state.H_System_NoCtl[11]) THEN ((state.H_PumpCurve_MinVFD[10] * state.H_System_NoCtl[11] - state.H_PumpCurve_MinVFD[11] * state.H_System_NoCtl[10]) / (state.H_System_NoCtl[11] - state.H_System_NoCtl[10] + state.H_PumpCurve_MinVFD[10] - state.H_PumpCurve_MinVFD[11])) ELSE  
          IF (state.H_PumpCurve_MinVFD[11] > state.H_System_NoCtl[11] && state.H_PumpCurve_MinVFD[12] <= state.H_System_NoCtl[12]) THEN ((state.H_PumpCurve_MinVFD[11] * state.H_System_NoCtl[12] - state.H_PumpCurve_MinVFD[12] * state.H_System_NoCtl[11]) / (state.H_System_NoCtl[12] - state.H_System_NoCtl[11] + state.H_PumpCurve_MinVFD[11] - state.H_PumpCurve_MinVFD[12])) ELSE  
            IF (state.H_PumpCurve_MinVFD[12] > state.H_System_NoCtl[12] && state.H_PumpCurve_MinVFD[13] <= state.H_System_NoCtl[13]) THEN ((state.H_PumpCurve_MinVFD[12] * state.H_System_NoCtl[13] - state.H_PumpCurve_MinVFD[13] * state.H_System_NoCtl[12]) / (state.H_System_NoCtl[13] - state.H_System_NoCtl[12] + state.H_PumpCurve_MinVFD[12] - state.H_PumpCurve_MinVFD[13])) ELSE  
              IF (state.H_PumpCurve_MinVFD[13] > state.H_System_NoCtl[13] && state.H_PumpCurve_MinVFD[14] <= state.H_System_NoCtl[14]) THEN ((state.H_PumpCurve_MinVFD[13] * state.H_System_NoCtl[14] - state.H_PumpCurve_MinVFD[14] * state.H_System_NoCtl[13]) / (state.H_System_NoCtl[14] - state.H_System_NoCtl[13] + state.H_PumpCurve_MinVFD[13] - state.H_PumpCurve_MinVFD[14])) ELSE  
                IF (state.H_PumpCurve_MinVFD[14] > state.H_System_NoCtl[14] && state.H_PumpCurve_MinVFD[15] <= state.H_System_NoCtl[15]) THEN ((state.H_PumpCurve_MinVFD[14] * state.H_System_NoCtl[15] - state.H_PumpCurve_MinVFD[15] * state.H_System_NoCtl[14]) / (state.H_System_NoCtl[15] - state.H_System_NoCtl[14] + state.H_PumpCurve_MinVFD[14] - state.H_PumpCurve_MinVFD[15])) ELSE  
                  IF (state.H_PumpCurve_MinVFD[15] > state.H_System_NoCtl[15] && state.H_PumpCurve_MinVFD[16] <= state.H_System_NoCtl[16]) THEN ((state.H_PumpCurve_MinVFD[15] * state.H_System_NoCtl[16] - state.H_PumpCurve_MinVFD[16] * state.H_System_NoCtl[15]) / (state.H_System_NoCtl[16] - state.H_System_NoCtl[15] + state.H_PumpCurve_MinVFD[15] - state.H_PumpCurve_MinVFD[16])) ELSE  
                    IF (state.H_PumpCurve_MinVFD[16] > state.H_System_NoCtl[16] && state.H_PumpCurve_MinVFD[17] <= state.H_System_NoCtl[17]) THEN ((state.H_PumpCurve_MinVFD[16] * state.H_System_NoCtl[17] - state.H_PumpCurve_MinVFD[17] * state.H_System_NoCtl[16]) / (state.H_System_NoCtl[17] - state.H_System_NoCtl[16] + state.H_PumpCurve_MinVFD[16] - state.H_PumpCurve_MinVFD[17])) ELSE  
      IF (state.H_PumpCurve_MinVFD[17] > state.H_System_NoCtl[17] && state.H_PumpCurve_MinVFD[18] <= state.H_System_NoCtl[18]) THEN ((state.H_PumpCurve_MinVFD[17] * state.H_System_NoCtl[18] - state.H_PumpCurve_MinVFD[18] * state.H_System_NoCtl[17]) / (state.H_System_NoCtl[18] - state.H_System_NoCtl[17] + state.H_PumpCurve_MinVFD[17] - state.H_PumpCurve_MinVFD[18])) ELSE  
        IF (state.H_PumpCurve_MinVFD[18] > state.H_System_NoCtl[18] && state.H_PumpCurve_MinVFD[19] <= state.H_System_NoCtl[19]) THEN ((state.H_PumpCurve_MinVFD[18] * state.H_System_NoCtl[19] - state.H_PumpCurve_MinVFD[19] * state.H_System_NoCtl[18]) / (state.H_System_NoCtl[19] - state.H_System_NoCtl[18] + state.H_PumpCurve_MinVFD[18] - state.H_PumpCurve_MinVFD[19])) ELSE  
          IF (state.H_PumpCurve_MinVFD[19] > state.H_System_NoCtl[19] && state.H_PumpCurve_MinVFD[20] <= state.H_System_NoCtl[20]) THEN ((state.H_PumpCurve_MinVFD[19] * state.H_System_NoCtl[20] - state.H_PumpCurve_MinVFD[20] * state.H_System_NoCtl[19]) / (state.H_System_NoCtl[20] - state.H_System_NoCtl[19] + state.H_PumpCurve_MinVFD[19] - state.H_PumpCurve_MinVFD[20])) ELSE  
            IF (state.H_PumpCurve_MinVFD[20] > state.H_System_NoCtl[20] && state.H_PumpCurve_MinVFD[21] <= state.H_System_NoCtl[21]) THEN ((state.H_PumpCurve_MinVFD[20] * state.H_System_NoCtl[21] - state.H_PumpCurve_MinVFD[21] * state.H_System_NoCtl[20]) / (state.H_System_NoCtl[21] - state.H_System_NoCtl[20] + state.H_PumpCurve_MinVFD[20] - state.H_PumpCurve_MinVFD[21])) ELSE  
              state.H_System_NoCtl[1];  
    
    state.Q_MinVFD_Duty = IF (state.H_PumpCurve_MinVFD[n] <= state.H_System_NoCtl[n]) THEN 0.0  
      ELSE MSLUGetInterpolated(ref(state.H_PumpCurve_MinVFD[1]), ref(state.Q_NoCtl[1]), n, state.H_MinVFD_Duty);
    
    state.H_MaxVFD_Duty = IF (parameters.N_max == 1.0) THEN state.H_NoCtl_Duty ELSE
      IF (state.H_PumpCurve_MaxVFD[1] > state.H_System_NoCtl[1] && state.H_PumpCurve_MaxVFD[2] <= state.H_System_NoCtl[2]) THEN ((state.H_PumpCurve_MaxVFD[1] * state.H_System_NoCtl[2] - state.H_PumpCurve_MaxVFD[2] * state.H_System_NoCtl[1]) / (state.H_System_NoCtl[2] - state.H_System_NoCtl[1] + state.H_PumpCurve_MaxVFD[1] - state.H_PumpCurve_MaxVFD[2])) ELSE
        IF (state.H_PumpCurve_MaxVFD[2] > state.H_System_NoCtl[2] && state.H_PumpCurve_MaxVFD[3] <= state.H_System_NoCtl[3]) THEN ((state.H_PumpCurve_MaxVFD[2] * state.H_System_NoCtl[3] - state.H_PumpCurve_MaxVFD[3] * state.H_System_NoCtl[2]) / (state.H_System_NoCtl[3] - state.H_System_NoCtl[2] + state.H_PumpCurve_MaxVFD[2] - state.H_PumpCurve_MaxVFD[3])) ELSE  
          IF (state.H_PumpCurve_MaxVFD[3] > state.H_System_NoCtl[3] && state.H_PumpCurve_MaxVFD[4] <= state.H_System_NoCtl[4]) THEN ((state.H_PumpCurve_MaxVFD[3] * state.H_System_NoCtl[4] - state.H_PumpCurve_MaxVFD[4] * state.H_System_NoCtl[3]) / (state.H_System_NoCtl[4] - state.H_System_NoCtl[3] + state.H_PumpCurve_MaxVFD[3] - state.H_PumpCurve_MaxVFD[4])) ELSE  
            IF (state.H_PumpCurve_MaxVFD[4] > state.H_System_NoCtl[4] && state.H_PumpCurve_MaxVFD[5] <= state.H_System_NoCtl[5]) THEN ((state.H_PumpCurve_MaxVFD[4] * state.H_System_NoCtl[5] - state.H_PumpCurve_MaxVFD[5] * state.H_System_NoCtl[4]) / (state.H_System_NoCtl[5] - state.H_System_NoCtl[4] + state.H_PumpCurve_MaxVFD[4] - state.H_PumpCurve_MaxVFD[5])) ELSE  
              IF (state.H_PumpCurve_MaxVFD[5] > state.H_System_NoCtl[5] && state.H_PumpCurve_MaxVFD[6] <= state.H_System_NoCtl[6]) THEN ((state.H_PumpCurve_MaxVFD[5] * state.H_System_NoCtl[6] - state.H_PumpCurve_MaxVFD[6] * state.H_System_NoCtl[5]) / (state.H_System_NoCtl[6] - state.H_System_NoCtl[5] + state.H_PumpCurve_MaxVFD[5] - state.H_PumpCurve_MaxVFD[6])) ELSE  
                IF (state.H_PumpCurve_MaxVFD[6] > state.H_System_NoCtl[6] && state.H_PumpCurve_MaxVFD[7] <= state.H_System_NoCtl[7]) THEN ((state.H_PumpCurve_MaxVFD[6] * state.H_System_NoCtl[7] - state.H_PumpCurve_MaxVFD[7] * state.H_System_NoCtl[6]) / (state.H_System_NoCtl[7] - state.H_System_NoCtl[6] + state.H_PumpCurve_MaxVFD[6] - state.H_PumpCurve_MaxVFD[7])) ELSE  
                  IF (state.H_PumpCurve_MaxVFD[7] > state.H_System_NoCtl[7] && state.H_PumpCurve_MaxVFD[8] <= state.H_System_NoCtl[8]) THEN ((state.H_PumpCurve_MaxVFD[7] * state.H_System_NoCtl[8] - state.H_PumpCurve_MaxVFD[8] * state.H_System_NoCtl[7]) / (state.H_System_NoCtl[8] - state.H_System_NoCtl[7] + state.H_PumpCurve_MaxVFD[7] - state.H_PumpCurve_MaxVFD[8])) ELSE  
                    IF (state.H_PumpCurve_MaxVFD[8] > state.H_System_NoCtl[8] && state.H_PumpCurve_MaxVFD[9] <= state.H_System_NoCtl[9]) THEN ((state.H_PumpCurve_MaxVFD[8] * state.H_System_NoCtl[9] - state.H_PumpCurve_MaxVFD[9] * state.H_System_NoCtl[8]) / (state.H_System_NoCtl[9] - state.H_System_NoCtl[8] + state.H_PumpCurve_MaxVFD[8] - state.H_PumpCurve_MaxVFD[9])) ELSE  
      IF (state.H_PumpCurve_MaxVFD[9] > state.H_System_NoCtl[9] && state.H_PumpCurve_MaxVFD[10] <= state.H_System_NoCtl[10]) THEN ((state.H_PumpCurve_MaxVFD[9] * state.H_System_NoCtl[10] - state.H_PumpCurve_MaxVFD[10] * state.H_System_NoCtl[9]) / (state.H_System_NoCtl[10] - state.H_System_NoCtl[9] + state.H_PumpCurve_MaxVFD[9] - state.H_PumpCurve_MaxVFD[10])) ELSE  
        IF (state.H_PumpCurve_MaxVFD[10] > state.H_System_NoCtl[10] && state.H_PumpCurve_MaxVFD[11] <= state.H_System_NoCtl[11]) THEN ((state.H_PumpCurve_MaxVFD[10] * state.H_System_NoCtl[11] - state.H_PumpCurve_MaxVFD[11] * state.H_System_NoCtl[10]) / (state.H_System_NoCtl[11] - state.H_System_NoCtl[10] + state.H_PumpCurve_MaxVFD[10] - state.H_PumpCurve_MaxVFD[11])) ELSE  
          IF (state.H_PumpCurve_MaxVFD[11] > state.H_System_NoCtl[11] && state.H_PumpCurve_MaxVFD[12] <= state.H_System_NoCtl[12]) THEN ((state.H_PumpCurve_MaxVFD[11] * state.H_System_NoCtl[12] - state.H_PumpCurve_MaxVFD[12] * state.H_System_NoCtl[11]) / (state.H_System_NoCtl[12] - state.H_System_NoCtl[11] + state.H_PumpCurve_MaxVFD[11] - state.H_PumpCurve_MaxVFD[12])) ELSE  
            IF (state.H_PumpCurve_MaxVFD[12] > state.H_System_NoCtl[12] && state.H_PumpCurve_MaxVFD[13] <= state.H_System_NoCtl[13]) THEN ((state.H_PumpCurve_MaxVFD[12] * state.H_System_NoCtl[13] - state.H_PumpCurve_MaxVFD[13] * state.H_System_NoCtl[12]) / (state.H_System_NoCtl[13] - state.H_System_NoCtl[12] + state.H_PumpCurve_MaxVFD[12] - state.H_PumpCurve_MaxVFD[13])) ELSE  
              IF (state.H_PumpCurve_MaxVFD[13] > state.H_System_NoCtl[13] && state.H_PumpCurve_MaxVFD[14] <= state.H_System_NoCtl[14]) THEN ((state.H_PumpCurve_MaxVFD[13] * state.H_System_NoCtl[14] - state.H_PumpCurve_MaxVFD[14] * state.H_System_NoCtl[13]) / (state.H_System_NoCtl[14] - state.H_System_NoCtl[13] + state.H_PumpCurve_MaxVFD[13] - state.H_PumpCurve_MaxVFD[14])) ELSE  
                IF (state.H_PumpCurve_MaxVFD[14] > state.H_System_NoCtl[14] && state.H_PumpCurve_MaxVFD[15] <= state.H_System_NoCtl[15]) THEN ((state.H_PumpCurve_MaxVFD[14] * state.H_System_NoCtl[15] - state.H_PumpCurve_MaxVFD[15] * state.H_System_NoCtl[14]) / (state.H_System_NoCtl[15] - state.H_System_NoCtl[14] + state.H_PumpCurve_MaxVFD[14] - state.H_PumpCurve_MaxVFD[15])) ELSE  
                  IF (state.H_PumpCurve_MaxVFD[15] > state.H_System_NoCtl[15] && state.H_PumpCurve_MaxVFD[16] <= state.H_System_NoCtl[16]) THEN ((state.H_PumpCurve_MaxVFD[15] * state.H_System_NoCtl[16] - state.H_PumpCurve_MaxVFD[16] * state.H_System_NoCtl[15]) / (state.H_System_NoCtl[16] - state.H_System_NoCtl[15] + state.H_PumpCurve_MaxVFD[15] - state.H_PumpCurve_MaxVFD[16])) ELSE  
                    IF (state.H_PumpCurve_MaxVFD[16] > state.H_System_NoCtl[16] && state.H_PumpCurve_MaxVFD[17] <= state.H_System_NoCtl[17]) THEN ((state.H_PumpCurve_MaxVFD[16] * state.H_System_NoCtl[17] - state.H_PumpCurve_MaxVFD[17] * state.H_System_NoCtl[16]) / (state.H_System_NoCtl[17] - state.H_System_NoCtl[16] + state.H_PumpCurve_MaxVFD[16] - state.H_PumpCurve_MaxVFD[17])) ELSE  
      IF (state.H_PumpCurve_MaxVFD[17] > state.H_System_NoCtl[17] && state.H_PumpCurve_MaxVFD[18] <= state.H_System_NoCtl[18]) THEN ((state.H_PumpCurve_MaxVFD[17] * state.H_System_NoCtl[18] - state.H_PumpCurve_MaxVFD[18] * state.H_System_NoCtl[17]) / (state.H_System_NoCtl[18] - state.H_System_NoCtl[17] + state.H_PumpCurve_MaxVFD[17] - state.H_PumpCurve_MaxVFD[18])) ELSE  
        IF (state.H_PumpCurve_MaxVFD[18] > state.H_System_NoCtl[18] && state.H_PumpCurve_MaxVFD[19] <= state.H_System_NoCtl[19]) THEN ((state.H_PumpCurve_MaxVFD[18] * state.H_System_NoCtl[19] - state.H_PumpCurve_MaxVFD[19] * state.H_System_NoCtl[18]) / (state.H_System_NoCtl[19] - state.H_System_NoCtl[18] + state.H_PumpCurve_MaxVFD[18] - state.H_PumpCurve_MaxVFD[19])) ELSE  
          IF (state.H_PumpCurve_MaxVFD[19] > state.H_System_NoCtl[19] && state.H_PumpCurve_MaxVFD[20] <= state.H_System_NoCtl[20]) THEN ((state.H_PumpCurve_MaxVFD[19] * state.H_System_NoCtl[20] - state.H_PumpCurve_MaxVFD[20] * state.H_System_NoCtl[19]) / (state.H_System_NoCtl[20] - state.H_System_NoCtl[19] + state.H_PumpCurve_MaxVFD[19] - state.H_PumpCurve_MaxVFD[20])) ELSE  
            IF (state.H_PumpCurve_MaxVFD[20] > state.H_System_NoCtl[20] && state.H_PumpCurve_MaxVFD[21] <= state.H_System_NoCtl[21]) THEN ((state.H_PumpCurve_MaxVFD[20] * state.H_System_NoCtl[21] - state.H_PumpCurve_MaxVFD[21] * state.H_System_NoCtl[20]) / (state.H_System_NoCtl[21] - state.H_System_NoCtl[20] + state.H_PumpCurve_MaxVFD[20] - state.H_PumpCurve_MaxVFD[21])) ELSE  
              state.H_System_NoCtl[1];  
    
    state.Q_MaxVFD_Duty = IF (parameters.N_max == 1.0) THEN state.Q_NoCtl_Duty ELSE
      IF (state.H_PumpCurve_MaxVFD[n] <= state.H_System_NoCtl[n]) THEN 0.0  
        ELSE MSLUGetInterpolated(ref(state.H_PumpCurve_MaxVFD[1]), ref(state.Q_NoCtl[1]), n, state.H_MaxVFD_Duty);
    
    state.Q_Max = state.Q_MaxVFD_Duty ;
    
     
    state.help_Q = IF (interface.IsOn == 0) THEN 0.0
      ELSE IF (interface.Q_Op > state.Q_MaxVFD_Duty) THEN state.Q_MaxVFD_Duty
        ELSE IF (interface.Q_Op < state.Q_MinVFD_Duty) THEN state.Q_MinVFD_Duty
          ELSE interface.Q_Op ;
    
    state.H = IF (interface.IsOn == 0) THEN 0.0
      ELSE IF (interface.Q_Op > state.Q_MaxVFD_Duty) THEN state.H_MaxVFD_Duty
        ELSE IF (interface.Q_Op < state.Q_MinVFD_Duty) THEN state.H_MinVFD_Duty
          ELSE state.H_System ;

     
     
    { FOREACH i IN {1 .. n}: state.Hvector[i] = IF (state.Nvector[i] <= 0.0) THEN 0.0
      ELSE IF (state.help_Q <= 0.0) THEN pow(state.Nvector[i], 2) * state.PumpCurveCoeff_A
        ELSE pow(state.Nvector[i], 2) * state.PumpCurveCoeff_A - state.PumpCurveCoeff_B * pow(state.Nvector[i], (2 - state.PumpCurveCoeff_C)) * pow(state.help_Q, state.PumpCurveCoeff_C) ; };

    state.help_N = IF (interface.Q_Op > state.Q_MaxVFD_Duty) THEN 1.0
      ELSE IF (interface.Q_Op < state.Q_MinVFD_Duty) THEN parameters.N_min
        ELSE MSLUGetMax2(parameters.N_min, MSLUGetInterpolated(ref(state.Hvector[1]), ref(state.Nvector[1]), n, state.H) + state.Dummy2);

    interface.N = state.help_N ;
    
    state.Eta_VFD = (parameters.Eta_VFD_Max - parameters.Eta_VFD_Half) * (pow(interface.N, 4) - pow(0.5, 4)) / (pow(1.0, 4) - pow(0.5, 4)) + parameters.Eta_VFD_Half ;
    
    state.Eta_Total = state.Eta_Pump * parameters.Eta_motor * state.Eta_VFD ;
    
     
    state.Dummy1 = 0.0 ; 
    state.Dummy2 = state.Dummy1 * (SUMOVER i IN {1 .. n}: state.Hvector[i]) ;
  };

:};



# 376 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.generic.q.msl" 2




# 90 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.pumps.msl" 2

 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.control.msl" 1
 




















CLASS Base_Pump_Controller "A base model for a multi-pump control model"
SPECIALISES PhysicalDAEModelType :=
{:

  comments <- "A base model for a multi-pump control model";
  
  interface <-
  {
    OBJ Q_In (* manip = "1"; hidden = "1" *) "Desired flow rate" : FlowRate := {: value <- 20000.0; causality <- "CIN" :};
     
    OBJ IsOn_PC1 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PC2 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PC3 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PC4 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PC5 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PU1 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PU2 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PU3 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PU4 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOn_PU5 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN"; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
  };
  
  state <-
  {
     
    OBJ help_IsOn_PC1 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PC2 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PC3 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PC4 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PC5 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PU1 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PU2 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PU3 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PU4 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ help_IsOn_PU5 (* hidden = "1" *) "Pump exists (1) or not (0)?" : Integer := {: interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
  };
  
  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
  };
  
  equations <-
  {
     
     
    state.help_IsOn_PC1 = IF (interface.IsOn_PC1 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PC2 = IF (interface.IsOn_PC1 < 1) THEN 0 ELSE IF (interface.IsOn_PC2 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PC3 = IF (interface.IsOn_PC2 < 1) THEN 0 ELSE IF (interface.IsOn_PC3 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PC4 = IF (interface.IsOn_PC3 < 1) THEN 0 ELSE IF (interface.IsOn_PC4 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PC5 = IF (interface.IsOn_PC4 < 1) THEN 0 ELSE IF (interface.IsOn_PC5 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PU1 = IF (interface.IsOn_PU1 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PU2 = IF (interface.IsOn_PU1 < 1) THEN 0 ELSE IF (interface.IsOn_PU2 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PU3 = IF (interface.IsOn_PU2 < 1) THEN 0 ELSE IF (interface.IsOn_PU3 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PU4 = IF (interface.IsOn_PU3 < 1) THEN 0 ELSE IF (interface.IsOn_PU4 < 1) THEN 0 ELSE 1 ; 
    state.help_IsOn_PU5 = IF (interface.IsOn_PU4 < 1) THEN 0 ELSE IF (interface.IsOn_PU5 < 1) THEN 0 ELSE 1 ; 
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.control.multipipe.10p.msl" 1
 


















  

CLASS Pump_Control_MultiPipe_10 "Intermediate control layer (for 10 centrifugal pumps, of which 5 controlled by throttling); each pump has its own discharge pipe"
EXTENDS Base_Pump_Controller WITH
{:

  comments <- "Intermediate control layer (for 10 centrifugal pumps, of which 5 controlled by throttling); each pump has its own discharge pipe";
  
  interface <-
  {
     
    OBJ QMax_PC1 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PC2 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PC3 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PC4 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PC5 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PU1 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PU2 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PU3 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PU4 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QMax_PU5 (* hidden = "1" *) "Max flow rate" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
     
    OBJ QMin_PC1 (* hidden = "1" *) "Min flow rate" : FlowRate := {: causality <- "CIN"; value <- 1.0; group <- "_ Operational" :};
    OBJ QMin_PC2 (* hidden = "1" *) "Min flow rate" : FlowRate := {: causality <- "CIN"; value <- 1.0; group <- "_ Operational" :};
    OBJ QMin_PC3 (* hidden = "1" *) "Min flow rate" : FlowRate := {: causality <- "CIN"; value <- 1.0; group <- "_ Operational" :};
    OBJ QMin_PC4 (* hidden = "1" *) "Min flow rate" : FlowRate := {: causality <- "CIN"; value <- 1.0; group <- "_ Operational" :};
    OBJ QMin_PC5 (* hidden = "1" *) "Min flow rate" : FlowRate := {: causality <- "CIN"; value <- 1.0; group <- "_ Operational" :};
     
    OBJ QOut_PC1 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PC2 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PC3 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PC4 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PC5 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PU1 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PU2 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PU3 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PU4 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
    OBJ QOut_PU5 (* hidden = "1" *) "Actual flow rate delivered" : FlowRate := {: causality <- "CIN"; value <- 10000; group <- "_ Operational" :};
     
    OBJ Volume_PC1 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PC2 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PC3 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PC4 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PC5 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PU1 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PU2 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PU3 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PU4 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Volume_PU5 (* hidden = "1" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "CIN" ; group <- "_ Energy" :};
     
    OBJ EnergyAve_PC1 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PC2 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PC3 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PC4 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PC5 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PU1 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PU2 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PU3 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PU4 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ EnergyAve_PU5 (* hidden = "1" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "CIN" ; group <- "_ Energy" :};
     
    OBJ Power_PC1 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PC2 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PC3 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PC4 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PC5 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PU1 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PU2 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PU3 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PU4 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Power_PU5 (* hidden = "1" *) "Actual power consumption" : Power := {: causality <- "CIN" ; group <- "_ Energy" :};
     
    OBJ Energy_PC1 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PC2 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PC3 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PC4 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PC5 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PU1 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PU2 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PU3 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PU4 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
    OBJ Energy_PU5 (* hidden = "1" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "CIN" ; group <- "_ Energy" :};
     
    OBJ QInPC1 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPC2 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPC3 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPC4 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPC5 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPU1 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPU2 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPU3 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPU4 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ QInPU5 (* hidden = "1" *) "Actual flow rate imposed to pump" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
     
    OBJ IsOnPC1 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPC2 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPC3 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPC4 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPC5 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPU1 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPU2 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPU3 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPU4 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
    OBJ IsOnPU5 (* hidden = "1" *) "Pump is running (1) or not (0)?" : Integer := {: causality <- "COUT"; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "_ Operational" :};
     
    OBJ Q_Out "Actual flow rate delivered" : FlowRate := {: causality <- "COUT" ; group <- "Output" :};
    OBJ PumpedVolume "Pumped quantity since start of simulation" : Volume := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ PumpingEnergy_Ave "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ PowerConsumption "Actual power consumption" : Power := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ PumpingEnergy "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :}
  };
  
  state <-
  {
     
    OBJ help_QMax_PC1 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PC2 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PC3 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PC4 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PC5 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PU1 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PU2 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PU3 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PU4 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMax_PU5 (* hidden = "1" *) "Max flow rate" : FlowRate := {: group <- "_ Operational" :};
     
    OBJ help_QMin_PC1 (* hidden = "1" *) "Min flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMin_PC2 (* hidden = "1" *) "Min flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMin_PC3 (* hidden = "1" *) "Min flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMin_PC4 (* hidden = "1" *) "Min flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QMin_PC5 (* hidden = "1" *) "Min flow rate" : FlowRate := {: group <- "_ Operational" :};
     
    OBJ help_QIn_PC (* hidden = "1" *) "Residual flow rate to controllable pumps" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PC1 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PC2 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PC3 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PC4 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PC5 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PU1 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PU2 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PU3 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PU4 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
    OBJ help_QIn_PU5 (* hidden = "1" *) "Desired flow rate" : FlowRate := {: group <- "_ Operational" :};
  };
  
  equations <-
  {
     
    state.help_QMax_PC1 = IF (state.help_IsOn_PC1 < 1) THEN 0.0 ELSE interface.QMax_PC1 ; 
    state.help_QMax_PC2 = IF (state.help_IsOn_PC2 < 1) THEN 0.0 ELSE interface.QMax_PC2 ; 
    state.help_QMax_PC3 = IF (state.help_IsOn_PC3 < 1) THEN 0.0 ELSE interface.QMax_PC3 ; 
    state.help_QMax_PC4 = IF (state.help_IsOn_PC4 < 1) THEN 0.0 ELSE interface.QMax_PC4 ; 
    state.help_QMax_PC5 = IF (state.help_IsOn_PC5 < 1) THEN 0.0 ELSE interface.QMax_PC5 ; 
    state.help_QMin_PC1 = IF (state.help_IsOn_PC1 < 1) THEN 0.0 ELSE interface.QMin_PC1 ; 
    state.help_QMin_PC2 = IF (state.help_IsOn_PC2 < 1) THEN 0.0 ELSE interface.QMin_PC2 ; 
    state.help_QMin_PC3 = IF (state.help_IsOn_PC3 < 1) THEN 0.0 ELSE interface.QMin_PC3 ; 
    state.help_QMin_PC4 = IF (state.help_IsOn_PC4 < 1) THEN 0.0 ELSE interface.QMin_PC4 ; 
    state.help_QMin_PC5 = IF (state.help_IsOn_PC5 < 1) THEN 0.0 ELSE interface.QMin_PC5 ; 
    state.help_QMax_PU1 = IF (state.help_IsOn_PU1 < 1) THEN 0.0 ELSE interface.QMax_PU1 ; 
    state.help_QMax_PU2 = IF (state.help_IsOn_PU2 < 1) THEN 0.0 ELSE interface.QMax_PU2 ; 
    state.help_QMax_PU3 = IF (state.help_IsOn_PU3 < 1) THEN 0.0 ELSE interface.QMax_PU3 ; 
    state.help_QMax_PU4 = IF (state.help_IsOn_PU4 < 1) THEN 0.0 ELSE interface.QMax_PU4 ; 
    state.help_QMax_PU5 = IF (state.help_IsOn_PU5 < 1) THEN 0.0 ELSE interface.QMax_PU5 ; 
    
     
     
     
     
     
     
     
    state.help_QIn_PU1 = IF (interface.Q_In < (state.help_QMax_PU1 + state.help_QMin_PC1)) THEN 0.0 ELSE state.help_QMax_PU1 ;
    state.help_QIn_PU2 = IF (interface.Q_In < (state.help_QMax_PU1 + state.help_QMax_PU2 + state.help_QMin_PC1)) THEN 0.0 ELSE state.help_QMax_PU2 ;
    state.help_QIn_PU3 = IF (interface.Q_In < (state.help_QMax_PU1 + state.help_QMax_PU2 + state.help_QMax_PU3 + state.help_QMin_PC1)) THEN 0.0 ELSE state.help_QMax_PU3 ;
    state.help_QIn_PU4 = IF (interface.Q_In < (state.help_QMax_PU1 + state.help_QMax_PU2 + state.help_QMax_PU3 + state.help_QMax_PU4 + state.help_QMin_PC1)) THEN 0.0 ELSE state.help_QMax_PU4 ;
    state.help_QIn_PU5 = IF (interface.Q_In < (state.help_QMax_PU1 + state.help_QMax_PU2 + state.help_QMax_PU3 + state.help_QMax_PU4 + state.help_QMax_PU5 + state.help_QMin_PC1)) THEN 0.0 ELSE state.help_QMax_PU5 ;
    
    state.help_QIn_PC = (interface.Q_In - state.help_QIn_PU1 - state.help_QIn_PU2 - state.help_QIn_PU3 - state.help_QIn_PU4 - state.help_QIn_PU5) ;
     
    state.help_QIn_PC1 = IF (state.help_IsOn_PC1 == 0) THEN 0.0
      ELSE IF (state.help_QIn_PC < state.help_QMin_PC1) THEN 0.0
        ELSE IF (state.help_QIn_PC < state.help_QMax_PC1) THEN state.help_QIn_PC
          ELSE IF (state.help_QIn_PC < (state.help_QMin_PC1 + state.help_QMin_PC2)) THEN state.help_QMax_PC1
            ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2)) THEN state.help_QMin_PC1 + (state.help_QMax_PC1 - state.help_QMin_PC1) * (state.help_QIn_PC - state.help_QMin_PC1 - state.help_QMin_PC2) / (state.help_QMax_PC1 + state.help_QMax_PC2 - state.help_QMin_PC1 - state.help_QMin_PC2)
              ELSE IF (state.help_QIn_PC < (state.help_QMin_PC1 + state.help_QMin_PC2 + state.help_QMin_PC3)) THEN state.help_QMax_PC1
                ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3)) THEN state.help_QMin_PC1 + (state.help_QMax_PC1 - state.help_QMin_PC1) * (state.help_QIn_PC - state.help_QMin_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3) / (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 - state.help_QMin_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3)
                  ELSE state.help_QMax_PC1 ;
    
    state.help_QIn_PC2 = IF (state.help_IsOn_PC2 == 0) THEN 0.0
      ELSE IF (state.help_QIn_PC < MSLUGetMax2(state.help_QMin_PC1 + state.help_QMin_PC2, state.help_QMax_PC1)) THEN 0.0
        ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2)) THEN state.help_QMin_PC2 + (state.help_QMax_PC2 - state.help_QMin_PC2) * (state.help_QIn_PC - state.help_QMin_PC1 - state.help_QMin_PC2) / (state.help_QMax_PC1 + state.help_QMax_PC2 - state.help_QMin_PC1 - state.help_QMin_PC2)
          ELSE IF (state.help_QIn_PC < (state.help_QMin_PC1 + state.help_QMin_PC2 + state.help_QMin_PC3)) THEN state.help_QMax_PC2
            ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3)) THEN state.help_QMin_PC2 + (state.help_QMax_PC2 - state.help_QMin_PC2) * (state.help_QIn_PC - state.help_QMin_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3) / (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 - state.help_QMin_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3)
              ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMin_PC2 + state.help_QMin_PC3 + state.help_QMin_PC4)) THEN state.help_QMax_PC2
                ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4)) THEN state.help_QMin_PC2 + (state.help_QMax_PC2 - state.help_QMin_PC2) * (state.help_QIn_PC - state.help_QMin_PC1 - state.help_QMax_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4) / (state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4 - state.help_QMin_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4)
                  ELSE state.help_QMax_PC2 ;
    
    state.help_QIn_PC3 = IF (state.help_IsOn_PC3 == 0) THEN 0.0
      ELSE IF (state.help_QIn_PC < MSLUGetMax2(state.help_QMin_PC1 + state.help_QMin_PC2 + state.help_QMin_PC3, state.help_QMax_PC1 + state.help_QMax_PC2)) THEN 0.0
        ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3)) THEN state.help_QMin_PC3 + (state.help_QMax_PC3 - state.help_QMin_PC3) * (state.help_QIn_PC - state.help_QMin_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3) / (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 - state.help_QMin_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3)
          ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMin_PC2 + state.help_QMin_PC3 + state.help_QMin_PC4)) THEN state.help_QMax_PC3
            ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4)) THEN state.help_QMin_PC3 + (state.help_QMax_PC3 - state.help_QMin_PC3) * (state.help_QIn_PC - state.help_QMax_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4) / (state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4 - state.help_QMin_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4)
              ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMin_PC3 + state.help_QMin_PC4 + state.help_QMin_PC5)) THEN state.help_QMax_PC3
                ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4 + state.help_QMax_PC5)) THEN state.help_QMin_PC3 + (state.help_QMax_PC3 - state.help_QMin_PC3) * (state.help_QIn_PC  - state.help_QMax_PC1 - state.help_QMax_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4 - state.help_QMin_PC5) / (state.help_QMax_PC3 + state.help_QMax_PC4 + state.help_QMax_PC5 - state.help_QMin_PC3 - state.help_QMin_PC4 - state.help_QMin_PC5)
                  ELSE state.help_QMax_PC3 ;
    
    state.help_QIn_PC4 = IF (state.help_IsOn_PC4 == 0) THEN 0.0
      ELSE IF (state.help_QIn_PC < MSLUGetMax2(state.help_QMax_PC1 + state.help_QMin_PC2 + state.help_QMin_PC3 + state.help_QMin_PC4, state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3)) THEN 0.0
        ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4)) THEN state.help_QMin_PC4 + (state.help_QMax_PC4 - state.help_QMin_PC4) * (state.help_QIn_PC - state.help_QMax_PC1 - state.help_QMin_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4) / (state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4 - state.help_QMin_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4)
          ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMin_PC3 + state.help_QMin_PC4 + state.help_QMin_PC5)) THEN state.help_QMax_PC4
            ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4 + state.help_QMax_PC5)) THEN state.help_QMin_PC4 + (state.help_QMax_PC4 - state.help_QMin_PC4) * (state.help_QIn_PC - state.help_QMax_PC1 - state.help_QMax_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4 - state.help_QMin_PC5) / (state.help_QMax_PC3 + state.help_QMax_PC4 + state.help_QMax_PC5 - state.help_QMin_PC3 - state.help_QMin_PC4 - state.help_QMin_PC5)
              ELSE state.help_QMax_PC4 ;
    
    state.help_QIn_PC5 = IF (state.help_IsOn_PC5 == 0) THEN 0.0
      ELSE IF (state.help_QIn_PC < MSLUGetMax2(state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMin_PC3 + state.help_QMin_PC4 + state.help_QMin_PC5, state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4)) THEN 0.0
        ELSE IF (state.help_QIn_PC < (state.help_QMax_PC1 + state.help_QMax_PC2 + state.help_QMax_PC3 + state.help_QMax_PC4 + state.help_QMax_PC5)) THEN state.help_QMin_PC5 + (state.help_QMax_PC5 - state.help_QMin_PC5) * (state.help_QIn_PC - state.help_QMax_PC1 - state.help_QMax_PC2 - state.help_QMin_PC3 - state.help_QMin_PC4 - state.help_QMin_PC5) / (state.help_QMax_PC3 + state.help_QMax_PC4 + state.help_QMax_PC5 - state.help_QMin_PC3 - state.help_QMin_PC4 - state.help_QMin_PC5)
          ELSE state.help_QMax_PC5 ;
    
    interface.QInPU1 = IF (state.help_QIn_PU1 >= 0.0) THEN state.help_QIn_PU1 ELSE 0.0 ;
    interface.QInPU2 = IF (state.help_QIn_PU2 >= 0.0) THEN state.help_QIn_PU2 ELSE 0.0 ;
    interface.QInPU3 = IF (state.help_QIn_PU3 >= 0.0) THEN state.help_QIn_PU3 ELSE 0.0 ;
    interface.QInPU4 = IF (state.help_QIn_PU4 >= 0.0) THEN state.help_QIn_PU4 ELSE 0.0 ;
    interface.QInPU5 = IF (state.help_QIn_PU5 >= 0.0) THEN state.help_QIn_PU5 ELSE 0.0 ;
    interface.QInPC1 = IF (state.help_QIn_PC1 >= 0.0) THEN state.help_QIn_PC1 ELSE 0.0 ;
    interface.QInPC2 = IF (state.help_QIn_PC2 >= 0.0) THEN state.help_QIn_PC2 ELSE 0.0 ;
    interface.QInPC3 = IF (state.help_QIn_PC3 >= 0.0) THEN state.help_QIn_PC3 ELSE 0.0 ;
    interface.QInPC4 = IF (state.help_QIn_PC4 >= 0.0) THEN state.help_QIn_PC4 ELSE 0.0 ;
    interface.QInPC5 = IF (state.help_QIn_PC5 >= 0.0) THEN state.help_QIn_PC5 ELSE 0.0 ;
    
     
    interface.IsOnPC1 = IF (state.help_IsOn_PC1 < 1) THEN 0 ELSE IF (state.help_QIn_PC1 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPC2 = IF (state.help_IsOn_PC2 < 1) THEN 0 ELSE IF (state.help_QIn_PC2 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPC3 = IF (state.help_IsOn_PC3 < 1) THEN 0 ELSE IF (state.help_QIn_PC3 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPC4 = IF (state.help_IsOn_PC4 < 1) THEN 0 ELSE IF (state.help_QIn_PC4 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPC5 = IF (state.help_IsOn_PC5 < 1) THEN 0 ELSE IF (state.help_QIn_PC5 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPU1 = IF (state.help_IsOn_PU1 < 1) THEN 0 ELSE IF (state.help_QIn_PU1 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPU2 = IF (state.help_IsOn_PU2 < 1) THEN 0 ELSE IF (state.help_QIn_PU1 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPU3 = IF (state.help_IsOn_PU3 < 1) THEN 0 ELSE IF (state.help_QIn_PU1 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPU4 = IF (state.help_IsOn_PU4 < 1) THEN 0 ELSE IF (state.help_QIn_PU1 <= 0.0) THEN 0 ELSE 1 ;
    interface.IsOnPU5 = IF (state.help_IsOn_PU5 < 1) THEN 0 ELSE IF (state.help_QIn_PU1 <= 0.0) THEN 0 ELSE 1 ;
    
    interface.Q_Out = interface.QOut_PC1 + interface.QOut_PC2 + interface.QOut_PC3 + interface.QOut_PC4 + interface.QOut_PC5 +
      interface.QOut_PU1 + interface.QOut_PU2 + interface.QOut_PU3 + interface.QOut_PU4 + interface.QOut_PU5 ;  
    
    interface.PumpedVolume = interface.Volume_PC1 + interface.Volume_PC2 + interface.Volume_PC3 + interface.Volume_PC4 +
      interface.Volume_PC5 + interface.Volume_PU1 + interface.Volume_PU2 + interface.Volume_PU3 + interface.Volume_PU4 +  
      interface.Volume_PU5 ;
    
    interface.PumpingEnergy_Ave = IF (interface.PumpedVolume <= 0.0) THEN 0.0
      ELSE (interface.EnergyAve_PC1 + interface.EnergyAve_PC2 + interface.EnergyAve_PC3 + interface.EnergyAve_PC4 +
      interface.EnergyAve_PC5 + interface.EnergyAve_PU1 + interface.EnergyAve_PU2 + interface.EnergyAve_PU3 + interface.EnergyAve_PU4 +  
      interface.EnergyAve_PU5) / interface.PumpedVolume ;
    
    interface.PowerConsumption = interface.Power_PC1 + interface.Power_PC2 + interface.Power_PC3 + interface.Power_PC4 +
      interface.Power_PC5 + interface.Power_PU1 + interface.Power_PU2 + interface.Power_PU3 + interface.Power_PU4 +    
      interface.Power_PU5 ;
    
    interface.PumpingEnergy = interface.Energy_PC1 + interface.Energy_PC2 + interface.Energy_PC3 + interface.Energy_PC4 +
      interface.Energy_PC5 + interface.Energy_PU1 + interface.Energy_PU2 + interface.Energy_PU3 + interface.Energy_PU4 +    
      interface.Energy_PU5 ;
  };

:};


 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.control.multipipe.10c5t.msl" 1
 




















CLASS MultiPipe_10cf_5throttle (* icon = "pump" *)  
"Pump group controller: 10 centrifugal pumps, of which 5 controlled by throttling; each pump has its own discharge pipe"
SPECIALISES CoupledModelType :=
{:

  comments <- "Pump group controller: 10 centrifugal pumps, of which 5 controlled by throttling; each pump has its own discharge pipe";
  
  interface <-
  {
     
    OBJ Q_In (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired flow rate" : FlowRate := {: value <- 20000.0; causality <- "CIN" ; group <- "Input" :};
    OBJ TSS (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "TSS in the pumped liquid" : Concentration := {: value <- 3000.0; causality <- "CIN" ; group <- "Operational" :};
    OBJ HeadLoss_Ext (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Head loss due to external phenomena (optional)" : Length := {: causality <- "CIN" ; group <- "Operational" :};
    OBJ Elevation (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Elevation head to be overcome by the pump" : Length := {: causality <- "CIN" ; group <- "Operational" :};
     
    OBJ IsOn_PC1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PC2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PC3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PC4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PC5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PU1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 1; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PU2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PU3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PU4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    OBJ IsOn_PU5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Pump exists (1) or not (0)?" : Integer := {: causality <- "CIN" ; value <- 0; interval <- {: lowerBound <- 0 ; upperBound <- 1 :}; group <- "Operational" :};
    
    OBJ Q_Out (* terminal = "out_2" *) "Actual flow rate delivered" : FlowRate := {: causality <- "COUT" ; group <- "Output" :};
    OBJ PumpedVolume (* terminal = "out_2" *) "Pumped quantity since start of simulation" : Volume := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ PumpingEnergy_Ave (* terminal = "out_2" *) "Average energy consumption since start of simulation" : EnergyForPumping := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ PowerConsumption (* terminal = "out_2" *) "Actual power consumption" : Power := {: causality <- "COUT" ; group <- "Energy" :};
    OBJ PumpingEnergy (* terminal = "out_2" *) "Energy consumption since start of simulation" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :}
  };
  
  sub_models <-
  {
    OBJ Ctl : Pump_Control_MultiPipe_10 ;
    OBJ PC1 : Centrifugal_Q_Throttling ;  
    OBJ PC2 : Centrifugal_Q_Throttling ;
    OBJ PC3 : Centrifugal_Q_Throttling ;
    OBJ PC4 : Centrifugal_Q_Throttling ;
    OBJ PC5 : Centrifugal_Q_Throttling ;
    OBJ PU1 : Centrifugal_Q_Throttling ;  
    OBJ PU2 : Centrifugal_Q_Throttling ;
    OBJ PU3 : Centrifugal_Q_Throttling ;
    OBJ PU4 : Centrifugal_Q_Throttling ;
    OBJ PU5 : Centrifugal_Q_Throttling ;
  };
  
  coupling <-
  {
    connect(interface.Q_In, sub_models.Ctl.interface.Q_In),
    
     
    connect(interface.TSS, sub_models.PC1.interface.TSS),  
    connect(interface.TSS, sub_models.PC2.interface.TSS),
    connect(interface.TSS, sub_models.PC3.interface.TSS),
    connect(interface.TSS, sub_models.PC4.interface.TSS),
    connect(interface.TSS, sub_models.PC5.interface.TSS),
    connect(interface.TSS, sub_models.PU1.interface.TSS),
    connect(interface.TSS, sub_models.PU2.interface.TSS),
    connect(interface.TSS, sub_models.PU3.interface.TSS),
    connect(interface.TSS, sub_models.PU4.interface.TSS),
    connect(interface.TSS, sub_models.PU5.interface.TSS),
    
    connect(interface.Elevation, sub_models.PC1.interface.Elevation),  
    connect(interface.Elevation, sub_models.PC2.interface.Elevation),
    connect(interface.Elevation, sub_models.PC3.interface.Elevation),
    connect(interface.Elevation, sub_models.PC4.interface.Elevation),
    connect(interface.Elevation, sub_models.PC5.interface.Elevation),
    connect(interface.Elevation, sub_models.PU1.interface.Elevation),
    connect(interface.Elevation, sub_models.PU2.interface.Elevation),
    connect(interface.Elevation, sub_models.PU3.interface.Elevation),
    connect(interface.Elevation, sub_models.PU4.interface.Elevation),
    connect(interface.Elevation, sub_models.PU5.interface.Elevation),
    
    connect(interface.HeadLoss_Ext, sub_models.PC1.interface.HeadLoss_Ext),  
    connect(interface.HeadLoss_Ext, sub_models.PC2.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PC3.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PC4.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PC5.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PU1.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PU2.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PU3.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PU4.interface.HeadLoss_Ext),
    connect(interface.HeadLoss_Ext, sub_models.PU5.interface.HeadLoss_Ext),
    
     
    connect(interface.IsOn_PC1, sub_models.Ctl.interface.IsOn_PC1),
    connect(interface.IsOn_PC2, sub_models.Ctl.interface.IsOn_PC2),
    connect(interface.IsOn_PC3, sub_models.Ctl.interface.IsOn_PC3),
    connect(interface.IsOn_PC4, sub_models.Ctl.interface.IsOn_PC4),
    connect(interface.IsOn_PC5, sub_models.Ctl.interface.IsOn_PC5),
    connect(interface.IsOn_PU1, sub_models.Ctl.interface.IsOn_PU1),
    connect(interface.IsOn_PU2, sub_models.Ctl.interface.IsOn_PU2),
    connect(interface.IsOn_PU3, sub_models.Ctl.interface.IsOn_PU3),
    connect(interface.IsOn_PU4, sub_models.Ctl.interface.IsOn_PU4),
    connect(interface.IsOn_PU5, sub_models.Ctl.interface.IsOn_PU5),
    
     
     
    connect(sub_models.PC1.state.Q_Max, sub_models.Ctl.interface.QMax_PC1),
    connect(sub_models.PC2.state.Q_Max, sub_models.Ctl.interface.QMax_PC2),
    connect(sub_models.PC3.state.Q_Max, sub_models.Ctl.interface.QMax_PC3),
    connect(sub_models.PC4.state.Q_Max, sub_models.Ctl.interface.QMax_PC4),
    connect(sub_models.PC5.state.Q_Max, sub_models.Ctl.interface.QMax_PC5),
    connect(sub_models.PC1.state.Q_Min, sub_models.Ctl.interface.QMin_PC1),
    connect(sub_models.PC2.state.Q_Min, sub_models.Ctl.interface.QMin_PC2),
    connect(sub_models.PC3.state.Q_Min, sub_models.Ctl.interface.QMin_PC3),
    connect(sub_models.PC4.state.Q_Min, sub_models.Ctl.interface.QMin_PC4),
    connect(sub_models.PC5.state.Q_Min, sub_models.Ctl.interface.QMin_PC5),
    connect(sub_models.PU1.state.Q_Max, sub_models.Ctl.interface.QMax_PU1),
    connect(sub_models.PU2.state.Q_Max, sub_models.Ctl.interface.QMax_PU2),
    connect(sub_models.PU3.state.Q_Max, sub_models.Ctl.interface.QMax_PU3),
    connect(sub_models.PU4.state.Q_Max, sub_models.Ctl.interface.QMax_PU4),
    connect(sub_models.PU5.state.Q_Max, sub_models.Ctl.interface.QMax_PU5),
    
     
     
    connect(sub_models.Ctl.interface.QInPC1, sub_models.PC1.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPC2, sub_models.PC2.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPC3, sub_models.PC3.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPC4, sub_models.PC4.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPC5, sub_models.PC5.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPU1, sub_models.PU1.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPU2, sub_models.PU2.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPU3, sub_models.PU3.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPU4, sub_models.PU4.interface.Q_Op),
    connect(sub_models.Ctl.interface.QInPU5, sub_models.PU5.interface.Q_Op),
    
    connect(sub_models.Ctl.interface.IsOnPC1, sub_models.PC1.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPC2, sub_models.PC2.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPC3, sub_models.PC3.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPC4, sub_models.PC4.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPC5, sub_models.PC5.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPU1, sub_models.PU1.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPU2, sub_models.PU2.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPU3, sub_models.PU3.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPU4, sub_models.PU4.interface.IsOn),
    connect(sub_models.Ctl.interface.IsOnPU5, sub_models.PU5.interface.IsOn),
    
     
    connect(sub_models.Ctl.interface.Q_Out, interface.Q_Out),
    connect(sub_models.PC1.interface.Q_Out, sub_models.Ctl.interface.QOut_PC1),
    connect(sub_models.PC2.interface.Q_Out, sub_models.Ctl.interface.QOut_PC2),
    connect(sub_models.PC3.interface.Q_Out, sub_models.Ctl.interface.QOut_PC3),
    connect(sub_models.PC4.interface.Q_Out, sub_models.Ctl.interface.QOut_PC4),
    connect(sub_models.PC5.interface.Q_Out, sub_models.Ctl.interface.QOut_PC5),
    connect(sub_models.PU1.interface.Q_Out, sub_models.Ctl.interface.QOut_PU1),
    connect(sub_models.PU2.interface.Q_Out, sub_models.Ctl.interface.QOut_PU2),
    connect(sub_models.PU3.interface.Q_Out, sub_models.Ctl.interface.QOut_PU3),
    connect(sub_models.PU4.interface.Q_Out, sub_models.Ctl.interface.QOut_PU4),
    connect(sub_models.PU5.interface.Q_Out, sub_models.Ctl.interface.QOut_PU5),
    
    connect(sub_models.Ctl.interface.PumpedVolume, interface.PumpedVolume),
    connect(sub_models.PC1.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PC1),
    connect(sub_models.PC2.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PC2),
    connect(sub_models.PC3.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PC3),
    connect(sub_models.PC4.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PC4),
    connect(sub_models.PC5.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PC5),
    connect(sub_models.PU1.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PU1),
    connect(sub_models.PU2.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PU2),
    connect(sub_models.PU3.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PU3),
    connect(sub_models.PU4.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PU4),
    connect(sub_models.PU5.interface.PumpedVolume, sub_models.Ctl.interface.Volume_PU5),
    
    connect(sub_models.Ctl.interface.PumpingEnergy_Ave, interface.PumpingEnergy_Ave),
    connect(sub_models.PC1.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PC1),
    connect(sub_models.PC2.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PC2),
    connect(sub_models.PC3.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PC3),
    connect(sub_models.PC4.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PC4),
    connect(sub_models.PC5.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PC5),
    connect(sub_models.PU1.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PU1),
    connect(sub_models.PU2.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PU2),
    connect(sub_models.PU3.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PU3),
    connect(sub_models.PU4.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PU4),
    connect(sub_models.PU5.interface.PumpingEnergy_Ave, sub_models.Ctl.interface.EnergyAve_PU5),
    
    connect(sub_models.Ctl.interface.PowerConsumption, interface.PowerConsumption),
    connect(sub_models.PC1.interface.PowerConsumption, sub_models.Ctl.interface.Power_PC1),
    connect(sub_models.PC2.interface.PowerConsumption, sub_models.Ctl.interface.Power_PC2),
    connect(sub_models.PC3.interface.PowerConsumption, sub_models.Ctl.interface.Power_PC3),
    connect(sub_models.PC4.interface.PowerConsumption, sub_models.Ctl.interface.Power_PC4),
    connect(sub_models.PC5.interface.PowerConsumption, sub_models.Ctl.interface.Power_PC5),
    connect(sub_models.PU1.interface.PowerConsumption, sub_models.Ctl.interface.Power_PU1),
    connect(sub_models.PU2.interface.PowerConsumption, sub_models.Ctl.interface.Power_PU2),
    connect(sub_models.PU3.interface.PowerConsumption, sub_models.Ctl.interface.Power_PU3),
    connect(sub_models.PU4.interface.PowerConsumption, sub_models.Ctl.interface.Power_PU4),
    connect(sub_models.PU5.interface.PowerConsumption, sub_models.Ctl.interface.Power_PU5),
    
    connect(sub_models.Ctl.interface.PumpingEnergy, interface.PumpingEnergy),
    connect(sub_models.PC1.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PC1),
    connect(sub_models.PC2.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PC2),
    connect(sub_models.PC3.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PC3),
    connect(sub_models.PC4.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PC4),
    connect(sub_models.PC5.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PC5),
    connect(sub_models.PU1.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PU1),
    connect(sub_models.PU2.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PU2),
    connect(sub_models.PU3.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PU3),
    connect(sub_models.PU4.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PU4),
    connect(sub_models.PU5.interface.PumpingEnergy, sub_models.Ctl.interface.Energy_PU5),
  };

:};



# 286 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.control.multipipe.10p.msl" 2




# 83 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/pumps/wwtp.pumps.control.msl" 2




# 92 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.base.pumps.msl" 2




# 80 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.ASU.AStage.msl" 1
 














 
 





# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.ASU.AStage.fixvolumeasu.msl" 1
 














 
 





CLASS FixVolumeASU_AStage_Single (* icon = "activated_sludge_unit" *)
EXTENDS FixVolumeASMConversionModel_AStage WITH
{:

  comments <- "Model for an A-stage activated sludge tank with a fixed volume";
  
  interface <-  
  {
    OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
    OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *)  "Temperature of the activated sludge" : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };
  
  parameters <- 
  {
     
    OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
     
    OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : EnergyForMixing := {: value <- 0.005; group <- "Mixing energy":};
    OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Integer := {: value <- 0 ; interval <- {: lowerBound <- 0; upperBound <- 1:}; group <- "Mixing energy":};  
  };
  
  state <-
  {
     
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : Volume ;
     
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
    OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : EnergyIndex := {: group <- "Mixing":};
  };
  
  initial <-
  {
    state.Integ_AE = 0.0 ;
    state.Integ_ME = 0.0 ;
  };
  
  equations <- 
  {
    state.Kla_Actual = interface.Kla;
    state.Temp_Actual = interface.Temp;
  
     
     
    interface.AerationPower = (1 / parameters.OTR_Energy) * state.S_O_Saturation * state.Kla_Actual * state.V ;
    DERIV(state.Integ_AE,[independent.t])= state.S_O_Saturation * state.Kla_Actual * state.V ;
    interface.AerationEnergy = (1/parameters.OTR_Energy) * state.Integ_AE ; 
    
     
    state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0)) THEN parameters.ME_unit * state.V
      ELSE IF (parameters.Mixing_When_Aerated == 1) THEN parameters.ME_unit * state.V
        ELSE 0.0 ;    
    
     
    interface.MixingPower = state.ME_Instant ;
    DERIV(state.Integ_ME,[independent.t]) = state.ME_Instant;
    interface.MixingEnergy = state.Integ_ME ;
  };   

:};


CLASS FixVolumeASMConversionModel_AStage EXTENDS FixVolumeConversionModel_AStage WITH
{:
  
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 1
 

  interface <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABModel.interface.msl" 1
 

    OBJ AUR (*terminal = "out_2"; *) "Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; group <- "Measurement data"; :};
    OBJ DO (*is_favorite = "1"; terminal = "out_2"; *) "Dissolved oxygen concentration measurement" : DissolvedOxygen := {: causality <- "COUT"; unit <- "gO2/m3"; group <- "Measurement data"; :};
    OBJ Kla_ASU (*terminal = "out_2"; *) "Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ NH4 (*is_favorite = "1"; terminal = "out_2"; *) "Ammonium concentration measurement" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ NO3 (*is_favorite = "1"; terminal = "out_2"; *) "Nitrate+Nitrite concentration measurement" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ NPR (*terminal = "out_2"; *) "Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; group <- "Measurement data"; :};
    OBJ NUR (*terminal = "out_2"; *) "Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; group <- "Measurement data"; :};
    OBJ OUR_ASU (*terminal = "out_2"; *) "Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT"; unit <- "g/(m3.d)"; group <- "Measurement data"; :};
    OBJ OfflineBOD (*terminal = "out_2"; *) "Biological Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ OfflineTKN (*terminal = "out_2"; *) "Total Kjeldal nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ OnlineCOD (*terminal = "out_2"; *) "Chemical Oxygen Demand measurement" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ OnlineTN (*terminal = "out_2"; *) "Total nitrogen concentration measurement" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ TSS (*is_favorite = "1"; terminal = "out_2"; *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ V_ASU (*terminal = "out_2"; *) "Volume measurement data" : Volume := {: causality <- "COUT"; group <- "Measurement data"; :};

# 5 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 2

  };

  parameters <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.parameters.msl" 1
 

    OBJ F_BOD_COD (* *) "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ F_TSS_COD (* *) "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; interval <- {: lowerBound <- 0.000000; upperBound <- 1.000000; :}; group <- "Conversion factors"; :};
    OBJ K_B_hyd (* *) "Half saturation coefficient for hydrolysis of slowly biodegradable substrate" : HalfSatCoeffForHydrolysis := {: unit <- "gCOD/gCOD"; value <- 0.03; group <- "Kinetics"; :};
    OBJ K_Bf (* *) "S_Bf half-saturation coeff for OHO" : HalfSatCoeffForHetero := {: value <- 5.0; group <- "Kinetics"; :};
    OBJ K_Bs (* *) "S_Bs half-saturation coeff for OHO" : HalfSatCoeffForHetero := {: value <- 40.0; group <- "Kinetics"; :};
    OBJ K_EPS (* *) "Half-saturation coefficient for EPS (X_OHO)" : HalfSatCoeffForHetero := {: value <- 50.0; group <- "Kinetics"; :};
    OBJ K_NHx_ANO (* *) "Half-saturation coefficient of ANOx for ammonium" : AmmonHalfSatCoeffForAutotr := {: unit <- "gNH3-N/m3"; value <- 1.0; group <- "Kinetics"; :};
    OBJ K_NHx_OHO (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: value <- 0.05; group <- "Kinetics"; :};
    OBJ K_NOx_OHO (* *) "Nitrate half-saturation coefficient for denitrifying OHO" : NitrateHalfSatCoeffForDenitrifHetero := {: unit <- "gNO3-N/m3"; value <- 0.5; group <- "Kinetics"; :};
    OBJ K_O_ANO (* *) "Oxygen half-saturation coeff for ANO" : OxygenHalfSatCoeffForAutotr := {: value <- 0.4; group <- "Kinetics"; :};
    OBJ K_O_EPS (* *) "Oxygen half-saturation coefficient" : OxygenHalfSatCoeffForHetero := {: value <- 1.5; group <- "Kinetics"; :};
    OBJ K_O_OHO (* *) "Oxygen half-saturation coeff for OHO" : OxygenHalfSatCoeffForHetero := {: value <- 0.2; group <- "Kinetics"; :};
    OBJ K_O_STO (* *) "Oxygen half-saturation coefficient for storage" : OxygenHalfSatCoeffForHetero := {: value <- 1.0; group <- "Kinetics"; :};
    OBJ K_SL (* *) "Half saturation coefficient for surface limitation" : HalfSatCoeffForHetero := {: value <- 0.002; group <- "Kinetics"; :};
    OBJ K_STO_hyd (* *) "Hydrolysis half-saturation coefficient for X_STO (X_OHO)" : HalfSatCoeffForHydrolysis := {: value <- 0.15; group <- "Kinetics"; :};
    OBJ Temp_Ref (* hidden = "1"; *) "Reference temperature of the activated sludge" : CelsiusTemperature := {: value <- 20.0; group <- "Kinetics"; :};
    OBJ Y_ANO (* *) "Yield for autotrophic biomass" : YieldForAutotrophicBiomass := {: value <- 0.24; group <- "Stoichiometry"; :};
    OBJ Y_OHO (* *) "Yield for OHOs" : YieldForHeterotrophicBiomass := {: value <- 0.67; group <- "Stoichiometry"; :};
    OBJ b_ANO (* *) "Decay coefficient for ANO" : DecayCoeffAutotr := {: value <- 0.15; group <- "Kinetics"; :};
    OBJ b_OHO (* *) "Decay coefficient for OHO" : DecayCoeffHeterotr := {: value <- 0.62; group <- "Kinetics"; :};
    OBJ f_Shunt_max (* *) "Fraction of X_STO in the active biomass" : Real := {: unit <- "-"; value <- 0.30; group <- "Kinetics"; :};
    OBJ f_U (* *) "Fraction of biomass converted to inert matter" : FractOfBiomassLeadingToPartProd := {: value <- 0.08; group <- "Stoichiometry"; :};
    OBJ f_dia (* *) "Dual substrate (0) vs. diauxic (1) model for S_Bs uptake" : Integer := {: value <- 0.0; interval <- {: lowerBound <- 0.0; upperBound <- 1.0; :}; group <- "Kinetics"; :};
    OBJ i_CB (* *) "COD to VSS ratio (for X_OHO)" : Ratio := {: value <- 1.48; group <- "Composition parameters"; :};
    OBJ i_X_B (* *) "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; group <- "Composition parameters"; :};
    OBJ i_X_U (* *) "Mass of nitrogen per unit COD in products formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; group <- "Composition parameters"; :};
    OBJ k_EPS_hyd (* *) "Rate constant for EPS hydrolysis" : RateConstant := {: value <- 0.12; group <- "Kinetics"; :};
    OBJ k_EPS_max (* *) "EPS formation coefficient" : Ratio := {: value <- 0.25; group <- "Kinetics"; :};
    OBJ k_a (* *) "Maximum specific ammonification rate" : AmmonificationRate := {: unit <- "m3/(gCOD*d)"; value <- 0.08; group <- "Kinetics"; :};
    OBJ mu_ANO (* *) "Max specific growth rate of ANOs" : MaxSpecifGrowthRateAutotr := {: value <- 0.8; group <- "Kinetics"; :};
    OBJ mu_OHO (* *) "Max specific growth rate of OHOs" : MaxSpecifGrowthRateHetero := {: value <- 7.0; group <- "Kinetics"; :};
    OBJ mu_OHOs (* *) "Max specific growth rate of OHOs on S_Bs" : MaxSpecifGrowthRateHetero := {: value <- 3.0; group <- "Kinetics"; :};
    OBJ n_g (* *) "Correction factor for anoxic growth of OHOs" : CorrectionFactor := {: value <- 0.8; group <- "Kinetics"; :};
    OBJ n_hyd (* *) "Correction factor for anoxic hydrolysis" : CorrectionFactor := {: value <- 0.4; group <- "Kinetics"; :};
    OBJ q_STO_hyd (* *) "Rate constant for storage hydrolysis" : RateConstant := {: value <- 3.0; group <- "Kinetics"; :};
    OBJ q_XB_hyd (* *) "Maximum specific hydrolysis rate" : MaxSpecificHydrolysisRate := {: unit <- "gCOD/(gCOD*d)"; value <- 3.5; group <- "Kinetics"; :};
    OBJ q_ads (* *) "Rate constant for adsorption" : RateConstant := {: value <- 0.07; group <- "Kinetics"; :};
    OBJ theta_K_X (* hidden = "1"; *) "Temperature correction factor for K_X (K_B_hyd)" : Real := {: value <- 1.116; group <- "Kinetics"; :};
    OBJ theta_b_ANO (* hidden = "1"; *) "Temperature correction factor for b_A" : Real := {: value <- 1.116; group <- "Kinetics"; :};
    OBJ theta_b_OHO (* hidden = "1"; *) "Temperature correction factor for b_H" : Real := {: value <- 1.12; group <- "Kinetics"; :};
    OBJ theta_k_a (* hidden = "1"; *) "Temperature correction factor for k_a" : Real := {: value <- 1.072; group <- "Kinetics"; :};
    OBJ theta_k_h (* hidden = "1"; *) "Temperature correction factor for k_h (q_XB_hyd)" : Real := {: value <- 1.116; group <- "Kinetics"; :};
    OBJ theta_mu_ANO (* hidden = "1"; *) "Temperature correction factor for mu_A" : Real := {: value <- 1.103; group <- "Kinetics"; :};
    OBJ theta_mu_OHO (* hidden = "1"; *) "Temperature correction factor for mu_H" : Real := {: value <- 1.072; group <- "Kinetics"; :};

# 10 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 2

  };

  state <-
  {
    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.state.msl" 1
 

    OBJ K_X_T (* *) "K_B_hyd at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ S_O_Saturation (* *) "Oxygen saturation concentration" : Concentration := {: group <- "Temperature dependency"; :};
    OBJ X_TSS (* *) "Total suspended solids" : Concentration := {: unit <- "g/m3"; group <- "Concentration"; :};
    OBJ b_ANO_T (* *) "b_ANO at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ b_OHO_T (* *) "b_OHO at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ f_STO (* *) "Flow of electrons to storage" : Real := {: unit <- "-"; group <- "Kinetics"; :};
    OBJ k_EPS_PC (* *) "Proportionality coeff for extra-cellular polymeric substances production" : Real := {: unit <- "-"; group <- "Kinetics"; :};
    OBJ k_EPS_SC (* *) "Normalised stoichiometric coeff for extra-cellular polymeric substances production" : Real := {: unit <- "-"; group <- "Kinetics"; :};
    OBJ k_STO_PC (* *) "[GUESS]" : Real := {: unit <- "-"; group <- "Kinetics"; :};
    OBJ k_a_T (* *) "k_a at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ k_h_T (* *) "q_XB_hyd at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ mu_ANO_T (* *) "mu_ANO at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ mu_OHO_T (* *) "mu_OHO at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ mu_OHOs_T (* *) "mu_OHOs at the system temperature" : Real := {: group <- "Temperature dependency"; :};
    OBJ r_ads_B (* hidden = "1"; *) "Rate expression for adsorption (C_B)" : Real := {: group <- "Kinetic rates"; :};
    OBJ r_ads_U (* hidden = "1"; *) "Rate expression for adsorption (C_U)" : Real := {: group <- "Kinetic rates"; :};
    OBJ r_dia (* *) "Rate expression for diauxic model (of aerobic growth of OHOs)" : Real := {: group <- "Kinetic rates"; :};
    OBJ r_dual (* *) "Rate expression for dual model (of aerobic growth of OHOs)" : Real := {: group <- "Kinetic rates"; :};
    OBJ r_hydr_org (* *) "Rate expression for hydrolysis of entrapped organic matter" : Real := {: group <- "Kinetic rates"; :};

# 15 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 2

  };

  initial <-
  {
     


     


     


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.stoichiometry.msl" 1
 

    state.Stoichiometry[AerGrowthOHOfast][S_O] := - (1 - parameters.Y_OHO) / parameters.Y_OHO;
    state.Stoichiometry[AerGrowthOHOfast][S_NHx] := - parameters.i_X_B;
    state.Stoichiometry[AerGrowthOHOfast][S_Alk] := - parameters.i_X_B / 14;
    state.Stoichiometry[AerGrowthOHOfast][X_OHO] := 1;
    state.Stoichiometry[AerGrowthOHOslow][S_O] := - (1 - parameters.Y_OHO) / parameters.Y_OHO;
    state.Stoichiometry[AerGrowthOHOslow][S_NHx] := - parameters.i_X_B;
    state.Stoichiometry[AerGrowthOHOslow][S_Alk] := - parameters.i_X_B / 14;
    state.Stoichiometry[AerGrowthOHOslow][X_OHO] := 1;
    state.Stoichiometry[AnGrowthOHO][S_Bf] := - 1 / parameters.Y_OHO;
    state.Stoichiometry[AnGrowthOHO][S_NOx] := - (1 - parameters.Y_OHO) / (2.86 * parameters.Y_OHO);
    state.Stoichiometry[AnGrowthOHO][S_NHx] := - parameters.i_X_B;
    state.Stoichiometry[AnGrowthOHO][S_Alk] := ((1 - parameters.Y_OHO) / (14 * 2.86 * parameters.Y_OHO)) - (parameters.i_X_B / 14);
    state.Stoichiometry[AnGrowthOHO][X_OHO] := 1;
    state.Stoichiometry[AerGrowthANO][S_O] := - (4.57 - parameters.Y_ANO) / parameters.Y_ANO;
    state.Stoichiometry[AerGrowthANO][S_NOx] := 1 / parameters.Y_ANO;
    state.Stoichiometry[AerGrowthANO][S_NHx] := - parameters.i_X_B - 1 / parameters.Y_ANO;
    state.Stoichiometry[AerGrowthANO][S_Alk] := - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_ANO));
    state.Stoichiometry[AerGrowthANO][X_ANO] := 1;
    state.Stoichiometry[DecayOHO][X_B] := 1 - parameters.f_U;
    state.Stoichiometry[DecayOHO][X_OHO] := - 1;
    state.Stoichiometry[DecayOHO][X_E] := parameters.f_U;
    state.Stoichiometry[DecayOHO][X_NB] := parameters.i_X_B - parameters.f_U * parameters.i_X_U;
    state.Stoichiometry[DecayANO][X_B] := 1 - parameters.f_U;
    state.Stoichiometry[DecayANO][X_ANO] := - 1;
    state.Stoichiometry[DecayANO][X_E] := parameters.f_U;
    state.Stoichiometry[DecayANO][X_NB] := parameters.i_X_B - parameters.f_U * parameters.i_X_U;
    state.Stoichiometry[AmmonifSolOrgN][S_NHx] := 1;
    state.Stoichiometry[AmmonifSolOrgN][S_NB] := - 1;
    state.Stoichiometry[AmmonifSolOrgN][S_Alk] := 1 / 14;
    state.Stoichiometry[HydrolEntrapOrg][S_Bs] := 1;
    state.Stoichiometry[HydrolEntrapOrg][X_B] := - 1;
    state.Stoichiometry[HydrolEntrapOrgN][S_NB] := 1;
    state.Stoichiometry[HydrolEntrapOrgN][X_NB] := - 1;
    state.Stoichiometry[FlocculatCB][C_B] := -1;
    state.Stoichiometry[FlocculatCB][X_B] := 1;
    state.Stoichiometry[FlocculatCU][C_U] := -1;
    state.Stoichiometry[FlocculatCU][X_U] := 1;
    state.Stoichiometry[HydrolXSTO][S_Bs] := 1;
    state.Stoichiometry[HydrolXSTO][X_STO] := -1;
    state.Stoichiometry[HydrolXEPS][S_Bs] := 1;
    state.Stoichiometry[HydrolXEPS][X_EPS] := -1;
    state.Stoichiometry[Aerat][S_O] := 1;

# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 2

  };

  equations <-
  {
     

    state.K_X_T = parameters.K_B_hyd * pow(parameters.theta_K_X, state.Temp_Actual - parameters.Temp_Ref);
    state.X_TSS = (state.C[X_OHO] + state.C[X_ANO] + state.C[X_U] + state.C[X_B] + state.C[X_E]) * parameters.F_TSS_COD;
    state.b_ANO_T = parameters.b_ANO * pow(parameters.theta_b_ANO, state.Temp_Actual - parameters.Temp_Ref);
    state.b_OHO_T = parameters.b_OHO * pow(parameters.theta_b_OHO, state.Temp_Actual - parameters.Temp_Ref);
    state.f_STO = parameters.f_Shunt_max * state.C[S_O] / (parameters.K_O_STO + state.C[S_O]);
    state.k_EPS_PC = state.k_EPS_SC * parameters.Y_OHO * (1 - state.k_STO_PC) / (1 + (state.k_EPS_SC * parameters.Y_OHO));
    state.k_EPS_SC = (parameters.k_EPS_max / parameters.i_CB) * (state.C[S_O] / (parameters.K_O_EPS + state.C[S_O]));
    state.k_STO_PC = state.f_STO * parameters.Y_OHO / (1 + state.f_STO * parameters.Y_OHO);
    state.k_a_T = parameters.k_a * pow(parameters.theta_k_a, state.Temp_Actual - parameters.Temp_Ref);
    state.k_h_T = parameters.q_XB_hyd * pow(parameters.theta_k_h, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_ANO_T = parameters.mu_ANO * pow(parameters.theta_mu_ANO, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_OHO_T = parameters.mu_OHO * pow(parameters.theta_mu_OHO, state.Temp_Actual - parameters.Temp_Ref);
    state.mu_OHOs_T = parameters.mu_OHOs * pow(parameters.theta_mu_OHO, state.Temp_Actual - parameters.Temp_Ref);
    state.r_ads_B = (state.C[X_OHO] + state.C[X_ANO]) * (parameters.K_SL / (state.C[C_B] / (state.C[X_OHO] + state.C[X_ANO]) + parameters.K_SL)) * (state.C[X_EPS] / (parameters.K_EPS + state.C[X_EPS]));
    state.r_ads_U = (state.C[X_OHO] + state.C[X_ANO]) * (parameters.K_SL / (state.C[C_U] / (state.C[X_OHO] + state.C[X_ANO]) + parameters.K_SL)) * (state.C[X_EPS] / (parameters.K_EPS + state.C[X_EPS]));
    state.r_dia = state.mu_OHOs_T * (state.C[S_Bs] / (parameters.K_Bs + state.C[S_Bs])) * (parameters.K_Bf / (parameters.K_Bf + state.C[S_Bf])) * (state.C[S_O] / (parameters.K_O_OHO + state.C[S_O])) * (state.C[S_NHx] / (parameters.K_NHx_OHO + state.C[S_NHx])) * state.C[X_OHO];
    state.r_dual = state.mu_OHO_T * (state.C[S_Bs] / (parameters.K_Bs + state.C[S_Bs])) * (state.C[S_O] / (parameters.K_O_OHO + state.C[S_O])) * (state.C[S_NHx] / (parameters.K_NHx_OHO + state.C[S_NHx])) * state.C[X_OHO];
    state.r_hydr_org = state.k_h_T * (state.C[X_B] / state.C[X_OHO]) / (state.K_X_T + (state.C[X_B] / state.C[X_OHO])) * ((state.C[S_O] / (parameters.K_O_OHO + state.C[S_O])) + parameters.n_hyd * (parameters.K_O_OHO / (parameters.K_O_OHO + state.C[S_O])) * (state.C[S_NOx] / (parameters.K_NOx_OHO + state.C[S_NOx]))) * state.C[X_OHO];

     

       
       
      state.S_O_Saturation = 290326 * exp(- 66.7354 + 87.4755 / ((state.Temp_Actual + 273.15) / 100.0) + 24.4526 * log((state.Temp_Actual + 273.15) / 100.0)) ;

     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.stoichiometry2.msl" 1
    state.Stoichiometry[AerGrowthOHOfast][S_Bf] := - 1 / (parameters.Y_OHO * (1 - state.k_EPS_PC - state.k_STO_PC));
    state.Stoichiometry[AerGrowthOHOfast][X_STO] := state.k_STO_PC / (parameters.Y_OHO * (1 - state.k_EPS_PC - state.k_STO_PC));
    state.Stoichiometry[AerGrowthOHOfast][X_EPS] := state.k_EPS_PC / (parameters.Y_OHO * (1 - state.k_EPS_PC - state.k_STO_PC));
    state.Stoichiometry[AerGrowthOHOslow][S_Bs] := - 1 / (parameters.Y_OHO * (1 - state.k_EPS_PC - state.k_STO_PC));
    state.Stoichiometry[AerGrowthOHOslow][X_STO] := state.k_STO_PC / (parameters.Y_OHO * (1 - state.k_EPS_PC - state.k_STO_PC));
    state.Stoichiometry[AerGrowthOHOslow][X_EPS] := state.k_EPS_PC / (parameters.Y_OHO * (1 - state.k_EPS_PC));
# 65 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.kinetics.msl" 1
 

    state.Kinetics[AerGrowthANO] = state.mu_ANO_T * (state.C[S_NHx] / (parameters.K_NHx_ANO + state.C[S_NHx])) * (state.C[S_O] / (parameters.K_O_ANO + state.C[S_O])) * state.C[X_ANO];
    state.Kinetics[AerGrowthOHOfast] = state.mu_OHO_T * (state.C[S_Bf] / (parameters.K_Bf + state.C[S_Bf])) * (state.C[S_O] / (parameters.K_O_OHO + state.C[S_O])) * (state.C[S_NHx] / (parameters.K_NHx_OHO + state.C[S_NHx])) * state.C[X_OHO];
    state.Kinetics[AerGrowthOHOslow] = parameters.f_dia * state.r_dia + (1 - parameters.f_dia) * state.r_dual;
    state.Kinetics[Aerat] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);
    state.Kinetics[AmmonifSolOrgN] = state.k_a_T * state.C[S_NB] * state.C[X_OHO];
    state.Kinetics[AnGrowthOHO] = state.mu_OHO_T * (state.C[S_Bf] / (parameters.K_Bf + state.C[S_Bf])) * (parameters.K_O_OHO / (parameters.K_O_OHO + state.C[S_O])) * (state.C[S_NOx] / (parameters.K_NOx_OHO + state.C[S_NOx])) * (state.C[S_NHx] / (parameters.K_NHx_OHO + state.C[S_NHx])) * parameters.n_g * state.C[X_OHO];
    state.Kinetics[DecayANO] = state.b_ANO_T * state.C[X_ANO];
    state.Kinetics[DecayOHO] = state.b_OHO_T * state.C[X_OHO];
    state.Kinetics[FlocculatCB] = parameters.q_ads * state.C[C_B] * state.r_ads_B;
    state.Kinetics[FlocculatCU] = parameters.q_ads * state.C[C_U] * state.r_ads_U;
    state.Kinetics[HydrolEntrapOrg] = state.r_hydr_org;
    state.Kinetics[HydrolEntrapOrgN] = state.r_hydr_org * (state.C[X_NB] / state.C[X_B]);
    state.Kinetics[HydrolXEPS] = parameters.k_EPS_hyd * state.C[X_EPS];
    state.Kinetics[HydrolXSTO] = parameters.q_STO_hyd * ((state.C[X_STO] / state.C[X_OHO]) / (parameters.K_STO_hyd + (state.C[X_STO] / state.C[X_OHO]))) * (parameters.K_Bf / (parameters.K_Bf + state.C[S_Bf])) * (parameters.K_Bs / (parameters.K_Bs + state.C[S_Bs])) * (state.C[S_O] / (parameters.K_O_OHO + state.C[S_O])) * state.C[X_OHO];

# 69 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 2


     

    
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABModel.sensors.msl" 1
 

    interface.AUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NHx] / state.V);
    interface.DO = state.C[S_O];
    interface.Kla_ASU = state.Kla_Actual;
    interface.NH4 = state.C[S_NHx];
    interface.NO3 = state.C[S_NOx];
    interface.NPR = IF (state.V == 0) THEN 0 ELSE state.Stoichiometry[AerGrowthANO][S_NOx] * state.Kinetics[AerGrowthANO];
    interface.NUR = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_NOx] / state.V) + state.Stoichiometry[AerGrowthANO][S_NOx] * state.Kinetics[AerGrowthANO];
    interface.OUR_ASU = IF (state.V == 0) THEN 0 ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + state.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
    interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_Bf] + state.C[S_Bs] + state.C[X_B] + (1 - parameters.f_U) * (state.C[X_OHO] + state.C[X_ANO]));
    interface.OfflineTKN = (state.C[S_NHx] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_OHO] + state.C[X_ANO]) + parameters.i_X_U * (state.C[X_P] + state.C[X_U]));
    interface.OnlineCOD = (state.C[S_Bf] + state.C[S_Bs] + state.C[S_U] + state.C[X_OHO] + state.C[X_ANO] + state.C[X_B] + state.C[X_U] + state.C[X_P]);
    interface.OnlineTN = (state.C[S_NOx] + state.C[S_NHx] + state.C[S_ND] + state.C[X_ND] + parameters.i_X_B * (state.C[X_OHO] + state.C[X_ANO]) + parameters.i_X_U * (state.C[X_P] + state.C[X_U]));
    interface.TSS = state.X_TSS;
    interface.V_ASU = state.V;

# 73 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\ASM1_AB/wwtp.VolumeASM1_ABConversionModel.body.msl" 2

  };

# 91 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.ASU.AStage.fixvolumeasu.msl" 2

:};


 
CLASS FixVolumeConversionModel_AStage EXTENDS WWTPAtomicModelWithVolume_AStage WITH
{:

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : ASM1_ABInWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };
  
  parameters <-  
  {
     
 
    OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
  };   
  
  state <-
  {
    OBJ Stoichiometry (* hidden = "1" *) "A-stage stoichiometry" : PhysicalQuantityType[ASM1_ABNrOfReactions;][ASM1_ABNrOfComponents,] := {: group <- "Stoichiometry" :} ;
    OBJ Kinetics (* hidden = "1" *) "A-stage kinetics" : PhysicalQuantityType[ASM1_ABNrOfReactions;] := {: group <- "_Kinetics" :};
    OBJ Kla_Actual (* is_favorite = "1" *) "Actual kLa in the tank" : OxygenTransferCoefficient := {: group <- "Operational" :};
    OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
  };

  initial <-  
  {
    state.M[ASM1_ABIndexOfSolvent] = parameters.Vol / 0.000001 ;
  };
  
  equations <-
  {
    {FOREACH Comp_Index IN {ASM1_ABIndexOfSolvent .. ASM1_ABNrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
        SUMOVER Reaction_Index IN {1 .. ASM1_ABNrOfReactions}:
         
 
        (state.Stoichiometry[Reaction_Index][Comp_Index] * state.Kinetics[Reaction_Index]) * state.V ;};

    {FOREACH Comp_Index IN {ASM1_ABIndexOfSolvent .. ASM1_ABNrOfComponents}:
      state.C[Comp_Index] = IF (state.V <= 0.0) THEN 0.0
        ELSE state.M[Comp_Index] / state.V ; };
  
    {FOREACH Comp_Index IN {ASM1_ABIndexOfSolvent .. ASM1_ABNrOfComponents}:
      interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_In ; };

    state.V = parameters.Vol ;
  };
  
:};


CLASS WWTPAtomicModelWithVolume_AStage EXTENDS WWTPAtomicModel_AStage WITH
{:

  state <-
  {
    OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Dimension" :};
    OBJ C "(state components) concentration vector" : ASM1_ABConcentrationVector := {: group <- "Concentration" :};
  };

:};


CLASS WWTPAtomicModel_AStage SPECIALISES PhysicalDAEModelType :=
{:

  independent <- 
  {
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
  };
  
  state <-
  {
         OBJ M "(state components) mass vector" : ASM1_ABMassVector 
 
 











  
  
   
 
  := [{: value <- 1000000000:}, {: value <- 17.20550289 :}, {: value <- 21.01489814 :}, {: value <- 1.199353142 :}, {: value <- 8.248260375 :},
   
  {: value <- 0.1339327707 :}, {: value <- 14.53676395 :}, {: value <- 1.14812285 :}, {: value <- 17.89451839 :},
   
  {: value <- 2.469166597 :}, {: value <- 19.98574934 :}, {: value <- 377.1885391 :}, {: value <- 86.43215147 :},
     
  {: value <- 74.46421139 :}, {: value <- 3.067400777 :}, {: value <- 0.07439595118 :}, {: value <- 1.895716105 :}, 
   
  {: value <- 0.8217210168 :},{: value <- 23.77321306 :}; ] ;
  
 
    OBJ FluxPerComponent (* hidden = "1" *) "(state components) flux vector" : ASM1_ABMassFluxVector := {: group <- "_Flux" :} ;
    OBJ InFluxPerComponent (* hidden = "1" *) "(state components) in-flux vector": ASM1_ABMassFluxVector := {: group <- "_Flux - In" :} ;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "(state components) conversion terms vector": ASM1_ABMassFluxVector := {: group <- "_Conversion" :} ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
    {FOREACH Comp_Index IN {ASM1_ABIndexOfSolvent .. ASM1_ABNrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
        (SUMOVER ASM1_ABIn_Terminal IN {SelectByType(interface,ASM1_ABInWWTPTerminal)}: ASM1_ABIn_Terminal[Comp_Index]) +
        (SUMOVER ASM1_ABOut_Terminal IN {SelectByType(interface,ASM1_ABOutWWTPTerminal)}: ASM1_ABOut_Terminal[Comp_Index]) ; };
    
    {FOREACH Comp_Index IN {ASM1_ABIndexOfSolvent .. ASM1_ABNrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) =
        state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index] ; };
    
    {FOREACH Comp_Index IN {ASM1_ABIndexOfSolvent .. ASM1_ABNrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
        SUMOVER ASM1_ABIn_Terminal IN {SelectByType(interface,ASM1_ABInWWTPTerminal)}: (ASM1_ABIn_Terminal[Comp_Index]) ; };
    
    state.Q_In = state.InFluxPerComponent[ASM1_ABIndexOfSolvent] * 1E-06 ;
  };

:};




# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.ASU.AStage.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/transformers/wwtp.transformers.AStage.msl" 1
 





















CLASS ASM1toASM1_AB  
"Translates the state vector of ASM1 components into their counterparts in ASM1_A"
SPECIALISES PhysicalDAEModelType :=
{:

  comments <- "Translates the state vector of ASM1 components into their counterparts in ASM1_A";

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow in flux" : InWWTPTerminal := {: causality <- "CIN"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT"; group <- "Effluent" :};
    OBJ f_S_Bs (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Slowly- to total biodegradable soluble organics" : Fraction := {: causality <- "CIN" ; value <- 0.589 ; group <- "Influent" :};
    OBJ f_C_B (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Colloidal biodegradable to total suspended biodegradable organics" : Fraction := {: causality <- "CIN" ; value <- 0.124 ; group <- "Influent" :};
    OBJ f_C_U (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Colloidal non-biodegradable to total suspended non-biodegradable organics" : Fraction := {: causality <- "CIN" ; value <- 0.114 ; group <- "Influent" :};
    OBJ f_X_STO (* terminal = "in_2"; manip = "1" *) "Fraction of intracellular storage polymeric substances" : Fraction := {: causality <- "CIN" ; value <- 0.0005 ; group <- "Influent" :};
    OBJ f_X_EPS (* terminal = "in_2"; manip = "1" *) "Fraction of extracellular polymeric substances" : Fraction := {: causality <- "CIN" ; value <- 0.00003 ; group <- "Influent" :};
  };

  state <-
  {
    OBJ Q_In "Flow rate" : FlowRate := {: group <- "Influent specs" :};
    OBJ C_SU "Concentration of inert soluble organic matter" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SBf "Conc. of rapidly biodegradable soluble organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SBs "Conc. of slowly biodegradable soluble organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SO "Dissolved oxygen" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SNOx "Concentration of nitrate and nitrite" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SNHx "Concentration of total ammonium nitrogen" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SNorg "Conc. of soluble biodegradable organic nitrogen" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SAlk "Alkalinity" : Concentration := {: group <- "Influent specs" :};
    OBJ C_CU "Conc. of colloidal non-biodegradable organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_CB "Conc. of colloidal biodegradable organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XU "Conc. of inert particulate organic matter" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XB "Conc. of particulate biodegradable organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XOHO "Conc. of active heterotrophic biomass" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XANO "Conc. of active autotrophic biomass" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XE "Conc. of particulate non-biodegradable endogenous products" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XEPS "Conc. of extracellular polymeric substances" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XSTO "Conc. of intracellular storage polymeric substances" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XNorg "Conc. of particulate biodegradable organic nitrogen" : Concentration := {: group <- "Influent specs" :};
  };

  independent <- 
  {
    OBJ t "Time" : Time := {: group <- "Time" :};
  };

  equations <-
  {
    state.Q_In = interface.Inflow[H2O] * 1E-06 ;
    state.C_SU = - interface.Outflow[S_U] / state.Q_In ;
    state.C_SBf = - interface.Outflow[S_Bf] / state.Q_In ;
    state.C_SBs = - interface.Outflow[S_Bs] / state.Q_In ;
    state.C_SO = - interface.Outflow[S_O] / state.Q_In ;
    state.C_SNOx = - interface.Outflow[S_NOx] / state.Q_In ;
    state.C_SNHx = - interface.Outflow[S_NHx] / state.Q_In ;
    state.C_SNorg = - interface.Outflow[S_NB] / state.Q_In ;
    state.C_SAlk = - interface.Outflow[S_Alk] / state.Q_In ;
    state.C_CU = - interface.Outflow[C_U] / state.Q_In ;
    state.C_CB = - interface.Outflow[C_B] / state.Q_In ;
    state.C_XU = - interface.Outflow[X_U] / state.Q_In ;
    state.C_XB = - interface.Outflow[X_B] / state.Q_In ;
    state.C_XOHO = - interface.Outflow[X_OHO] / state.Q_In ;
    state.C_XANO = - interface.Outflow[X_ANO] / state.Q_In ;
    state.C_XE = - interface.Outflow[X_E] / state.Q_In ;
    state.C_XEPS = - interface.Outflow[X_EPS] / state.Q_In ;
    state.C_XSTO = - interface.Outflow[X_STO] / state.Q_In ;
    state.C_XNorg = - interface.Outflow[X_NB] / state.Q_In ;
    
    interface.Outflow[H2O] = - interface.Inflow[H2O] ;
    interface.Outflow[S_Bf] = - (1 - interface.f_S_Bs) * interface.Inflow[S_S] ;
    interface.Outflow[S_Bs] = - interface.f_S_Bs * interface.Inflow[S_S] ;
    interface.Outflow[S_O] = - interface.Inflow[S_O] ;
    interface.Outflow[S_U] = - interface.Inflow[S_I] ;
    interface.Outflow[S_NOx] = - interface.Inflow[S_NO] ;
    interface.Outflow[S_NHx] = - interface.Inflow[S_NH] ;
    interface.Outflow[S_NB] = - interface.Inflow[S_ND] ;
    interface.Outflow[S_Alk] = - interface.Inflow[S_ALK] ;
    interface.Outflow[C_U] = - interface.f_C_U * interface.Inflow[X_I] ;
    interface.Outflow[X_U] = - (1 - interface.f_C_U) * interface.Inflow[X_I] ;
    interface.Outflow[C_B] = - interface.f_C_B * interface.Inflow[X_S] ;
    interface.Outflow[X_B] = - (1 - interface.f_C_B - interface.f_X_EPS) * interface.Inflow[X_S] ;
    interface.Outflow[X_OHO] = - interface.Inflow[X_BH] - 0.5 * interface.f_X_STO * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) ;
    interface.Outflow[X_ANO] = - interface.Inflow[X_BA] - 0.5 * interface.f_X_STO * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) ;
    interface.Outflow[X_E] = - interface.Inflow[X_P] ;
    interface.Outflow[X_EPS] = - interface.f_X_EPS * interface.Inflow[X_S] ;
    interface.Outflow[X_STO] = - interface.f_X_STO * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) ;
    interface.Outflow[X_NB] = - interface.Inflow[X_ND] ;
  };

:};
 
 
CLASS ASM1_ABtoASM1  
"Translates the state vector of ASM1_A components into their counterparts in ASM1"
SPECIALISES PhysicalDAEModelType :=
{:

  comments <- "Translates the state vector of ASM1_A components into their counterparts in ASM1";

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : ASM1_ABInWWTPTerminal := {: causality <- "CIN"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT"; group <- "Effluent" :};
  };
  
  state <-
  {
    OBJ Q_In "Flow rate" : FlowRate := {: group <- "Influent specs" :};
    OBJ f_OHO (* hidden = "1" *) "Fraction of active OHO" : Fraction := {: group <- "Influent specs" :};    
    OBJ C_SU "Concentration of inert soluble organic matter" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SBf "Conc. of rapidly biodegradable soluble organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SBs "Conc. of slowly biodegradable soluble organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SO "Dissolved oxygen" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SNOx "Concentration of nitrate and nitrite" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SNHx "Concentration of total ammonium nitrogen" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SNorg "Conc. of soluble biodegradable organic nitrogen" : Concentration := {: group <- "Influent specs" :};
    OBJ C_SAlk "Alkalinity" : Concentration := {: group <- "Influent specs" :};
    OBJ C_CU "Conc. of colloidal non-biodegradable organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_CB "Conc. of colloidal biodegradable organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XU "Conc. of inert particulate organic matter" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XB "Conc. of particulate biodegradable organics" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XOHO "Conc. of active heterotrophic biomass" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XANO "Conc. of active autotrophic biomass" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XE "Conc. of particulate non-biodegradable endogenous products" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XEPS "Conc. of extracellular polymeric substances" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XSTO "Conc. of intracellular storage polymeric substances" : Concentration := {: group <- "Influent specs" :};
    OBJ C_XNorg "Conc. of particulate biodegradable organic nitrogen" : Concentration := {: group <- "Influent specs" :};
  };

  independent <- 
  {
    OBJ t "Time": Time:= {: group <- "Time" :} ;
  };

  equations <-
  {
    state.f_OHO = interface.Inflow[X_OHO] / (interface.Inflow[X_OHO] + interface.Inflow[X_ANO]) ;
    state.Q_In = interface.Inflow[H2O] * 1E-06 ;
    state.C_SU = interface.Inflow[S_U] / state.Q_In ;
    state.C_SBf = interface.Inflow[S_Bf] / state.Q_In ;
    state.C_SBs = interface.Inflow[S_Bs] / state.Q_In ;
    state.C_SO = interface.Inflow[S_O] / state.Q_In ;
    state.C_SNOx = interface.Inflow[S_NOx] / state.Q_In ;
    state.C_SNHx = interface.Inflow[S_NHx] / state.Q_In ;
    state.C_SNorg = interface.Inflow[S_NB] / state.Q_In ;
    state.C_SAlk = interface.Inflow[S_Alk] / state.Q_In ;
    state.C_CU = interface.Inflow[C_U] / state.Q_In ;
    state.C_CB = interface.Inflow[C_B] / state.Q_In ;
    state.C_XU = interface.Inflow[X_U] / state.Q_In ;
    state.C_XB = interface.Inflow[X_B] / state.Q_In ;
    state.C_XOHO = interface.Inflow[X_OHO] / state.Q_In ;
    state.C_XANO = interface.Inflow[X_ANO] / state.Q_In ;
    state.C_XE = interface.Inflow[X_E] / state.Q_In ;
    state.C_XEPS = interface.Inflow[X_EPS] / state.Q_In ;
    state.C_XSTO = interface.Inflow[X_STO] / state.Q_In ;
    state.C_XNorg = interface.Inflow[X_NB] / state.Q_In ;

    interface.Outflow[H2O] = - interface.Inflow[H2O] ;  
    interface.Outflow[S_S] = - (interface.Inflow[S_Bf] + interface.Inflow[S_Bs]);
    interface.Outflow[S_O] = - interface.Inflow[S_O] ;
    interface.Outflow[S_I] = - interface.Inflow[S_U] ;
    interface.Outflow[S_NO] = - interface.Inflow[S_NOx] ;
    interface.Outflow[S_NH] = - interface.Inflow[S_NHx] ;
    interface.Outflow[S_ND] = - interface.Inflow[S_NB] ;
    interface.Outflow[S_ALK] = - interface.Inflow[S_Alk] ;
    interface.Outflow[X_I] = - (interface.Inflow[C_U] + interface.Inflow[X_U]) ;
    interface.Outflow[X_S] = - (interface.Inflow[C_B] + interface.Inflow[X_EPS] + interface.Inflow[X_B]) ;
    interface.Outflow[X_BH] = - interface.Inflow[X_OHO] + state.f_OHO * interface.Inflow[X_STO] ;
    interface.Outflow[X_BA] = - interface.Inflow[X_ANO] + (1 - state.f_OHO) * interface.Inflow[X_STO] ;
    interface.Outflow[X_P] = - interface.Inflow[X_E] ;
    interface.Outflow[X_ND] = - interface.Inflow[X_NB] ;
  };

:};






# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/activated_sludge_unit/wwtp.ASU.AStage.msl" 2



CLASS FixVolumeASU_AStage (* icon = "activated_sludge_unit" *)
SPECIALISES CoupledModelType :=
{:

  comments <- "Constant volume Activated Sludge tank for A-stage, incl. in- and out transformers from/to ASM1";

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ f_S_Bs (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Slowly- to total biodegradable soluble organics" : Fraction := {: causality <- "CIN" ; value <- 0.589 ; group <- "Influent" :};
    OBJ f_C_B (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Colloidal biodegradable to total suspended biodegradable organics" : Fraction := {: causality <- "CIN" ; value <- 0.124 ; group <- "Influent" :};
    OBJ f_C_U (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Colloidal non-biodegradable to total suspended non-biodegradable organics" : Fraction := {: causality <- "CIN" ; value <- 0.114 ; group <- "Influent" :};
 
    OBJ f_X_STO (* terminal = "in_2"; manip = "1" *) "Fraction of intracellular storage polymeric substances" : Fraction := {: causality <- "CIN" ; value <- 0.0005 ; group <- "Influent" :};
    OBJ f_X_EPS (* terminal = "in_2"; manip = "1" *) "Fraction of extracellular polymeric substances" : Fraction := {: causality <- "CIN" ; value <- 0.00003 ; group <- "Influent" :};
    OBJ Temp (* terminal = "in_2"; manip = "1"; *) "Temperature of the activated sludge" : CelsiusTemperature := {: causality <- "CIN"; value <- 15 ; group <- "Operational" :};
    OBJ Kla (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient := {: causality <- "CIN"; value <- 0 ; group <- "Operational" :};
     
    OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate" : AmmoniumUptakeRate := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ DO (* is_favorite = "1"; terminal = "out_2" *) "Dissolved oxygen concentration" : DissolvedOxygen := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ Kla_ASU (* terminal = "out_2" *) "Kla" : OxygenTransferCoefficient := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate" : NitrateProductionRate := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate" : NitrateUptakeRate := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ OUR_ASU (* terminal = "out_2" *) "Oxygen Uptake Rate" : OxygenUptakeRate := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ BOD (* terminal = "out_2" *) "Biological Oxygen Demand" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ TKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ COD (* terminal = "out_2" *) "Chemical Oxygen Demand" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ TN (* terminal = "out_2" *) "Total nitrogen concentration" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ TSS (* is_favorite = "1"; terminal = "out_2" *) "Total suspended solids" : Concentration := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ V_ASU (* terminal = "out_2" *) "Volume" : Volume := {: causality <- "COUT"; group <- "Measurement data"; :};
    OBJ AerationEnergy (* terminal = "out_2" *) "Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ AerationPower (* terminal = "out_2" *) "Aeration power" : Power := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *) "Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingPower (* terminal = "out_2" *) "Mixing power" : Power := {: causality <- "COUT"; group <- "Energy" :};
  };

  parameters <-
  {
    
    OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {: unit <- "-"; value <- 0.65; group <- "Conversion factors"; :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: unit <- "-"; value <- 0.75; group <- "Conversion factors"; :};
    OBJ i_CB (* *) "Biomass COD to VSS ratio (for X_OHO)" : Ratio := {: value <- 1.42; group <- "Composition parameters"; :};
 
    OBJ i_X_B (* *) "Nitrogen content of biomass" : MassOfNitrogenPerMassOfCODInBiomass := {: unit <- "gN/gCOD"; value <- 0.086; group <- "Composition parameters"; :};
    OBJ i_X_U (* *) "Nitrogen content of product from biomass" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: unit <- "gN/gCOD"; value <- 0.06; group <- "Composition parameters"; :};
    OBJ f_U (* *) "Fraction of X_U generated in biomass decay" : FractOfBiomassLeadingToPartProd := {: value <- 0.08; group <- "Stoichiometry"; :};
    OBJ f_dia (* *) "Dual substrate (0) vs. diauxic (1) model for S_Bs uptake" : Integer := {: value <- 0; interval <- {: lowerBound <- 0; upperBound <- 1; :}; group <- "Kinetics"; :};
    OBJ f_Shunt_max (* *) "Fraction of X_STO in the active biomass" : Real := {: unit <- "-"; value <- 0.30; group <- "Kinetics"; :};
    OBJ Y_ANO "Yield for ANOs growth per S_NO3" : YieldForAutotrophicBiomass := {: value <- 0.24; group <- "Stoichiometry"; :};
 
 
    OBJ Y_OHO "Yield for OHOs growth" : YieldForHeterotrophicBiomass := {: value <- 0.67; group <- "Stoichiometry"; :};
 
    OBJ mu_ANO (* *) "Max specific growth rate of ANOs" : MaxSpecifGrowthRateAutotr := {: value <- 0.8; group <- "Kinetics - ANO growth and decay"; :};
    OBJ mu_OHO (* *) "Max specific growth rate of OHOs" : MaxSpecifGrowthRateHetero := {: value <- 7; group <- "Kinetics - OHO growth and decay"; :};
    OBJ mu_OHOs (* *) "Max specific growth rate of OHOs on S_Bs" : MaxSpecifGrowthRateHetero := {: value <- 3; group <- "Kinetics - OHO growth and decay"; :};
    OBJ b_ANO (* *) "Decay rate for ANO" : DecayCoeffAutotr := {: value <- 0.15; group <- "Kinetics - ANO growth and decay"; :};
    OBJ b_OHO (* *) "Decay rate for OHO" : DecayCoeffHeterotr := {: value <- 0.62; group <- "Kinetics - OHO growth and decay"; :};
 
 
    OBJ q_STO_hyd (* *) "Rate constant for storage hydrolysis" : RateConstant := {: value <- 3.0; group <- "Kinetics - hydrolysis"; :};
 
    OBJ q_XB_hyd (* *) "Maximum specific hydrolysis rate" : MaxSpecificHydrolysisRate := {: value <- 3.5; group <- "Kinetics - hydrolysis"; :};
 
    OBJ q_ads (* *) "Rate constant for adsorption" : RateConstant := {: value <- 0.07; group <- "Kinetics - adsorption"; :};
 
    OBJ K_B_hyd (* *) "Half saturation coefficient for hydrolysis of slowly biodegradable substrate" : HalfSatCoeffForHydrolysis := {: value <- 0.03; group <- "Kinetics - hydrolysis"; :};
 
    OBJ K_Bf (* *) "S_Bf half-saturation coeff for OHO" : HalfSatCoeffForHetero := {: value <- 5; group <- "Kinetics - OHO growth and decay"; :};
    OBJ K_Bs (* *) "S_Bs half-saturation coeff for OHO" : HalfSatCoeffForHetero := {: value <- 40; group <- "Kinetics - OHO growth and decay"; :};
 
    OBJ K_EPS (* *) "Half-saturation coefficient for EPS (X_OHO)" : HalfSatCoeffForHetero := {: value <- 50; group <- "Kinetics - hydrolysis"; :};
    OBJ K_NHx_ANO (* *) "Half-saturation coefficient of ANOx for ammonium" : AmmonHalfSatCoeffForAutotr := {: value <- 1; group <- "Kinetics - ANO growth and decay"; :};
    OBJ K_NHx_OHO (* *) "Saturation coeff of heterotrophs for ammonium" : SaturationCoefficient := {: value <- 0.05; group <- "Kinetics - OHO growth and decay"; :};
    OBJ K_NOx_OHO (* *) "Nitrate half-saturation coefficient for denitrifying OHO" : NitrateHalfSatCoeffForDenitrifHetero := {: value <- 0.5; group <- "Kinetics - OHO growth and decay"; :};
    OBJ K_O_ANO (* *) "Oxygen half-saturation coeff for ANO" : OxygenHalfSatCoeffForAutotr := {: value <- 0.4; group <- "Kinetics - ANO growth and decay"; :};
    OBJ K_O_EPS (* *) "Oxygen half-saturation coefficient" : OxygenHalfSatCoeffForHetero := {: value <- 1.5; group <- "Kinetics - EPS"; :};
 
    OBJ K_O_OHO (* *) "Oxygen half-saturation coeff for OHO" : OxygenHalfSatCoeffForHetero := {: value <- 0.1; group <- "Kinetics - OHO growth and decay"; :};
 
    OBJ K_O_STO (* *) "Oxygen half-saturation coefficient for storage" : OxygenHalfSatCoeffForHetero := {: value <- 1; group <- "Kinetics - OHO growth and decay"; :};
    
    OBJ K_SL (* *) "Half saturation coefficient for surface limitation" : HalfSatCoeffForHetero := {: value <- 0.002; group <- "Kinetics - adsorption"; :};
    OBJ K_STO_hyd (* *) "Hydrolysis half-saturation coefficient for X_STO (X_OHO)" : HalfSatCoeffForHydrolysis := {: value <- 0.15; group <- "Kinetics - hydrolysis"; :};
 
    OBJ k_EPS_max (* *) "EPS formation coefficient" : Ratio := {: value <- 0.25; group <- "Kinetics - EPS"; :};
    OBJ k_a (* *) "Maximum specific ammonification rate" : AmmonificationRate := {: value <- 0.08; group <- "Kinetics - ammonification"; :};
    OBJ n_g (* *) "Reduction factor for anoxic growth of OHOs" : CorrectionFactor := {: value <- 0.8; group <- "Kinetics - OHO growth and decay"; :};
    OBJ n_hyd (* *) "Correction factor for anoxic hydrolysis" : CorrectionFactor := {: value <- 0.4; group <- "Kinetics - hydrolysis"; :};
    OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
  };

  sub_models <-
  {
    OBJ Trans_In : ASM1toASM1_AB ;
    OBJ Tank : FixVolumeASU_AStage_Single ;
    OBJ Trans_Out : ASM1_ABtoASM1 ;
  };

   coupling <-
  {
    connect(interface.Inflow, sub_models.Trans_In.interface.Inflow),
    connect(sub_models.Trans_In.interface.Outflow, sub_models.Tank.interface.Inflow),
    connect(sub_models.Tank.interface.Outflow, sub_models.Trans_Out.interface.Inflow),
    connect(sub_models.Trans_Out.interface.Outflow, interface.Outflow),

    sub_models.Tank.parameters.F_BOD_COD.value := parameters.F_BOD_COD.value,
    sub_models.Tank.parameters.F_TSS_COD.value := parameters.F_TSS_COD.value,
    sub_models.Tank.parameters.i_CB.value := parameters.i_CB.value,
 
    sub_models.Tank.parameters.i_X_B.value := parameters.i_X_B.value,
    sub_models.Tank.parameters.i_X_U.value := parameters.i_X_U.value,
 
 
    sub_models.Tank.parameters.Y_OHO.value := parameters.Y_OHO.value,
    sub_models.Tank.parameters.Y_ANO.value := parameters.Y_ANO.value,
 
    sub_models.Tank.parameters.mu_OHO.value := parameters.mu_OHO.value,
    sub_models.Tank.parameters.mu_OHOs.value := parameters.mu_OHOs.value,
    sub_models.Tank.parameters.mu_ANO.value := parameters.mu_ANO.value,
    sub_models.Tank.parameters.b_OHO.value := parameters.b_OHO.value,
    sub_models.Tank.parameters.b_ANO.value := parameters.b_ANO.value,
 
 
    sub_models.Tank.parameters.q_STO_hyd.value := parameters.q_STO_hyd.value,
    sub_models.Tank.parameters.q_XB_hyd.value := parameters.q_XB_hyd.value,
    sub_models.Tank.parameters.q_ads.value := parameters.q_ads.value,
 
    sub_models.Tank.parameters.K_B_hyd.value := parameters.K_B_hyd.value,
    sub_models.Tank.parameters.K_Bs.value := parameters.K_Bs.value,
    sub_models.Tank.parameters.K_Bf.value := parameters.K_Bf.value,
    sub_models.Tank.parameters.K_EPS.value := parameters.K_EPS.value,
    sub_models.Tank.parameters.K_NHx_ANO.value := parameters.K_NHx_ANO.value,
    sub_models.Tank.parameters.K_NHx_OHO.value := parameters.K_NHx_OHO.value,
    sub_models.Tank.parameters.K_NOx_OHO.value := parameters.K_NOx_OHO.value,
    sub_models.Tank.parameters.K_O_EPS.value := parameters.K_O_EPS.value,
    sub_models.Tank.parameters.K_O_ANO.value := parameters.K_O_ANO.value,
    sub_models.Tank.parameters.K_O_OHO.value := parameters.K_O_OHO.value,
    sub_models.Tank.parameters.K_O_STO.value := parameters.K_O_STO.value,
    sub_models.Tank.parameters.K_SL.value := parameters.K_SL.value,
    sub_models.Tank.parameters.K_STO_hyd.value := parameters.K_STO_hyd.value,
    sub_models.Tank.parameters.f_U.value := parameters.f_U.value,
    sub_models.Tank.parameters.f_dia.value := parameters.f_dia.value,
    sub_models.Tank.parameters.f_Shunt_max.value := parameters.f_Shunt_max.value,
    sub_models.Tank.parameters.k_EPS_max.value := parameters.k_EPS_max.value,
    sub_models.Tank.parameters.k_a.value := parameters.k_a.value,
    sub_models.Tank.parameters.n_g.value := parameters.n_g.value,
    sub_models.Tank.parameters.n_hyd.value := parameters.n_hyd.value,
    sub_models.Tank.parameters.OTR_Energy.value := parameters.OTR_Energy.value,
    sub_models.Tank.parameters.Vol.value := parameters.Vol.value,

     
    connect(interface.f_S_Bs, sub_models.Trans_In.interface.f_S_Bs),
    connect(interface.f_C_B, sub_models.Trans_In.interface.f_C_B),
    connect(interface.f_C_U, sub_models.Trans_In.interface.f_C_U),
    connect(interface.f_X_STO, sub_models.Trans_In.interface.f_X_STO),
    connect(interface.f_X_EPS, sub_models.Trans_In.interface.f_X_EPS),
     
    connect(interface.Temp, sub_models.Tank.interface.Temp),
    connect(interface.Kla, sub_models.Tank.interface.Kla),
     
    connect(sub_models.Tank.interface.AUR, interface.AUR),
    connect(sub_models.Tank.interface.DO, interface.DO),
    connect(sub_models.Tank.interface.Kla_ASU, interface.Kla_ASU),
    connect(sub_models.Tank.interface.NH4, interface.NH4),
    connect(sub_models.Tank.interface.NO3, interface.NO3),
    connect(sub_models.Tank.interface.NPR, interface.NPR),
    connect(sub_models.Tank.interface.NUR, interface.NUR),
    connect(sub_models.Tank.interface.OUR_ASU, interface.OUR_ASU),
     
    connect(sub_models.Tank.interface.OfflineBOD, interface.BOD),
    connect(sub_models.Tank.interface.OfflineTKN, interface.TKN),
    connect(sub_models.Tank.interface.OnlineCOD, interface.COD),
    connect(sub_models.Tank.interface.OnlineTN, interface.TN),
     
     
     
     
    connect(sub_models.Tank.interface.TSS, interface.TSS),
    connect(sub_models.Tank.interface.V_ASU, interface.V_ASU),
    connect(sub_models.Tank.interface.AerationEnergy, interface.AerationEnergy),
    connect(sub_models.Tank.interface.AerationPower, interface.AerationPower),
    connect(sub_models.Tank.interface.MixingEnergy, interface.MixingEnergy),
    connect(sub_models.Tank.interface.MixingPower, interface.MixingPower),
  };

:};





# 83 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.Astage.splitters.combiners.msl" 1
 









CLASS A_AtomicModelWithoutVolume SPECIALISES PhysicalDAEModelType :=
{:

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
  };

  state <-
  {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : ASM1_ABMassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
    {FOREACH Comp_Index IN {1 .. ASM1_ABNrOfComponents}: state.InFluxPerComponent[Comp_Index] =
      SUMOVER In_Terminal IN {SelectByType(interface, ASM1_ABInWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };
    
    state.Q_In = 1E-06 * state.InFluxPerComponent[1] ;
  };

:};


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.Astage.twosplitter.msl" 1
 














CLASS A_2Splitter_Valve (* icon = "two_fraction_splitter" *) "Relative 2-way splitter for ASM1 A-stage only"
EXTENDS A_AtomicModelWithoutVolume WITH
{:

  comments <- "Relative 2-way splitter for ASM1 A-stage only" ;
  
  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : ASM1_ABInWWTPTerminal := {: causality <- "CIN" ; group <- "Influent":};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1":};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2":};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : Fraction := {: causality <- "CIN" ; value <- 0.9; group <- "Operational" :};
  };
  
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
  };
  
  equations <-
  {
    {FOREACH Comp_Index IN {1 .. ASM1_ABNrOfComponents}: interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0) THEN - state.InFluxPerComponent[Comp_Index] * interface.f_Out2
      ELSE - state.InFluxPerComponent[Comp_Index] ; };   
  
    {FOREACH Comp_Index IN {1 .. ASM1_ABNrOfComponents}:
      interface.Outflow1[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] ; };  
  
    state.Q_Out1 = - interface.Outflow1[1] * 1E-06 ;
    state.Q_Out2 = - interface.Outflow2[1] * 1E-06 ;
  }; 

:};


CLASS A_2Splitter_Flow (* icon = "two_flow_splitter" *) "Absolute 2-way splitter for ASM1 A-stage only"
EXTENDS A_2Splitter_Flow_Base WITH
{:
  comments <- "Absolute 2-way splitter for ASM1 A-stage only";

  interface <-
  { 
    OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };

  parameters <- 
  { 
     
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };
  
  state <-
  {
     
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };
  
  initial <-
  {
    state.Integ_PE = 0.0 ;
  };
  
  equations <-
  {
     
     
    interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Out2_Actual ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  }; 

:};


CLASS A_2Splitter_Flow_Base (* icon = "two_flow_splitter" *) "Base class for an absolute 2-way splitter for ASM1 A-stage only"
EXTENDS A_AtomicModelWithoutVolume WITH
{:

  comments <- "Base class for an absolute 2-way splitter for ASM1 A-stage only";

  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : ASM1_ABInWWTPTerminal := {: causality <- "CIN" ; group <- "Influent":};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1":};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2":};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired flow rate (outflow #2)" : FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
     
    OBJ Q_Op1 (* terminal = "out_3" *) "Actual operating flow rate no.1" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
    OBJ Q_Op2 (* terminal = "out_3" *) "Actual operating flow rate no.2" : FlowRate := {: causality <- "COUT"; group <- "Operational" :};
  };

  state <-
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate := {: group <- "Operational" :};
  };
  
  equations <-
  {
    state.Q_Out1 = IF(interface.Q_Out2 > state.Q_In) THEN 0.0
      ELSE state.Q_In - state.Q_Out2_Actual ;
    
    state.Q_Out2_Actual = IF(interface.Q_Out2 > state.Q_In) THEN state.Q_In
      ELSE interface.Q_Out2;
    
    state.f_Out2 = IF (state.Q_In == 0) THEN 0.0
      ELSE state.Q_Out2_Actual / state.Q_In ;
    
    {FOREACH Comp_Index IN {1 .. ASM1_ABNrOfComponents}:
      interface.Outflow1[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out2) ;};
    
    {FOREACH Comp_Index IN {1 .. ASM1_ABNrOfComponents}:
      interface.Outflow2[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

     
    interface.Q_Op1 = state.Q_Out1 ;
    interface.Q_Op2 = state.Q_Out2_Actual ;
  }; 

:};






# 36 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.Astage.splitters.combiners.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.Astage.threecombiner.msl" 1
 














CLASS A_3Combiner (* icon = "three_combiner" *) "3-way combiner for ASM1 A-stage only"
EXTENDS A_AtomicModelWithoutVolume WITH
{:

  comments <- "3-way combiner for ASM1 A-stage only";
  
  interface <-
  { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : ASM1_ABInWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : ASM1_ABInWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : ASM1_ABInWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
  };
 
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   

  equations <-
  {
    {FOREACH Comp_Index IN {1 .. ASM1_ABNrOfComponents}: interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   
    
    state.Q_In1 = interface.Inflow1[1] * 1E-06 ;
    state.Q_In2 = interface.Inflow2[1] * 1E-06 ;
    state.Q_In3 = interface.Inflow3[1] * 1E-06 ;
    
    state.Q_Out = 1E-06 * state.InFluxPerComponent[1] ;
  }; 

:};






# 37 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/splitter_combiner/wwtp.Astage.splitters.combiners.msl" 2




# 84 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/secondary_clarifier/wwtp.clarifier.AStage.pointsettler.msl" 1
 





















CLASS SecondaryPointSettler_AStage (* icon = "secondary_clarifier" *) "Point-settler model for secondary clarifier, in the scope of ASM1 A-stage"
EXTENDS PointSettler_AStage WITH
{:

  comments <- "Point-settler model for secondary clarifier, in the scope of ASM1 A-stage";

  parameters <-
  {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.6 ; group <- "Settling" :};
  };
  
  equations <-
  {
    state.f_ns_help = IF (state.Q_Under_Actual > 0) THEN parameters.f_ns
      ELSE 1 ;
  };

:};

CLASS PointSettler_AStage "Point-settler for A-stage state vector" EXTENDS BaseSettler_AStage WITH
{:

  comments <- "Point-settler for A-stage state vector";

  state <-
  {
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     
    OBJ f_ns_help (* hidden = "1" *) "Non-settleable fraction of suspended solids" : Fraction ;
  };

  equations <-
  {
    state.f_Out = IF (state.Q_In <= interface.Q_Under) THEN 0.0
      ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;
    
    state.f_Under = IF (state.Q_In <= interface.Q_Under) THEN 1.0
      ELSE interface.Q_Under / state.Q_In ;

    {FOREACH Comp_Index IN {1 .. ASM1_ABIndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out ; };
    
    {FOREACH Comp_Index IN {ASM1_ABIndexOfFirstSolubleComponent .. ASM1_ABIndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Under ; };

    {FOREACH Comp_Index IN {ASM1_ABIndexOfFirstParticulateComponent .. ASM1_ABIndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * state.f_Out * state.f_ns_help ; };   
    
    {FOREACH Comp_Index IN {ASM1_ABIndexOfFirstParticulateComponent .. ASM1_ABIndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = IF (state.Q_In <= interface.Q_Under) THEN
        IF (state.Q_In <= 0.0) THEN 0.0
          ELSE - state.InFluxPerComponent[Comp_Index]
        ELSE - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]) ; };

    
      state.Help_X_Out = (SUMOVER Comp_Index IN {ASM1_ABIndexOfFirstTSSComponent .. ASM1_ABIndexOfLastTSSComponent}:
      - interface.Outflow[Comp_Index] ) ;
      
      state.X_Out = IF (state.Q_In <= interface.Q_Under) THEN 0.0
        ELSE state.Help_X_Out / (state.Q_In - interface.Q_Under) * parameters.F_TSS_COD ;
      
      state.Help_X_Under = (SUMOVER Comp_Index IN {ASM1_ABIndexOfFirstTSSComponent .. ASM1_ABIndexOfLastTSSComponent}:
        - interface.Underflow[Comp_Index] ) ;
      
      state.X_Under = IF (state.Q_In <= interface.Q_Under) THEN
        IF (state.Q_In <= 0.0) THEN 0.0
          ELSE state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
        ELSE IF (interface.Q_Under <= 0.0) THEN 0.0
          ELSE state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
    
   };

:};

CLASS BaseSettler_AStage SPECIALISES PhysicalDAEModelType :=
{:

  interface <-
  { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : ASM1_ABInWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : ASM1_ABOutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
    OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ PumpingPower (* terminal = "out_3" *) "Pumping power" : Real := {: causality <- "COUT"; unit <- "kWh/d" ; group <- "Energy" :};
  };
  
  parameters <- 
  { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
     
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : EnergyForPumping := {: value <- 0.04 ; group <- "Energy":};
  };

  state <-
  {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : ASM1_ABMassFluxVector ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
     
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
  };

  initial <-
  {
    state.Integ_PE = 0.0 ;
  };
  
  equations <-
  {
    {FOREACH Comp_Index IN {1 .. ASM1_ABNrOfComponents}: state.InFluxPerComponent[Comp_Index] =
      SUMOVER In_Terminal IN {SelectByType(interface,ASM1_ABInWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };
    
    state.Q_In = 1E-06 * state.InFluxPerComponent[1] ;
  
    state.Q_Out = state.Q_In - state.Q_Under_Actual;
  
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under) THEN state.Q_In
     ELSE interface.Q_Under ; 
  
 
      {state.SolidFlux_In =
        SUMOVER Comp_Index IN {ASM1_ABIndexOfFirstTSSComponent .. ASM1_ABIndexOfLastTSSComponent}:
        state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ;
      };
 
    
    state.X_In = IF (state.Q_In <= 0.0) THEN 0.0
      ELSE state.SolidFlux_In / state.Q_In ;

    interface.Underflow[1] = - state.Q_Under_Actual / 1E-06 ;

     
     
    interface.PumpingPower = parameters.F_Energy_FlowRate * state.Q_Under_Actual ;
    DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual ;
    interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };
  
:};






# 85 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\WWTP/wwtp.main.msl" 2



# 31 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl" 2


# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.main.msl" 1
 




















# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.general.msl" 1
 


















# 43 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.general.msl"



# 22 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.definitions.msl" 1
 






























# 23 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.main.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.reactions.msl" 1
 






























# 24 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.main.msl" 2


# 35 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\River/river.main.msl"




# 33 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl" 2

 
 
# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\temp_models.msl" 1
 






















# 36 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\temp_models2.msl" 1
 






















# 37 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl" 2

# 1 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\temp_models3.msl" 1
 






















# 38 "C:\\Users\\cgomezco\\OneDrive - UGent\\Documents\\GitHub\\AutomaticRecalibration\\Recalibration_Eindhoven\\blocks\\MSL\\Models\\west.msl" 2

