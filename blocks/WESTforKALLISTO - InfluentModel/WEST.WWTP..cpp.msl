# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl"
 














 



# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\generic.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\generic.base.msl" 1
 


















 
 
 
 
 
 
 
 
 
 
 

 TYPE Generic "builtin: type variable";
  
  
  

 TYPE Integer "builtin: positive and negative Natural Numbers";

 TYPE Real "builtin: Real numbers";

 TYPE Char "builtin: ASCII character";

 TYPE String 
  "builtin: Char* (implemented as atomic type for efficiency reasons)";

 TYPE Bottom "builtin: bottom type" = ENUM {null};
  
  
  
  

 TYPE Boolean "builtin: Logic type" = ENUM {True, False};

 
 
 

 TYPE TypeDeclarationType
 "builtin: type of TYPE declaration statement";
 TYPE ClassDeclarationType
 "builtin: type of CLASS declaration statement";

 TYPE ObjectDeclarationType
 "builtin: type of OBJ declaration statement";

 TYPE DeclarationType
 "type of a declaration (TYPE, CLASS, or OBJ) statement"
 = UNION {TypeDeclarationType, ClassDeclarationType, ObjectDeclarationType};

 TYPE ExpressionType
 "builtin: type of expressions";

 TYPE EquationType
 "builtin: type of equations";

 TYPE GenericIntervalType
 "Generic Interval"
 
 
 
 = RECORD 
   {
    lowerBound: Generic;   
    upperBound: Generic;   
    lowerIncluded: Boolean;
    upperIncluded: Boolean;
   };

 TYPE RealIntervalType "Interval of real numbers"
 SUBSUMES GenericIntervalType =
 RECORD 
 {
  lowerBound: Real;  
  upperBound: Real;  
  lowerIncluded: Boolean;
  upperIncluded: Boolean;
 };

 
 
 

 TYPE UnitType 
 "The type of physical units. For the time being, a string"
 = String;

 TYPE QuantityType
 "The different physical quantities. For the time being, string"
 = String;

 TYPE CausalityType
 " Causality of entities"
 
 
 
 
 = ENUM {CIN, COUT, CINOUT};

 TYPE PhysicalNatureType
 "The nature of physical variables FIELD is used (in the physicalDAE context) to denote parameters and constants"
 = ENUM {ACROSS, THROUGH, FIELD};

 TYPE PhysicalQuantityType 
 "The type of any physical quantity" 
 =
 RECORD
 {
  quantity   : QuantityType;
  unit       : UnitType;
  interval   : RealIntervalType;
  value      : Real;
  causality  : CausalityType;
  nature     : PhysicalNatureType;
 };

  
  
  

 TYPE InterfaceDeclarationType
 "declarations within an interface" = DeclarationType;

 TYPE ParameterDeclarationType
 "declarations within parameter section" = DeclarationType;

 TYPE ModelDeclarationType
 "declarations within sub_models section" = DeclarationType;

 TYPE CouplingStatementType
 "parameter coupling and connect() statements" = EquationType;

 TYPE GenericModelType 
 "The signature of the generic part of any (whatever the formalism) model"
 = 
 RECORD
 { 
  comments   : String;
  interface  : SET_OF (InterfaceDeclarationType); 
    
  parameters : SET_OF (ParameterDeclarationType); 
    
 };

 TYPE DAEModelType 
 "The signature of a Differential Algebraic Equation (DAE) model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };
 
 TYPE PhysicalDAEModelType 
 "The signature of a physicalDAEModelType model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };

 TYPE CoupledModelType "The signature of a coupled (network) model"
 EXTENDS GenericModelType WITH
 RECORD
 {
  sub_models : SET_OF (ModelDeclarationType);
  coupling   : SET_OF (CouplingStatementType);
 };
  

# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\generic.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\generic.quantity.si.msl" 1
 


















 
 
 
 
 

 

   CLASS Angle
   "A class for angle"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Angle";
    unit      <- "rad";
    displayunit <- "deg";
   :};

   CLASS SolidAngle
   "A class for SolidAngle"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SolidAngle";
    unit      <- "sr";
   :};

   TYPE StringType
   "The class for all kind of strings + some extra's"
   =
   RECORD
   {
    quantity   : QuantityType;
    value      : String;
    unit       : UnitType;
   };

   CLASS Date
   "A class for date"
   SPECIALISES StringType :=
   {:
    quantity  <- "Date";
   :};

   CLASS Time
   "A class for time"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Time";
    unit      <- "d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

   CLASS Length
   "A class for Length"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Length";
    unit      <- "m";
   :};

   CLASS Area
   "A class for Area"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Area";
    unit      <- "m2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS Volume
   "Volume"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Volume";
    unit      <- "m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS AngularVelocity
   "A class for AngularVelocity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AngularVelocity";
    unit      <- "rad/d";
   :};

   CLASS Velocity
   "A class for Velocity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Velocity";
    unit      <- "m/d";
   :};

 
 
 

   CLASS Rate
   "A class for rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Rate";
    unit      <- "dUnit/dt";
   :};

   CLASS FlowRate
   "Flow rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity <- "FlowRate";
    unit     <- "m3/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
 
 

   CLASS Ratio
   "A class for ratio"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Ratio";
    unit      <- "dUnit/dUnit";
   :};

   CLASS AngularAcceleration
   "A class for AngularAcceleration"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AngularAcceleration";
    unit      <- "rad/d2";
   :};

   CLASS Acceleration
   "A class for Acceleration"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Acceleration";
    unit      <- "m/d2";
   :};

 

   CLASS Frequency
   "The type of frequency"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Frequency";
    unit      <- "Hz";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 

   CLASS Mass
   "A class for Mass"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SludgeMass
   "Sludge production"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "SludgeMass";
   unit     <- "kg SS";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};

   CLASS SludgePerDay
   "Sludge production"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "SludgePerDay";
   unit     <- "kg SS/d";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};
 
   CLASS Density
   "A class for Density"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Density";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SurfaceDensity
   "A class for Areal Density"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Areal Density";
    unit      <- "g/m2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};
   
   CLASS SpecificVolume
   "Specific volume ((density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificVolume";
    unit      <- "m3/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS SpecificArea
   "Specific area ((surface density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificArea";
    unit      <- "m2/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

      CLASS SpecificLength
   "Specific length ((length density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificLength";
    unit      <- "m/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   
   CLASS LinearDensity
   "A class for LinearDensity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LinearDensity";
    unit      <- "g/m";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS MomentOfInertia
   "A class for MomentOfInertia"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MomentOfInertia";
    unit      <- "g*m2";
   :};

   CLASS Momentum
   "A class for Momentum"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g*m/d";
   :};

   CLASS Force
   "A class for Force"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Force";
    unit      <- "N";
   :};

   CLASS AngularMomentum
   "A class for AngularMomentum"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g*m2/d";
   :};

   CLASS MomentOfForce
   "A class for MomentOfForce"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MomentOfForce";
    unit      <- "N*m";
   :};

   CLASS PressureDifference
   "A class for Pressure"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "Pa";
    interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF; :};
   :};

   
   CLASS Pressure
   "A class for Pressure"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "Pa";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS NormalStress
   "A class for NormalStress"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "NormalStress";
    unit      <- "Pa";
   :};

   CLASS Diffusivity
   "A class for Diffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Diffusivity";
    unit      <- "m2/d";
   :};

   CLASS DynamicViscosity
   "A class for DynamicViscosity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "DynamicViscosity";
    unit      <- "Pa*d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS KinematicViscosity
   "A class for KinematicViscosity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "KinematicViscosity";
    unit      <- "m2/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SurfaceTension
   "A class for SurfaceTension"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SurfaceTension";
    unit      <- "N/m";
   :};
   
   CLASS Energy
   "A class for Energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Energy";
    unit      <- "J";
   :};

   CLASS Power
   "A class for Power"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Power";
    unit      <- "W";
   :};

   CLASS EnergyIndex
   "Aeration and Pumping energy"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "EnergyIndex";
   unit     <- "kWh/d";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};

   CLASS FiltrationResistance SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "filtration resistance";
    unit      <- "1/m";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

   CLASS SpecificAreaVolume
   "Mass per time unit"
   SPECIALISES PhysicalQuantityType :=
   {:
   quantity  <- "specific area per volume";
   unit      <- "1/m";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
   CLASS KelvinTemperature
   "A class for KelvinTemperature"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity    <- "KelvinTemperature";
    unit        <- "K";
    interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS CelsiusTemperature
   "A class for CelsiusTemperature"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CelsiusTemperature";
    unit      <- "degC";
    interval  <- {: lowerBound <- -273.15; upperBound <- PLUS_INF; :};
   :};

   CLASS LinearExpansionCoefficient
   "A class for LinearExpansionCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LinearExpansionCoefficient";
    unit      <- "1/K";
   :};

   CLASS CubicExpansionCoefficient
   "A class for CubicExpansionCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CubicExpansionCoefficient";
    unit      <- "1/K";
   :};

   CLASS RelativePressureCoefficient
   "A class for RelativePressureCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RelativePressureCoefficient";
    unit      <- "1/K";
   :};

   CLASS PressureCoefficient
   "A class for PressureCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PressureCoefficient";
    unit      <- "Pa/K";
   :};

   CLASS IsothermalCompressibility
   "A class for IsothermalCompressibility"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsothermalCompressibility";
    unit      <- "1/Pa";
   :};

   CLASS IsentropicCompressibility
   "A class for IsentropicCompressibility"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsentropicCompressibility";
    unit      <- "1/Pa";
   :};

   CLASS Heat = Energy;

   CLASS HeatFlowRate
   "A class for HeatFlowRate"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "HeatFlowRate";
    unit      <- "W";
   :};

   CLASS DensityOfHeatFlowRate
   "A class for DensityOfHeatFlowRate"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "DensityOfHeatFlowRate";
    unit      <- "W/m2";
   :};

   CLASS ThermalConductivity
   "A class for ThermalConductivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalConductivity";
    unit      <- "W/(m*K)";
   :};

   CLASS CoefficientOfHeatTransfer
   "A class for CoefficientOfHeatTransfer"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CoefficientOfHeatTransfer";
    unit      <- "W/(m2*K)";
   :};

   CLASS SurfaceCoefficientOfHeatTransfer
   "A class for SurfaceCoefficientOfHeatTransfer"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SurfaceCoefficientOfHeatTransfer";
    unit      <- "W/(m2*K)";
   :};

   CLASS ThermalInsulance
   "A class for ThermalInsulance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalInsulance";
    unit      <- "m2*K/W";
   :};

   CLASS ThermalResistance
   "A class for ThermalResistance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalResistance";
    unit      <- "K/W";
   :};

   CLASS ThermalConductance
   "A class for ThermalConductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalConductance";
    unit      <- "W/K";
   :};

   CLASS ThermalDiffusivity
   "A class for ThermalDiffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalDiffusivity";
    unit      <- "m2/d";
   :};

   CLASS HeatCapacity
   "A class for HeatCapacity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "HeatCapacity";
    unit      <- "J/K";
   :};

   CLASS SpecificHeatCapacity
   "A class for SpecificHeatCapacity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificHeatCapacity";
    unit      <- "J/(g*K)";
   :};

 
 
 

   CLASS RatioOfspecificHeatCapacities
   "A class for RatioOfSpecificHeatCapacities"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RatioOfSpecificHeatCapacities";
    unit      <- "-";
   :};

   CLASS IsentropicExponent
   "A class for IsentropicExponent"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsentropicExponent";
    unit      <- "-";
   :};

   CLASS Entropy
   "A class for Entropy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Entropy";
    unit      <- "J/K";
   :};

   CLASS SpecificEntropy
   "A class for SpecificEntropy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificEntropy";
    unit      <- "J/(g*K)";
   :};

   CLASS SpecificEnergy
   "A class for SpecificEnergy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificEnergy";
    unit      <- "J/g";
   :};

 
 
 
 

   CLASS ThermodynamicEnergy         = Energy;
   CLASS HelmholtzFreeEnergy         = Energy;
   CLASS GibbsFreeEnergy             = Energy;
   CLASS Enthalpy                    = Energy;

   CLASS SpecificThermodynamicEnergy = SpecificEnergy;
   CLASS SpecificHelmholtzFreeEnergy = SpecificEnergy;
   CLASS SpecificGibbsFreeEnergy     = SpecificEnergy;
   CLASS SpecificEnthalpy            = SpecificEnergy;

   CLASS PlanckFunction
   "A class for PlanckFunction"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PlanckFunction";
    unit      <- "J/g";
   :};

 
   CLASS ElectricCurrent
   "A class for ElectricCurrent"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricCurrent";
    unit      <- "A";
   :};

   CLASS ElectricCharge
   "A class for ElectricCharge"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricCharge";
    unit      <- "C";
   :};

   CLASS ElectricPotential
   "A class for ElectricPotential"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricPotential";
    unit      <- "V";
   :};

   CLASS Capacitance
   "A class for Capacitance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Capacitance";
    unit      <- "F";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Inductance
   "A class for Inductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Inductance";
    unit      <- "H";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Resistance
   "A class for Resistance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Resistance";
    unit      <- "Ohm";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Conductance
   "A class for Conductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Conductance";
    unit      <- "S";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

 

   CLASS LuminousIntensity
   "A class for LuminousIntensity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LuminousIntensity";
    unit      <- "cd";
   :};

 

   CLASS AmountOfSubstance
   "A class for AmountOfSubstance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AmountOfSubstance";
    unit      <- "mol";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

 

   CLASS pH
   "A class for pH"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "pH";
    interval  <- {: lowerBound <- 0; upperBound <- 14 :};
   :};

   CLASS Concentration
   "A class for concentration"
   SPECIALISES PhysicalQuantityType :=
   {:
    nature <- "ACROSS";
    quantity <- "Concentration";
    unit <- "g/m3";
    interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
 

   CLASS ReynoldsNumber
   "A class for ReynoldsNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ReynoldsNumber";
    unit      <- "-";
   :};

   CLASS EulerNumber
   "A class for EulerNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "EulerNumber";
    unit      <- "-";
   :};

   CLASS FroudeNumber
   "A class for FroudeNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "FroudeNumber";
    unit      <- "-";
   :};

   CLASS GrashofNumber
   "A class for GrashofNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "GrashofNumber";
    unit      <- "-";
   :};

   CLASS WeberNumber
   "A class for WeberNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "WeberNumber";
    unit      <- "-";
   :};

   CLASS MachNumber
   "A class for MachNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MachNumber";
    unit      <- "-";
   :};

   CLASS KnudsenNumber
   "A class for KnudsenNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "KnudsenNumber";
    unit      <- "-";
   :};

   CLASS StrouhalNumber
   "A class for StrouhalNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "StrouhalNumber";
    unit      <- "-";
   :};

 
   CLASS FourierNumber
   "A class for FourierNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "FourierNumber";
    unit      <- "-";
   :};

   CLASS PecletNumber
   "A class for PecletNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PecletNumber";
    unit      <- "-";
   :};

   CLASS RayleighNumber
   "A class for RayleighNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RayleighNumber";
    unit      <- "-";
   :};

   CLASS NusseltNumber
   "A class for NusseltNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "NusseltNumber";
    unit      <- "-";
   :};

   CLASS BiotNumber = NusseltNumber;
 
 
 

   CLASS StantonNumber
   "A class for StantonNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "StantonNumber";
    unit      <- "-";
   :};

 
   CLASS PrandtlNumber
   "A class for PrandtlNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PrandtlNumber";
    unit      <- "-";
   :};

   CLASS SchmidtNumber
   "A class for SchmidtNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SchmidtNumber";
    unit      <- "-";
   :};

   CLASS LewisNumber
   "A class for LewisNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LewisNumber";
    unit      <- "-";
   :};

 
 
 

 
 
 

 
 
 
 
 

 



































































 
 
 
   CLASS PartialPressureInAir
   "A class for Partial Pressure in air"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "atm";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS MolecularDiffusivity
   "A class for Diffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Diffusivity";
    unit      <- "m2/s";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};


# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\generic.msl" 2



# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.quantity.msl" 1
 














 



 
 
 
 
 
 

 CLASS MassFlux
 "Mass per time unit"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity  <- "MassFlux";
  unit      <- "g/d";
  interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF :};
  nature <- "THROUGH";
 :};

 CLASS ArealFlux
 "Mass per unit of surface and per unit of time"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "ArealFlux";
  unit     <- "g/(m2*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
 :};

 

 

  CLASS YieldForAutotrophicBiomass
  "A class for YieldForAutotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_A";
    unit      <- "gCOD/gN";
    interval  <- {: lowerBound <- 0; upperBound <- 4.57 :};
  :};

  CLASS YieldForHeterotrophicBiomass
  "A class for YieldForHeterotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_H";
    unit      <- "gCOD/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};    

  CLASS FractOfBiomassLeadingToPartProd
  "Fraction of biomass leading to particulate products"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "F_P";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};    

  CLASS MassOfNitrogenPerMassOfCODInBiomass
  "Mass of N per mass of COD in biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I_XB";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
  :};    

  CLASS MassOfNitrogenPerMassOfCODInProdFromBiomass
  "Mass of N per mass of COD in products from biomass" 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I_XP";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
  :};    

 

  CLASS MaxSpecifGrowthRateHetero
  "Maximum specific growth rate for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_H";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 20 :};
  :};    

  CLASS MaxSpecifGrowthRateAutotr
  "Maximum specific growth rate for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 5 :};
  :};    

  CLASS HalfSatCoeff
  "Half-saturation coefficient"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_";
    unit      <- "gCOD/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 1000000 :};
  :};    

  CLASS HalfSatCoeffForHetero
  "Half-saturation coefficient for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_S";
    unit      <- "gCOD/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 100 :};
  :};    

  CLASS OxygenHalfSatCoeffForHetero
  "Oxygen half-saturation coeff for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OH";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};    

  CLASS NitrateHalfSatCoeffForDenitrifHetero
  "Nitrate half-saturation coeff for denitrifying heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NO";
    unit      <- "gNO3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 2 :};
  :};    

  CLASS OxygenHalfSatCoeffForAutotr
  "Oxygen half-saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OA";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};    

  CLASS AmmonHalfSatCoeffForAutotr
  "Ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NH";
    unit      <- "gNH3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};

  CLASS HalfSatCoeffForHydrolSlowBioDegradeSubstr
  "Half saturation constant for hydrolysis of slowly biodegradable substrate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_X";
    unit      <- "gCOD/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS MaxSpecificHydrolysisRate
  "Maximum specific hydrolysis rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_h";
    unit      <- "gCOD/(gCOD*d)";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

  CLASS AmmonificationRate
  "Ammonification rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_a";
    unit      <- "m3/(gCOD*d)";
    interval  <- {: lowerBound <- 0; upperBound <- 0.25 :};
  :};    

  CLASS DecayCoeffHeterotr
  "Decay coefficient for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "B_H";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

  CLASS DecayCoeffAutotr
  "Decay coefficient for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "B_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

 

  CLASS DissolvedComponent
  "A class for dissolved components"
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "S";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
    nature <- "ACROSS";
  :};    

  CLASS ParticulateComponent
  "A class for particulate component"
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "X";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
    nature <- "ACROSS";
  :};    

  CLASS ConversionFactor
  "A class for typical conversion factors for continuity equations"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "g/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS NitrogenConversionFactor
  "A class for typical conversion factors of Nitrogen for continuity equations"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS PhosphorusConversionFactor
  "A class for typical conversion factors of Phosphorus for continuity equations"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "gP/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};
    
  CLASS MaxGrowthRate
  "Maximum growth rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 100 :};
  :};    

  CLASS RateConstant
  "Rate constant"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Q_or_B_or_K";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 20 :};
  :};    

 
 

  CLASS ChemOxDemand
  "Chemical oxygen demand"
 
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "COD";
    unit      <- "gO2/m3";
  :};    
  
  CLASS BiolOxDemand
  "Biological oxygen demand" 
 
 
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "BOD_5_20";
    unit      <- "gO2/m3";
  :};    

  CLASS NitrifOxDemand
  "Nitrification oxygen demand"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "NOD";
    unit      <- "gO2/m3";
  :};    

  CLASS DissolvedOxygen
  "A class for the ammount of dissolved oxygen"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity    <- "DO";
    unit        <- "gO2/m3";
    displayunit <- "gO2/m3";
    interval    <- {: lowerBound <- 0; upperBound <- 15 :};
  :};

 
 

 CLASS Yield
 "A class for Yield"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Yield";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};

 CLASS GrowthRate
 "GrowthRate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "GrowthRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
 :};

  CLASS ProcessRate
 "GrowthRate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "ProcessRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :}; 
 
 CLASS Fraction
 "Fraction"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Fraction";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1:};
 :};

 CLASS SaturationCoefficient
 "Saturation coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "K";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 100:};
 :};

 CLASS DecayCoefficient
 "Decay coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "B";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
 :};

 CLASS CorrectionFactor
 "CorrectionFactor"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
 :};

 CLASS ReductionFactor
 "Reductionfactor"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
 :};

 CLASS MaxSpecAmmonRate
 "Maximum specific ammonification rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "MaxSpecAmmonRate";
  unit     <- "m3/(gCOD*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};

 CLASS OxygenTransferCoefficient
 "Oxygen Transfer Coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Kla";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 5000 :};
 :};

CLASS OxygenUptakeRate
 "Oxygen Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "OUR";
  unit     <- "g/(m3.d)";
 :};

CLASS NitrateUptakeRate
 "Nitrate Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "NUR";
  unit     <- "g/(m3.d)";
 :};

 CLASS NitrateProductionRate
 "Nitrate Production Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "NPR";
  unit     <- "g/(m3.d)";
 :};
 
CLASS AmmoniumUptakeRate
 "Ammonium Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "AUR";
  unit     <- "g/(m3.d)";
 :};
 
CLASS PhosphateUptakeRate
 "Phosphate Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "PUR";
  unit     <- "g/(m3.d)";
 :};  

CLASS PhosphateReleaseRate
 "Phosphate Release Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "PRR";
  unit     <- "g/(m3.d)";
 :};   
 
CLASS ElectricalEnergy
   "A class for electrical energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Electrical energy";
    unit      <- "kWh";
    :};

CLASS TransferRateEnergy
   "A class for transfer rate per unit of energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Transfer rate per energy";
    unit      <- "g/kWh";
    :};
  
CLASS Dollar
   "dollars"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "dollar";
    unit      <- "$";
    :};

CLASS Euro
   "Euro"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "euro";
    unit      <- "E";
    :};

 CLASS HenryCoefficient
 "A class for the Henry coefficient"
 SPECIALISES PhysicalQuantityType := 
 {:
  quantity    <- "HenryCoefficient";
  unit        <- "atm.m3.Mol-1";
  interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS MassOfNitrogenPerMassOfCOD
 "Mass of N per mass of COD"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "I_";
   unit      <- "gN/gCOD";
   interval  <- {: lowerBound <- 0; upperBound <- 0.2; :};
 :};    

 CLASS MolarHalfSatCoeff
 "Half-saturation coefficient for components expressed in mol.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_S_";
   unit      <- "Mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};    

 CLASS InhibitionCoeff
 "Inhibition coefficient for components expressed in g.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "g.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   

 CLASS MolarInhibitionCoeff
 "Inhibition coefficient for components expressed in mol.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "Mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};    

 CLASS TemperatureCoefficient
 "Temperature coefficient for reaction rate"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "TemperatureCoefficient";
   unit      <- "-";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS MolConcentration
 "Concentration in Mol per m3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "MolConcentration";
   unit      <- "Mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :}; 
 
 CLASS MolFlowRate
 "Gas flow rate in Mol per day"
 SPECIALISES PhysicalQuantityType :=
 {: 
   quantity  <- "MolFlowRate";
   unit      <- "Mol.d-1";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS GasFlowRate
 "Gas flow rate in m3 per day"
 SPECIALISES PhysicalQuantityType :=
 {: 
   quantity  <- "GasFlowRate";
   unit      <- "m3.d-1";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 




  CLASS MonodTerm
  "A class for Monod-like terms"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "S / ( K + S)";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1:};
  :};    

  CLASS InhibitionTerm
  "A class for inhibtion terms of the ASM-models"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K / ( K + S)";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1:};
  :};    


 
 
CLASS LengthFlux
 "Mass per unit of length and per unit of time"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "LengthFlux";
  unit     <- "g/(m*d)";
  interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
 :};

CLASS BurgerDispersion
 "Time per unit of surface"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "b_mix";
   unit      <- "d/m2";
   interval  <- {: lowerbound <- 0; upperbound <- PLUS_INF; :};
 :};

CLASS BurgerSolidsStress
"A class for the parameter of the solids stress function"
SPECIALISES PhysicalQuantityType :=
{:
   quantity  <- "Alpha";
   unit      <- "m2/s2";
   interval  <- {: lowerbound <- 0; upperbound <- PLUS_INF; :};
 :};
 
 
 
 
  CLASS YieldForAutotrophicBiomassForMampaeyA
  "A class for YieldForAutotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_A";
    unit      <- "gCOD/gN";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS MaxSpecifDenitrifyRateForMampaeyB
  "Maximum specific growth rate for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};    
  
  CLASS AmmonHalfSatCoeffForAutotrForMampaeyA
  "Ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NH";
    unit      <- "gNH3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS OxygenHalfSatCoeffForAutotrForMampaeyA
  "Oxygen half-saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OA";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};  
  
  CLASS NSaturationCoefficientForMampaey
  "Saturation coefficient"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "K";
    unit     <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
  :};
  
 
  CLASS FreeAmmoniaSatCoeffForAutotr
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};

  CLASS FreeNitrousAcidSatCoeffForAutotr
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FNA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};
  
  CLASS bCoeffForRatkowsky
  "b coefficient of Ratkowsky temperature correction"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "eta";
    unit     <- "1/[(d^0.5)*(deg C)]";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};
 
  CLASS cCoeffForRatkowsky
  "c coefficient of Ratkowsky temperature correction"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "eta";
    unit     <- "1/degC";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};
  
  CLASS FreeAmmoniaInhibitionCoeff
  "Inhibition coefficient for free Ammonia"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_I_";
    unit      <- "gN/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
  :};   
 
 CLASS FreeNitrousAcidInhibitionCoeff
 "Inhibition coefficient for free nitrous acid"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 CLASS NitricOxideInhibitionCoeffForDenitrification
 "Inhibition coefficient for nitric oxide substances during denitrification"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 CLASS NHalfSatCoeffForDenitrification
 "Half saturation coefficient for N substances during denitrification"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 
  
 
  CLASS FreeAmmoniaSatCoeffForAutotrModif
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS FreeNitrousAcidSatCoeffForAutotrModif
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FNA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS FreeAmmoniaInhibitionCoeffModif
  "Inhibition coefficient for free Ammonia in the modified competitive term"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_I_";
    unit      <- "gN/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
  :};  
  
   CLASS FreeNitrousAcidInhibitionCoeffModif
   "Inhibition coefficient for free nitrous acid"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};  
   
   CLASS NitricOxideInhibitionCoeffForDenitrificationModif
   "Inhibition coefficient for nitric oxide substances during denitrification"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};  

   CLASS NHalfSatCoeffForDenitrificationModif
   "Half saturation coefficient for N substances during denitrification"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :}; 



# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.general.msl" 1
 


















 
 
 

 
 
 

  
  




 TYPE BODCODComponents 
 "The number of biological components considered in the input of a BODCOD transformer"
  = ENUM {H2O, COD, BOD5, TSS, TKN};

 TYPE BODComponents 
 "The number of biological components considered in the input of a BOD transformer"
  = ENUM {H2O, BOD_5, SS, KjN};
 


# 54 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.general.msl"

 OBJ NrOfBODCODComponents
  "The number of biological components considered in the input of a BODCOD transformer"
  : Integer := Cardinality(BODCODComponents);

 OBJ NrOfBODComponents
  "The number of biological components considered in the input of a BODCOD transformer"
  : Integer := Cardinality(BODComponents); 

  
 
 CLASS BODCODTerminal
 "The parameters passed to a BOD COD transformer from the influent file"
 = Concentration[NrOfBODCODComponents;];

 CLASS InBODCODTerminal SPECIALISES BODCODTerminal;  
 CLASS OutBODCODTerminal SPECIALISES BODCODTerminal;  

  
 
 CLASS BODTerminal
  "The parameters passed to a BOD transformer from the influent file"
  = Concentration[NrOfBODComponents;];

 CLASS InBODTerminal SPECIALISES BODTerminal;  
 CLASS OutBODTerminal SPECIALISES BODTerminal;  

 OBJ In_BOD_COD_Terminal "Temporary iteration variable" : BODCODTerminal;
  


 
 
 

 

 OBJ NrOfComponents
  "The number of biological components considered in the WWTP models"
  : Integer := Cardinality(Components);

 OBJ NrOfReactions
  "The number of reactions between biological components considered in the WWTP models"
  : Integer := Cardinality(Reactions);

  

 OBJ NrOfLayers "The number of layers in the secondary clarifier"
  : Integer := 10 ;

 OBJ NrOfLayersButOne "The number of layers in the secondary clarifier minus one" 
  : Integer := 9 ;

 OBJ NrOfLayersPlusOne "The number of layers in the secondary clarifier plus one" 
  : Integer := 11 ;

  
 
 
  OBJ NrOfLayersBurger "Burger model: The number of layers in the secondary clarifier (N)" : Integer := 90 ;  
  OBJ NrOfLayersPlusOneBurger "Burger model: The number of layers in the clarifier plus one (N+1)" : Integer := 91 ;  
  OBJ NrOfLayersPlusTwoBurger "Burger model: The number of layers in the clarifier plus two extra layers in the underflow (N+2)" : Integer := 92 ; 
  OBJ NrOfLayersPlusThreeBurger "Burger model: The number of layers in the secondary clarifier plus 3 (N+3)" : Integer := 93 ;
  OBJ NrOfLayersPlusFourBurger "Burger model: The number of layers in the clarifier plus the extra layers in effluent and underflow (N+4)" : Integer := 94 ;
 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 

 CLASS WWTPTerminal
 "The variables which are passed between WWTP model building blocks"
 = MassFlux[NrOfComponents;]; 

 CLASS InWWTPTerminal SPECIALISES WWTPTerminal;  
 CLASS OutWWTPTerminal SPECIALISES WWTPTerminal;  

 

 CLASS WWTPConcTerminal 
  "The variables which are passed between WWTP model building blocks in concentrations"
  = Concentration[NrOfComponents;]; 

 CLASS InWWTPConcTerminal SPECIALISES WWTPConcTerminal;  
 CLASS OutWWTPConcTerminal SPECIALISES WWTPConcTerminal;  

  
  
  
  



 
 
 

  
  
  
  

 OBJ Comp_Index "Temporary iteration variable, index of the component" : Integer;
 OBJ Reaction_Index "Temporary iteration variable, index of the reaction" : Integer;
 OBJ In_Comp_Index "Temporary iteration variable, index of the incoming component" : Integer;
 OBJ Out_Comp_Index "Temporary iteration variable, index of the outgoing component" : Integer;
 OBJ Terminal "Temporary iteration variable" : WWTPTerminal;
 OBJ In_Terminal "Temporary iteration variable" : WWTPTerminal;
 OBJ Out_Terminal "Temporary iteration variable" : WWTPTerminal;

  

 OBJ Layer_Index "Temporary iteration variable, index of the layer" : Integer;
 OBJ IndexOfFeedLayer "The index of the layer where the influent is feeded to the clarifier" 
  : Integer := 5 ;
 
  

 
  OBJ IndexOfFeedLayerBurger "The index of the layer where the influent is feeded to the clarifier" : Integer := 25 ;
  OBJ I_Index "Temporary iteration variable, index of the compression coefficient" : Integer;
 

 
 
 

 
 
 
 

CLASS MassVector = Mass[NrOfComponents;];
CLASS MassFluxVector = MassFlux[NrOfComponents;];
CLASS ConcentrationVector = Concentration[NrOfComponents;];
CLASS SpecificVolumeVector = SpecificVolume[NrOfComponents;];
CLASS VelocityVector = Velocity[NrOfComponents;];
CLASS ArealFluxVector = ArealFlux[NrOfComponents;];
CLASS LengthVector = Length[NrOfLayers;];
CLASS VolumeVector = Volume[NrOfLayers;];
CLASS L_and_B_ConcentrationVector = Concentration[5;];

 
CLASS TakacsMassVector = Mass[NrOfLayers;];
CLASS TakacsConcentrationVector = Concentration[NrOfLayers;];
CLASS TakacsVelocityVector = Velocity[NrOfLayers;];
CLASS TakacsArealFluxVector = ArealFlux[NrOfLayers;];
CLASS LayerConcentrationMatrix = Concentration[NrOfComponents;][NrOfLayers;];

 
CLASS LayerMassMatrix = Mass[NrOfComponents;][NrOfLayers;];
 
 
CLASS BurgerMassVector = Mass[NrOfLayersPlusFourBurger;];
CLASS BurgerLengthVector = Length[NrOfLayersPlusFourBurger;];
CLASS BurgerConcentrationVector = Concentration[NrOfLayersPlusFourBurger;];
CLASS BurgerVelocityVector = Velocity[NrOfLayersPlusFourBurger;];
CLASS BurgerArealFluxVector = ArealFlux[NrOfLayersPlusFourBurger;];
CLASS BurgerLayerConcentrationMatrix = Concentration[NrOfComponents;][NrOfLayersPlusFourBurger;];
CLASS BurgerDiffusivityVector = Diffusivity[NrOfLayersPlusFourBurger;];
CLASS BurgerLengthFluxVector = LengthFlux[NrOfLayersPlusFourBurger;];
 
 
CLASS PloszConcentrationVector = Concentration[60;];
CLASS PloszVelocityVector = Velocity[60;];
CLASS PloszArealFluxVector = ArealFlux[60;];
CLASS PloszDiffusivityVector = Diffusivity[60;]; 
 
 


# 24 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 1
 


















  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

  
 
 

  
  
  
  
  
  

  
  

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM1Temp.msl" 1
 



















TYPE Components
"The biological components considered in the WWTP models"
  = ENUM {H2O, 
    S_I, 
    S_S, 
    S_O, 
    S_NO, 
    S_ND, 
    S_NH, 
    S_ALK, 
    X_I, 
    X_S, 
    X_BH, 
    X_BA, 
    X_P, 
    X_ND, 
    };



TYPE Reactions
"The reactions between biological components considered in the WWTP models"
  = ENUM {AerGrowthHetero, 
    AnGrowthHetero, 
    AerGrowthAuto, 
    DecayOfHetero, 
    DecayOfAuto, 
    AmmonOfSolOrgN, 
    HydrolOfEntrOrg, 
    HydrolOfEntrOrgN, 
    Aeration, };





 OBJ IndexOfSolvent 
  "Index of the solvent (water) in the component vector" 
  : Integer := 1;


 OBJ IndexOfFirstSolubleComponent
  "Index of the first soluble component in the component vector"
  : Integer := 2;

 OBJ IndexOfLastSolubleComponent
  "Index of the last soluble component in the component vector"
  : Integer := 8;


 OBJ IndexOfFirstParticulateComponent
  "Index of the first particulate component in the component vector"
  : Integer := 9;

 OBJ IndexOfLastParticulateComponent
  "Index of the last particulate component in the component vector"
  : Integer := 14;


 OBJ IndexOfFirstTSSComponent
  "Index of the first TSS component in the component vector"
  : Integer := 9;

 OBJ IndexOfLastTSSComponent
  "Index of the last TSS component in the component vector"
  : Integer := 13;




# 55 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM2dModTemp.msl" 1
 


















# 46 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM2dModTemp.msl"


# 75 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM2dModTemp.msl"



# 108 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM2dModTemp.msl"



# 56 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3Temp.msl" 1
 


















# 38 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3Temp.msl"


# 56 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3Temp.msl"


# 88 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3Temp.msl"



# 57 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3P_EAWAG.msl" 1
 


















# 43 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3P_EAWAG.msl"


# 74 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3P_EAWAG.msl"


# 107 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM3P_EAWAG.msl"



# 58 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM1_AN.msl" 1
 



















# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM1_AN.msl"



# 59 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM1_AN.msl"


# 78 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM1_AN.msl"



# 61 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASMG1.msl" 1
 



















# 44 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASMG1.msl"



# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASMG1.msl"


# 90 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASMG1.msl"



# 62 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 2



# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM2dChemTemp.msl" 1
# 107 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsASM2dChemTemp.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions1.msl" 2



# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitions2.msl" 1
 


















  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

 
 
 

TYPE AnaerobicComponents
  "The biological components considered in the Siegrist anaerobic digestion model"
  = ENUM {H2O_An, S_H2, S_CH4, S_CO2, S_HCO3, S_H, S_NH4, S_AC, S_PRO,
          S_AS, S_FA, S_IN, X_S_An, X_AS, X_FA, X_PRO, X_AC, X_H2, X_IN};

  
  
  
  
  
  
 
 TYPE AnaerobicReactions
  "The anaerobic reactions between biological components considered in the Siegrist anaerobic digestion model"
  = ENUM {
          H2Stripping,
          CH4Stripping,
          CO2Stripping,
          BiopolymHydrol,
          ASFermentation,
          AnOxOfS_FA,
          AnOxOfS_PRO,
          AcToCH4Conv,
          H2ToCH4Conv,
          DecayOfX_AS,
          DecayOfX_FA,
          DecayOfX_PRO,
          DecayOfX_AC,
          DecayOfX_H2,
          ProtolysisOfHCO3,
          DeprotolysisOfCO2,
         };

 
 
 

 OBJ NrOfAnaerobicComponents "The number of anaerobic components considered in the anaerobic digestion model"
  : Integer := Cardinality(AnaerobicComponents);

 OBJ NrOfAnaerobicReactions "The number of anaerobic reactions considered in the anaerobic digestion model"
  : Integer := Cardinality(AnaerobicReactions);

 
 
 
 

 
 CLASS AnaerobicConcentrationVector = Concentration[NrOfAnaerobicComponents;];
 CLASS AnaerobicSpecificVolumeVector = SpecificVolume[NrOfAnaerobicComponents;];
 CLASS AnaerobicMassVector = Mass[NrOfAnaerobicComponents;];
 CLASS AnaerobicMassFluxVector = MassFlux[NrOfAnaerobicComponents;];

 
 
 


# 26 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl" 1
 


















 CLASS WWTPAtomicModel
 " A generic atomic WWTP model. Only specifies mass balances"
 
 
 
 
 
 
 
 
 SPECIALISES PhysicalDAEModelType :=
 {:
  
  
  parameters <-
   {

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

     
     
     
     
    OBJ WWTPSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SpecificVolumeVector;

     
     
     
     
     
     
     
     
     
     

   };

  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };

  state <-
   {
    OBJ M "Vector containing masses for all the components" : MassVector 

         := [{: value <- 1000000000:},{: value <- 1 :},
                  {: value <- 2 :},{: value <- 1 :},
                {: value <- 2 :}, {: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                                {: value <- 1000 :},{: value <- 100 :},
                {: value <- 1 :},{: value <- 1 :}; ]


































# 147 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl"

;
    OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": MassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all the components": MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =

     
     
     
     
     

    (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
    In_Terminal[Comp_Index])+
    (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
    Out_Terminal[Comp_Index]);};

     
     
     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};

     
     
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
    };

    {state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);
    };

 
 
 

   }; 
 :};

 
 
 

 
 
 

 CLASS WWTPAtomicModelWithoutVolume 
 SPECIALISES PhysicalDAEModelType :=
 {:
  parameters <-
   {
    OBJ WWTPSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SpecificVolumeVector;
   };

  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };
   
  state <-
   {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
   };

   equations <-
   {
     { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
         (In_Terminal[Comp_Index]);
     };

     {state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);
     };

   };
 :};

 
 
 

 CLASS WWTPAtomicModelWithVolume EXTENDS WWTPAtomicModel WITH
 {:

   state <-
    {
      OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Dimension" :};
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
    };

   equations <-
    {
      
      
    };

 :};

 
 
 

 CLASS WWTPAtomicModelWithVariableVolume
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  parameters <-
   {
     OBJ N "Number of weirs on a tank" : PhysicalQuantityType := 
         {: value <- 100 ; 
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :};
      group <- "Hydraulic" 
         :} ;
     OBJ A (* is_favorite = "1" *) "Surface area of the tank" : Area := {: value <- 200; group <- "Dimension"  :} ;
     OBJ alfa "Parameter, function of the weir type or width" 
         : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic"  :};
     OBJ beta "Parameter, depends on the weir design" 
         : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
     OBJ V_Const (* is_favorite = "1" *) "Constant tank volume beneath the lowest point of the weir" 
         : Volume := {: value <- 1900; group <- "Dimension" :};
   };

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
     
     
     
     

    state.Q_Out = IF (state.V > parameters.V_Const)
                THEN
    parameters.N * parameters.alfa 
      * pow((state.V - parameters.V_Const)/parameters.A, parameters.beta)
        ELSE 0;

     
     
     
     

    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};

  
  
  
  
  

 CLASS VarVolumeConversionModel EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 355 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl" 2

 :};
 
  

 CLASS VarVolumeASMConversionModel EXTENDS VarVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 1
 
















   interface <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.interface.msl" 1
 















 
    
    OBJ DO (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4 (* terminal = "out_2"; is_favorite = "1" *)"Ammonium concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ NO3 (* terminal = "out_2"; is_favorite = "1" *)"Nitrate+Nitrite concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2"; is_favorite = "1" *)"Total suspended solids concentration" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD (* terminal = "out_2" *)"Chemical Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   
    OBJ OfflineBOD (* terminal = "out_2" *)"Biological Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN (* terminal = "out_2" *)"Total nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   

    OBJ V_ASU (* terminal = "out_2" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU (* terminal = "out_2" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR (* terminal = "out_2" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR (* terminal = "out_2" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR (* terminal = "out_2" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU (* terminal = "out_2" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   parameters <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   state <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.state.msl" 1
 














 

    OBJ X_TSS "Total suspended solids" 
  : Concentration := {: group <- "Concentration" :};
  OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
  OBJ mu_H_Temp "mu_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ mu_A_Temp "mu_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_H_Temp  "b_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_A_Temp  "b_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_h_Temp  "k_h at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_a_Temp  "k_a at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ K_X_Temp  "K_X at the system temperature"
  : Real := {: group <- "Kinetic" :};

# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   initial <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 
















  parameters.Stoichiometry[AerGrowthHetero][S_S] :=  - 1 / (parameters.Y_H);
  parameters.Stoichiometry[AerGrowthHetero][S_O] :=  - (1 - parameters.Y_H) / parameters.Y_H;
  parameters.Stoichiometry[AerGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AerGrowthHetero][S_ALK] :=  - parameters.i_X_B / 14;
  parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AnGrowthHetero][S_S] :=  - 1 / parameters.Y_H;
  parameters.Stoichiometry[AnGrowthHetero][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
  parameters.Stoichiometry[AnGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
  parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AerGrowthAuto][S_O] :=  - (4.57 - parameters.Y_A) / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NH] :=  - parameters.i_X_B - 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_ALK] :=  - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
  parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
  parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_BH] :=  - 1;
  parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_BA] :=  - 1;
  parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] :=  - 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.0 / 14.0;
  parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrg][X_S] :=  - 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] :=  - 1;
  parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   equations <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 
















    state.X_TSS := (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

  state.Kinetics[AerGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
  state.Kinetics[AnGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
  state.Kinetics[AerGrowthAuto] := state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
  state.Kinetics[DecayOfHetero] := state.b_H_Temp * state.C[X_BH];
  state.Kinetics[DecayOfAuto] := state.b_A_Temp * state.C[X_BA];
  state.Kinetics[AmmonOfSolOrgN] := state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrg] := state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrgN] := (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);
  state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.sensors.msl" 1
 















 

  interface.DO = state.C[S_O];
  
  interface.NH4 = state.C[S_NH];
  
  interface.NO3 = state.C[S_NO];
  
  interface.TSS = state.X_TSS ; 
      
  interface.OnlineCOD = ( state.C[S_S] + state.C[S_I] + 
        state.C[X_BH] + state.C[X_BA] + state.C[X_S] 
          + state.C[X_I] + state.C[X_P]); 
          
  
  interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] 
             + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA])) ;
             
             
  interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
     + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OfflineTKN = ( state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
       + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OUR_ASU = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_O] / state.V)
     + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];

  interface.NUR = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_NO] / state.V)
     + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
   
  interface.NPR = IF (state.V == 0)
              THEN 0
              ELSE
     parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];   

  interface.AUR = IF (state.V == 0)
            THEN 0
            ELSE
     - (state.ConversionTermPerComponent[S_NH] / state.V);    
   
  interface.Kla_ASU = state.Kla_Actual;

  interface.V_ASU = state.V;

         
      
  
  

# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



























# 362 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl" 2

 :};

 
 
 

CLASS WWTPAtomicModelWithPumpedVolume
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Q_Pump (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired effluent flow rate" : FlowRate := {: causality <- "CIN" ; value <- 100; group <- "Operational" :} ;
   };

  parameters <-
   {
     OBJ V_Max (* is_favorite = "1" *) "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min (* is_favorite = "1" *) "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
   };

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min && 
                    interface.Q_Pump > state.Q_In) 
                THEN state.Q_In
                ELSE  
                  IF (state.V < parameters.V_Max)
                  THEN interface.Q_Pump
                  ELSE
                    IF (state.Q_In < interface.Q_Pump)
                    THEN interface.Q_Pump
                    ELSE state.Q_In ;    

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};

CLASS PumpedVolumeConversionModel EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 425 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl" 2

 :};

 CLASS PumpedVolumeASMConversionModel EXTENDS PumpedVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 1
 
















   interface <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.interface.msl" 1
 















 
    
    OBJ DO (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4 (* terminal = "out_2"; is_favorite = "1" *)"Ammonium concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ NO3 (* terminal = "out_2"; is_favorite = "1" *)"Nitrate+Nitrite concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2"; is_favorite = "1" *)"Total suspended solids concentration" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD (* terminal = "out_2" *)"Chemical Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   
    OBJ OfflineBOD (* terminal = "out_2" *)"Biological Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN (* terminal = "out_2" *)"Total nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   

    OBJ V_ASU (* terminal = "out_2" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU (* terminal = "out_2" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR (* terminal = "out_2" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR (* terminal = "out_2" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR (* terminal = "out_2" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU (* terminal = "out_2" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   parameters <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   state <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.state.msl" 1
 














 

    OBJ X_TSS "Total suspended solids" 
  : Concentration := {: group <- "Concentration" :};
  OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
  OBJ mu_H_Temp "mu_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ mu_A_Temp "mu_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_H_Temp  "b_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_A_Temp  "b_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_h_Temp  "k_h at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_a_Temp  "k_a at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ K_X_Temp  "K_X at the system temperature"
  : Real := {: group <- "Kinetic" :};

# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   initial <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 
















  parameters.Stoichiometry[AerGrowthHetero][S_S] :=  - 1 / (parameters.Y_H);
  parameters.Stoichiometry[AerGrowthHetero][S_O] :=  - (1 - parameters.Y_H) / parameters.Y_H;
  parameters.Stoichiometry[AerGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AerGrowthHetero][S_ALK] :=  - parameters.i_X_B / 14;
  parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AnGrowthHetero][S_S] :=  - 1 / parameters.Y_H;
  parameters.Stoichiometry[AnGrowthHetero][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
  parameters.Stoichiometry[AnGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
  parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AerGrowthAuto][S_O] :=  - (4.57 - parameters.Y_A) / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NH] :=  - parameters.i_X_B - 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_ALK] :=  - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
  parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
  parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_BH] :=  - 1;
  parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_BA] :=  - 1;
  parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] :=  - 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.0 / 14.0;
  parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrg][X_S] :=  - 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] :=  - 1;
  parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   equations <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 
















    state.X_TSS := (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

  state.Kinetics[AerGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
  state.Kinetics[AnGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
  state.Kinetics[AerGrowthAuto] := state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
  state.Kinetics[DecayOfHetero] := state.b_H_Temp * state.C[X_BH];
  state.Kinetics[DecayOfAuto] := state.b_A_Temp * state.C[X_BA];
  state.Kinetics[AmmonOfSolOrgN] := state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrg] := state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrgN] := (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);
  state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.sensors.msl" 1
 















 

  interface.DO = state.C[S_O];
  
  interface.NH4 = state.C[S_NH];
  
  interface.NO3 = state.C[S_NO];
  
  interface.TSS = state.X_TSS ; 
      
  interface.OnlineCOD = ( state.C[S_S] + state.C[S_I] + 
        state.C[X_BH] + state.C[X_BA] + state.C[X_S] 
          + state.C[X_I] + state.C[X_P]); 
          
  
  interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] 
             + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA])) ;
             
             
  interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
     + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OfflineTKN = ( state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
       + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OUR_ASU = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_O] / state.V)
     + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];

  interface.NUR = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_NO] / state.V)
     + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
   
  interface.NPR = IF (state.V == 0)
              THEN 0
              ELSE
     parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];   

  interface.AUR = IF (state.V == 0)
            THEN 0
            ELSE
     - (state.ConversionTermPerComponent[S_NH] / state.V);    
   
  interface.Kla_ASU = state.Kla_Actual;

  interface.V_ASU = state.V;

         
      
  
  

# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



























# 430 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl" 2


 :};

 
 
 

 CLASS WWTPAtomicModelWithFixedVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  parameters <-  
   {
     OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
   };   
   
  state <-
   {
 
   };

  initial <-  
  {
  state.M[IndexOfSolvent] = parameters.Vol / parameters.WWTPSpecificVolume[IndexOfSolvent];
  };   
  equations <-
   {
     
     
     
 
      
     
     
     

    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_In ;};
   };
 :};

 CLASS FixVolumeConversionModel EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 493 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl" 2

 :};
 
 CLASS FixVolumeASMConversionModel EXTENDS FixVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 1
 
















   interface <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.interface.msl" 1
 















 
    
    OBJ DO (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4 (* terminal = "out_2"; is_favorite = "1" *)"Ammonium concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ NO3 (* terminal = "out_2"; is_favorite = "1" *)"Nitrate+Nitrite concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2"; is_favorite = "1" *)"Total suspended solids concentration" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD (* terminal = "out_2" *)"Chemical Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   
    OBJ OfflineBOD (* terminal = "out_2" *)"Biological Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN (* terminal = "out_2" *)"Total nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   

    OBJ V_ASU (* terminal = "out_2" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU (* terminal = "out_2" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR (* terminal = "out_2" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR (* terminal = "out_2" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR (* terminal = "out_2" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU (* terminal = "out_2" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   parameters <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   state <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.state.msl" 1
 














 

    OBJ X_TSS "Total suspended solids" 
  : Concentration := {: group <- "Concentration" :};
  OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
  OBJ mu_H_Temp "mu_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ mu_A_Temp "mu_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_H_Temp  "b_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_A_Temp  "b_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_h_Temp  "k_h at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_a_Temp  "k_a at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ K_X_Temp  "K_X at the system temperature"
  : Real := {: group <- "Kinetic" :};

# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   initial <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 
















  parameters.Stoichiometry[AerGrowthHetero][S_S] :=  - 1 / (parameters.Y_H);
  parameters.Stoichiometry[AerGrowthHetero][S_O] :=  - (1 - parameters.Y_H) / parameters.Y_H;
  parameters.Stoichiometry[AerGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AerGrowthHetero][S_ALK] :=  - parameters.i_X_B / 14;
  parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AnGrowthHetero][S_S] :=  - 1 / parameters.Y_H;
  parameters.Stoichiometry[AnGrowthHetero][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
  parameters.Stoichiometry[AnGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
  parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AerGrowthAuto][S_O] :=  - (4.57 - parameters.Y_A) / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NH] :=  - parameters.i_X_B - 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_ALK] :=  - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
  parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
  parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_BH] :=  - 1;
  parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_BA] :=  - 1;
  parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] :=  - 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.0 / 14.0;
  parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrg][X_S] :=  - 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] :=  - 1;
  parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   equations <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 
















    state.X_TSS := (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

  state.Kinetics[AerGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
  state.Kinetics[AnGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
  state.Kinetics[AerGrowthAuto] := state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
  state.Kinetics[DecayOfHetero] := state.b_H_Temp * state.C[X_BH];
  state.Kinetics[DecayOfAuto] := state.b_A_Temp * state.C[X_BA];
  state.Kinetics[AmmonOfSolOrgN] := state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrg] := state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrgN] := (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);
  state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.sensors.msl" 1
 















 

  interface.DO = state.C[S_O];
  
  interface.NH4 = state.C[S_NH];
  
  interface.NO3 = state.C[S_NO];
  
  interface.TSS = state.X_TSS ; 
      
  interface.OnlineCOD = ( state.C[S_S] + state.C[S_I] + 
        state.C[X_BH] + state.C[X_BA] + state.C[X_S] 
          + state.C[X_I] + state.C[X_P]); 
          
  
  interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] 
             + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA])) ;
             
             
  interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
     + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OfflineTKN = ( state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
       + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OUR_ASU = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_O] / state.V)
     + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];

  interface.NUR = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_NO] / state.V)
     + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
   
  interface.NPR = IF (state.V == 0)
              THEN 0
              ELSE
     parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];   

  interface.AUR = IF (state.V == 0)
            THEN 0
            ELSE
     - (state.ConversionTermPerComponent[S_NH] / state.V);    
   
  interface.Kla_ASU = state.Kla_Actual;

  interface.V_ASU = state.V;

         
      
  
  

# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



























# 498 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.msl" 2

 :};

 

 
 
 

 
 
 

 
 
 
 
 



# 28 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 1
 


















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.twocombiner.msl" 1
 


















 CLASS TwoCombiner
 (* icon = "two_combiner" ; is_default = "true" *)  
 "two combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of two flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1" :};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.threecombiner.msl" 1
 


















 CLASS ThreeCombiner
 (* icon = "three_combiner" ; is_default = "false" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of three flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};

CLASS InSewTerminal SPECIALISES SewTerminal;  
CLASS OutSewTerminal SPECIALISES SewTerminal;  

CLASS SewSpecificVolumeVector = SpecificVolume[NrOfSewComponents;];
CLASS SewMassFluxVector = MassFlux[NrOfSewComponents;];
CLASS SewConcentrationVector = Concentration[NrOfSewComponents;];
	

 CLASS SewThreeCombiner
 (* icon = "three_combiner" ; is_default = "true" *)  
 "three combiner"
  
  SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for a combiner of three flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InSewTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InSewTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InSewTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutSewTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };

  parameters <-
   {
    OBJ SewSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SewSpecificVolumeVector;
   };

  state <-  
  {
    OBJ Total_Flux (* is_favorite = "1" *) "Total flux per component" : MassFlux[NrOfSewComponents;] := {: group <- "Operational" :};
    OBJ inFluxPerSewComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : SewMassFluxVector;
    OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Influent" :};
	  OBJ Out "Outgoing concentrations and flow rate" : SewConcentrationVector := {: group <- "Effluent" :};
	  OBJ CODtot "Total COD concentration" : Concentration := {: group <- "Effluent" :};
  };  

  initial <-
   {
    parameters.SewSpecificVolume[H2O_sew] := 0.000001;
   };

  independent <- { OBJ t "Time" : Time; };
	  
  equations <-
   {
     { FOREACH Comp_Index IN {1 .. NrOfSewComponents}:
        state.inFluxPerSewComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InSewTerminal)}:
         (In_Terminal[Comp_Index]);
     };

     {state.Q_In = (parameters.SewSpecificVolume[H2O_sew] 
                  * state.inFluxPerSewComponent[H2O_sew]);
     };


    {FOREACH Comp_Index IN {1 .. NrOfSewComponents}:
      interface.Outflow[Comp_Index] =
      - state.inFluxPerSewComponent[Comp_Index];};   

    state.Out[H2O_sew]= -(parameters.SewSpecificVolume[H2O_sew] * interface.Outflow[H2O_sew]);

    {FOREACH Comp_Index IN {2 .. NrOfSewComponents}:
      state.Out[Comp_Index] = - interface.Outflow[Comp_Index] / state.Out[H2O_sew];};   

		state.CODtot = state.Out[COD_part] + state.Out[COD_sol];
    
   }; 
 :};




# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.fourcombiner.msl" 1
 


















 CLASS FourCombiner
 (* icon = "four_combiner" ; is_default = "true" *)  
 "Four combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of four flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 23 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.fivecombiner.msl" 1
 














 



 CLASS FiveCombiner
 (* icon = "five_combiner" ; is_default = "true" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of five flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Inflow5 (* terminal = "in_5" *) "Inflow5" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 5":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In5 (* is_favorite = "1" *) "Influent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In5 = interface.Inflow5[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 24 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2


 
 

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.reltwosplitter.msl" 1
 














 



CLASS RelTwoSplitter
 (* icon = "two_fraction_splitter" ; is_default = "true" *)
 "relative splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.9; group <- "Operational" :};
   };
  parameters <-
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 
 
 :};


# 29 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relthreesplitter.msl" 1
 














 



 CLASS RelThreeSplitter
 (* icon = "three_fraction_splitter" ; is_default = "true" *)
 "relative three splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.8 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};


# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relfoursplitter.msl" 1
 


















 CLASS RelFourSplitter
 (* icon = "four_fraction_splitter" ; is_default = "true" *)
 "relative four splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into four flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};
 


# 31 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relfivesplitter.msl" 1
 


















 CLASS RelFiveSplitter
 (* icon = "five_fraction_splitter" ; is_default = "true" *)
 "relative five splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into five flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow5" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out5 (* is_favorite = "1" *) "Effluent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4 + interface.f_Out5) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out5)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
      };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index] - interface.Outflow5[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out5 = - interface.Outflow5[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};


# 32 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2


 

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.abstwosplitter.msl" 1
 


















 CLASS AbsTwoSplitter
 (* icon = "two_flow_splitter" ; is_default = "true" *)
 "absolute two way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };
  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   
  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
    state.Q_Out1 = IF(interface.Q_Out2 > state.Q_In)
                   THEN 0
                   ELSE state.Q_In - state.Q_Out2_Actual ;

    state.Q_Out2_Actual = IF(interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out2) ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    
   }; 
 :};


# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absthreesplitter.msl" 1
 


















 CLASS AbsThreeSplitter
 (* icon = "three_flow_splitter" ; is_default = "true" *)
 "absolute three way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_4" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = IF ((state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual)) < 0.0)
	 								THEN 0.0
	 								ELSE state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual);

    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        	THEN state.Q_In - state.Q_Out2_Actual
                        	ELSE interface.Q_Out3;

    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   }; 
 :};


# 37 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absfoursplitter.msl" 1
 


















 CLASS AbsFourSplitter
 (* icon = "four_flow_splitter" ; is_default = "true" *)
 "absolute four way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into four flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_5" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual);
 
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual
                        ELSE interface.Q_Out3;

    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
                        ELSE interface.Q_Out4;

    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;
    state.f_Out4 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out4_Actual /state.Q_In ; 
           
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    
   }; 
 :};


# 38 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absfivesplitter.msl" 1
 


















 CLASS AbsFiveSplitter
 (* icon = "five_flow_splitter" ; is_default = "true" *)
 "absolute five way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into five flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow5 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_6" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ f_Out5 (* hidden = "1" *) "Fraction of the influent flux going to outflow5" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate ;
    OBJ Q_Out5_Actual (* is_favorite = "1" *) "Help variable for outflow5 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual);
 
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual
                        ELSE interface.Q_Out3;

    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
                        ELSE interface.Q_Out4;

    state.Q_Out5_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4+interface.Q_Out5) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual - state.Q_Out4_Actual
                        ELSE interface.Q_Out5;
            
    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;
    state.f_Out4 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out4_Actual /state.Q_In ; 
    state.f_Out5 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out5_Actual / state.Q_In ;
           
           
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out5 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   }; 
 :};


# 39 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.splitters_combiners.msl" 2



# 31 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.buffertanks.msl" 1
 


















CLASS PumpedVolumeBuffer
 "A class for buffertanks with a pumped variable volume"
 EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
  comments <- "A model for a tank with a variable volume caused by a pump";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

  equations <-
   {
     interface.V_Buffer = state.V;
   };
  initial <-
   {
   };
 :};

CLASS FixVolumeBuffer
 "A class for buffertanks with a fixed volume"
 EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
   comments <- "A model for a tank with a fixed volume";

   interface <-
   {
     OBJ V_Buffer  (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

   equations <-
   {
     interface.V_Buffer = state.V;
   };

   initial <-
   {
   };
 :};

CLASS VarVolumeBuffer
 "A class for buffertanks with variable volume"
 EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
  comments <- "A model for a  tank with a variable volume caused by a weir";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

  equations <-
   {
    interface.V_Buffer = state.V;
   };

  initial <-
   {
   }; :};
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumestormtank.msl" 1
 














 



CLASS PumpedVolumeStormTank
  (* icon = "storm_tank" ; is_default = "true" *)
  "Model for a storm tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a storm tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *) "Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :}; 



 
# 84 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumebuffertank.msl" 1
 


















CLASS PumpedVolumeBufferTank
  (* icon = "buffer_tank" ; is_default = "true" *)
  "Model for a buffer tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a buffer tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :};  
 



 
# 85 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\buffertank/wwtp.base.buffertanks.fixvolumeequalisationtank.msl" 1
 


















  CLASS FixVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES FixVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  



 
# 86 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\buffertank/wwtp.base.buffertanks.varvolumeequalisationtank.msl" 1
 


















  CLASS VarVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES VarVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  



 
# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumebuffertankEindhoven.msl" 1
 








 CLASS PumpedVolumeBuffer_Eindhoven
 (* icon = "buffer_tank" ; is_default = "true" *)
 "A class for buffertanks with a pumped variable volume"
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Q_Pump (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired effluent flow rate" : 
	 	  FlowRate := {: causality <- "CIN" ; value <- 100; group <- "Operational" :} ;   
		};

  parameters <-
   {
     OBJ V_Max "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
   };

  state <-
   {
     OBJ Q_Out "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
				   THEN 0
				   ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min)
                  THEN 0
                  ELSE IF ((state.V < parameters.V_Max) && (state.Q_In == 0))
                       THEN interface.Q_Pump
                       ELSE IF ((state.V < parameters.V_Max) && (state.Q_In > 0))
                            THEN 0
                            ELSE IF ((state.V >= parameters.V_Max) && (state.Q_In > 0))
							     THEN state.Q_In
								 ELSE interface.Q_Pump;    

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};



 
# 88 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.buffertanks.msl" 2




 
# 32 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.activated_sludge_units.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl" 1
 


















 CLASS FixVolumeASU 
 (* icon = "activated_sludge_unit" ; is_default = "true" *)
 SPECIALISES FixVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a fixed volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	 	OBJ DOsat	(* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen saturation" : Concentration	
	 	:= {: causality <- "CIN" ; value <- 12 ; group <- "Conversion factors" :}; 


   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;
  	state.S_O_Saturation = interface.DOsat;


    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ; 
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
               THEN parameters.ME_unit * state.V
             ELSE 
               IF (parameters.Mixing_When_Aerated)
               THEN parameters.ME_unit * state.V
               ELSE 0;    

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
   };   
 :};



# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.pumpedvolumeasu.msl" 1
 


















 CLASS PumpedVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES PumpedVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable pumped volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	 	OBJ DOsat	(* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen saturation" : Concentration	
	 	:= {: causality <- "CIN" ; value <- 12 ; group <- "Conversion factors" :}; 

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;
  	state.S_O_Saturation = interface.DOsat;


    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };   
 :};



# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.varvolumeasu.msl" 1
 


















 CLASS VarVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES VarVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
   };   
 :};



# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.activated_sludge_units.msl" 2




# 33 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 1
 


















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 1
 


















CLASS  FixVolumeTwoTank
SPECIALISES CoupledModelType :=
{:
 interface <-
 {
  OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :},
  OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent" :},

  OBJ Temp (* terminal = "in_2"; manip = "1" *) "Temperature of the activated sludge" : CelsiusTemperature := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  OBJ Kla1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU1" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ Kla2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU2" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy1 (* terminal = "out_2" *)"Aeration energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy1 (* terminal = "out_2" *)"Mixing energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ AerationEnergy2 (* terminal = "out_2" *)"Aeration energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy2 (* terminal = "out_2" *)"Mixing energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  


   
    OBJ DO_ASU1 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU1" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU1 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU1 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU1 (* terminal = "out_2" *)"Total suspended solids concentration in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU1 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU1 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU1 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU1 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU1 (* terminal = "out_2" *)"Volume measurement data in ASU1" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU1 (* terminal = "out_2" *)"OUR measurement data in ASU1" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU1 (* terminal = "out_2" *)"NUR measurement data in ASU1" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU1 (* terminal = "out_2" *)"NPR measurement data in ASU1" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU1 (* terminal = "out_2" *)"AUR measurement data in ASU1" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU1 (* terminal = "out_2" *)"Kla measurement data in ASU1" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
 
    OBJ DO_ASU2 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU2" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU2 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU2 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU2 (* terminal = "out_2" *)"Total suspended solids concentration in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU2 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU2 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU2 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU2 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU2 (* terminal = "out_2" *)"Volume measurement data in ASU2" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU2 (* terminal = "out_2" *)"OUR measurement data in ASU2" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU2 (* terminal = "out_2" *)"NUR measurement data in ASU2" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU2 (* terminal = "out_2" *)"NPR measurement data in ASU2" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU2 (* terminal = "out_2" *)"AUR measurement data in ASU2" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU2 (* terminal = "out_2" *)"Kla measurement data in ASU2" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 37 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2


 };

 parameters <-
 {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.parameters.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.parameters.msl" 2














# 43 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

  OBJ Vol1 (* is_favorite = "1" *) "Volume of ASU1" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  OBJ Vol2 (* is_favorite = "1" *) "Volume of ASU2" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
 };

 sub_models <-
 {
  OBJ ASU1 : FixVolumeASU,
  OBJ ASU2 : FixVolumeASU,
 };

 coupling <-
 {
   
  sub_models.ASU1.parameters.Vol.value := parameters.Vol1.value,
  sub_models.ASU2.parameters.Vol.value := parameters.Vol2.value,


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 


















  sub_models.ASU1.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU2.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU1.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU2.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU1.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU2.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU1.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU2.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU1.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU2.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU1.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU2.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU1.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU2.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU1.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU2.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU1.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU2.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU1.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU2.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU1.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU2.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU1.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU2.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU1.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU2.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU1.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU2.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU1.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU2.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU1.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU2.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU1.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU2.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU1.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU2.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU1.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU2.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU1.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU2.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU1.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU2.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU1.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU2.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU1.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU2.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU1.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU2.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU1.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU2.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU1.parameters.K_OA.value := parameters.K_OA.value,
  sub_models.ASU2.parameters.K_OA.value := parameters.K_OA.value,


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 61 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 

















  connect(sub_models.ASU1.interface.DO, interface.DO_ASU1),
  connect(sub_models.ASU2.interface.DO, interface.DO_ASU2),
  connect(sub_models.ASU1.interface.NH4, interface.NH4_ASU1),
  connect(sub_models.ASU2.interface.NH4, interface.NH4_ASU2),
  connect(sub_models.ASU1.interface.NO3, interface.NO3_ASU1),
  connect(sub_models.ASU2.interface.NO3, interface.NO3_ASU2),
  connect(sub_models.ASU1.interface.TSS, interface.TSS_ASU1),
  connect(sub_models.ASU2.interface.TSS, interface.TSS_ASU2),
  connect(sub_models.ASU1.interface.OnlineCOD, interface.OnlineCOD_ASU1),
  connect(sub_models.ASU2.interface.OnlineCOD, interface.OnlineCOD_ASU2),
  connect(sub_models.ASU1.interface.OfflineBOD, interface.OfflineBOD_ASU1),
  connect(sub_models.ASU2.interface.OfflineBOD, interface.OfflineBOD_ASU2),
  connect(sub_models.ASU1.interface.OnlineTN, interface.OnlineTN_ASU1),
  connect(sub_models.ASU2.interface.OnlineTN, interface.OnlineTN_ASU2),
  connect(sub_models.ASU1.interface.OfflineTKN, interface.OfflineTKN_ASU1),
  connect(sub_models.ASU2.interface.OfflineTKN, interface.OfflineTKN_ASU2),
  connect(sub_models.ASU1.interface.V_ASU, interface.V_ASU1),
  connect(sub_models.ASU2.interface.V_ASU, interface.V_ASU2),
  connect(sub_models.ASU1.interface.OUR_ASU, interface.OUR_ASU1),
  connect(sub_models.ASU2.interface.OUR_ASU, interface.OUR_ASU2),
  connect(sub_models.ASU1.interface.NUR, interface.NUR_ASU1),
  connect(sub_models.ASU2.interface.NUR, interface.NUR_ASU2),
  connect(sub_models.ASU1.interface.NPR, interface.NPR_ASU1),
  connect(sub_models.ASU2.interface.NPR, interface.NPR_ASU2),
  connect(sub_models.ASU1.interface.AUR, interface.AUR_ASU1),
  connect(sub_models.ASU2.interface.AUR, interface.AUR_ASU2),
  connect(sub_models.ASU1.interface.Kla_ASU, interface.Kla_ASU1),
  connect(sub_models.ASU2.interface.Kla_ASU, interface.Kla_ASU2),



# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 62 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2




  sub_models.ASU1.parameters.Temp_Ref.value := parameters.Temp_Ref.value,
  sub_models.ASU2.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   
  connect(interface.Inflow, sub_models.ASU1.interface.Inflow),
  connect(sub_models.ASU1.interface.Outflow, sub_models.ASU2.interface.Inflow),
  connect(interface.Kla1, sub_models.ASU1.interface.Kla),
  connect(interface.Kla2, sub_models.ASU2.interface.Kla),
  connect(sub_models.ASU1.interface.AerationEnergy, interface.AerationEnergy1),
  connect(sub_models.ASU2.interface.AerationEnergy, interface.AerationEnergy2),
  connect(sub_models.ASU1.interface.MixingEnergy, interface.MixingEnergy1),
  connect(sub_models.ASU2.interface.MixingEnergy, interface.MixingEnergy2),

  connect(interface.Temp, sub_models.ASU1.interface.Temp),
  connect(interface.Temp, sub_models.ASU2.interface.Temp),

 };
:};



# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasutwotank.msl" 1
 


















CLASS  FixVolumeASUTwoTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTwoTank:=
{:
 comments <- "A coupled model for two activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU2.interface.Outflow, interface.Outflow),
 };
:};



# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 1
 


















CLASS  FixVolumeThreeTank
EXTENDS FixVolumeTwoTank WITH
{:

 sub_models <-
 {

  OBJ ASU3 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU3" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy3 (* terminal = "out_2" *)"Aeration energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy3 (* terminal = "out_2" *)"Mixing energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU3 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU3" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU3 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU3 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU3 (* terminal = "out_2" *)"Total suspended solids concentration in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU3 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU3 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU3 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU3 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU3 (* terminal = "out_2" *)"Volume measurement data in ASU3" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU3 (* terminal = "out_2" *)"OUR measurement data in ASU3" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU3 (* terminal = "out_2" *)"NUR measurement data in ASU3" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU3 (* terminal = "out_2" *)"NPR measurement data in ASU3" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU3 (* terminal = "out_2" *)"AUR measurement data in ASU3" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU3 (* terminal = "out_2" *)"Kla measurement data in ASU3" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol3 (* is_favorite = "1" *) "Volume of ASU3" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU3.parameters.Vol.value := parameters.Vol3.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU3.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU3.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU3.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU3.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU3.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU3.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU3.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU3.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU3.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU3.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU3.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU3.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU3.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU3.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU3.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU3.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU3.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU3.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU3.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU3.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU3.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU3.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU3.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU3.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU3.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU3.parameters.K_OA.value := parameters.K_OA.value,


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU3.interface.DO, interface.DO_ASU3),
  connect(sub_models.ASU3.interface.NH4, interface.NH4_ASU3),
  connect(sub_models.ASU3.interface.NO3, interface.NO3_ASU3),
  connect(sub_models.ASU3.interface.TSS, interface.TSS_ASU3),
  connect(sub_models.ASU3.interface.OnlineCOD, interface.OnlineCOD_ASU3),
  connect(sub_models.ASU3.interface.OfflineBOD, interface.OfflineBOD_ASU3),
  connect(sub_models.ASU3.interface.OnlineTN, interface.OnlineTN_ASU3),
  connect(sub_models.ASU3.interface.OfflineTKN, interface.OfflineTKN_ASU3),
  connect(sub_models.ASU3.interface.V_ASU, interface.V_ASU3),
  connect(sub_models.ASU3.interface.OUR_ASU, interface.OUR_ASU3),
  connect(sub_models.ASU3.interface.NUR, interface.NUR_ASU3),
  connect(sub_models.ASU3.interface.NPR, interface.NPR_ASU3),
  connect(sub_models.ASU3.interface.AUR, interface.AUR_ASU3),
  connect(sub_models.ASU3.interface.Kla_ASU, interface.Kla_ASU3),


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

 


  sub_models.ASU3.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU2.interface.Outflow, sub_models.ASU3.interface.Inflow),
  connect(interface.Kla3, sub_models.ASU3.interface.Kla),
  connect(sub_models.ASU3.interface.AerationEnergy, interface.AerationEnergy3),
  connect(sub_models.ASU3.interface.MixingEnergy, interface.MixingEnergy3),

  connect(interface.Temp, sub_models.ASU3.interface.Temp),


 };
:};



# 24 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuthreetank.msl" 1
 


















CLASS  FixVolumeASUThreeTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeThreeTank:=
{:
 comments <- "A coupled model for three activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU3.interface.Outflow, interface.Outflow),
 };
:};



# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 1
 


















CLASS  FixVolumeFourTank
EXTENDS FixVolumeThreeTank WITH
{:

 sub_models <-
 {

  OBJ ASU4 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU4" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy4 (* terminal = "out_2" *)"Aeration energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy4 (* terminal = "out_2" *)"Mixing energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU4 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU4" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU4 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU4 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU4 (* terminal = "out_2" *)"Total suspended solids concentration in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU4 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU4 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU4 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU4 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU4 (* terminal = "out_2" *)"Volume measurement data in ASU4" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU4 (* terminal = "out_2" *)"OUR measurement data in ASU4" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU4 (* terminal = "out_2" *)"NUR measurement data in ASU4" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU4 (* terminal = "out_2" *)"NPR measurement data in ASU4" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU4 (* terminal = "out_2" *)"AUR measurement data in ASU4" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU4 (* terminal = "out_2" *)"Kla measurement data in ASU4" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol4 (* is_favorite = "1" *) "Volume of ASU4" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU4.parameters.Vol.value := parameters.Vol4.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU4.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU4.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU4.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU4.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU4.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU4.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU4.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU4.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU4.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU4.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU4.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU4.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU4.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU4.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU4.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU4.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU4.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU4.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU4.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU4.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU4.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU4.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU4.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU4.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU4.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU4.parameters.K_OA.value := parameters.K_OA.value,



# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU4.interface.DO, interface.DO_ASU4),
  connect(sub_models.ASU4.interface.NH4, interface.NH4_ASU4),
  connect(sub_models.ASU4.interface.NO3, interface.NO3_ASU4),
  connect(sub_models.ASU4.interface.TSS, interface.TSS_ASU4),
  connect(sub_models.ASU4.interface.OnlineCOD, interface.OnlineCOD_ASU4),
  connect(sub_models.ASU4.interface.OfflineBOD, interface.OfflineBOD_ASU4),
  connect(sub_models.ASU4.interface.OnlineTN, interface.OnlineTN_ASU4),
  connect(sub_models.ASU4.interface.OfflineTKN, interface.OfflineTKN_ASU4),
  connect(sub_models.ASU4.interface.V_ASU, interface.V_ASU4),
  connect(sub_models.ASU4.interface.OUR_ASU, interface.OUR_ASU4),
  connect(sub_models.ASU4.interface.NUR, interface.NUR_ASU4),
  connect(sub_models.ASU4.interface.NPR, interface.NPR_ASU4),
  connect(sub_models.ASU4.interface.AUR, interface.AUR_ASU4),
  connect(sub_models.ASU4.interface.Kla_ASU, interface.Kla_ASU4),


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

 


  sub_models.ASU4.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU3.interface.Outflow, sub_models.ASU4.interface.Inflow),
  connect(interface.Kla4, sub_models.ASU4.interface.Kla),
  connect(sub_models.ASU4.interface.AerationEnergy, interface.AerationEnergy4),
  connect(sub_models.ASU4.interface.MixingEnergy, interface.MixingEnergy4),

  connect(interface.Temp, sub_models.ASU4.interface.Temp),


 };
:};



# 27 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasufourtank.msl" 1
 


















CLASS  FixVolumeASUFourTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFourTank:=
{:
 comments <- "A coupled model for four activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU4.interface.Outflow, interface.Outflow),
 };
:};



# 28 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 1
 


















CLASS  FixVolumeFiveTank
EXTENDS FixVolumeFourTank WITH
{:

 sub_models <-
 {

  OBJ ASU5 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU5" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy5 (* terminal = "out_2" *)"Aeration energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy5 (* terminal = "out_2" *)"Mixing energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU5 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU5" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU5 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU5 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU5 (* terminal = "out_2" *)"Total suspended solids concentration in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU5 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU5 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU5 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU5 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU5 (* terminal = "out_2" *)"Volume measurement data in ASU5" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU5 (* terminal = "out_2" *)"OUR measurement data in ASU5" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU5 (* terminal = "out_2" *)"NUR measurement data in ASU5" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU5 (* terminal = "out_2" *)"NPR measurement data in ASU5" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU5 (* terminal = "out_2" *)"AUR measurement data in ASU5" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU5 (* terminal = "out_2" *)"Kla measurement data in ASU5" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol5 (* is_favorite = "1" *) "Volume of ASU5" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU5.parameters.Vol.value := parameters.Vol5.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU5.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU5.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU5.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU5.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU5.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU5.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU5.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU5.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU5.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU5.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU5.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU5.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU5.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU5.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU5.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU5.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU5.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU5.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU5.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU5.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU5.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU5.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU5.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU5.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU5.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU5.parameters.K_OA.value := parameters.K_OA.value,


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU5.interface.DO, interface.DO_ASU5),
  connect(sub_models.ASU5.interface.NH4, interface.NH4_ASU5),
  connect(sub_models.ASU5.interface.NO3, interface.NO3_ASU5),
  connect(sub_models.ASU5.interface.TSS, interface.TSS_ASU5),
  connect(sub_models.ASU5.interface.OnlineCOD, interface.OnlineCOD_ASU5),
  connect(sub_models.ASU5.interface.OfflineBOD, interface.OfflineBOD_ASU5),
  connect(sub_models.ASU5.interface.OnlineTN, interface.OnlineTN_ASU5),
  connect(sub_models.ASU5.interface.OfflineTKN, interface.OfflineTKN_ASU5),
  connect(sub_models.ASU5.interface.V_ASU, interface.V_ASU5),
  connect(sub_models.ASU5.interface.OUR_ASU, interface.OUR_ASU5),
  connect(sub_models.ASU5.interface.NUR, interface.NUR_ASU5),
  connect(sub_models.ASU5.interface.NPR, interface.NPR_ASU5),
  connect(sub_models.ASU5.interface.AUR, interface.AUR_ASU5),
  connect(sub_models.ASU5.interface.Kla_ASU, interface.Kla_ASU5),


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

 


  sub_models.ASU5.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU4.interface.Outflow, sub_models.ASU5.interface.Inflow),
  connect(interface.Kla5, sub_models.ASU5.interface.Kla),
  connect(sub_models.ASU5.interface.AerationEnergy, interface.AerationEnergy5),
  connect(sub_models.ASU5.interface.MixingEnergy, interface.MixingEnergy5),

  connect(interface.Temp, sub_models.ASU5.interface.Temp),


 };
:};



# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasufivetank.msl" 1
 


















CLASS  FixVolumeASUFiveTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFiveTank:=
{:
 comments <- "A coupled model for five activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU5.interface.Outflow, interface.Outflow),
 };
:};



# 31 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 1
 


















CLASS  FixVolumeSixTank
EXTENDS FixVolumeFiveTank WITH
{:

 sub_models <-
 {

  OBJ ASU6 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU6" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy6 (* terminal = "out_2" *)"Aeration energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy6 (* terminal = "out_2" *)"Mixing energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU6 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU6" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU6 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU6 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU6 (* terminal = "out_2" *)"Total suspended solids concentration in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU6 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU6 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU6 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU6 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU6 (* terminal = "out_2" *)"Volume measurement data in ASU6" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU6 (* terminal = "out_2" *)"OUR measurement data in ASU6" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU6 (* terminal = "out_2" *)"NUR measurement data in ASU6" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU6 (* terminal = "out_2" *)"NPR measurement data in ASU6" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU6 (* terminal = "out_2" *)"AUR measurement data in ASU6" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU6 (* terminal = "out_2" *)"Kla measurement data in ASU6" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol6 (* is_favorite = "1" *) "Volume of ASU6" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU6.parameters.Vol.value := parameters.Vol6.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU6.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU6.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU6.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU6.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU6.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU6.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU6.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU6.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU6.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU6.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU6.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU6.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU6.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU6.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU6.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU6.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU6.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU6.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU6.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU6.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU6.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU6.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU6.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU6.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU6.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU6.parameters.K_OA.value := parameters.K_OA.value,


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU6.interface.DO, interface.DO_ASU6),
  connect(sub_models.ASU6.interface.NH4, interface.NH4_ASU6),
  connect(sub_models.ASU6.interface.NO3, interface.NO3_ASU6),
  connect(sub_models.ASU6.interface.TSS, interface.TSS_ASU6),
  connect(sub_models.ASU6.interface.OnlineCOD, interface.OnlineCOD_ASU6),
  connect(sub_models.ASU6.interface.OfflineBOD, interface.OfflineBOD_ASU6),
  connect(sub_models.ASU6.interface.OnlineTN, interface.OnlineTN_ASU6),
  connect(sub_models.ASU6.interface.OfflineTKN, interface.OfflineTKN_ASU6),
  connect(sub_models.ASU6.interface.V_ASU, interface.V_ASU6),
  connect(sub_models.ASU6.interface.OUR_ASU, interface.OUR_ASU6),
  connect(sub_models.ASU6.interface.NUR, interface.NUR_ASU6),
  connect(sub_models.ASU6.interface.NPR, interface.NPR_ASU6),
  connect(sub_models.ASU6.interface.AUR, interface.AUR_ASU6),
  connect(sub_models.ASU6.interface.Kla_ASU, interface.Kla_ASU6),


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

 


  sub_models.ASU6.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU5.interface.Outflow, sub_models.ASU6.interface.Inflow),
  connect(interface.Kla6, sub_models.ASU6.interface.Kla),
  connect(sub_models.ASU6.interface.AerationEnergy, interface.AerationEnergy6),
  connect(sub_models.ASU6.interface.MixingEnergy, interface.MixingEnergy6),

  connect(interface.Temp, sub_models.ASU6.interface.Temp),


 };
:};



# 33 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasusixtank.msl" 1
 


















CLASS  FixVolumeASUSixTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSixTank:=
{:
 comments <- "A coupled model for six activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU6.interface.Outflow, interface.Outflow),
 };
:};



# 34 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 1
 


















CLASS  FixVolumeSevenTank
EXTENDS FixVolumeSixTank WITH
{:

 sub_models <-
 {

  OBJ ASU7 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU7" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy7 (* terminal = "out_2" *)"Aeration energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy7 (* terminal = "out_2" *)"Mixing energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU7 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU7" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU7 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU7 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU7 (* terminal = "out_2" *)"Total suspended solids concentration in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU7 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU7 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU7 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU7 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU7 (* terminal = "out_2" *)"Volume measurement data in ASU7" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU7 (* terminal = "out_2" *)"OUR measurement data in ASU7" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU7 (* terminal = "out_2" *)"NUR measurement data in ASU7" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU7 (* terminal = "out_2" *)"NPR measurement data in ASU7" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU7 (* terminal = "out_2" *)"AUR measurement data in ASU7" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU7 (* terminal = "out_2" *)"Kla measurement data in ASU7" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol7 (* is_favorite = "1" *) "Volume of ASU7" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU7.parameters.Vol.value := parameters.Vol7.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU7.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU7.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU7.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU7.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU7.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU7.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU7.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU7.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU7.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU7.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU7.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU7.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU7.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU7.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU7.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU7.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU7.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU7.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU7.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU7.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU7.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU7.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU7.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU7.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU7.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU7.parameters.K_OA.value := parameters.K_OA.value,


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU7.interface.DO, interface.DO_ASU7),
  connect(sub_models.ASU7.interface.NH4, interface.NH4_ASU7),
  connect(sub_models.ASU7.interface.NO3, interface.NO3_ASU7),
  connect(sub_models.ASU7.interface.TSS, interface.TSS_ASU7),
  connect(sub_models.ASU7.interface.OnlineCOD, interface.OnlineCOD_ASU7),
  connect(sub_models.ASU7.interface.OfflineBOD, interface.OfflineBOD_ASU7),
  connect(sub_models.ASU7.interface.OnlineTN, interface.OnlineTN_ASU7),
  connect(sub_models.ASU7.interface.OfflineTKN, interface.OfflineTKN_ASU7),
  connect(sub_models.ASU7.interface.V_ASU, interface.V_ASU7),
  connect(sub_models.ASU7.interface.OUR_ASU, interface.OUR_ASU7),
  connect(sub_models.ASU7.interface.NUR, interface.NUR_ASU7),
  connect(sub_models.ASU7.interface.NPR, interface.NPR_ASU7),
  connect(sub_models.ASU7.interface.AUR, interface.AUR_ASU7),
  connect(sub_models.ASU7.interface.Kla_ASU, interface.Kla_ASU7),


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

 


  sub_models.ASU7.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU6.interface.Outflow, sub_models.ASU7.interface.Inflow),
  connect(interface.Kla7, sub_models.ASU7.interface.Kla),
  connect(sub_models.ASU7.interface.AerationEnergy, interface.AerationEnergy7),
  connect(sub_models.ASU7.interface.MixingEnergy, interface.MixingEnergy7),

  connect(interface.Temp, sub_models.ASU7.interface.Temp),


 };
:};



# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuseventank.msl" 1
 


















CLASS  FixVolumeASUSevenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSevenTank:=
{:
 comments <- "A coupled model for seven activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU7.interface.Outflow, interface.Outflow),
 };
:};



# 37 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 1
 


















CLASS  FixVolumeEightTank
EXTENDS FixVolumeSevenTank WITH
{:

 sub_models <-
 {

  OBJ ASU8 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU8" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy8 (* terminal = "out_2" *)"Aeration energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy8 (* terminal = "out_2" *)"Mixing energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU8 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU8" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU8 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU8 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU8 (* terminal = "out_2" *)"Total suspended solids concentration in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU8 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU8 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU8 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU8 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU8 (* terminal = "out_2" *)"Volume measurement data in ASU8" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU8 (* terminal = "out_2" *)"OUR measurement data in ASU8" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU8 (* terminal = "out_2" *)"NUR measurement data in ASU8" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU8 (* terminal = "out_2" *)"NPR measurement data in ASU8" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU8 (* terminal = "out_2" *)"AUR measurement data in ASU8" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU8 (* terminal = "out_2" *)"Kla measurement data in ASU8" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol8 (* is_favorite = "1" *) "Volume of ASU8" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU8.parameters.Vol.value := parameters.Vol8.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU8.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU8.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU8.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU8.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU8.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU8.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU8.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU8.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU8.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU8.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU8.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU8.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU8.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU8.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU8.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU8.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU8.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU8.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU8.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU8.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU8.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU8.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU8.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU8.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU8.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU8.parameters.K_OA.value := parameters.K_OA.value,


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU8.interface.DO, interface.DO_ASU8),
  connect(sub_models.ASU8.interface.NH4, interface.NH4_ASU8),
  connect(sub_models.ASU8.interface.NO3, interface.NO3_ASU8),
  connect(sub_models.ASU8.interface.TSS, interface.TSS_ASU8),
  connect(sub_models.ASU8.interface.OnlineCOD, interface.OnlineCOD_ASU8),
  connect(sub_models.ASU8.interface.OfflineBOD, interface.OfflineBOD_ASU8),
  connect(sub_models.ASU8.interface.OnlineTN, interface.OnlineTN_ASU8),
  connect(sub_models.ASU8.interface.OfflineTKN, interface.OfflineTKN_ASU8),
  connect(sub_models.ASU8.interface.V_ASU, interface.V_ASU8),
  connect(sub_models.ASU8.interface.OUR_ASU, interface.OUR_ASU8),
  connect(sub_models.ASU8.interface.NUR, interface.NUR_ASU8),
  connect(sub_models.ASU8.interface.NPR, interface.NPR_ASU8),
  connect(sub_models.ASU8.interface.AUR, interface.AUR_ASU8),
  connect(sub_models.ASU8.interface.Kla_ASU, interface.Kla_ASU8),


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

 


  sub_models.ASU8.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU7.interface.Outflow, sub_models.ASU8.interface.Inflow),
  connect(interface.Kla8, sub_models.ASU8.interface.Kla),
  connect(sub_models.ASU8.interface.AerationEnergy, interface.AerationEnergy8),
  connect(sub_models.ASU8.interface.MixingEnergy, interface.MixingEnergy8),

  connect(interface.Temp, sub_models.ASU8.interface.Temp),


 };
:};



# 39 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasueighttank.msl" 1
 


















CLASS  FixVolumeASUEightTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeEightTank:=
{:
 comments <- "A coupled model for eight activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU8.interface.Outflow, interface.Outflow),
 };
:};



# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 1
 


















CLASS  FixVolumeNineTank
EXTENDS FixVolumeEightTank WITH
{:

 sub_models <-
 {

  OBJ ASU9 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla9 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU9" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy9 (* terminal = "out_2" *)"Aeration energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy9 (* terminal = "out_2" *)"Mixing energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU9 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU9" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU9 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU9 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU9 (* terminal = "out_2" *)"Total suspended solids concentration in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU9 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU9 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU9 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU9 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU9 (* terminal = "out_2" *)"Volume measurement data in ASU9" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU9 (* terminal = "out_2" *)"OUR measurement data in ASU9" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU9 (* terminal = "out_2" *)"NUR measurement data in ASU9" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU9 (* terminal = "out_2" *)"NPR measurement data in ASU9" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU9 (* terminal = "out_2" *)"AUR measurement data in ASU9" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU9 (* terminal = "out_2" *)"Kla measurement data in ASU9" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 195 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol9 (* is_favorite = "1" *) "Volume of ASU9" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU9.parameters.Vol.value := parameters.Vol9.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU9.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU9.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU9.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU9.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU9.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU9.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU9.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU9.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU9.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU9.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU9.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU9.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU9.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU9.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU9.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU9.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU9.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU9.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU9.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU9.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU9.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU9.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU9.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU9.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU9.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU9.parameters.K_OA.value := parameters.K_OA.value,


# 322 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU9.interface.DO, interface.DO_ASU9),
  connect(sub_models.ASU9.interface.NH4, interface.NH4_ASU9),
  connect(sub_models.ASU9.interface.NO3, interface.NO3_ASU9),
  connect(sub_models.ASU9.interface.TSS, interface.TSS_ASU9),
  connect(sub_models.ASU9.interface.OnlineCOD, interface.OnlineCOD_ASU9),
  connect(sub_models.ASU9.interface.OfflineBOD, interface.OfflineBOD_ASU9),
  connect(sub_models.ASU9.interface.OnlineTN, interface.OnlineTN_ASU9),
  connect(sub_models.ASU9.interface.OfflineTKN, interface.OfflineTKN_ASU9),
  connect(sub_models.ASU9.interface.V_ASU, interface.V_ASU9),
  connect(sub_models.ASU9.interface.OUR_ASU, interface.OUR_ASU9),
  connect(sub_models.ASU9.interface.NUR, interface.NUR_ASU9),
  connect(sub_models.ASU9.interface.NPR, interface.NPR_ASU9),
  connect(sub_models.ASU9.interface.AUR, interface.AUR_ASU9),
  connect(sub_models.ASU9.interface.Kla_ASU, interface.Kla_ASU9),


# 184 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

 


  sub_models.ASU9.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU8.interface.Outflow, sub_models.ASU9.interface.Inflow),
  connect(interface.Kla9, sub_models.ASU9.interface.Kla),
  connect(sub_models.ASU9.interface.AerationEnergy, interface.AerationEnergy9),
  connect(sub_models.ASU9.interface.MixingEnergy, interface.MixingEnergy9),

  connect(interface.Temp, sub_models.ASU9.interface.Temp),


 };
:};



# 42 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuninetank.msl" 1
 


















CLASS  FixVolumeASUNineTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeNineTank:=
{:
 comments <- "A coupled model for nine activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU9.interface.Outflow, interface.Outflow),
 };
:};



# 43 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 1
 


















CLASS  FixVolumeTenTank
EXTENDS FixVolumeNineTank WITH
{:

 sub_models <-
 {

  OBJ ASU10 : FixVolumeASU,
 };

 parameters <-  
 {
  OBJ Vol10 (* is_favorite = "1" *) "Volume of ASU10" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 interface <-
 {
  OBJ Kla10 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU10" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy10 (* terminal = "out_2" *)"Aeration energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy10 (* terminal = "out_2" *)"Mixing energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl" 1
 















 
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 87 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 105 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 123 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 141 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"


# 177 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM1.msl"



   
    OBJ DO_ASU10 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU10" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU10 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU10 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU10 (* terminal = "out_2" *)"Total suspended solids concentration in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU10 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU10 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU10 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU10 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU10 (* terminal = "out_2" *)"Volume measurement data in ASU10" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU10 (* terminal = "out_2" *)"OUR measurement data in ASU10" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU10 (* terminal = "out_2" *)"NUR measurement data in ASU10" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU10 (* terminal = "out_2" *)"NPR measurement data in ASU10" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU10 (* terminal = "out_2" *)"AUR measurement data in ASU10" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU10 (* terminal = "out_2" *)"Kla measurement data in ASU10" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};



# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2














# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2


 };

 coupling <-
 {
   
  sub_models.ASU10.parameters.Vol.value := parameters.Vol10.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl" 1
 
















# 73 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 104 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 136 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 198 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 229 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 260 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"


# 291 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM1.msl"




  sub_models.ASU10.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU10.parameters.theta_mu_A.value := parameters.theta_mu_A.value,
  sub_models.ASU10.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU10.parameters.theta_b_A.value := parameters.theta_b_A.value,
  sub_models.ASU10.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU10.parameters.theta_k_a.value := parameters.theta_k_a.value,
  sub_models.ASU10.parameters.theta_K_X.value := parameters.theta_K_X.value,

  sub_models.ASU10.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU10.parameters.i_X_B.value := parameters.i_X_B.value,
  sub_models.ASU10.parameters.Y_A.value := parameters.Y_A.value,
  sub_models.ASU10.parameters.f_P.value := parameters.f_P.value,
  sub_models.ASU10.parameters.i_X_P.value := parameters.i_X_P.value,
  sub_models.ASU10.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU10.parameters.mu_A.value := parameters.mu_A.value,
  sub_models.ASU10.parameters.K_S.value := parameters.K_S.value,
  sub_models.ASU10.parameters.K_OH.value := parameters.K_OH.value,
  sub_models.ASU10.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU10.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU10.parameters.b_A.value := parameters.b_A.value,
  sub_models.ASU10.parameters.n_h.value := parameters.n_h.value,
  sub_models.ASU10.parameters.n_g.value := parameters.n_g.value,
  sub_models.ASU10.parameters.k_a.value := parameters.k_a.value,
  sub_models.ASU10.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU10.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU10.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU10.parameters.K_OA.value := parameters.K_OA.value,


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2














# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 
















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl" 1
 
















# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 82 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 99 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 116 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 133 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"


# 167 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM1.msl"



  connect(sub_models.ASU10.interface.DO, interface.DO_ASU10),
  connect(sub_models.ASU10.interface.NH4, interface.NH4_ASU10),
  connect(sub_models.ASU10.interface.NO3, interface.NO3_ASU10),
  connect(sub_models.ASU10.interface.TSS, interface.TSS_ASU10),
  connect(sub_models.ASU10.interface.OnlineCOD, interface.OnlineCOD_ASU10),
  connect(sub_models.ASU10.interface.OfflineBOD, interface.OfflineBOD_ASU10),
  connect(sub_models.ASU10.interface.OnlineTN, interface.OnlineTN_ASU10),
  connect(sub_models.ASU10.interface.OfflineTKN, interface.OfflineTKN_ASU10),
  connect(sub_models.ASU10.interface.V_ASU, interface.V_ASU10),
  connect(sub_models.ASU10.interface.OUR_ASU, interface.OUR_ASU10),
  connect(sub_models.ASU10.interface.NUR, interface.NUR_ASU10),
  connect(sub_models.ASU10.interface.NPR, interface.NPR_ASU10),
  connect(sub_models.ASU10.interface.AUR, interface.AUR_ASU10),
  connect(sub_models.ASU10.interface.Kla_ASU, interface.Kla_ASU10),


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2














# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

 


  sub_models.ASU10.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU9.interface.Outflow, sub_models.ASU10.interface.Inflow),
  connect(interface.Kla10, sub_models.ASU10.interface.Kla),
  connect(sub_models.ASU10.interface.AerationEnergy, interface.AerationEnergy10),
  connect(sub_models.ASU10.interface.MixingEnergy, interface.MixingEnergy10),

  connect(interface.Temp, sub_models.ASU10.interface.Temp),


 };
:};



# 45 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasutentank.msl" 1
 


















CLASS  FixVolumeASUTenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTenTank:=
{:
 comments <- "A coupled model for ten activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU10.interface.Outflow, interface.Outflow),
 };
:};



# 46 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.n_tanks.msl" 2




# 34 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.SBR.msl" 1
 


















CLASS SBRAtomicModel
SPECIALISES PhysicalDAEModelType :=
  {:
  
  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "influent" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :};
  OBJ Outflow1 (* terminal = "out_1" *) "effluent" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 1" :};
  };
  
  parameters <- 
  {
   
    OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components": SpecificVolumeVector;
  
   
    OBJ Q_Waste (* is_favorite = "1" *) "Desired waste flow rate during the idle phase" : FlowRate := {: value <- 240; group <- "Operational" :};
  };

  independent <- 
  { 
    OBJ t "Time": Time := {: group <- "Time" :};
  };
    
  state <-
  
  {
    OBJ ConversionTermPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ V (* is_favorite = "1" *) "Volume in the tank" : Volume := {: group <- "Dimension" :};
    OBJ C "Concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
 
    OBJ FluxPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Incoming massflux per component" : MassFluxVector;
 
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
 
    OBJ M "Vector containing masses for all the components" : MassVector 

         := [{: value <- 1000000000:},{: value <- 1 :},
                  {: value <- 2 :},{: value <- 1 :},
                {: value <- 2 :}, {: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                {: value <- 1 :},{: value <- 1 :},
                                {: value <- 1000 :},{: value <- 100 :},
                {: value <- 1 :},{: value <- 1 :}; ]



















;
    };
  
  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    };  

  equations <- 
   {
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
       (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
         In_Terminal[Comp_Index])+
       (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
         Out_Terminal[Comp_Index]);
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
     };
   
 
    state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]);

 
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     (parameters.WWTPSpecificVolume[Comp_Index] * state.M[Comp_Index]);

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.C[Comp_Index] = IF (state.V == 0)
                   THEN 0
                 ELSE state.M[Comp_Index]/state.V;
     };  
    };  
    :};

CLASS SBRConversionModel
EXTENDS SBRAtomicModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 129 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.SBR.msl" 2

 :};

CLASS SBRASMConversionModel
EXTENDS SBRConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 1
 
















   interface <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.interface.msl" 1
 















 
    
    OBJ DO (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4 (* terminal = "out_2"; is_favorite = "1" *)"Ammonium concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ NO3 (* terminal = "out_2"; is_favorite = "1" *)"Nitrate+Nitrite concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2"; is_favorite = "1" *)"Total suspended solids concentration" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD (* terminal = "out_2" *)"Chemical Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   
    OBJ OfflineBOD (* terminal = "out_2" *)"Biological Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN (* terminal = "out_2" *)"Total nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   

    OBJ V_ASU (* terminal = "out_2" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU (* terminal = "out_2" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR (* terminal = "out_2" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR (* terminal = "out_2" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR (* terminal = "out_2" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU (* terminal = "out_2" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   parameters <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   state <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.state.msl" 1
 














 

    OBJ X_TSS "Total suspended solids" 
  : Concentration := {: group <- "Concentration" :};
  OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
  OBJ mu_H_Temp "mu_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ mu_A_Temp "mu_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_H_Temp  "b_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_A_Temp  "b_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_h_Temp  "k_h at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_a_Temp  "k_a at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ K_X_Temp  "K_X at the system temperature"
  : Real := {: group <- "Kinetic" :};

# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   initial <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 
















  parameters.Stoichiometry[AerGrowthHetero][S_S] :=  - 1 / (parameters.Y_H);
  parameters.Stoichiometry[AerGrowthHetero][S_O] :=  - (1 - parameters.Y_H) / parameters.Y_H;
  parameters.Stoichiometry[AerGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AerGrowthHetero][S_ALK] :=  - parameters.i_X_B / 14;
  parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AnGrowthHetero][S_S] :=  - 1 / parameters.Y_H;
  parameters.Stoichiometry[AnGrowthHetero][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
  parameters.Stoichiometry[AnGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
  parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AerGrowthAuto][S_O] :=  - (4.57 - parameters.Y_A) / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NH] :=  - parameters.i_X_B - 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_ALK] :=  - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
  parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
  parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_BH] :=  - 1;
  parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_BA] :=  - 1;
  parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] :=  - 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.0 / 14.0;
  parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrg][X_S] :=  - 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] :=  - 1;
  parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   equations <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 
















    state.X_TSS := (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

  state.Kinetics[AerGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
  state.Kinetics[AnGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
  state.Kinetics[AerGrowthAuto] := state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
  state.Kinetics[DecayOfHetero] := state.b_H_Temp * state.C[X_BH];
  state.Kinetics[DecayOfAuto] := state.b_A_Temp * state.C[X_BA];
  state.Kinetics[AmmonOfSolOrgN] := state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrg] := state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrgN] := (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);
  state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.sensors.msl" 1
 















 

  interface.DO = state.C[S_O];
  
  interface.NH4 = state.C[S_NH];
  
  interface.NO3 = state.C[S_NO];
  
  interface.TSS = state.X_TSS ; 
      
  interface.OnlineCOD = ( state.C[S_S] + state.C[S_I] + 
        state.C[X_BH] + state.C[X_BA] + state.C[X_S] 
          + state.C[X_I] + state.C[X_P]); 
          
  
  interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] 
             + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA])) ;
             
             
  interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
     + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OfflineTKN = ( state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
       + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OUR_ASU = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_O] / state.V)
     + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];

  interface.NUR = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_NO] / state.V)
     + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
   
  interface.NPR = IF (state.V == 0)
              THEN 0
              ELSE
     parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];   

  interface.AUR = IF (state.V == 0)
            THEN 0
            ELSE
     - (state.ConversionTermPerComponent[S_NH] / state.V);    
   
  interface.Kla_ASU = state.Kla_Actual;

  interface.V_ASU = state.V;

         
      
  
  

# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



























# 135 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.SBR.msl" 2

 :};
 

    

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 1
 


















CLASS SBRModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
   OBJ Outflow2 (* terminal = "out_3" *) "bypass" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 2" :};
   OBJ Underflow (* terminal = "out_4" *) "effluent waste" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Underflow" :};
   OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one SBR in a multi-sbr system configuration " : Time 
     := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
   OBJ T1 (* terminal = "in_2"; manip = "1" *) "Period for the fill phase" : Time 
     := {: causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
   OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time 
     := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
   OBJ T4 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ T5 (* terminal = "in_2"; manip = "1" *) "Period for the idle phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate 
       := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };
  
  parameters <- 
  {
  };
  
  state <-
  {
   
    OBJ T "Length of total cycle" : Time := {: group <- "Operational" :};
    OBJ T2 "Period for the reaction phase" : Time := {: value <- 0.125 ; group <- "Operational" :};
    OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
   
    OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    OBJ Q_Bypass "Bypass flow rate" : FlowRate := {: group <- "Operational" :};
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = interface.T1 + state.T2 + interface.T3 + interface.T4 + interface.T5 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};


CLASS SBRPointsettler
EXTENDS SBRModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000 ; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0 ; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 10000 ; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1 ; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400 ; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005 ; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2 ; group <- "Settling":};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    };

  equations <-
   {
 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                        THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN 0
        ELSE
          IF (independent.t - state.t_Begin < (interface.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
          THEN 0
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3) )
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
              THEN state.Q_Out_Help_Draw
            ELSE 0;

   state.Q_Bypass =
       
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
     THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN state.Q_In
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN state.Q_In
         ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN state.Q_In
             ELSE state.Q_In;

    state.Q_Under =
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN 0
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN 0
             ELSE state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < interface.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE
       IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
       THEN state.ConversionTermPerComponent[Comp_Index]
       ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
           THEN state.FluxPerComponent[Comp_Index]
           ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:

       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN 0 
        ELSE
          IF (independent.t - state.t_Begin < interface.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
              THEN 0
              ELSE
                IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
                THEN - state.C[Comp_Index] * interface.Q_Draw * parameters.f_ns
                ELSE 0;
     };

    interface.Outflow2[IndexOfSolvent] = - state.Q_Bypass / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      
      interface.Outflow2[Comp_Index] =
       IF (independent.t < interface.T_Launch)
       THEN 0
       ELSE
         IF (independent.t - state.t_Begin < interface.T1)
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
           THEN - state.InFluxPerComponent[Comp_Index]
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
             THEN - state.InFluxPerComponent[Comp_Index]
             ELSE
               IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
               THEN - state.InFluxPerComponent[Comp_Index]
               ELSE - state.InFluxPerComponent[Comp_Index];
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns) ;
     };

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
 
   };
 :};


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler1phasereact.msl" 1
 



















CLASS SBRPointsettler1PhaseReact
(* icon = "sbr"; is_default = "true" *)
EXTENDS SBRPointsettler WITH
 {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFCD" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

state <-
   {
    };
 
 equations <- 
   {
      state.T2 = interface.T2R1 ;
   
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < interface.T1 )
            THEN interface.Kla_Fill 
              ELSE
              IF ((independent.t - state.t_Begin) < (state.T2 +interface.T1))
            THEN interface.Kla_React1 
              ELSE 0; 
   };
   
    :};



# 325 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler2phasereact.msl" 1
 



















 CLASS SBRPointsettler2PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1 )
         THEN interface.Kla_Fill 
           ELSE 
             IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
             THEN interface.Kla_React1 
           ELSE 
               IF ( (independent.t - state.t_Begin)<(state.T2 + interface.T1) )
               THEN interface.Kla_React2
               ELSE 0; 
    };
    
    :};



# 326 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler3phasereact.msl" 1
 



















CLASS SBRPointsettler3PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
  interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
              THEN interface.Kla_React3
                  ELSE 0; 
            
    };
    
    :};



# 327 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler4phasereact.msl" 1
 



















CLASS SBRPointsettler4PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                THEN interface.Kla_React4
                    ELSE 0; 
            
    };
    
    :};



# 328 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler5phasereact.msl" 1
 



















CLASS SBRPointsettler5PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5;
      
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                  THEN interface.Kla_React5
                      ELSE 0; 
            
    };
    
    :};



# 329 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler6phasereact.msl" 1
 














 




CLASS SBRPointsettler6PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                    THEN interface.Kla_React6
                        ELSE 0; 
            
    };
    
    :};



# 330 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler7phasereact.msl" 1
 



















CLASS SBRPointsettler7PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                      THEN interface.Kla_React7
                          ELSE 0; 
            
    };
    
    :};



# 331 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\SBR/wwtp.base.SBR.sbrpointsettler8phasereact.msl" 1
 



















CLASS SBRPointsettler8PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T2R8;
   
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T1))
                        THEN interface.Kla_React7
                        ELSE  
                            IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                        THEN interface.Kla_React8
                            ELSE 0; 
            
    };
    
    :};



# 332 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.SBR.msl" 2




# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 1
 


















CLASS CFCDModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFCD in a multi-CFCD system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };
    
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {: group <- "Operational" :};  
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = state.T1 + interface.T2 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};


CLASS CFCDPointsettler
EXTENDS CFCDModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {

 

 

 

 
  
 

 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    };

  equations <-
   {
 
    

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out = state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       DERIV(state.M[Comp_Index],[independent.t]) =
      IF (independent.t < interface.T_Launch)
    THEN state.FluxPerComponent[Comp_Index]
    ELSE
        IF (independent.t - state.t_Begin < state.T1)
        THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
        ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out * parameters.f_ns
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns)
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler1phasereact.msl" 1
 



















CLASS CFCDPointsettler1PhaseReact
(* icon = "cfcd"; is_default = "true" *)
EXTENDS CFCDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed continuous discharge tank with 1 reaction phase";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFCD" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

  state <-

   {
     
    };
 
 equations <- 
   {
      state.T1 = interface.T1R1 ;
  
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN 0
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1 
              ELSE  0; 
   };
   
    :};
 


# 234 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler2phasereact.msl" 1
 



















 CLASS CFCDPointsettler2PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge with 2 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN 0 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 235 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler3phasereact.msl" 1
 



















CLASS CFCDPointsettler3PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 3 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 236 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler4phasereact.msl" 1
 



















CLASS CFCDPointsettler4PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 4 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
      state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
              THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 237 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler5phasereact.msl" 1
 














 




CLASS CFCDPointsettler5PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 5 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 238 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler6phasereact.msl" 1
 



















CLASS CFCDPointsettler6PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 6 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                  THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 239 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler7phasereact.msl" 1
 



















CLASS CFCDPointsettler7PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 7 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;

       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React7
                      ELSE 0; 
            
    };
    
    :};



# 240 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler8phasereact.msl" 1
 



















CLASS CFCDPointsettler8PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 8 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
     
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 241 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFCD.msl" 2





# 37 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 1
 


















CLASS CFIDModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFID in a multi-CFID system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time := {: causality <- "CIN" ; value <- 0.025; group <- "Operational":};
    OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };  
  
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {:value <- 0.25; group <- "Operational" :};
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
    state.T = state.T1 + interface.T2 + interface.T3 ;

 
   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};
  

CLASS CFIDPointsettler
EXTENDS CFIDModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 

 

 

 
  
 
 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
 

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                            THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN state.Q_Out_Help
        ELSE
          IF (independent.t - state.t_Begin < (state.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (state.T1 + interface.T2))
          THEN state.Q_Out_Help
          ELSE state.Q_Out_Help_Draw + state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < state.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE state.FluxPerComponent[Comp_Index];
     };

       

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };
 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler1phasereact.msl" 1
 














 




CLASS CFIDPointsettler1PhaseReact
(* icon = "cfid"; is_default = "true" *)
EXTENDS CFIDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed SBR with 1 reaction phase";
 
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

 parameters <-
   { 
    };

  state <-
   {
    };
 
 equations <- 
   {

    state.T1 = interface.T1R1;
    
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1
              ELSE  0; 
   };
   
    :};



# 248 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler2phasereact.msl" 1
 



















 CLASS CFIDPointsettler2PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 2 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 249 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler3phasereact.msl" 1
 



















CLASS CFIDPointsettler3PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 3 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 250 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler4phasereact.msl" 1
 



















CLASS CFIDPointsettler4PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 4 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 251 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler5phasereact.msl" 1
 



















CLASS CFIDPointsettler5PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 5 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 252 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler6phasereact.msl" 1
 



















CLASS CFIDPointsettler6PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 6 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 253 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler7phasereact.msl" 1
 



















CLASS CFIDPointsettler7PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 7 reaction phases";
  
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React7
                        ELSE 0; 
            
    };
    
    :};



# 254 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\CFID/wwtp.base.CFID.cfidpointsettler8phasereact.msl" 1
 



















CLASS CFIDPointsettler8PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 8 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                        THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 255 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.CFID.msl" 2



# 38 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.clarifier.msl" 1
 



















 CLASS PointSettler
 "Pointsettler"

 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 



    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
    OBJ f_ns_help (* hidden = "1" *) "Non-settleable fraction of suspended solids" : Fraction ;
   };

  equations <-
   {
      
      
  
      
      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
                 THEN state.Q_In
                 ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.f_Out = IF  (state.Q_In <= interface.Q_Under)
              THEN 0
              ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;
    state.f_Under = IF (state.Q_In <= interface.Q_Under)
                THEN 1
              ELSE interface.Q_Under/state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    interface.Underflow[IndexOfSolvent] = IF  (state.Q_In <= interface.Q_Under)
                   THEN - state.Q_In / parameters.WWTPSpecificVolume[IndexOfSolvent]
                   ELSE - interface.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = 
     - state.InFluxPerComponent[Comp_Index]* state.f_Under ;};

      
      
      
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * 
        state.f_ns_help ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

     

    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
          THEN 0
          ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

    state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (- interface.Outflow[Comp_Index]));

    {state.X_Out = IF (state.Q_In <= interface.Q_Under)
           THEN 0
           ELSE state.Help_X_Out / (state.Q_In - interface.Q_Under) * parameters.F_TSS_COD;
     };

     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));

    {state.X_Under = 
        IF (state.Q_In <= interface.Q_Under)
      THEN
          IF (state.Q_In == 0)
          THEN 0
          ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
      ELSE 
          IF (interface.Q_Under == 0)
          THEN 0
          ELSE
               state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
     };


# 183 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.clarifier.msl"


 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };
 :};





# 39 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarypointsettler.msl" 1
 



















 CLASS PrimaryPointSettler  (* icon = "primary_clarifier" ; is_default = "true" *)
 "Point-settler model for primary clarifier"
  EXTENDS PointSettler WITH
  {:
    comments <- "A model for a primary point settler only using mass balances";
    parameters <-
    {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.6 ; group <- "Settling" :};
    };
    equations <-
    {
    state.f_ns_help = parameters.f_ns ;
    };
  :};




# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl" 1
 



















 CLASS PrimaryOtterpohlFreund
 (* icon = "primary_clarifier" *)
 "Otterpohl & Freund model for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Otterpohl and Freund";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "true" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ alfa "Otterpohl and Freund function constant" : PhysicalQuantityType := 
        {: 
          value <- 2.7;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ beta "Otterpohl and Freund function constant" : PhysicalQuantityType := 
        {:
          value <- 9;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    
    
    
    OBJ V_Clar (* is_favorite = "true" *) "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "true" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "true" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ Eff_COD "Efficiency of COD removal" : PhysicalQuantityType := {: group <- "Settling" :};
    OBJ Eff_X_COD "Efficiency of particulate COD removal" :     PhysicalQuantityType := {: group <- "Settling" :};
    OBJ COD "Total COD in the clarifier influent" : MassFlux := {: group <- "Influent characterization" :};
    OBJ X_COD "Particulate COD in the clarifier influent" : MassFlux := {: group <- "Influent characterization" :};
    OBJ X_In (* is_favorite = "true" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "true" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "true" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent waterflux going to the Overflow" : Fraction ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;


    {state.COD = 
              state.X_COD
              +interface.Inflow[S_I] + interface.Inflow[S_S] ;
     };

     {state.X_COD = 
      (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (interface.Inflow[Comp_Index]));
     };


# 146 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl"













    state.Eff_COD =   IF ( state.Q_In == 0)
            THEN 1
            ELSE  parameters.alfa * 0.01 *
               ( log ( ( parameters.V_Clar / state.Q_In ) 
                  * ( parameters.V_Clar / state.Q_In ) ) 
            + parameters.beta ) ;

    state.Eff_X_COD = IF (state.X_COD == 0)
              THEN 0
          ELSE state.Eff_COD * state.COD / state.X_COD ;

      
      

    state.f_Out = IF (state.Q_In <= interface.Q_Under)
      THEN 0
      ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

     
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * 
        (1 - state.Eff_X_COD) ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};



    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

      state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (- interface.Outflow[Comp_Index]));
    {
      state.X_Out = IF (state.Q_In <= interface.Q_Under)
        THEN 0
        ELSE state.Help_X_Out * parameters.F_TSS_COD / (state.Q_In - interface.Q_Under) ;
     };
     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));

    {state.X_Under = 
        IF (state.Q_In <= interface.Q_Under)
    THEN
      IF (state.Q_In == 0)
      THEN 0
      ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
    ELSE 
      IF (interface.Q_Under == 0)
      THEN 0
      ELSE
               state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
     };


# 253 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl"


 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    }; 

 :};



# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay.msl" 1
 



















 CLASS Tay
 (* icon = "primary_clarifier" *)
 "The model of Tay for primary clarifiers"

 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Tay";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ T_A "Half removal time" : Time := {: value <- 0.125 ; group <- "Settling" :};
    OBJ Delta_t "Time period defining the interval over which the average flow rate is calculated" : Time := {: value <- 0.1 ; group <- "Settling" :};
    OBJ t_Start "Time where the calculation of the average flow rate starts" : Time := {: value <- 0.1 ; group <- "Settling":};
    
    
    OBJ V_Clar (* is_favorite = "1" *) "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ thelp (* hidden = "1" *) "Previous time help variable" : Time;
    OBJ Qmean (* hidden = "1" *) "Averaged influent flow rate" : FlowRate;
    OBJ Qprev1 (* hidden = "1" *) "Influent flow rate over a period Delta_t back in time" : FlowRate;
    OBJ Qprev2 (* hidden = "1" *) "Influent flow rate over a period Delta_t, two times Delta_t back in time" : FlowRate;
    OBJ Qprev3 (* hidden = "1" *) " Influent flow rate over a period Delta_t, three times Delta_t back in time " : FlowRate;
    OBJ Qprev4 (* hidden = "1" *) " Influent flow rate over a period Delta_t, four times Delta_t back in time " : FlowRate;
    OBJ Qprev5 (* hidden = "1" *) " Influent flow rate over a period Delta_t, five times Delta_t back in time " : FlowRate;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.f_Out := IF (state.Q_In <= interface.Q_Under)
                   THEN 0
       ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;

    state.Qprev1 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN state.Q_In
                     ELSE previous(state.Qprev1);

    state.Qprev2 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev1)
                     ELSE previous(state.Qprev2);

    state.Qprev3 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev2)
                     ELSE previous(state.Qprev3);

    state.Qprev4 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev3)
                     ELSE previous(state.Qprev4);

    state.Qprev5 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev4)
                     ELSE previous(state.Qprev5);

    state.thelp = IF (independent.t < parameters.t_Start)
                   THEN independent.t
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN independent.t
                     ELSE previous(state.thelp);

    state.Qmean = (state.Qprev1 + state.Qprev2 + state.Qprev3 + state.Qprev4 + state.Qprev5) / 5;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] = 
      IF (state.Q_In == 0 || state.Qmean == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                       (state.Q_In * (1 + parameters.V_Clar / (state.Qmean * parameters.T_A)));
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

      
      

    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

     state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Outflow[Comp_Index]));

    {state.X_Out = IF (state.Q_In <= interface.Q_Under)
       THEN 0
       ELSE state.Help_X_Out * parameters.F_TSS_COD / (state.Q_In - interface.Q_Under);
     };

     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));
 
    {state.X_Under = 
        IF (state.Q_In <= interface.Q_Under)
    THEN
      IF (state.Q_In == 0)
      THEN 0
      ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
    ELSE 
      IF (interface.Q_Under == 0)
      THEN 0
      ELSE
               state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
     };


# 226 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay.msl"

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    }; 
  :};



# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay4.msl" 1
 









# 355 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay4.msl"



# 23 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.removalfractions.msl" 1
 









# 393 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.removalfractions.msl"



# 24 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.lessardbeck.msl" 1
 



















 CLASS LessardBeck
 (* icon = "primary_clarifier" *)
 "The model of Lessard and Beck for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Lessard and Beck";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   {
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors":};
    OBJ alfa "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 3.6 ; group <- "Settling" :};
    OBJ beta "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 59 ; group <- "Settling" :};
    OBJ gamma "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 1.17 ; group <- "Settling" :};
    OBJ lambda "Correlation parameter for the calculation of scouring" : PhysicalQuantityType := {: value <- 8.05 ; group <- "Settling":};
    OBJ H (* is_favorite = "1" *) "Height" : Length := {: value <- 3 ; group <- "Dimension" :};
    OBJ v_PC "Settling velocity" : Velocity := {: value <- 1 ; group <- "Settling":};
    OBJ k_a "Ammonification rate" : AmmonificationRate:= {: value <- 0.003 ; group <- "Kinetic":};
    OBJ k_h "Specific Hydrolysis rate" : MaxSpecificHydrolysisRate:= {: value <- 0.083 ; group <- "Kinetic":};
    OBJ pi (* hidden = "1" *) "" : Real := {: value <- 3.1415927 :};
     
    OBJ V_Clar (* is_favorite = "1" *) "Volume of the clarifier" : Volume := {: value <- 1000 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;    
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ Scour (* hidden = "1" *) "Scouring term" : Real;
    OBJ Setterm (* hidden = "1" *) "Settling term" : Real;
    OBJ A (* is_favorite = "1" *) "Surface" : Area := {: group <- "Dimension" :};
    OBJ R "Radius" : Length := {: group <- "Dimension" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of the layers" : Volume;
    OBJ Q_Out_Div_V_Layer (* hidden = "1" *) "Q_Out/V_Layer" : PhysicalQuantityType;
    OBJ Q_Under_Div_V_Layer (* hidden = "1" *) "Q_Under/V_Layer" : PhysicalQuantityType;
    OBJ Hydrolysis_X_S_Layer1 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 1" : Real;
    OBJ Hydrolysis_X_ND_Layer1 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 1" : Real;
    OBJ Ammonification_Layer1 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 1" : Real;
    OBJ Hydrolysis_X_S_Layer2 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 2" : Real;
    OBJ  Hydrolysis_X_ND_Layer2 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 2" : Real;
    OBJ  Ammonification_Layer2 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 2" : Real;
    OBJ Hydrolysis_X_S_Layer3 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 3" : Real;
    OBJ  Hydrolysis_X_ND_Layer3 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 3" : Real;
    OBJ  Ammonification_Layer3 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 3" : Real;
    OBJ Hydrolysis_X_S_Layer4 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 4" : Real;
    OBJ  Hydrolysis_X_ND_Layer4 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 4" : Real;
    OBJ  Ammonification_Layer4 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 4" : Real;
    OBJ Hydrolysis_X_S_Layer5 (* hidden = "1" *) "help variable for hydrolysis of X_S to S_S in layer 5" : Real;
    OBJ  Hydrolysis_X_ND_Layer5 (* hidden = "1" *) "help variable for hydrolysis of X_ND to S_ND in layer 5" : Real;
    OBJ  Ammonification_Layer5 (* hidden = "1" *) "help variable for ammonification of S_ND to S_NH in layer 5" : Real;
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ S_I_Layer "Vector containing S_I concentration for all the layers" : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ND_Layer " Vector containing S_ND concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NH_Layer " Vector containing S_NH concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NO_Layer " Vector containing S_NO concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_O_Layer " Vector containing S_O concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_S_Layer " Vector containing S_S concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ALK_Layer " Vector containing S_ALK concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_BA_Layer " Vector containing X_BA concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_BH_Layer " Vector containing X_BH concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_I_Layer " Vector containing X_I concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_P_Layer " Vector containing X_P concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_ND_Layer " Vector containing X_ND concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ X_S_Layer " Vector containing X_S concentration for all the layers " : L_and_B_ConcentrationVector := {: group <- "Concentration" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration  := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration  := {: group <- "Concentration" :}; 
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration  := {: group <- "Concentration" :};   
 
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    state.V_Layer = parameters.V_Clar / 5;
    state.A = parameters.V_Clar / parameters.H;
    state.R = sqrt(state.A / parameters.pi);
    state.Q_Under_Div_V_Layer = interface.Q_Under / state.V_Layer;
   };

  equations <-
   {
    state.Q_Out = IF (state.Q_In <= interface.Q_Under)
      THEN 0
      ELSE state.Q_In - interface.Q_Under;

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    interface.Outflow[IndexOfSolvent] = - state.Q_Out
               / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    interface.Underflow[IndexOfSolvent] = 
    IF (state.Q_In <= interface.Q_Under)
    THEN - state.Q_In / parameters.WWTPSpecificVolume[IndexOfSolvent]
    ELSE - interface.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 

    state.Scour = parameters.gamma * exp(-parameters.lambda / parameters.alfa /
      (exp ((parameters.beta * state.Q_Out / (2.0 * parameters.pi * parameters.H * state.R * sqrt(7.32e10 * parameters.H))))));
    state.Q_Out_Div_V_Layer = state.Q_Out / state.V_Layer;

    state.Setterm = (1 - state.Scour) * parameters.v_PC * state.A / state.V_Layer;

 
 
 

    
    state.Hydrolysis_X_S_Layer1 = IF (state.X_S_Layer[1] > 0)
                    THEN parameters.k_h * state.X_S_Layer[1]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer1 = IF ((state.X_S_Layer[1] * state.X_ND_Layer[1]) > 0)
                    THEN state.Hydrolysis_X_S_Layer1 * (state.X_ND_Layer[1] / state.X_S_Layer[1])
                    ELSE 0;

    state.Ammonification_Layer1 = IF ((state.S_ND_Layer[1] * state.X_BH_Layer[1]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[1] * state.X_BH_Layer[1]
                    ELSE 0;

    {DERIV(state.S_I_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_I_Layer[2] - state.S_I_Layer[1]);
    };

    {DERIV(state.S_O_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_O_Layer[2] - state.S_O_Layer[1]);
    };

    {DERIV(state.S_S_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_S_Layer[2] - state.S_S_Layer[1]) + state.Hydrolysis_X_S_Layer1;
    };

    {DERIV(state.S_ALK_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ALK_Layer[2] - state.S_ALK_Layer[1]);
    };

    {DERIV(state.S_NH_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NH_Layer[2] - state.S_NH_Layer[1]) + state.Ammonification_Layer1;
    };

    {DERIV(state.S_ND_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ND_Layer[2] - state.S_ND_Layer[1])
      - state.Ammonification_Layer1 + state.Hydrolysis_X_ND_Layer1;
    };

    {DERIV(state.S_NO_Layer[1],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NO_Layer[2] - state.S_NO_Layer[1]);
    };

    {DERIV(state.X_BA_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BA_Layer[2] - state.X_BA_Layer[1]) 
           - state.Setterm * state.X_BA_Layer[1];
    };

    {DERIV(state.X_BH_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BH_Layer[2] - state.X_BH_Layer[1])
           - state.Setterm * state.X_BH_Layer[1];
    };

    {DERIV(state.X_I_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_I_Layer[2] - state.X_I_Layer[1])
           - state.Setterm * state.X_I_Layer[1];
    };

    {DERIV(state.X_P_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_P_Layer[2] - state.X_P_Layer[1])
           - state.Setterm * state.X_P_Layer[1];
    };

    {DERIV(state.X_S_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_S_Layer[2] - state.X_S_Layer[1])
           - state.Setterm * state.X_S_Layer[1] - state.Hydrolysis_X_S_Layer1;
    };

    {DERIV(state.X_ND_Layer[1],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_ND_Layer[2] - state.X_ND_Layer[1])
           - state.Setterm * state.X_ND_Layer[1] - state.Hydrolysis_X_ND_Layer1;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer2 = IF (state.X_S_Layer[2] > 0)
                    THEN parameters.k_h * state.X_S_Layer[2]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer2 = IF ((state.X_S_Layer[2] * state.X_ND_Layer[2]) > 0)
                    THEN state.Hydrolysis_X_S_Layer2 * (state.X_ND_Layer[2] / state.X_S_Layer[2])
                    ELSE 0;

    state.Ammonification_Layer2 = IF ((state.S_ND_Layer[2] * state.X_BH_Layer[2]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[2] * state.X_BH_Layer[2]
                    ELSE 0;

    {DERIV(state.S_I_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_I_Layer[3] - state.S_I_Layer[2]);
    };

    {DERIV(state.S_O_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_O_Layer[3] - state.S_O_Layer[2]);
    };

    {DERIV(state.S_S_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_S_Layer[3] - state.S_S_Layer[2]) + state.Hydrolysis_X_S_Layer2;
    };

    {DERIV(state.S_ALK_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ALK_Layer[3] - state.S_ALK_Layer[2]);
    };

    {DERIV(state.S_NH_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NH_Layer[3] - state.S_NH_Layer[2]) + state.Ammonification_Layer2;
    };

    {DERIV(state.S_ND_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_ND_Layer[3] - state.S_ND_Layer[2])
      - state.Ammonification_Layer2 + state.Hydrolysis_X_ND_Layer2;
    };

    {DERIV(state.S_NO_Layer[2],[independent.t]) = 
      state.Q_Out_Div_V_Layer * (state.S_NO_Layer[3] - state.S_NO_Layer[2]);
    };

    {DERIV(state.X_BA_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BA_Layer[3] - state.X_BA_Layer[2])
           - state.Setterm * state.X_BA_Layer[2] + state.Setterm * state.X_BA_Layer[1];
    };

    {DERIV(state.X_BH_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_BH_Layer[3] - state.X_BH_Layer[2])
           - state.Setterm * state.X_BH_Layer[2] + state.Setterm * state.X_BH_Layer[1];
    };

    {DERIV(state.X_I_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_I_Layer[3] - state.X_I_Layer[2])
           - state.Setterm * state.X_I_Layer[2] + state.Setterm * state.X_I_Layer[1];
    };

    {DERIV(state.X_P_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_P_Layer[3] - state.X_P_Layer[2])
           - state.Setterm * state.X_P_Layer[2] + state.Setterm * state.X_P_Layer[1];
    };

    {DERIV(state.X_S_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_S_Layer[3] - state.X_S_Layer[2])
           - state.Setterm * state.X_S_Layer[2] + state.Setterm * state.X_S_Layer[1] - state.Hydrolysis_X_S_Layer2;
    };

    {DERIV(state.X_ND_Layer[2],[independent.t]) =
      state.Q_Out_Div_V_Layer * (state.X_ND_Layer[3] - state.X_ND_Layer[2])
           - state.Setterm * state.X_ND_Layer[2] + state.Setterm * state.X_ND_Layer[1] - state.Hydrolysis_X_ND_Layer2;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer3 = IF (state.X_S_Layer[3] > 0)
                    THEN parameters.k_h * state.X_S_Layer[3]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer3 = IF ((state.X_S_Layer[3] * state.X_ND_Layer[3]) > 0)
                    THEN state.Hydrolysis_X_S_Layer3 * (state.X_ND_Layer[3] / state.X_S_Layer[3])
                    ELSE 0;

    state.Ammonification_Layer3 = IF ((state.S_ND_Layer[3] * state.X_BH_Layer[3]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[3] * state.X_BH_Layer[3]
                    ELSE 0;

    {DERIV(state.S_I_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_I] - state.Q_In * state.S_I_Layer[3]);
    };

    {DERIV(state.S_O_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_O] - state.Q_In * state.S_O_Layer[3]);
    };

    {DERIV(state.S_S_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_S] - state.Q_In * state.S_S_Layer[3]) + state.Hydrolysis_X_S_Layer3;
    };

    {DERIV(state.S_ALK_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_ALK] - state.Q_In * state.S_ALK_Layer[3]);
    };

    {DERIV(state.S_NH_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_NH] - state.Q_In * state.S_NH_Layer[3]) + state.Ammonification_Layer3;
    };

    {DERIV(state.S_ND_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_ND] - state.Q_In * state.S_ND_Layer[3]) - state.Ammonification_Layer3 + state.Hydrolysis_X_ND_Layer3;
    };

    {DERIV(state.S_NO_Layer[3],[independent.t]) = 
      1/state.V_Layer * (interface.Inflow[S_NO] - state.Q_In * state.S_NO_Layer[3]);
    };

    {DERIV(state.X_BA_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_BA] - state.Q_In * state.X_BA_Layer[3])
           - state.Setterm * state.X_BA_Layer[3] + state.Setterm * state.X_BA_Layer[2];
    };

    {DERIV(state.X_BH_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_BH] - state.Q_In * state.X_BH_Layer[3])
           - state.Setterm * state.X_BH_Layer[3] + state.Setterm * state.X_BH_Layer[2];
    };

    {DERIV(state.X_I_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_I] - state.Q_In * state.X_I_Layer[3])
           - state.Setterm * state.X_I_Layer[3] + state.Setterm * state.X_I_Layer[2];
    };

    {DERIV(state.X_P_Layer[3],[independent.t]) =
      1/state.V_Layer * (interface.Inflow[X_P] - state.Q_In * state.X_P_Layer[3])
           - state.Setterm * state.X_P_Layer[3] + state.Setterm * state.X_P_Layer[2];
    };
    {DERIV(state.X_S_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_S] - state.Q_In * state.X_S_Layer[3])
           - state.Setterm * state.X_S_Layer[3] + state.Setterm * state.X_S_Layer[2] - state.Hydrolysis_X_S_Layer3;
    };

    {DERIV(state.X_ND_Layer[3],[independent.t]) =
       1/state.V_Layer * (interface.Inflow[X_ND] - state.Q_In * state.X_ND_Layer[3])
           - state.Setterm * state.X_ND_Layer[3] + state.Setterm * state.X_ND_Layer[2] - state.Hydrolysis_X_ND_Layer3;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer4 = IF (state.X_S_Layer[4] > 0)
                    THEN parameters.k_h * state.X_S_Layer[4]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer4 = IF ((state.X_S_Layer[4] * state.X_ND_Layer[4]) > 0)
                    THEN state.Hydrolysis_X_S_Layer4 * (state.X_ND_Layer[4] / state.X_S_Layer[4])
                    ELSE 0;

    state.Ammonification_Layer4 = IF ((state.S_ND_Layer[4] * state.X_BH_Layer[4]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[4] * state.X_BH_Layer[4]
                    ELSE 0;

    {DERIV(state.S_I_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_I_Layer[3] - state.S_I_Layer[4]);
    };

    {DERIV(state.S_O_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_O_Layer[3] - state.S_O_Layer[4]);
    };

    {DERIV(state.S_S_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_S_Layer[3] - state.S_S_Layer[4]) + state.Hydrolysis_X_S_Layer4;
    };

    {DERIV(state.S_ALK_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ALK_Layer[3] - state.S_ALK_Layer[4]);
    };

    {DERIV(state.S_NH_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NH_Layer[3] - state.S_NH_Layer[4]) + state.Ammonification_Layer4;
    };

    {DERIV(state.S_ND_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ND_Layer[3] - state.S_ND_Layer[4])
      - state.Ammonification_Layer4 + state.Hydrolysis_X_ND_Layer4;
    };

    {DERIV(state.S_NO_Layer[4],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NO_Layer[3] - state.S_NO_Layer[4]);
    };

    {DERIV(state.X_BA_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BA_Layer[3] - state.X_BA_Layer[4])
           - state.Setterm * state.X_BA_Layer[4] + state.Setterm * state.X_BA_Layer[3];
    };

    {DERIV(state.X_BH_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BH_Layer[3] - state.X_BH_Layer[4])
           - state.Setterm * state.X_BH_Layer[4] + state.Setterm * state.X_BH_Layer[3];
    };

    {DERIV(state.X_I_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_I_Layer[3] - state.X_I_Layer[4])
           - state.Setterm * state.X_I_Layer[4] + state.Setterm * state.X_I_Layer[3];
    };

    {DERIV(state.X_P_Layer[4],[independent.t]) =
      state.Q_Under_Div_V_Layer * (state.X_P_Layer[3] - state.X_P_Layer[4])
           - state.Setterm * state.X_P_Layer[4] + state.Setterm * state.X_P_Layer[3];
    };

    {DERIV(state.X_S_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_S_Layer[3] - state.X_S_Layer[4])
           - state.Setterm * state.X_S_Layer[4] + state.Setterm * state.X_S_Layer[3] - state.Hydrolysis_X_S_Layer4;
    };

    {DERIV(state.X_ND_Layer[4],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_ND_Layer[3] - state.X_ND_Layer[4])
           - state.Setterm * state.X_ND_Layer[4] + state.Setterm * state.X_ND_Layer[3] - state.Hydrolysis_X_ND_Layer4;
    };

 
 
 

    
    state.Hydrolysis_X_S_Layer5 = IF (state.X_S_Layer[5] > 0)
                    THEN parameters.k_h * state.X_S_Layer[5]
                    ELSE 0;

    state.Hydrolysis_X_ND_Layer5 = IF ((state.X_S_Layer[5] * state.X_ND_Layer[5]) > 0)
                    THEN state.Hydrolysis_X_S_Layer5 * (state.X_ND_Layer[5] / state.X_S_Layer[5])
                    ELSE 0;

    state.Ammonification_Layer5 = IF ((state.S_ND_Layer[5] * state.X_BH_Layer[5]) > 0)
                    THEN parameters.k_a * state.S_ND_Layer[5] * state.X_BH_Layer[5]
                    ELSE 0;

    {DERIV(state.S_I_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_I_Layer[4] - state.S_I_Layer[5]);
    };

    {DERIV(state.S_O_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_O_Layer[4] - state.S_O_Layer[5]);
    };

    {DERIV(state.S_S_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_S_Layer[4] - state.S_S_Layer[5]) + state.Hydrolysis_X_S_Layer5;
    };

    {DERIV(state.S_ALK_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ALK_Layer[4] - state.S_ALK_Layer[5]);
    };

    {DERIV(state.S_NH_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NH_Layer[4] - state.S_NH_Layer[5]) + state.Ammonification_Layer5;
    };

    {DERIV(state.S_ND_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_ND_Layer[4] - state.S_ND_Layer[5])
      - state.Ammonification_Layer5 + state.Hydrolysis_X_ND_Layer5;
    };

    {DERIV(state.S_NO_Layer[5],[independent.t]) = 
      state.Q_Under_Div_V_Layer * (state.S_NO_Layer[4] - state.S_NO_Layer[5]);
    };

    {DERIV(state.X_BA_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BA_Layer[4] - state.X_BA_Layer[5])
           + state.Setterm * state.X_BA_Layer[4];
    };

    {DERIV(state.X_BH_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_BH_Layer[4] - state.X_BH_Layer[5])
           + state.Setterm * state.X_BH_Layer[4];
    };

    {DERIV(state.X_I_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_I_Layer[4] - state.X_I_Layer[5])
           + state.Setterm * state.X_I_Layer[4];
    };

    {DERIV(state.X_P_Layer[5],[independent.t]) =
      state.Q_Under_Div_V_Layer * (state.X_P_Layer[4] - state.X_P_Layer[5])
           + state.Setterm * state.X_P_Layer[4];
    };

    {DERIV(state.X_S_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_S_Layer[4] - state.X_S_Layer[5])
           + state.Setterm * state.X_S_Layer[4] - state.Hydrolysis_X_S_Layer5;
    };

    {DERIV(state.X_ND_Layer[5],[independent.t]) =
       state.Q_Under_Div_V_Layer * (state.X_ND_Layer[4] - state.X_ND_Layer[5])
           + state.Setterm * state.X_ND_Layer[4] - state.Hydrolysis_X_ND_Layer5;
    };

 
 
 

    interface.Underflow[S_I] = - state.S_I_Layer[5] * interface.Q_Under;
    interface.Underflow[S_O] = - state.S_O_Layer[5] * interface.Q_Under;
    interface.Underflow[S_S] = - state.S_S_Layer[5] * interface.Q_Under;
    interface.Underflow[S_ALK] = - state.S_ALK_Layer[5] * interface.Q_Under;
    interface.Underflow[S_NH] = - state.S_NH_Layer[5] * interface.Q_Under;
    interface.Underflow[S_ND] = - state.S_ND_Layer[5] * interface.Q_Under;
    interface.Underflow[S_NO] = - state.S_NO_Layer[5] * interface.Q_Under;
    interface.Underflow[X_BA] = - state.X_BA_Layer[5] * interface.Q_Under;
    interface.Underflow[X_BH] = - state.X_BH_Layer[5] * interface.Q_Under;
    interface.Underflow[X_I] = - state.X_I_Layer[5] * interface.Q_Under;
    interface.Underflow[X_P] = - state.X_P_Layer[5] * interface.Q_Under;
    interface.Underflow[X_S] = - state.X_S_Layer[5] * interface.Q_Under;
    interface.Underflow[X_ND] = - state.X_ND_Layer[5] * interface.Q_Under;

 
 
 

    interface.Outflow[S_I] = - state.S_I_Layer[1] * state.Q_Out;
    interface.Outflow[S_O] = - state.S_O_Layer[1] * state.Q_Out;
    interface.Outflow[S_S] = - state.S_S_Layer[1] * state.Q_Out;
    interface.Outflow[S_ALK] = - state.S_ALK_Layer[1] * state.Q_Out;
    interface.Outflow[S_NH] = - state.S_NH_Layer[1] * state.Q_Out;
    interface.Outflow[S_ND] = - state.S_ND_Layer[1] * state.Q_Out;
    interface.Outflow[S_NO] = - state.S_NO_Layer[1] * state.Q_Out;
    interface.Outflow[X_BA] = - state.X_BA_Layer[1] * state.Q_Out;
    interface.Outflow[X_BH] = - state.X_BH_Layer[1] * state.Q_Out;
    interface.Outflow[X_I] = - state.X_I_Layer[1] * state.Q_Out;
    interface.Outflow[X_P] = - state.X_P_Layer[1] * state.Q_Out;
    interface.Outflow[X_S] = - state.X_S_Layer[1] * state.Q_Out;
    interface.Outflow[X_ND] = - state.X_ND_Layer[1] * state.Q_Out;

 
 
 
    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

     state.Help_X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Outflow[Comp_Index]));

    {
     state.X_Out = IF (state.Q_In <= interface.Q_Under)
       THEN 0
       ELSE state.Help_X_Out *  parameters.F_TSS_COD / (state.Q_In - interface.Q_Under );

     };

     state.Help_X_Under = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Underflow[Comp_Index]));

    {state.X_Under = 
        IF (state.Q_In <= interface.Q_Under)
    THEN
      IF (state.Q_In == 0)
      THEN 0
      ELSE
               state.Help_X_Under / state.Q_In * parameters.F_TSS_COD
    ELSE 
      IF (interface.Q_Under == 0)
      THEN 0
      ELSE
               state.Help_X_Under / interface.Q_Under * parameters.F_TSS_COD ;
     };

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
	 
   };
 :};




# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacs.msl" 1
 



















 CLASS PrimaryTakacs
 (* icon = "primary_clarifier" *)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1"*) "Height of the sludge blanket" : 
         Length := {: causality <- "COUT" ; group <- "Measurement data":};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length  := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration  := {: group <- "Settling" :};  
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration  := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration  := {: group <- "Concentration" :}; 
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration  := {: group <- "Concentration" :};   
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In =
       SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD;
    };






    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE 
      - state.InFluxPerComponent[Comp_Index] * 
      (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE
      - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) *
      state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual /
                  parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] -
      interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
    ELSE
      - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) *
      state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;
 
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};



# 26 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacssolublespropagator.msl" 1
 



















 
 
 

 
 

 CLASS PrimaryTakacsSolublesPropagator
 (* icon = "primary_clarifier" *)
 "Takacs Solubles Propagator for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.24 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :}; 
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length  := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration  := {: group <- "Settling" :};  
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration  := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration  := {: group <- "Concentration" :}; 
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration  := {: group <- "Concentration" :};   
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_I_Layer "Vector containing concentration of S_I for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_S_Layer "Vector containing concentration of S_S for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_O_Layer "Vector containing concentration of S_O for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NO_Layer "Vector containing concentration of S_NO for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NH_Layer "Vector containing concentration of S_NH for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ND_Layer "Vector containing concentration of S_ND for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ALK_Layer "Vector containing concentration of S_ALK for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of the layers" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of the layers" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;

   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual ; 

    { 
     state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD ;
    };

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };
 
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };
    
    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (state.Q_Under_Actual  / state.V_Layer) * state.X_Layer[NrOfLayers];
    };
    

    { DERIV(state.S_I_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_I_Layer[2] - state.S_I_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_I_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_I] - state.Q_In * state.S_I_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_I_Layer[Layer_Index+1] - state.S_I_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_I_Layer[Layer_Index-1] - state.S_I_Layer[Layer_Index]);
    };

    
    { DERIV(state.S_S_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_S_Layer[2] - state.S_S_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_S_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_S] - state.Q_In * state.S_S_Layer[IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_S_Layer[Layer_Index+1] - state.S_S_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_S_Layer[Layer_Index-1] - state.S_S_Layer[Layer_Index]);
    };    

    { DERIV(state.S_O_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_O_Layer[2] - state.S_O_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_O_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_O] - state.Q_In * state.S_O_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_O_Layer[Layer_Index+1] - state.S_O_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_O_Layer[Layer_Index-1] - state.S_O_Layer[Layer_Index]);
    };

    { DERIV(state.S_NO_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NO_Layer[2] - state.S_NO_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NO_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NO] - state.Q_In * state.S_NO_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NO_Layer[Layer_Index+1] - state.S_NO_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NO_Layer[Layer_Index-1] - state.S_NO_Layer[Layer_Index]);
    };

    { DERIV(state.S_NH_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NH_Layer[2] - state.S_NH_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NH_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NH] - state.Q_In * state.S_NH_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NH_Layer[Layer_Index+1] - state.S_NH_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NH_Layer[Layer_Index-1] - state.S_NH_Layer[Layer_Index]);
    };

    { DERIV(state.S_ND_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ND_Layer[2] - state.S_ND_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ND_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ND] - state.Q_In * state.S_ND_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ND_Layer[Layer_Index+1] - state.S_ND_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ND_Layer[Layer_Index-1] - state.S_ND_Layer[Layer_Index]);
    };

    { DERIV(state.S_ALK_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ALK_Layer[2] - state.S_ALK_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ALK_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ALK] - state.Q_In * state.S_ALK_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ALK_Layer[Layer_Index+1] - state.S_ALK_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ALK_Layer[Layer_Index-1] - state.S_ALK_Layer[Layer_Index]);
    };
    { DERIV(state.S_I_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_I_Layer[NrOfLayersButOne] - state.S_I_Layer[NrOfLayers]);
    };
 
    { DERIV(state.S_S_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_S_Layer[NrOfLayersButOne] - state.S_S_Layer[NrOfLayers]);
    };

    { DERIV(state.S_O_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_O_Layer[NrOfLayersButOne] - state.S_O_Layer[NrOfLayers]);
    };

    { DERIV(state.S_NO_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NO_Layer[NrOfLayersButOne] - state.S_NO_Layer[NrOfLayers]);
    };

    { DERIV(state.S_NH_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NH_Layer[NrOfLayersButOne] - state.S_NH_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ND_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ND_Layer[NrOfLayersButOne] - state.S_ND_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ALK_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ALK_Layer[NrOfLayersButOne] - state.S_ALK_Layer[NrOfLayers]);
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];    

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                parameters.H / NrOfLayers;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;
    

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];
    interface.Overflow[S_I] = -state.S_I_Layer[1]*state.Q_Out;
    interface.Overflow[S_S] = -state.S_S_Layer[1]*state.Q_Out;
    interface.Overflow[S_O] = -state.S_O_Layer[1]*state.Q_Out;
    interface.Overflow[S_NO] = -state.S_NO_Layer[1]*state.Q_Out;
    interface.Overflow[S_NH] = -state.S_NH_Layer[1]*state.Q_Out;
    interface.Overflow[S_ND] = -state.S_ND_Layer[1]*state.Q_Out;
    interface.Overflow[S_ALK] = -state.S_ALK_Layer[1]*state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual ;
    

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual  / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    interface.Underflow[S_I] = -state.S_I_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_S] = -state.S_S_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_O] = -state.S_O_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_NO] = -state.S_NO_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_NH] = -state.S_NH_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ND] = -state.S_ND_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ALK] = -state.S_ALK_Layer[NrOfLayers]*state.Q_Under_Actual ;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

 

    interface.Sludge_Blanket_Height = state.H_S;
 
   };

 :};



# 27 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsallfractionpropagator.msl" 1
 



















 CLASS PrimaryTakacsAllFractionPropagator
 (* icon = "primary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD  ;
    };






    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 


{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
    state.X_Layer[Layer_Index] = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
state.C[Comp_Index][Layer_Index] * parameters.F_TSS_COD);
};








 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};



# 28 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsreactive1.msl" 1
 




















 CLASS PrimaryTakacsReactive1
 (* icon = "primary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1"*) "Height of the sludge blanket" : 
         Length := {: causality <- "COUT" ; group <- "Measurement data":};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
 
 
   };

   parameters <-
   {
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components, m^3*g^-1" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :};
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ k_Floc "Flocculation rate constant" : Rate := {: value <- 0.5 ; group <- "Kinetic" :};
    OBJ k_a "Ammonification rate constant" : Rate := {: value <- 0.5 ; group <- "Kinetic" :};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :};
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};
    OBJ X_Layer "Concentration of particulates in a layer" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In "Sum of massfluxes of particulates" : MassFlux  := {: group <- "Influent characterization" :};
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ;
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers);
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A;

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index];
    };

    { state.Q_In =
       (parameters.WWTPSpecificVolume[IndexOfSolvent]
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 

    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD;
    };

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 

{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
    state.X_Layer[Layer_Index] = ((SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
state.C[Comp_Index][Layer_Index]) * parameters.F_TSS_COD);
};

 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A;

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min)
        THEN 0
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index])
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 

   
   

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. S_S}:
    { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1])
       - parameters.k_Floc * state.C[Comp_Index][1] * state.X_Layer[1] / parameters.F_TSS_COD;
    };
};

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. S_S}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
             - parameters.k_Floc * state.C[Comp_Index][IndexOfFeedLayer] * state.X_Layer[IndexOfFeedLayer] / parameters.F_TSS_COD
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
             - parameters.k_Floc * state.C[Comp_Index][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD
        ELSE state.D_Under * (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index])
             - parameters.k_Floc * state.C[Comp_Index][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD;
    };
};

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. S_S}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers])
       - parameters.k_Floc * state.C[Comp_Index][NrOfLayers] * state.X_Layer[NrOfLayers] / parameters.F_TSS_COD;
    };
};

   

   { DERIV(state.C[S_O][1],[independent.t]) =
       state.D_Out * (state.C[S_O][2] - state.C[S_O][1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_O][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_O]
       - state.Q_In * state.C[S_O][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out *
     (state.C[S_O][Layer_Index+1] - state.C[S_O][Layer_Index])
        ELSE state.D_Under *
         (state.C[S_O][Layer_Index-1] - state.C[S_O][Layer_Index]);
    };

    { DERIV(state.C[S_O][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_O][NrOfLayersButOne] - state.C[S_O][NrOfLayers]);
    };
   

   { DERIV(state.C[S_NO][1],[independent.t]) =
       state.D_Out * (state.C[S_NO][2] - state.C[S_NO][1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_NO][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NO]
       - state.Q_In * state.C[S_NO][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out *
     (state.C[S_NO][Layer_Index+1] - state.C[S_NO][Layer_Index])
        ELSE state.D_Under *
         (state.C[S_NO][Layer_Index-1] - state.C[S_NO][Layer_Index]);
    };

    { DERIV(state.C[S_NO][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_NO][NrOfLayersButOne] - state.C[S_NO][NrOfLayers]);
    };

 

    { DERIV(state.C[S_NH][1],[independent.t]) =
       state.D_Out * (state.C[S_NH][2] - state.C[S_NH][1])
      + parameters.k_a * state.C[S_ND][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_NH][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NH] - state.Q_In * state.C[S_NH][IndexOfFeedLayer])
             + parameters.k_a * state.C[S_ND][IndexOfFeedLayer]
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * (state.C[S_NH][Layer_Index+1] - state.C[S_NH][Layer_Index])
             + parameters.k_a * state.C[S_ND][Layer_Index]
        ELSE state.D_Under * (state.C[S_NH][Layer_Index-1] - state.C[S_NH][Layer_Index])
             + parameters.k_a * state.C[S_ND][Layer_Index];
    };

    { DERIV(state.C[S_NH][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_NH][NrOfLayersButOne] - state.C[S_NH][NrOfLayers])
       + parameters.k_a * state.C[S_ND][NrOfLayers];
    };

   

    { DERIV(state.C[S_ND][1],[independent.t]) =
       state.D_Out * (state.C[S_ND][2] - state.C[S_ND][1])
       - parameters.k_a * state.C[S_ND][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_ND][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ND] - state.Q_In * state.C[S_ND][IndexOfFeedLayer])
             - parameters.k_a * state.C[S_ND][IndexOfFeedLayer]
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * (state.C[S_ND][Layer_Index+1] - state.C[S_ND][Layer_Index])
             - parameters.k_a * state.C[S_ND][Layer_Index]
        ELSE state.D_Under * (state.C[S_ND][Layer_Index-1] - state.C[S_ND][Layer_Index])
             - parameters.k_a * state.C[S_ND][Layer_Index];
    };

    { DERIV(state.C[S_ND][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_ND][NrOfLayersButOne] - state.C[S_ND][NrOfLayers])
       - parameters.k_a * state.C[S_ND][NrOfLayers];
    };

   
   { DERIV(state.C[S_ALK][1],[independent.t]) =
       state.D_Out * (state.C[S_ALK][2] - state.C[S_ALK][1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[S_ALK][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ALK]
       - state.Q_In * state.C[S_ALK][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out *
     (state.C[S_ALK][Layer_Index+1] - state.C[S_ALK][Layer_Index])
        ELSE state.D_Under *
         (state.C[S_ALK][Layer_Index-1] - state.C[S_ALK][Layer_Index]);
    };

    { DERIV(state.C[S_ALK][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[S_ALK][NrOfLayersButOne] - state.C[S_ALK][NrOfLayers]);
    };

 

   
   

{ DERIV(state.C[X_I][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_I][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_I][1] / state.X_Layer[1]) - state.D_Out * state.C[X_I][1]
       + parameters.k_Floc * state.C[S_I][1] * state.X_Layer[1] / parameters.F_TSS_COD;
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_I][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_I][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_I][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_I]
             + parameters.k_Floc * state.C[S_I][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_I][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_I][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_I][Layer_Index] / state.X_Layer[Layer_Index])
             + parameters.k_Floc * state.C[S_I][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD;
    };

    { DERIV(state.C[X_I][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_I][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_I][NrOfLayers]
       + parameters.k_Floc * state.C[S_I][NrOfLayers] * state.X_Layer[NrOfLayers] / parameters.F_TSS_COD;
    };

   
   

{ DERIV(state.C[X_S][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_S][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_S][1] / state.X_Layer[1]) - state.D_Out * state.C[X_S][1]
       + parameters.k_Floc * state.C[S_S][1] * state.X_Layer[1] / parameters.F_TSS_COD;
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_S][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_S][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_S][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_S]
             + parameters.k_Floc * state.C[S_S][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_S][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_S][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_S][Layer_Index] / state.X_Layer[Layer_Index])
             + parameters.k_Floc * state.C[S_S][Layer_Index] * state.X_Layer[Layer_Index] / parameters.F_TSS_COD;
    };

    { DERIV(state.C[X_S][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_S][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_S][NrOfLayers]
       + parameters.k_Floc * state.C[S_S][NrOfLayers] * state.X_Layer[NrOfLayers] / parameters.F_TSS_COD;
    };

   

  { DERIV(state.C[X_BH][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_BH][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_BH][1] / state.X_Layer[1]) - state.D_Out * state.C[X_BH][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_BH][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_BH][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_BH][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_BH]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_BH][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_BH][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_BH][Layer_Index] / state.X_Layer[Layer_Index]);
    };

   { DERIV(state.C[X_BH][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_BH][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_BH][NrOfLayers];
    };

   

  { DERIV(state.C[X_BA][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_BA][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_BA][1] / state.X_Layer[1]) - state.D_Out * state.C[X_BA][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_BA][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_BA][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_BA][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_BA]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_BA][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_BA][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_BA][Layer_Index] / state.X_Layer[Layer_Index]);
    };

   { DERIV(state.C[X_BA][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_BA][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_BA][NrOfLayers];
    };

 

  { DERIV(state.C[X_P][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_P][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_P][1] / state.X_Layer[1]) - state.D_Out * state.C[X_P][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_P][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_P][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_P][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_P]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_P][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_P][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_P][Layer_Index] / state.X_Layer[Layer_Index]);
    };

   { DERIV(state.C[X_P][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_P][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_P][NrOfLayers];
    };

   

    { DERIV(state.C[X_ND][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[X_ND][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[X_ND][1] / state.X_Layer[1]) - state.D_Out * state.C[X_ND][1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[X_ND][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[X_ND][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[X_ND][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[X_ND]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1])
             * state.C[X_ND][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[X_ND][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[X_ND][Layer_Index] / state.X_Layer[Layer_Index]);
    };

    { DERIV(state.C[X_ND][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[X_ND][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[X_ND][NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 

    state.SolidFlux_Out = state.X_Out * state.Q_Out ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

    interface.Sludge_Blanket_Height = state.H_S;

   };

 :};





# 29 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.daf.wdd.msl" 1
 









# 213 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\primary_clarifier/wwtp.base.daf.wdd.msl"



# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.primary_clarifier.msl" 2



# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarypointsettler.msl" 1
 



















 CLASS SecondaryPointSettler
 (* icon = "secondary_clarifier" *)
 "Point-settler model for secondary clarifiers"
  EXTENDS PointSettler WITH
  {:
    comments <- "A model for a secondary point settler only using mass balances";
    parameters <-
    {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.005 ; group <- "Settling" :};
    };
    equations <-
    {
    state.f_ns_help = parameters.f_ns ;
    };
  :};




# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.marsililibelli.msl" 1
 



















 CLASS MarsiliLibelli
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
 
 
 
 
 
 
 
 
 
 
 
 
 
   Comments <- "A model for a secondary settler by Marsili Libelli";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ A (* is_favorite = "1" *) "Surface of secondary clarifier" : Area := {: value <- 400 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of secondary clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Limit sedimentation velocity for diluted suspensions" : Velocity := {: value <- 4 ; group <- "Settling" :};
    OBJ N "Cole sludge concentration dependency parameter" : Real := {: value <- 2.75 ; group <- "Settling" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ J_T "Total sludge flux" : ArealFlux := {: group <- "Settling" :};
    OBJ help (* hidden = "1" *) "Help variable" : Real;
    OBJ AA (* hidden = "1" *) "Help variable" : Real;
    OBJ U "Underflow velocity" : Velocity := {: group <- "Settling" :};
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ M "Mass of sludge in secondary clarifier" : Mass := {: group <- "Mass" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_L "Limiting sludge biomass concentration" : Concentration := {: group <- "Settling" :};
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {           
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 
    
    state.U = state.Q_Under_Actual / parameters.A;

    state.AA = 1 - parameters.N;
    state.help = IF (state.U == 0)
         THEN 0
         ELSE log(-state.U / (state.AA * parameters.v0)) ;

    state.J_T = 1000 * (parameters.v0 * exp(state.AA / (state.AA - 1) * state.help) + state.U *
               exp(1 / (state.AA - 1) * state.help));
    state.X_L = 1000 * exp(1 / (state.AA - 1) * state.help);

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.H_S = state.M / state.X_L / parameters.A;

    state.X_Out = IF (state.H_S <= parameters.H)
                THEN 0
                ELSE state.X_L;

 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD)  ;
    };






    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

    state.X_Under = IF (( state.SolidFlux_In) >= (parameters.A *state.J_T))   
          THEN
              IF (state.Q_Under_Actual == 0)
          THEN 0 
          ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                    ELSE
                      IF (state.H_S > 0)
                      THEN
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                      ELSE
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE state.SolidFlux_In / state.Q_Under_Actual;

    {DERIV(state.M,[independent.t]) =
             IF (state.SolidFlux_In >= (parameters.A * state.J_T))
             THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
             ELSE
               IF (state.H_S > 0)
               THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
               ELSE 0;
    };

 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
interface.Overflow[Comp_Index] = 
IF (state.Q_In == 0)
    THEN 0 
    ELSE
- state.InFluxPerComponent[Comp_Index] * state.Q_Out / state.Q_In;
      };

       interface.Underflow[IndexOfSolvent] = 
              - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent];

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] = 
 - (state.InFluxPerComponent[Comp_Index]
        + interface.Overflow[Comp_Index]) ;
     };

    interface.TSS = state.M /(parameters.A * parameters.H);

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };
 :};




# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondaryotterpohlfreund.msl" 1
 



















 CLASS SecondaryOtterpohlFreund
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
 
 
 
 
 
 
 
 
 
 
 
 
 
 

   Comments <- "A model for a secondary settler by Otterpohl and Freund";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge volume index" : Real := 
        {: 
          causality <- "CIN" ; 
      value <- 100;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; upperBound <- 1000; :};
        :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {
    
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v_FS "Settling velocity for small fraction of solids" : Velocity := {: value <- 0.24 ; group <- "Settling" :};
    OBJ f0 "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.04;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ A_FS "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.00078;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ J_Up_FS (* hidden = "1" *) "Upward sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_Up_FM (* hidden = "1" *) "Upward sludge flux of the macroflocs" : TakacsArealFluxVector;
    OBJ J_Dn_FS (* hidden = "1" *) "Downward sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_Dn_FM (* hidden = "1" *) "Downward sludge flux macroflocs" : TakacsArealFluxVector;
    OBJ J_G_FS (* hidden = "1" *) "Static sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_G_FM (* hidden = "1" *) "Static sludge flux of the macroflocs" : TakacsArealFluxVector;
    OBJ J_G_FM_Help (* hidden = "1" *) "Static sludge flux of the macroflocs": TakacsArealFluxVector;
    OBJ J_G_FS_Help (* hidden = "1" *) "Static sludge flux of the small solids fraction": TakacsArealFluxVector;
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;

    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};

    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    
    OBJ X_FM_Layer "Vector containing concentration of macroflocs for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ X_FS_Layer "Vector containing concentration of small solids  for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
    OBJ v_FM "Settling velocity for macroflocs" : TakacsVelocityVector := {: group <- "Settling" :};
    OBJ f1 "Fraction of small solids" : Fraction := {: group <- "Influent characterization" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  

     
    OBJ B (* hidden = "1" *) "variable B of the omega function" : Real ;
    OBJ help_var_omega (* hidden = "1" *) "help state" : Real ;
    
    OBJ H_T "Height of transition point" : Length := {: group <- "Settling" :};
    OBJ H_C "Height of compressing point" : Length := {: group <- "Settling" :};
    OBJ H0 "Height of influent" : Length := {: group <- "Dimension" :};
    OBJ omega (* hidden = "1" *) "Hartels omega function" : Real[NrOfLayers;] ;
    OBJ z (* hidden = "1" *) "Vertical coordinate, bottom z=0" : LengthVector ;
    OBJ X_C "Solids concentration at compression point" : Concentration := {: group <- "Settling" :};
    OBJ X_AT "Solids concentration of the aeration tank" : Concentration := {: group <- "Concentration" :};
    OBJ X_FM_AT "Solids concentration of the aeration tank, macroflocs" : Concentration := {: group <- "Concentration" :};
    OBJ X_FS_AT "Solids concentration of the aeration tank, small solids" : Concentration := {: group <- "Concentration" :};
    OBJ k (* hidden = "1" *) "Part of the Vesilind equation, here results of Hartel" : Real ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of small solids and macroflocs" : Concentration ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
    state.H0 = ((NrOfLayers - IndexOfFeedLayer) + 0.5) * state.H_Layer;
    state.X_C = 480 / interface.SVI ;
    state.k = 1.043 - 0.9834 * exp( -0.00581 * interface.SVI) ;
    state.help_var_omega = -(1 + 2 * interface.SVI / (100 + interface.SVI));

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
     state.z[Layer_Index] =
        ((NrOfLayers - Layer_Index) + 0.5) * state.H_Layer ;
    };

   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
          state.InFluxPerComponent[Comp_Index]* parameters.F_TSS_COD) ;
    };






     
     
     
    state.B = - (( 100 + interface.SVI) / interface.SVI + 1)
                * pow(state.H_C, (1 + 2 * interface.SVI / (100 + interface.SVI)));

    

    state.H_T = IF(2 * state.H_C > state.H0)
                THEN state.H0
                ELSE 2 * state.H_C ;

    state.H_C = (state.X_AT * state.H0 / state.X_C) * (1 - 1 / (state.X_C * state.k)) ;
    state.X_AT = IF (state.Q_In == 0 )
             THEN 0
         ELSE state.SolidFlux_In / state.Q_In;

 
 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.omega[Layer_Index] = IF (state.H_T == 0)
             THEN 1 / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega))
             ELSE (1 - state.B * pow(state.H_T,state.help_var_omega))
              / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega));
    };

    state.f1 = parameters.f0 * exp( - parameters.A_FS * state.X_AT) ;

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.v_FM[Layer_Index] = 
             (17.4 * exp(-0.00581 * interface.SVI) + 3.931)
             * (exp(-(-0.9834e-3 * exp(-0.00581 * interface.SVI) + 1.043e-3)
                       * (state.X_FM_Layer[Layer_Index] + state.X_FS_Layer[Layer_Index])))
             * 24 ;
    };

     
     
     

    state.X_FM_AT = state.X_AT * (1 - state.f1) ;
    state.X_FS_AT = state.X_AT * state.f1 ;

    state.v_Up = state.Q_Out / parameters.A; 
    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FM_Help[Layer_Index] =
        state.v_FM[Layer_Index] * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FS_Help[Layer_Index] =
        parameters.v_FS * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FS[Layer_Index] =
        state.v_Up * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FM[Layer_Index] =
        state.v_Up * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FS[Layer_Index] =
        state.v_Dn * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FM[Layer_Index] =
        state.v_Dn * state.X_FM_Layer[Layer_Index];
    };

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FS[Layer_Index] =
        IF (state.J_G_FS_Help[Layer_Index] > state.J_G_FS_Help[Layer_Index+1])
        THEN state.J_G_FS_Help[Layer_Index+1]
        ELSE state.J_G_FS_Help[Layer_Index] ;
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FM[Layer_Index] =
        IF (state.J_G_FM_Help[Layer_Index] > state.J_G_FM_Help[Layer_Index+1])
        THEN state.J_G_FM_Help[Layer_Index+1]
        ELSE state.J_G_FM_Help[Layer_Index] ;
    };

     
     
     

    { DERIV(state.X_FS_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FS[2] - state.J_G_FS[1] - ( state.Q_Out / parameters.A * state.X_FS_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FS_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FS[Layer_Index] - state.J_Up_FS[Layer_Index]
             + state.J_G_FS[Layer_Index-1]
             - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * state.f1
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FS[Layer_Index+1] - ( state.J_Up_FS[Layer_Index])
                - state.J_G_FS[Layer_Index] + state.J_G_FS[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FS[Layer_Index-1] - ( state.J_Dn_FS[Layer_Index])
                + (state.J_G_FS[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FS_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FS[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FS_Layer[NrOfLayers])
       + (state.J_G_FS[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    { DERIV(state.X_FM_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FM[2] - state.J_G_FM[1] - ( state.Q_Out / parameters.A * state.X_FM_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FM_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FM[Layer_Index] - state.J_Up_FM[Layer_Index]
             + state.J_G_FM[Layer_Index-1]
             - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * (1 - state.f1)
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FM[Layer_Index+1] - ( state.J_Up_FM[Layer_Index])
                - state.J_G_FM[Layer_Index] + state.J_G_FM[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FM[Layer_Index-1] - ( state.J_Dn_FM[Layer_Index])
                + (state.J_G_FM[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FM_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FM[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FM_Layer[NrOfLayers])
       + (state.J_G_FM[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_FS_Layer[1] + state.X_FM_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_FS_Layer[NrOfLayers] + state.X_FM_Layer[NrOfLayers];

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    }; 

    { state.SolidConcentration = (SUMOVER Layer_Index IN {1 .. NrOfLayers}:
       state.X_FS_Layer[Layer_Index] + state.X_FM_Layer[Layer_Index]) ;
    };

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.takacs.msl" 1
 



















 
 
 

 CLASS Takacs
 (* icon = "secondary_clarifier"*)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In =
       SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ;
    };






    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
         THEN parameters.v00
         ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};




# 23 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.takacssvi.msl" 1
 




















 CLASS Takacs_SVI
 (* icon = "secondary_clarifier"; is_default = "true" *)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge Volume Index in mL/g" : 
      Real := {: causality <- "CIN" ; value <- 100 ; group <- "Settling" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.r_H = (0.148 + 0.00210 * interface.SVI) / 1000;

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In =
       SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ;
    };






    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

 
    state.v0_H = parameters.v0 * exp(state.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

 








    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - state.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
         THEN parameters.v00
         ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};





# 24 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl" 1
 



















 
 
 

 
 

 CLASS SecondaryTakacsSolublesPropagator
 (* icon = "secondary_clarifier" *)
 "Takacs_Solubles"

 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :}; 
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_I_Layer "Vector containing concentration of S_I for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_S_Layer "Vector containing concentration of S_S for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_O_Layer "Vector containing concentration of S_O for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NO_Layer "Vector containing concentration of S_NO for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_NH_Layer "Vector containing concentration of S_NH for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ND_Layer "Vector containing concentration of S_ND for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ S_ALK_Layer "Vector containing concentration of S_ALK for all layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *) "Volume of the layers" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of the layers" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;

   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual ; 

    { 
     state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD ;
    };

    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };
 
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.S_I_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_I_Layer[2] - state.S_I_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_I_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_I] - state.Q_In * state.S_I_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_I_Layer[Layer_Index+1] - state.S_I_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_I_Layer[Layer_Index-1] - state.S_I_Layer[Layer_Index]);
    };

    
    { DERIV(state.S_S_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_S_Layer[2] - state.S_S_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_S_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_S] - state.Q_In * state.S_S_Layer[IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_S_Layer[Layer_Index+1] - state.S_S_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_S_Layer[Layer_Index-1] - state.S_S_Layer[Layer_Index]);
    };    

    { DERIV(state.S_O_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_O_Layer[2] - state.S_O_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_O_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_O] - state.Q_In * state.S_O_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_O_Layer[Layer_Index+1] - state.S_O_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_O_Layer[Layer_Index-1] - state.S_O_Layer[Layer_Index]);
    };

    { DERIV(state.S_NO_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NO_Layer[2] - state.S_NO_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NO_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NO] - state.Q_In * state.S_NO_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NO_Layer[Layer_Index+1] - state.S_NO_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NO_Layer[Layer_Index-1] - state.S_NO_Layer[Layer_Index]);
    };

    { DERIV(state.S_NH_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_NH_Layer[2] - state.S_NH_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_NH_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_NH] - state.Q_In * state.S_NH_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_NH_Layer[Layer_Index+1] - state.S_NH_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_NH_Layer[Layer_Index-1] - state.S_NH_Layer[Layer_Index]);
    };

    { DERIV(state.S_ND_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ND_Layer[2] - state.S_ND_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ND_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ND] - state.Q_In * state.S_ND_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ND_Layer[Layer_Index+1] - state.S_ND_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ND_Layer[Layer_Index-1] - state.S_ND_Layer[Layer_Index]);
    };

{ DERIV(state.S_ALK_Layer[1],[independent.t]) =
       (state.Q_Out / state.V_Layer) * (state.S_ALK_Layer[2] - state.S_ALK_Layer[1]);
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.S_ALK_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[S_ALK] - state.Q_In * state.S_ALK_Layer[IndexOfFeedLayer])
        ELSE 
        IF (Layer_Index < IndexOfFeedLayer)
        THEN (state.Q_Out / state.V_Layer) *
             (state.S_ALK_Layer[Layer_Index+1] - state.S_ALK_Layer[Layer_Index])
        ELSE (state.Q_Under_Actual  / state.V_Layer) *
          (state.S_ALK_Layer[Layer_Index-1] - state.S_ALK_Layer[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (state.Q_Under_Actual  / state.V_Layer) * state.X_Layer[NrOfLayers];
    };
    
    { DERIV(state.S_I_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_I_Layer[NrOfLayersButOne] - state.S_I_Layer[NrOfLayers]);
    };
 
    { DERIV(state.S_S_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_S_Layer[NrOfLayersButOne] - state.S_S_Layer[NrOfLayers]);
    };

    { DERIV(state.S_O_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_O_Layer[NrOfLayersButOne] - state.S_O_Layer[NrOfLayers]);
    };

    { DERIV(state.S_NO_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NO_Layer[NrOfLayersButOne] - state.S_NO_Layer[NrOfLayers]);
    };

    { DERIV(state.S_NH_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_NH_Layer[NrOfLayersButOne] - state.S_NH_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ND_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ND_Layer[NrOfLayersButOne] - state.S_ND_Layer[NrOfLayers]);
    };

    { DERIV(state.S_ALK_Layer[NrOfLayers],[independent.t]) =
       (state.Q_Under_Actual  / state.V_Layer) * 
       (state.S_ALK_Layer[NrOfLayersButOne] - state.S_ALK_Layer[NrOfLayers]);
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];
    

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                parameters.H / NrOfLayers;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;
    

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];
    interface.Overflow[S_I] = -state.S_I_Layer[1]*state.Q_Out;
    interface.Overflow[S_S] = -state.S_S_Layer[1]*state.Q_Out;
    interface.Overflow[S_O] = -state.S_O_Layer[1]*state.Q_Out;
    interface.Overflow[S_NO] = -state.S_NO_Layer[1]*state.Q_Out;
    interface.Overflow[S_NH] = -state.S_NH_Layer[1]*state.Q_Out;
    interface.Overflow[S_ND] = -state.S_ND_Layer[1]*state.Q_Out;
    interface.Overflow[S_ALK] = -state.S_ALK_Layer[1]*state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual ;
    

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual  / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    interface.Underflow[S_I] = -state.S_I_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_S] = -state.S_S_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_O] = -state.S_O_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_NO] = -state.S_NO_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_NH] = -state.S_NH_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ND] = -state.S_ND_Layer[NrOfLayers]*state.Q_Under_Actual ;
    interface.Underflow[S_ALK] = -state.S_ALK_Layer[NrOfLayers]*state.Q_Under_Actual ;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

 

    interface.Sludge_Blanket_Height = state.H_S;
 
    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};



# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacsallfractionpropagator.msl" 1
 



















 CLASS SecondaryTakacsAllFractionPropagator
 (* icon = "secondary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 


    { state.SolidFlux_In =
       (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index]) * parameters.F_TSS_COD  ;
    };






    {state.X_In = IF (state.Q_In == 0)
                        THEN 0
                        ELSE state.SolidFlux_In / state.Q_In;
     };

 


{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
    state.X_Layer[Layer_Index] = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
state.C[Comp_Index][Layer_Index] * parameters.F_TSS_COD);
};








 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

    interface.Sludge_Blanket_Height = state.H_S;
 
    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

   
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 26 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.secondary_clarifier.burger.msl" 1
 














 
 






CLASS Burger
  (* icon = "secondary_clarifier" *)
  "Layered clarifier model by Burger with Vesilind settling function" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A model for a secondary settler by Burger with Vesilind settling";
    interface <-
    {
		OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
		OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
		OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
		OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
		 
		OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    };
    parameters <-
    {
		OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/d2)": Acceleration := {: value <- 7.32312576e10 :};
		OBJ PI (* hidden = "1" *) "PI": Real := {: value <- 3.141592653 :};
		OBJ A "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
		OBJ H "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
		OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
		OBJ X_Lim "Minimum concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
		 
		OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
		OBJ r_V "Settling parameter" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :};
		 
		OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
		 
		 
		OBJ Comp_ON "Switch on/off compression": Integer :={: value <- 0 ; group <- "Compression" :};
		OBJ Alpha "Effective solids stress parameter" : BurgerSolidsStress := {: value <- 0.8 ; group <- "Compression" :};
		OBJ Rhos "Solid density": Density := {: value <- 1050000 ; group <- "Compression" :};
		OBJ Rhof "Fluid density": Density := {: value <- 998000 ; group <- "Compression" :};
		OBJ C_crit "Gel point" : Concentration := {: value <- 6000 ; group <- "Compression" :};
		 
		OBJ C_min (* hidden = "1" *) "Minimum packing concentration" : Concentration := {: value <- 0 ; group <- "Settling" :};
		OBJ C_max (* hidden = "1" *) "Maximum packing concentration" : Concentration := {: value <- 20000 ; group <- "Settling" :};
		OBJ TOL (* hidden = "1" *) "Tolerance level to calculate concentration with maximum settling flux" : Fraction := {: value <- 1e-10 ; group <- "Settling" :};
		 
		OBJ Disp_ON "Switch on/off dispersion": Integer :={: value <- 0 ; group <- "Dispersion" :};
		OBJ a_mix "Dispersion parameter" : Length := {: value <- 0.4 ; group <- "Dispersion" :};
		OBJ b_mix "Dispersion parameter" : BurgerDispersion := {: value <- 0.00001 ; group <- "Dispersion" :}; 
    };
    state <-
    {
		 
		OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
		OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;
		OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
		OBJ v_S (* hidden = "1" *) "Static settling velocity" : BurgerVelocityVector;
		OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : BurgerArealFluxVector;
		OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : BurgerArealFluxVector;
		OBJ J_G (* hidden = "1" *) "Static sludge flux" : BurgerArealFluxVector;
		OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": BurgerArealFluxVector;
		OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
		OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
		OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
		OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;
		OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
		OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
		OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
		 
		OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Under_Actual "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
		OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :};
		OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Layer "Vector containing concentration of particulates for all the layers" : BurgerConcentrationVector := {: group <- "Concentration" :};
		 
		OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
		 
		 
		OBJ D_comp (* hidden = "1" *) "Primitive of compression function" : BurgerLengthFluxVector;
		 
		OBJ Fbk_max (* hidden = "1" *) "Maximum flux" : ArealFlux := {: group <- "Settling" :};
		OBJ C_fbk_max (* hidden = "1" *) "Concentration corresponding to maximal settling flux" : Concentration := {: group <- "Settling" :};
		 
		OBJ d_mix (* hidden = "1" *) "Dispersion function" : BurgerDiffusivityVector;
		OBJ z "Height in clarifier" : BurgerLengthVector;
    };
    initial <-
    {
		parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
		state.V_Layer = parameters.A * (parameters.H / NrOfLayersBurger);
		state.H_Layer = parameters.H / (NrOfLayersBurger);
		 
		 
		state.C_fbk_max = MSLUBurgerCHat(parameters.v0, parameters.r_V, parameters.C_min, parameters.C_max, parameters.TOL) ;
		state.Fbk_max = parameters.v0 * exp(-parameters.r_V * state.C_fbk_max) * state.C_fbk_max ;
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.z[Layer_Index] =
		  	fabs(state.H_Layer * (Layer_Index - IndexOfFeedLayerBurger)) ; };
    };
    independent <-
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    equations <-
    {
		state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under) THEN state.Q_In
			ELSE interface.Q_Under ;
		state.v_Dn = state.Q_Under_Actual / parameters.A ;
		
		{ FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
		  	SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

		state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]);
		state.Q_Out = state.Q_In - state.Q_Under_Actual ;

		
		{ state.SolidFlux_In = SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
		  	state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ; };
		

		



		state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;
		{state.SolidConcentration = ( SUMOVER Layer_Index IN {3 .. NrOfLayersPlusTwoBurger}:
			state.X_Layer[Layer_Index]) / NrOfLayersBurger; };
		state.v_Up = state.Q_Out / parameters.A ;
		
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.v_S[Layer_Index] =
		  	parameters.v0 * exp(-parameters.r_V * state.X_Layer[Layer_Index]) ; }; 
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.J_G_Help[Layer_Index] =
		  	state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };
	
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}: state.J_G[Layer_Index] =
		  	IF (state.X_Layer[Layer_Index]<state.X_Layer[Layer_Index+1]) THEN MSLUGetMin2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1])
			   ELSE IF (((state.C_fbk_max-state.X_Layer[Layer_Index])*(state.C_fbk_max-state.X_Layer[Layer_Index+1]))<0) THEN state.Fbk_max
			   ELSE MSLUGetMax2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1]) ; };
	
		 
		{ FOREACH Layer_Index IN {2 .. IndexOfFeedLayerBurger}: state.J_Up[Layer_Index] =
		  	state.v_Up * state.X_Layer[Layer_Index] ; };
		{ FOREACH Layer_Index IN {IndexOfFeedLayerBurger .. NrOfLayersPlusFourBurger}: state.J_Dn[Layer_Index] =
		  	state.v_Dn * state.X_Layer[Layer_Index] ; };

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.D_comp[Layer_Index] =
		       IF (state.X_Layer[Layer_Index] < parameters.C_crit) THEN 0
		 	   ELSE
			   parameters.Comp_ON * parameters.Alpha * pow(24*3600,2) *parameters.Rhos * parameters.v0 *
			   (exp(-parameters.r_V * state.X_Layer[Layer_Index])-exp(-parameters.r_V * parameters.C_crit)) /
			   (-parameters.r_V * parameters.g * (parameters.Rhos-parameters.Rhof)) ; };

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.d_mix[Layer_Index] =
		  	IF (state.z[Layer_Index] < (parameters.b_mix*state.Q_In))
			THEN parameters.Disp_ON * parameters.a_mix/parameters.A * state.Q_In *
			  pow(cos(parameters.PI*state.z[Layer_Index]/(2*parameters.b_mix*state.Q_In)),2)
			ELSE 0 ; };

		 
		 
		{ DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[2]) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };
		{ DERIV(state.X_Layer[2],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[3] - state.J_Up[2] - state.J_G[2] + (1 / state.H_Layer) *(state.D_comp[3]- state.D_comp[2])); };
		
		 
		{ DERIV(state.X_Layer[3],[independent.t]) = IF (3 == IndexOfFeedLayerBurger)
		  	THEN (1 / state.H_Layer) * (- state.J_Up[3] - state.J_Dn[3] + state.J_G[2] - state.J_G[3] +
			(1 / state.H_Layer) *(state.d_mix[3]*(state.X_Layer[4]-state.X_Layer[3]) + state.D_comp[4]+state.D_comp[2]-2*state.D_comp[3])) + 
			(1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[4] - state.J_Up[3] + state.J_Dn[2] - state.J_Dn[3] + state.J_G[2] -
			state.J_G[3] + (1 / state.H_Layer) *(state.d_mix[3]*((state.X_Layer[4]-state.X_Layer[3])) + state.D_comp[4]+state.D_comp[2] -
			2*state.D_comp[3])); };
		
		 
		{ FOREACH Layer_Index IN {4 .. NrOfLayersPlusOneBurger}: DERIV(state.X_Layer[Layer_Index],[independent.t]) =
		  	IF (Layer_Index == IndexOfFeedLayerBurger) THEN (1 / state.H_Layer) * (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
			   state.d_mix[Layer_Index] *(state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) 
			   - state.d_mix[Layer_Index-1] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) + 
			   state.D_comp[Layer_Index+1] + state.D_comp[Layer_Index-1] - 2*state.D_comp[Layer_Index])) +
			   (1 / state.V_Layer) * state.SolidFlux_In
			   ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index] + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
				state.d_mix[Layer_Index]*(state.X_Layer[Layer_Index+1] - 
			   state.X_Layer[Layer_Index]) - state.d_mix[Layer_Index-1] *(state.X_Layer[Layer_Index]-state.X_Layer[Layer_Index-1]) +
			   state.D_comp[Layer_Index+1]+state.D_comp[Layer_Index-1]-2*state.D_comp[Layer_Index])) ; };

		 
		{ DERIV(state.X_Layer[NrOfLayersPlusTwoBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusOneBurger] - state.J_Dn[NrOfLayersPlusTwoBurger] +
		  		state.J_G[NrOfLayersPlusOneBurger] - state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) * (
				-state.d_mix[NrOfLayersPlusOneBurger] * (state.X_Layer[NrOfLayersPlusTwoBurger] - state.X_Layer[NrOfLayersPlusOneBurger]) + 
				state.D_comp[NrOfLayersPlusThreeBurger] + state.D_comp[NrOfLayersPlusOneBurger] - 2*state.D_comp[NrOfLayersPlusTwoBurger])) ; };
		
		 
		{ DERIV(state.X_Layer[NrOfLayersPlusThreeBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusTwoBurger] - state.J_Dn[NrOfLayersPlusThreeBurger] +
		  		state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) *(state.D_comp[NrOfLayersPlusTwoBurger]-state.D_comp[NrOfLayersPlusThreeBurger])) ; };
		{ DERIV(state.X_Layer[NrOfLayersPlusFourBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusThreeBurger] - state.J_Dn[NrOfLayersPlusFourBurger]); };

		state.X_Out = IF (state.Q_Out == 0)	THEN 0 ELSE state.X_Layer[1] ;
		state.X_Under = IF (state.Q_Under_Actual == 0) THEN 0 ELSE state.X_Layer[NrOfLayersPlusFourBurger] ;
		
		 
		state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayersPlusFourBurger,parameters.X_Lim) ;
		state.H_S = (NrOfLayersPlusTwoBurger - state.IndexOfSludgeBlanket + 1) * state.H_Layer ;

		 
		state.SolidFlux_Out = state.X_Out * state.Q_Out ;
		{ FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent} : interface.Overflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0	ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
		  		IF (state.SolidFlux_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

		 
		state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
		interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
		{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}: interface.Underflow[Comp_Index] =
		  		- state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

		 
		 
		interface.Sludge_Blanket_Height = state.H_S ;
		interface.TSS = state.SolidConcentration ;
		interface.V_Clarifier = parameters.A * parameters.H ;  
		 
		 
		DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
		interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    };

 :};




# 29 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.secondary_clarifier.plosz.msl" 1
 




















CLASS BasePlosz
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   interface <-
   {
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" :};
   OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" :};
   OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" :};
   OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    
   OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 754 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 3 ; group <- "Dimension" :};
 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.001375 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ L_60 "Fraction of  underflow withdrawn from layer 60" : Real := {: value <- 0.25 :};
    OBJ L_59 "Fraction of  underflow withdrawn from layer 59" : Real := {: value <- 0.25 :};
    OBJ L_58 "Fraction of  underflow withdrawn from layer 58" : Real := {: value <- 0.25 :};
    OBJ L_57 "Fraction of  underflow withdrawn from layer 57" : Real := {: value <- 0.075 :};
    OBJ L_56 "Fraction of  underflow withdrawn from layer 56" : Real := {: value <- 0.075 :};
    OBJ L_55 "Fraction of  underflow withdrawn from layer 55" : Real := {: value <- 0.05 :};
    OBJ L_54 "Fraction of  underflow withdrawn from layer 54" : Real := {: value <- 0.05 :};
 
    OBJ Eta_Con "Downwards convection control" : Velocity := {: value <- 0.504 :};
    OBJ D_01 "Over flow dependent dispersion model parameter" : Diffusivity := {: value <- 3.95 :}; 
    OBJ V_OV_DIS "Boundary overflow velocity for dispersion" : Velocity := {: value <- 15 :}; 
    OBJ V_F_CON "Boundary feedflow velocity for convection" : Length := {: value <- 30.5 :};
    OBJ g_Dis "Dispersion function coefficient" : Time := {: value <- 0.022 :}; 
 
    OBJ D_C_max "Maximum value of the dispersion coefficient" : Real := {: value <- 15 :};
 
 
    OBJ L_F_max "Maximum height of the feed layer" : Real := {: value <- 32 :};
 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : PloszConcentrationVector := {: group <- "Concentration" :};
 
    OBJ D_Con_Help (* hidden = "1" *) "Help for the over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ D_Con "Over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ V_Ff "Clarifier feed velocity" : Velocity;
    OBJ V_Fo "Clarifier overflow velocity" : Velocity;
    OBJ Eta_CC "Feed velocity dependent convection reduction factor" : Real;
    OBJ Eta_Con_Help (* hidden = "1" *) "Help for convection reduction factor" : Real;
 
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;	
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : PloszVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": PloszVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : PloszArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : PloszArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : PloszArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": PloszArealFluxVector;
 
    OBJ DynamicIndexOfFeedLayer_Help (* hidden = "1" *) "Dynamic Index of Feed Layer - HELP" : Real;
    OBJ DynamicIndexOfFeedLayer "Dynamic Index of Feed Layer" : Real := {: group <- "Operational" :};
 
    OBJ J_Dis (* hidden = "1" *) "Dispersion flux": PloszArealFluxVector;
    OBJ D_1 (* hidden = "1" *) "Dispersion with the following layer ": PloszDiffusivityVector; 
    OBJ D_2 (* hidden = "1" *) " Dispersion with the precedent layer ": PloszDiffusivityVector; 
    OBJ J_GUp_Help (* hidden = "1" *) "Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective help fluxes": PloszArealFluxVector; 
    OBJ J_GUp (* hidden = "1" *) " Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective fluxes": PloszArealFluxVector; 
 
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;	
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[H2O] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / 60); 
    state.H_Layer = parameters.H / 60;
   };

  independent <- { OBJ t "Time": Time; };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

 
    state.v_Dn = (state.Q_Under_Actual / parameters.A) * state.Eta_CC; 

 
 
    state.DynamicIndexOfFeedLayer_Help = MSLUFindThreshold(ref(state.X_Layer[1]),60,state.X_In);
    state.DynamicIndexOfFeedLayer = MSLUGetMax2(state.DynamicIndexOfFeedLayer_Help,parameters.L_F_max);
 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
			SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

    state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]) ;

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In = SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
			state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ; };






    state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;

	{ state.SolidConcentration =
			(SUMOVER Layer_Index IN {1 .. 60}: state.X_Layer[Layer_Index]) / 60 ; };

    state.X_Min = IF (state.Q_In == 0) THEN parameters.f_ns * state.SolidConcentration
			ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

 




    state.v_Up = state.Q_Out / parameters.A; 

 
    state.V_Ff = state.Q_In / parameters.A;
    state.V_Fo = state.Q_Out / parameters.A;

    state.D_Con_Help = IF (state.V_Fo < parameters.V_OV_DIS) THEN parameters.D_01
			ELSE parameters.D_01 + parameters.g_Dis * (state.V_Fo - parameters.V_OV_DIS) * (state.V_Fo - parameters.V_OV_DIS) ;

    state.D_Con = MSLUGetMin2(state.D_Con_Help, parameters.D_C_max);
	 
    state.Eta_Con_Help = IF (state.V_Ff < parameters.V_F_CON) THEN parameters.Eta_Con
			ELSE parameters.Eta_Con + (state.V_Ff - parameters.V_F_CON) /  parameters.V_F_CON * (state.V_Ff - parameters.V_F_CON) / parameters.V_F_CON;

    state.Eta_CC = MSLUGetMin2(state.Eta_Con_Help, 1.0);
 
    
 
    { FOREACH Layer_Index IN {1 .. 59}: state.D_1[Layer_Index] = state.D_Con ; };
    { FOREACH Layer_Index IN {1 .. 60}: state.D_2[Layer_Index] = state.D_Con ; };
 

 







        
    { FOREACH Layer_Index IN {1 .. 60}: state.J_G_Help[Layer_Index] =
			state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };

 
    { FOREACH Layer_Index IN {2 .. 60}: state.J_Up[Layer_Index] = 
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 0		   
					ELSE state.v_Up * state.X_Layer[Layer_Index]; };	 

 
    { FOREACH Layer_Index IN {1 .. 59}: state.J_Dn[Layer_Index] =
			IF (Layer_Index >= state.DynamicIndexOfFeedLayer) THEN state.v_Dn * state.X_Layer[Layer_Index]	 
					ELSE 0; }; 								  	   		 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_Dis[Layer_Index] =
			- state.D_2[Layer_Index] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) / state.H_Layer
			+ state.D_1[Layer_Index] * (state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) / state.H_Layer ; };
 

 

 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_G[Layer_Index-1] =
			IF (Layer_Index <= state.DynamicIndexOfFeedLayer) THEN
					IF (state.J_G_Help[Layer_Index-1] <= state.J_G_Help[Layer_Index]) THEN state.J_G_Help[Layer_Index-1]
					   		ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index-1] ; };

    { FOREACH Layer_Index IN {1 .. 59}: state.J_G[Layer_Index] =
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 
					IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1]) THEN state.J_G_Help[Layer_Index+1]
							ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index] ; };
 


 
    { DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1] + state.D_1[1] * (state.X_Layer[2]
			- state.X_Layer[1]) / state.H_Layer) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };

    { FOREACH Layer_Index IN {2 .. 53}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == state.DynamicIndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]);
    };

 
    { DERIV(state.X_Layer[54],[independent.t]) = IF (54 == state.DynamicIndexOfFeedLayer)
	  		THEN (1 / state.H_Layer) * (state.J_Up[55] - state.J_Up[54] + state.J_Dn[53] - state.J_Dn[54]
			+ state.J_G[53] - state.J_G[54] + state.J_Dis[54]) - ((state.Q_Under_Actual * parameters.L_54)
			/ state.V_Layer) * state.X_Layer[54] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[55] - state.J_Up[54] + state.J_Dn[53] - state.J_Dn[54]
			+ state.J_G[53] - state.J_G[54] + state.J_Dis[54]) - ((state.Q_Under_Actual * parameters.L_54)
			/ state.V_Layer) * state.X_Layer[54] ; };

    { DERIV(state.X_Layer[55],[independent.t]) = IF (55 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[56] - state.J_Up[55] + state.J_Dn[54] - state.J_Dn[55]
			+ state.J_G[54] - state.J_G[55] + state.J_Dis[55]) - ((state.Q_Under_Actual * parameters.L_55)
			/ state.V_Layer) * state.X_Layer[55] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[56] - state.J_Up[55] + state.J_Dn[54] - state.J_Dn[55]
			+ state.J_G[54] - state.J_G[55] + state.J_Dis[55]) - ((state.Q_Under_Actual * parameters.L_55)
			/ state.V_Layer) * state.X_Layer[55] ; };

    { DERIV(state.X_Layer[56],[independent.t]) = IF (56 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[57] - state.J_Up[56] + state.J_Dn[55] - state.J_Dn[56]
			+ state.J_G[55] - state.J_G[56] + state.J_Dis[56]) - ((state.Q_Under_Actual * parameters.L_56)
			/ state.V_Layer) * state.X_Layer[56] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[57] - state.J_Up[56] + state.J_Dn[55] - state.J_Dn[56]
			+ state.J_G[55] - state.J_G[56] + state.J_Dis[56]) - ((state.Q_Under_Actual * parameters.L_56)
			/ state.V_Layer) * state.X_Layer[56] ; };

    { DERIV(state.X_Layer[57],[independent.t]) =  IF (57 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[58] - state.J_Up[57] + state.J_Dn[56] - state.J_Dn[57]
			+ state.J_G[56] - state.J_G[57] + state.J_Dis[57]) - ((state.Q_Under_Actual * parameters.L_57)
			/ state.V_Layer) * state.X_Layer[57] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[58] - state.J_Up[57] + state.J_Dn[56] - state.J_Dn[57]
			+ state.J_G[56] - state.J_G[57] + state.J_Dis[57]) - ((state.Q_Under_Actual * parameters.L_57)
			/ state.V_Layer) * state.X_Layer[57] ; };

    { DERIV(state.X_Layer[58],[independent.t]) = IF (58 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[59] - state.J_Up[58] + state.J_Dn[57] - state.J_Dn[58]
			+ state.J_G[57] - state.J_G[58] + state.J_Dis[58]) - ((state.Q_Under_Actual * parameters.L_58)
			/ state.V_Layer) * state.X_Layer[58] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[59] - state.J_Up[58] + state.J_Dn[57] - state.J_Dn[58]
			+ state.J_G[57] - state.J_G[58] + state.J_Dis[58]) - ((state.Q_Under_Actual * parameters.L_58)
			/ state.V_Layer) * state.X_Layer[58] ; };

    { DERIV(state.X_Layer[59],[independent.t]) = IF (59 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[60] - state.J_Up[59] + state.J_Dn[58] - state.J_Dn[59]
			+ state.J_G[58] - state.J_G[59] + state.J_Dis[59]) - ((state.Q_Under_Actual * parameters.L_59)
			/ state.V_Layer) * state.X_Layer[59] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[60] - state.J_Up[59] + state.J_Dn[58] - state.J_Dn[59]
			+ state.J_G[58] - state.J_G[59] + state.J_Dis[59]) - ((state.Q_Under_Actual * parameters.L_59)
			/ state.V_Layer) * state.X_Layer[59] ; };

    { DERIV(state.X_Layer[60],[independent.t]) =  IF (60 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] ; };

    state.X_Out = IF (state.Q_Out == 0) THEN 0
			ELSE state.X_Layer[1]; 
 

 

    state.X_Under = IF (state.Q_Under_Actual == 0)
			  THEN 0
			  ELSE state.X_Layer[60] * parameters.L_60 + state.X_Layer[59] * parameters.L_59 + 
			  state.X_Layer[58] * parameters.L_58 + state.X_Layer[57] * parameters.L_57 + state.X_Layer[56] * parameters.L_56 + state.X_Layer[55] * parameters.L_55 + state.X_Layer[54] * parameters.L_54; 

 

 
    state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),60,parameters.X_Lim) ;
    state.H_S = (60 - state.IndexOfSludgeBlanket + 1) * state.H_Layer ;

 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}: interface.Overflow[Comp_Index] =
	  		IF (state.Q_In == 0) THEN 0
			ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
			IF (state.SolidFlux_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

 
    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
			interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
			IF (state.Q_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

 
 
    interface.Sludge_Blanket_Height = state.H_S;
    interface.TSS = state.SolidConcentration;
    interface.V_Clarifier = parameters.A * parameters.H;  

	 
	DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual ;
	interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};




CLASS Plosz
 (* icon = "secondary_clarifier" *)
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 103.012 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.0002526 ; group <- "Settling" :}; 
   };

  equations <-
   {
    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > parameters.v0) THEN parameters.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.secondary_clarifier.ploszsvi.msl" 1
 




















CLASS PloszSVI
 (* icon = "secondary_clarifier" *)
 "Layered convection-dispersion model of the secondary settling tank - Benedek Gy. Plosz"

 
 
 
 
 

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    
    OBJ V_alpha "SSVI3.5(ml/g) - V0(m/d) exponential regression - alpha value" : Real := {: value <- 133.7472 :};
    OBJ V_beta "SSVI3.5(ml/g) - V0(m/d) exponential regression - exponent" : Real := {: value <- -0.0034467 :};
    OBJ r_H_lambda "SSVI3.5(ml/g) - r_H(m3/g) linear regression - slope" : Real := {: value <- 0.0000026 :};
    OBJ r_H_kappa "SSVI3.5(ml/g) - r_H(m3/g) linear regression - y-intercept" : Real := {: value <- 0.0000628 :};
    OBJ DSVI "Diluted sludge volume index, DSVI (ml/g)" : SpecificVolume := {: value <- 85 :};
    OBJ p_SVI "SSVI3.5/DSVI ratio" : Real := {: value <- 0.658 :};
    
   };

   state <-
   {
 
    OBJ v0 "Maximum theoretical settling velocity" : Velocity ;
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume ;
 
   };

  equations <-
   {
 
    state.v0 = parameters.V_alpha * exp(parameters.V_beta * parameters.DSVI * parameters.p_SVI);
    state.r_H = parameters.r_H_lambda * parameters.DSVI * parameters.p_SVI + parameters.r_H_kappa;
	
    state.v0_P = state.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = state.v0 * exp(state.r_H * state.X_Min);

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - state.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > state.v0) THEN state.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 31 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\secondary_clarifier/wwtp.secondary_clarifier.burgerdoubleexponential.msl" 1
 





 
 






  OBJ Legendre_Index "Temporary iteration variable, index of Gaussian quadrature" : Integer;
  OBJ NrOfNodes "The number of nodes and weights used in the Gaussian Quadrature for compression calculation" : Integer := 16; 

CLASS BurgerDoubleExponential
 (* icon = "secondary_clarifier" ; is_default = "" *)
 "Layered clarifier model by Burger with double exponential settling function"

 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
	 		 FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  	OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
	  OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};


    
      
 
 
	 
    
      
       OBJ NoComp "Parameter to switch off compression": Integer :={: value <- 1 ; group <- "Compression" :};
	   OBJ alpha "Effective solids stress parameter" : NormalStress := {: value <- 5 ; group <- "Compression" :};
       OBJ beta "Effective solids stress parameter" : Concentration := {: value <- 4 ; group <- "Compression" :};
	   OBJ rhos "Solid density": Density := {: value <- 1050 ; group <- "Compression" :};
	   OBJ rhof "Fluid density": Density := {: value <- 998 ; group <- "Compression" :};
	   OBJ C_crit "Gel point" : Concentration := {: value <- 600 ; group <- "Compression" :};
	   OBJ gr "Acceleration of gravity": Acceleration := {: value <- 9.81 ; group <- "Compression" :};
	   OBJ wl (* hidden = "1" *) "Vector of Legendre weights used in the Gaussian quadrature for the calculation of compression": 
	   	   Real[NrOfNodes;] := [{: value <- 2.715245941175406e-2 :},{: value <- 6.225352393864778e-2 :},{: value <- 9.515851168249290e-2 :},
		   {: value <- 1.246289712555339e-1 :},{: value <- 1.495959888165768e-1 :},{: value <- 1.691565193950026e-1 :},{: value <- 1.826034150449236e-1 :},
		   {: value <- 1.894506104550684e-1 :},{: value <- 1.894506104550684e-1 :},{: value <- 1.826034150449236e-1 :},
		   {: value <- 1.691565193950026e-1 :},{: value <- 1.495959888165768e-1 :},{: value <- 1.246289712555339e-1 :},
		   {: value <- 9.515851168249290e-2 :},{: value <- 6.225352393864778e-2 :},{: value <- 2.715245941175406e-2 :}]; 
	   OBJ nl (* hidden = "1" *) "Vector of Legendre nodes used in the Gaussian quadrature for the calculation of compression": 
	   	   Real[NrOfNodes;] := [{: value <- 9.894009349916499e-1 :},{: value <- 9.445750230732326e-1 :},{: value <- 8.656312023878319e-1 :},
		   {: value <- 7.554044083550031e-1 :},{: value <- 6.178762444026438e-1 :},{: value <- 4.580167776572273e-1 :},{: value <- 2.816035507792589e-1 :},
		   {: value <- 9.501250983763748e-2 :},{: value <- -9.501250983763748e-2 :},{: value <- -2.816035507792589e-1 :},
		   {: value <- -4.580167776572273e-1 :},{: value <- -6.178762444026438e-1 :},{: value <- -7.554044083550031e-1 :},
		   {: value <- -8.656312023878319e-1 :},{: value <- -9.445750230732326e-1 :},{: value <- -9.894009349916499e-1 :}];
	    
	   OBJ C_min "Minimal packing concentration" : Concentration := {: value <- 0 ; group <- "Settling" :};
	   OBJ C_max "Maximal packing concentration" : Concentration := {: value <- 2000 ; group <- "Settling" :};
	   OBJ TOL "Tolerance level to calculate CHat" : Fraction := {: value <- 1e-15 ; group <- "Settling" :};     
   };

   state <-
   {
    
    
	OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
	OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};	
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};	 
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : BurgerConcentrationVector := {: group <- "Concentration" :};
	OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;	
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v_S (* hidden = "0" *) "Static settling velocity" : BurgerVelocityVector;
    OBJ J_Up "Upward sludge flux" : BurgerArealFluxVector;
    OBJ J_Dn "Downward sludge flux" : BurgerArealFluxVector;
    OBJ J_G "Static sludge flux" : BurgerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": BurgerArealFluxVector;
	OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;	
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
	OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;

	
	 
	   
       
 
 

    
	 
	   
	    OBJ X_comp (* hidden = "1" *) "Vector with max(Cj,Ccrit)" : BurgerConcentrationVector := {: group <- "Concentration" :};
	    OBJ J_comp_help (* hidden = "1" *) "Compression sludge flux" : BurgerArealFluxVector;
		OBJ J_comp (* hidden = "1" *) "Compression sludge flux" : BurgerArealFluxVector;
		OBJ HelpPar1 (* hidden = "1" *) "rhos*v0*alpha/(g*(rhos-rhof))" : Real;
		OBJ HelpPar2 (* hidden = "1" *) "-Ccrit+beta" : Concentration; 
 
 
		OBJ HelpVar1 (* hidden = "1" *) "Help variable for Gaussian quadrature: (b-a)/2" : Real[NrOfLayersPlusFourBurger;];
		OBJ HelpVar2 (* hidden = "1" *) "Help variable for Gaussian quadrature: (b+a)/2" : BurgerConcentrationVector;
	   
  	    OBJ Fbk_max "Maximum flux" : ArealFlux;
	    OBJ C_fbk_max "Concentration corresponding to maximal settling flux" : Concentration ;
 };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayersBurger); 
    state.H_Layer = parameters.H / NrOfLayersBurger;

	 
	state.C_fbk_max=CHat_DExp(parameters.v0,parameters.r_H,parameters.r_P,parameters.C_min,parameters.C_max,parameters.TOL);
	state.Fbk_max= parameters.v0*(exp(-parameters.r_H* state.C_fbk_max) - exp(- parameters.r_P*state.C_fbk_max));
    
	
	 
	state.HelpPar1 = parameters.NoComp * parameters.rhos * parameters.v0 * parameters.alpha / (parameters.gr * (parameters.rhos - parameters.rhof));
	state.HelpPar2 = -parameters.C_crit + parameters.beta;
    
	};
  
  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
				 THEN state.Q_In
				 ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 
	
	{ FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 


    { state.SolidFlux_In =
       SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
       state.InFluxPerComponent[Comp_Index] * parameters.F_TSS_COD ;
    };






    {state.X_In = IF (state.Q_In == 0)
			THEN 0
			ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {3 .. NrOfLayersPlusTwoBurger}:
                                         state.X_Layer[Layer_Index]) / NrOfLayersBurger;
    };

	 
		 
		 

    	 

		 

    	state.v_Up = state.Q_Out / parameters.A; 

    	 
    	 
    	 
    	 
    	 
    	 
    	 

   		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
         state.v_S[Layer_Index] = 
parameters.v0*(exp(-parameters.r_H* state.X_Layer[Layer_Index]) -exp(- parameters.r_P * state.X_Layer[Layer_Index]));

 
           
          	  
          	  
    	}; 
	
    
	 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
       	   state.J_G_Help[Layer_Index] =
           state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    	};

		 
       		 
        	 
        	 
        	 
        	 
        	 
        	 
    		 
	
			 
			 
			 
			 
			 
			 
			
		 
			{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
    		  state.J_G[Layer_Index] = 
			   IF (state.X_Layer[Layer_Index]<state.X_Layer[Layer_Index+1])
			   THEN MSLUGetMin2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1])
			   ELSE
			     IF (((state.C_fbk_max-state.X_Layer[Layer_Index])*(state.C_fbk_max-state.X_Layer[Layer_Index+1]))<0)
				 THEN state.Fbk_max
				 ELSE MSLUGetMax2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1]);
    		};
	

	{ FOREACH Layer_Index IN {2 .. IndexOfFeedLayerBurger}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayerBurger .. NrOfLayersPlusFourBurger}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

	
	 
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
        state.X_comp[Layer_Index] = MSLUGetMax2(parameters.C_crit,state.X_Layer[Layer_Index]);
      };
	  
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.HelpVar1[Layer_Index] = (state.X_comp[Layer_Index+1]-state.X_comp[Layer_Index])/2;
	  };
	  
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.HelpVar2[Layer_Index] = (state.X_comp[Layer_Index+1]+state.X_comp[Layer_Index])/2;
	  };
	
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
        state.J_comp_help[Layer_Index] = 
 
	    IF (state.X_comp[Layer_Index]>=state.X_comp[Layer_Index+1])
	    THEN 0
	    ELSE SUMOVER Legendre_Index IN {1 .. NrOfNodes}:
	  	  	   (state.HelpPar1*(exp(-parameters.r_H*(state.HelpVar1[Layer_Index] * parameters.nl[Legendre_Index] 
			   + state.HelpVar2[Layer_Index]))-exp(-parameters.r_P*(state.HelpVar1[Layer_Index] 
			   * parameters.nl[Legendre_Index]+ state.HelpVar2[Layer_Index])))/((state.HelpVar1[Layer_Index] 
			   * parameters.nl[Legendre_Index]+ state.HelpVar2[Layer_Index]) + state.HelpPar2)) * parameters.wl[Legendre_Index]; 
      };
	  
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.J_comp[Layer_Index] = state.J_comp_help[Layer_Index] * state.HelpVar1[Layer_Index];
	  };

	
	 
	
		 
		{ DERIV(state.X_Layer[1],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Up[2])
	   	  - (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    	};

		{ DERIV(state.X_Layer[2],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Up[3] - state.J_Up[2] 
		  - state.J_G[2]
	   	   
	   	  );
    	};
	
		 
		{ FOREACH Layer_Index IN {3 .. NrOfLayersPlusOneBurger}:
       	  DERIV(state.X_Layer[Layer_Index],[independent.t]) =
          IF (Layer_Index == IndexOfFeedLayerBurger)
          THEN (1 / state.H_Layer) *
          	  (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]
			   
			 ) + (1 / state.V_Layer) * state.SolidFlux_In 
          ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]
			  
			  );
    	};

    	 
		{ DERIV(state.X_Layer[NrOfLayersPlusTwoBurger],[independent.t]) =
       	  (1 / state.H_Layer) *
       	  (state.J_Dn[NrOfLayersPlusOneBurger] - state.J_Dn[NrOfLayersPlusTwoBurger] 
	   	  + state.J_G[NrOfLayersPlusOneBurger] - state.J_G[NrOfLayersPlusTwoBurger] 
	   	   
	   	  ) ;
    	};

		 
		{ DERIV(state.X_Layer[NrOfLayersPlusThreeBurger],[independent.t]) =
       	  (1 / state.H_Layer) *
       	  (state.J_Dn[NrOfLayersPlusTwoBurger] - state.J_Dn[NrOfLayersPlusThreeBurger] 
	   	  + state.J_G[NrOfLayersPlusTwoBurger] 
	   	   
	   	  ) ;
    	};
	
		{ DERIV(state.X_Layer[NrOfLayersPlusFourBurger],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusThreeBurger]
	   	  -state.J_Dn[NrOfLayersPlusFourBurger]);
    	};

	
    state.X_Out = IF (state.Q_Out == 0)
			THEN 0
			ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
			  THEN 0
			  ELSE state.X_Layer[NrOfLayersPlusFourBurger];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayersPlusFourBurger,parameters.X_Lim);

    state.H_S = (NrOfLayersPlusFourBurger - state.IndexOfSludgeBlanket - 2) *
                state.H_Layer;


 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
		IF (state.Q_In == 0)
	      THEN 0
		ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
		IF (state.SolidFlux_In == 0)
		THEN 0
		ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
		IF (state.Q_In == 0)
		THEN 0
		ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};





# 33 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.secondary_clarifier.msl" 2




# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sand_filter.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sandfilter/wwtp.base.sand_filter.simpledownflow.msl" 1
 



















 CLASS SimpleDownFlow
  (* icon = "sand_filter" ; is_default = "true" *)
  "Semicontinuous Downflow granular medium filter"
 SPECIALISES PhysicalDAEModelType :=
 {:
  comments <- "A model for sand filtration";

  interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Inflow_Backwash (* terminal = "in_3" *) "Inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent backwash" :};
    OBJ Outflow_Filtered (* terminal = "out_1" *) "Outflow filtered" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent Filtered" :};
    OBJ Outflow_Unfiltered (* terminal = "out_3" *) "Outflow unfiltered" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent Unfiltered" :};
    OBJ Backwash  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Backwashing state" : Integer := 
         {:
       causality <- "CIN" ; 
       group <- "Operational" ;
           interval <- {: lowerBound <- 0; upperBound <- 1; :};  
         :};
   };

  parameters <-
   {
    OBJ WWTPSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SpecificVolumeVector;

    OBJ A (* is_favorite = "1" *) "Surface" : Area:= {: value <- 10 ; group <- "Dimension" :};
    OBJ k "Sludge resistance coefficient" : Real := {: value <- 0.001 ; group <- "Hydraulic" :};
    OBJ f_nf "Non-filterable fraction" : Fraction := {: value <- 0.005 ; group <- "Filtration" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ alfa "Outflow parameter" : PhysicalQuantityType := {: value <- 2500 ; group <- "Hydraulic" :};
    OBJ beta "Outflow parameter" : PhysicalQuantityType := {: value <- 1 ; group <- "Hydraulic" :};
    OBJ f0 "Clean filter bed resistance factor": Fraction := {: value <- 0.025 ; group <- "Hydraulic" :};
    OBJ H_Max (* is_favorite = "1" *) "Maximum height of the water in the sand filter" : Length := {: value <- 1 ; group <- "Dimension" :};
    OBJ Backwash_Intensity "Backwash Intensity" : Real := 
         {:
           unit <- "m-3";
           value <- 0.02 ;
       group <- "Filtration";
           interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};  
         :};
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Backwash  (* is_favorite = "1" *) "Backwash flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Filtered (* is_favorite = "1" *) "Filtered effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Unfiltered (* is_favorite = "1" *) "Unfiltered effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Unfiltered_Help (* hidden = "1" *) "Unfiltered effluent flow rate" : Real := {: group <- "Operational" :};
    OBJ H (* is_favorite = "1" *) "Height of the water on the sand filter" : Length := {: group <- "Operational" :};
    OBJ V "Volume" : Volume := {: group <- "Dimension" :};
    OBJ s_X "Mass of Sludge on the sand filter" : SurfaceDensity := {: group <- "Operational" :};
    OBJ M_X "Mass of sludge on the sand filter" : MassVector := {: group <- "Operational" :};
    OBJ f_Out_Filtered (* hidden = "1" *) "Fraction of the influent flux going to the filtered outflow" : Fraction ;
    OBJ f_Out_Unfiltered (* hidden = "1" *) "Fraction of the influent flux going to the unfiltered outflow" : Fraction ;

    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Backwash (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out_Filtered (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out_Unfiltered (* hidden = "1" *) "" : MassFlux;

    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Backwash (* is_favorite = "1" *) "Backwash suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out_Filtered (* is_favorite = "1" *) "Filtered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out_Unfiltered (* is_favorite = "1" *) "Unfiltered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ b_Backwash "Backwash rate" : Frequency := {: group <- "Operational" :};
   };

  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   };

  equations <-
   {
 

    state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow[IndexOfSolvent];
    state.Q_Backwash = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow_Backwash[IndexOfSolvent];

 
 

    state.Q_Out_Filtered = IF (interface.Backwash <= 0)
                           THEN
      state.Q_Backwash +
                  parameters.alfa * pow(state.H, parameters.beta) * (1 - (parameters.f0 * exp(parameters.k * state.s_X)))
                           ELSE 0;

 
 
 
 

    state.Q_Out_Unfiltered_Help = state.Q_In
                           - parameters.alfa * pow(state.H, parameters.beta)
                             * (1 - (parameters.f0 * exp(parameters.k * state.s_X)));

    state.Q_Out_Unfiltered = IF (state.H > parameters.H_Max)
                   THEN 
                 IF (interface.Backwash <= 0)
                 THEN
                     IF (state.Q_Out_Unfiltered_Help < 0)
                   THEN 0
                   ELSE state.Q_Out_Unfiltered_Help
                 ELSE state.Q_In + state.Q_Backwash
                   ELSE 0;

 

    DERIV(state.H,[independent.t]) = 1/parameters.A * (state.Q_In + state.Q_Backwash - state.Q_Out_Filtered - state.Q_Out_Unfiltered);

    state.V = state.H * parameters.A;

 

    state.f_Out_Filtered = IF (interface.Backwash <= 0)
                 THEN
                 IF ((state.Q_Out_Filtered + state.Q_Out_Unfiltered) == 0)
                     THEN 0
                             ELSE state.Q_Out_Filtered / (state.Q_Out_Filtered + state.Q_Out_Unfiltered)
                 ELSE 0;

    state.f_Out_Unfiltered = 1 - state.f_Out_Filtered;

 
 
    DERIV(state.s_X,[independent.t]) =
  ((state.X_In * state.Q_In + state.X_Backwash * state.Q_Backwash - state.Q_Out_Filtered * state.X_Out_Filtered - state.Q_Out_Unfiltered * state.X_Out_Unfiltered)
    / parameters.A);

 
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       DERIV(state.M_X[Comp_Index],[independent.t]) =
      ( interface.Inflow[Comp_Index] + interface.Inflow_Backwash[Comp_Index]
    + interface.Outflow_Filtered[Comp_Index] + interface.Outflow_Unfiltered[Comp_Index]);
     };

 



    state.Help_X_In = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow[Comp_Index]));

    {state.X_In = IF (state.Q_In == 0)
          THEN 0
          ELSE state.Help_X_In / state.Q_In * parameters.F_TSS_COD;
     };

    state.Help_X_Backwash = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
                     (interface.Inflow_Backwash[Comp_Index]));

    {state.X_Backwash = IF (state.Q_Backwash == 0)
              THEN 0
            ELSE state.Help_X_Backwash / state.Q_Backwash * parameters.F_TSS_COD;
     };

    state.Help_X_Out_Filtered = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: - interface.Outflow_Filtered[Comp_Index]);

    {state.X_Out_Filtered = IF (state.Q_Out_Filtered == 0)
                  THEN 0
                ELSE state.Help_X_Out_Filtered / state.Q_Out_Filtered * parameters.F_TSS_COD;
     };

     state.Help_X_Out_Unfiltered = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:(- interface.Outflow_Unfiltered[Comp_Index]));

    {state.X_Out_Unfiltered  = IF (state.Q_Out_Unfiltered == 0)
                 THEN 0
                 ELSE state.Help_X_Out_Unfiltered  / state.Q_Out_Unfiltered  * parameters.F_TSS_COD;
     };



# 224 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sandfilter/wwtp.base.sand_filter.simpledownflow.msl"


 
 

    state.b_Backwash =  IF (state.H > parameters.H_Max)
            THEN interface.Backwash * state.Q_Backwash * parameters.Backwash_Intensity
            ELSE 0;

 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Filtered
                   - (1 - interface.Backwash) * interface.Inflow_Backwash[Comp_Index];
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * parameters.f_nf * state.f_Out_Filtered
                   - (1 - interface.Backwash) * interface.Inflow_Backwash[Comp_Index] ;
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Unfiltered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Unfiltered 
                 - interface.Backwash * interface.Inflow_Backwash[Comp_Index];
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Unfiltered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Unfiltered 
                 - interface.Backwash * interface.Inflow_Backwash[Comp_Index] 
                 - state.M_X[Comp_Index] * state.b_Backwash;
     };

   };
 :};




# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sand_filter.msl" 2




# 42 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.anaerobic_digestion.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.lessarddesjardins.msl" 1
 




















 CLASS Lessard_Desjardins
 (* icon = "anaerobic_digester" *)
 "anaerobic digester"

  
  
  

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  

  
  
  
  

  
  
  

 EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
   comments <- "A model for anaerobic digestion processes by Lessard and Desjardins";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Gas_LD (* terminal = "out_3"; is_favorite = "1" *) "gasflow" : 
         FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ C_X_B_Anaerobic (* terminal = "out_3" *) "Concentration of the anaerobic biomass" : 
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

  parameters <- 
   { 
    OBJ S_PO4_In "Influent phosphate concentration" : Concentration := {: value <- 10 ; group <- "Influent characterization" :};
    OBJ mu_H "Maximum specific growth rate for heterotrophic biomass" : MaxGrowthRate := {: value <- 0.3 ; group <- "Kinetic" :};
    OBJ b_H "Decay Coefficient For Heterotrophic Biomass" : DecayCoeffHeterotr := {:value <- 0.40 ; group <- "Kinetic" :};
    OBJ k_h "Maximum Specific Hydrolysis Rate" : MaxSpecificHydrolysisRate :=  {:value <- 2.00 ; group <- "Kinetic" :};
    OBJ K_VFA "Substrate half saturation coeff for heterotrophic biomass" : HalfSatCoeff := {: value <- 140 ; group <- "Kinetic" :};
    OBJ Y_XB_VFA "Yield for biomass production associated with VFA consumption" : Yield := {: value <- 0.06 ; group <- "Stoichiometry" :};
    OBJ Y_NH_VSS "Yield for S_NH production associated with VSS hydrolysis" : Yield := {: value <- 0.038 ; group <- "Stoichiometry" :};
    OBJ Y_PO_VSS "Yield for S_PO4 production associated with VSS hydrolysis" : Yield := {: value <- 0.00066 ; group <- "Stoichiometry" :};
    OBJ Y_CH_XB "Yield for methane production associated with biomass growth" : Yield := {: value <- 0.6 ; group <- "Stoichiometry" :};
    OBJ F_VFA_SS "VFA Fraction of SS" : Fraction := {: value <- 0.5 ; group <- "Conversion factors" :};
    OBJ i_X_B     "Mass Of Nitrogen Per Mass Of COD In Biomass"
      : MassOfNitrogenPerMassOfCODInBiomass := {:value <- 0.086 ; group <- "Composition parameters" :};
    OBJ i_X_P     "Mass Of Nitrogen Per Mass Of COD In Products Formed"
      : MassOfNitrogenPerMassOfCODInProdFromBiomass := {:value <- 0.06 ; group <- "Composition parameters" :};
    OBJ f_P      "Fraction Of Biomass Converted To Inert Matter"
      : FractOfBiomassLeadingToPartProd := {:value<- 0.08 ; group <- "Conversion factors":};
    OBJ rho_CH4 "Density of CH4" : Density := {: value <- 717 ; group <- "Conversion factors":};
    OBJ V (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000 ; group <- "Dimension":};
 
   };

  state <-
   {
    OBJ Help1 (* hidden = "1" *) "Rate of reaction for hydrolysis" : Real;
    OBJ Help2 (* hidden = "1" *) "Rate of reaction for growth" : Real;
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ VSSnb_In "Non-biodegradable susp. solids conc. of the influent" : Concentration := {: group <- "Influent characterization" :};
    OBJ VSSnb "Non-biodegradable susp. solids conc." : Concentration := {: group <- "Concentration" :};
    OBJ VSSb_In "Biodegradable susp. solids conc. of the influent" : Concentration := {: group <- "Influent characterization" :};
    OBJ VSSb "Biodegradable susp. solids conc." : Concentration := {: group <- "Concentration" :};
    OBJ VFA_In "Volatile fatty acids conc. in the influent" : Concentration := {: group <- "Influent characterization" :};
    OBJ VFA "Volatile fatty acids conc." : Concentration := {: group <- "Concentration" :};
    OBJ X_B "Methane and acetogene bacteria conc." : Concentration := {: group <- "Concentration" :};
    OBJ S_PO4 "Phosphate" : Concentration := {: group <- "Concentration" :};
    OBJ S_NH "Ammonia" : Concentration := {: group <- "Concentration" :};
    OBJ X_ND "Soluble biodegradable organic nitrogen" : Concentration := {: group <- "Concentration" :};
    OBJ CH4 "Methane" : MolConcentration := {: group <- "Concentration" :};
    OBJ Q_Under_Real (* is_favorite = "1" *) "Real underflow rate" : FlowRate := {: group <- "Operational" :};
   };

  initial <-
   {
   };

  equations <-
   {
   state.Q_Under_Real = IF (interface.Q_Under > state.Q_In)
        THEN state.Q_In
        ELSE interface.Q_Under;

   state.Q_Out = state.Q_In - state.Q_Under_Real ;

   state.VSSnb_In = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[X_I] / state.Q_In ;
   state.VSSb_In = IF (state.Q_In == 0)
       THEN 0
       ELSE ( interface.Inflow[X_S] + interface.Inflow[X_BH] + interface.Inflow[X_BA] ) / state.Q_In ;
   state.VFA_In = IF (state.Q_In == 0)
      THEN 0
      ELSE parameters.F_VFA_SS * interface.Inflow[S_S] / state.Q_In ;

   state.Help1 = parameters.k_h * state.VSSb ;
   state.Help2 = parameters.mu_H * (state.VFA / (parameters.K_VFA + state.VFA)) *  state.X_B ;

    
   {DERIV(state.VSSb,[independent.t]) =
          - state.Help1 
      + parameters.b_H * state.X_B * (1-parameters.f_P) 
      + state.Q_In / parameters.V * (state.VSSb_In - state.VSSb) ;
   };

    

   {DERIV(state.VSSnb,[independent.t]) =
          parameters.b_H * state.X_B * parameters.f_P
      + state.Q_In / parameters.V * (state.VSSnb_In - state.VSSnb) ;
   };
   {DERIV(state.VFA,[independent.t]) =
          state.Help1 - 1 / parameters.Y_XB_VFA * state.Help2 
          + state.Q_In / parameters.V * (state.VFA_In - state.VFA) ;
   };
   {DERIV(state.S_NH,[independent.t]) =
          parameters.Y_NH_VSS * state.Help1 
          + 1 / parameters.V * (interface.Inflow[S_NH] - state.Q_In * state.S_NH) ;
   };

    

   {DERIV(state.X_ND,[independent.t]) =
          parameters.b_H * state.X_B * (parameters.i_X_B - parameters.f_P * parameters.i_X_P)
      + 1 / parameters.V * (interface.Inflow[X_ND] - state.Q_In * state.X_ND) ;
   };

   {DERIV(state.S_PO4,[independent.t]) =
          parameters.Y_PO_VSS * state.Help1 
          + state.Q_In / parameters.V * (parameters.S_PO4_In - state.S_PO4) ;
   };

   {DERIV(state.X_B,[independent.t]) =
          state.Help2 - parameters.b_H * state.X_B - state.Q_In / parameters.V *  state.X_B;
   };
   {DERIV(state.CH4,[independent.t]) =
          parameters.Y_CH_XB * state.Help2 ;
   };

    
    

   interface.Q_Gas_LD = 16 * parameters.Y_CH_XB * state.Help2 * parameters.V / parameters.rho_CH4 ;
   interface.C_X_B_Anaerobic = state.X_B;

   interface.Outflow[X_BH] = 0 ;
   interface.Outflow[X_BA] = 0 ;
   interface.Outflow[S_O] = 0 ;   
 
 
   interface.Outflow[S_S] = IF (state.Q_In == 0)
              THEN 0 
              ELSE - ( interface.Inflow[S_S] / state.Q_In - state.VFA_In + state.VFA ) * state.Q_Out ;   
   interface.Outflow[X_S] = -( state.VSSb * state.Q_Out + state.X_B * state.Q_Out);   
   interface.Outflow[X_I] = - state.VSSnb * state.Q_Out;
   interface.Outflow[S_NH] = - state.S_NH * state.Q_Out; 
   interface.Outflow[X_ND] = - state.X_ND * state.Q_Out;
   interface.Outflow[S_ND] = IF (state.Q_In == 0)
               THEN 0
               ELSE - interface.Inflow[S_ND] * state.Q_Out / state.Q_In; 
   interface.Outflow[S_I] = IF (state.Q_In == 0)
              THEN 0
              ELSE - interface.Inflow[S_I] * state.Q_Out / state.Q_In;
   interface.Outflow[S_ALK] = IF (state.Q_In == 0)
            THEN 0
            ELSE - interface.Inflow[S_ALK] * state.Q_Out / state.Q_In;
   interface.Outflow[S_NO] = IF (state.Q_In == 0)
               THEN 0
               ELSE - interface.Inflow[S_NO] * state.Q_Out / state.Q_In;
   interface.Outflow[X_P] = IF (state.Q_In == 0)
              THEN 0
              ELSE - interface.Inflow[X_P] * state.Q_Out / state.Q_In;

   interface.Underflow[X_BH] = 0 ;
   interface.Underflow[X_BA] = 0 ;
   interface.Underflow[S_O] = 0 ;   
   interface.Underflow[S_S] = IF (state.Q_In == 0)
            THEN 0
            ELSE - ( interface.Inflow[S_S] / state.Q_In - state.VFA_In + state.VFA ) * state.Q_Under_Real ;   
   interface.Underflow[X_S] = -( state.VSSb * state.Q_Under_Real + state.X_B * state.Q_Under_Real);   
   interface.Underflow[X_I] = - state.VSSnb * state.Q_Under_Real ;
   interface.Underflow[S_NH] = - state.S_NH * state.Q_Under_Real ; 
   interface.Underflow[X_ND] = - state.X_ND * state.Q_Under_Real;
   interface.Underflow[S_ND] = IF (state.Q_In == 0)
            THEN 0
            ELSE - interface.Inflow[S_ND] * state.Q_Under_Real / state.Q_In; 
   interface.Underflow[S_I] = IF (state.Q_In == 0)
            THEN 0
            ELSE - interface.Inflow[S_I] * state.Q_Under_Real / state.Q_In;
   interface.Underflow[S_ALK] = IF (state.Q_In == 0)
              THEN 0
              ELSE - interface.Inflow[S_ALK] * state.Q_Under_Real / state.Q_In;
   interface.Underflow[S_NO] = IF (state.Q_In == 0)
             THEN 0
             ELSE - interface.Inflow[S_NO] * state.Q_Under_Real / state.Q_In;
   interface.Underflow[X_P] = IF (state.Q_In == 0)
                THEN 0
                ELSE - interface.Inflow[X_P] * state.Q_Under_Real / state.Q_In;

  };

 :};
 



# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.anaerobic_digestion.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.siegrist.msl" 1
 



















 CLASS Siegrist
 (* icon = "anaerobic_digester" *)
 "anaerobic digester according to Siegrist et al."

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
  {:
   comments <- "A model for anaerobic digestion processes by Siegrist et al.";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Q_Gas (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Gasflow for stripping" : 
    GasFlowRate := {: causality <- "CIN" ; value <- 30 ; group <- "Operational" :}; 
    OBJ T (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Celsius Temperature" : 
    CelsiusTemperature := {: causality <- "CIN" ; value <- 35.0 ; group <- "Operational":};
   };

  parameters <- 
   { 

 

    OBJ AnaerobicSpecificVolume (* hidden = "1" *)
         "Vector containing the specific volume (= 1/density) for all the components of the Siegrist model"
         : AnaerobicSpecificVolumeVector;

    OBJ TempCoef1 (* hidden = "1" *) "Temperature coefficient" : TemperatureCoefficient;

    OBJ TempCoef2 (* hidden = "1" *) "Temperature coefficient" : TemperatureCoefficient;

    OBJ UniversalGasConstant "Universal gas constant" : PhysicalQuantityType := 
         {:
           quantity  <- "RO";
           unit      <- "J/(mol*K)";
           value     <- 8.314510;
       group   <- "Miscellaneous"
         :};

    OBJ p (* is_favorite = "1" *) "Head pressure in the digester" : Pressure := {:value <- 101325.00 ; group <- "Operational":};

    OBJ pH_In "pH of incoming wastewater" : pH := {: value <- 7.0 ; group <- "Influent characterization" :};

    OBJ S_H_In (* hidden = "1" *) "Proton concentration in incoming wastewater" : MolConcentration := {: group <- "Influent characterization" :};

    OBJ CO2EquilibriumConstant (* hidden = "1" *) "Equilibrium constant for CO2, i.e. [H+][HCO3-]/[CO2]" : PhysicalQuantityType :=
         {:
           unit <- "Mol.m-3";
           interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};  
         :};

    OBJ H_H2 "Henry coefficient for H2" : HenryCoefficient := {: value <- 1.334 ; group <- "Stoichiometry" :};

    OBJ H_CH4 "Henry coefficient for CH4" : HenryCoefficient := {: value <- 0.876 ; group <- "Stoichiometry" :};

    OBJ H_CO2 "Henry coefficient for CO2" : HenryCoefficient := {: value <- 0.04 ; group <- "Stoichiometry" :};

    OBJ MolVolumeAtTempT (* hidden = "1" *) "Volume of 1 Mol gas at Celsius temperature T" : Volume;

    OBJ Initial_Q_Gas_Tot "Initial (previous) value of Q_Gas_Tot" : GasFlowRate := {: value <- 655 ; group <- "Miscellaneous":};

    OBJ f_X_Out "Fraction of the anaerobic particulate matter that leaves the reactor" : Fraction := {: value <- 0.10 ; group <- "Settling":};

 

    OBJ i_X_B "Mass of nitrogen per mass of COD in biomass (ASM1)" : MassOfNitrogenPerMassOfCODInBiomass :=
         {: value <- 0.086 ; group <- "Conversion factors" :};

    OBJ i_X_P "Mass of nitrogen per mass of COD in products formed (ASM1)" : MassOfNitrogenPerMassOfCODInProdFromBiomass :=
         {: value <- 0.04 ; group <- "Conversion factors" :};

    OBJ i_S_AS "Mass of nitrogen per mass of COD in Amino Acids (S_AS)" : MassOfNitrogenPerMassOfCOD :=
         {: value <- 0.040 ; group <- "Conversion factors" :};

    OBJ i_X_S_An "Mass of nitrogen per mass of COD in slowly biodegradable matter (X_S_An)" : MassOfNitrogenPerMassOfCOD :=
         {: value <- 0.020 ; group <- "Conversion factors" :};

    OBJ i_X_An "Mass of nitrogen per mass of COD in anaerobic biomass" : MassOfNitrogenPerMassOfCOD :=
         {: value <- 0.080 ; group <- "Conversion factors" :};

    OBJ i_X_IN "Mass of nitrogen per mass of COD in inert particulates" : MassOfNitrogenPerMassOfCOD :=
         {: value <- 0.040 ; group <- "Conversion factors" :};

    OBJ f_AC_S "Fraction of S_S that is acetate (S_AC)" : Fraction := {: value <- 0.30 ; group <- "Conversion factors" :};

    OBJ f_PRO_S "Fraction of S_S that is propionate (S_PRO)" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};

    OBJ f_AS_S "Fraction of S_S that are Amino Acids and sugar (S_AS)" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};

    OBJ f_XSAn_I "Fraction of X_I (ASM1) that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};

    OBJ f_XSAn_H "Fraction of X_BH (ASM1) that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.08 ; group <- "Conversion factors" :};

    OBJ f_XSAn_A "Fraction of X_BA (ASM1) that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.92 ; group <- "Conversion factors" :};

    OBJ f_XSAn_P "Fraction of X_P (ASM1) that becomes biodegradable in anaerobic conditions" : Fraction := {: value <- 0.10 ; group <- "Conversion factors" :};

    OBJ f_AS_H "Fraction of X_BH (heterotrophs in ASM1) that are capable of fermenting" : Fraction := {: value <- 0.50 ; group <- "Conversion factors" :};

 

    OBJ f_P_An "Fraction of anaerobic biomass that leads to inert matter" : Fraction := {: value <- 0.08 ; group <- "Conversion factors" :};

    OBJ f_H_AS "Fraction of fermenting biomass that are heterotrophs" : Fraction := {: value <- 0.50 ; group <- "Conversion factors" :};

 

    OBJ k_R "Specific hydrolysis rate of biopolymers" : MaxSpecificHydrolysisRate :=
         {: value <- 0.25 ; group <- "Kinetic" :};

    OBJ mu_AS "Maximum specific growth rate of AA and sugar fermenting bacteria" : MaxGrowthRate :=
         {: value <- 5.0 ; group <- "Kinetic" :};

    OBJ K_S_AS "Anaerobic fermentation half-saturation concentration for S_AS" : HalfSatCoeff :=
         {: value <- 50 ; group <- "Kinetic" :};

    OBJ mu_FA "Maximum specific growth rate of FA oxidising anaerobic bacteria" : MaxGrowthRate :=
         {: value <- 0.55 ; group <- "Kinetic" :};

    OBJ K_S_FA "Anaerobic FA oxidation half-saturation concentration for S_FA" : HalfSatCoeff :=
         {: value <- 200 ; group <- "Kinetic" :};

    OBJ K_I_AC_FA "Anaerobic FA oxidation inhibition concentration for S_AC" : InhibitionCoeff :=
         {: value <- 2000 ; group <- "Kinetic" :};

    OBJ K_I_H2_FA "Anaerobic FA oxidation inhibition concentration for S_H2" : InhibitionCoeff :=
         {: value <- 12e-3 ; group <- "Kinetic" :};

    OBJ mu_PRO "Maximum specific growth rate of propionate oxidising bacteria" : MaxGrowthRate :=
         {: value <- 0.8 ; group <- "Kinetic" :};

    OBJ K_S_PRO "Anaerobic propionate oxidation half-saturation concentration for S_PRO" : HalfSatCoeff :=
         {: value <- 15 ; group <- "Kinetic" :};

    OBJ K_I_AC_PRO "Anaerobic propionate inhibition concentration for S_AC" : InhibitionCoeff :=
         {: value <- 1500 ; group <- "Kinetic" :};

    OBJ K_I_H2_PRO "Anaerobic propionate oxidation inhibition concentration for S_H2" :  InhibitionCoeff :=
         {: value <- 0.6e-3 ; group <- "Kinetic" :};

    OBJ K_S_H_PRO "Anaerobic propionate oxidation half-saturation concentration for S_H" : MolarHalfSatCoeff :=
         {: value <- 1e-5 ; group <- "Kinetic" :};

    OBJ K_I_H_PRO "Anaerobic propionate oxidation inhibition concentration for S_H" : MolarInhibitionCoeff :=
         {: value <- 6.3e-4 ; group <- "Kinetic" :};

    OBJ mu_AC "Maximum specific growth rate of acetate to methane converting bacteria" : MaxGrowthRate :=
         {: value <- 0.95 ; group <- "Kinetic" :};

    OBJ K_S_AC "Acetate to methane conversion half-saturation concentration for S_AC" : HalfSatCoeff :=
         {: value <- 30 ; group <- "Kinetic" :};

    OBJ K_S_H_AC "Acetate to methane conversion half-saturation concentration for S_H" : MolarHalfSatCoeff :=
         {: value <- 1e-5 ; group <- "Kinetic" :};

    OBJ K_I_H_AC "Acetate to methane conversion inhibition concentration for S_H" : MolarInhibitionCoeff :=
         {: value <- 6.3e-4 ; group <- "Kinetic" :};

    OBJ mu_H2 "Maximum specific growth rate of hydrogen to methane converting bacteria" : MaxGrowthRate :=
         {: value <- 3.6 ; group <- "Kinetic" :};

     

    OBJ K_S_H2 "Hydrogen to methane conversion half-saturation concentration for S_H2" : HalfSatCoeff :=
         {: value <- 0.06 ; group <- "Kinetic" :};

    OBJ K_S_H_H2 "Hydrogen to methane conversion half-saturation concentration for S_H" : MolarHalfSatCoeff :=
         {: value <- 1e-5 ; group <- "Kinetic" :};

    OBJ K_I_H_H2 "Hydrogen to methane conversion inhibition concentration for S_H" : MolarInhibitionCoeff :=
         {: value <- 6.3e-4 ; group <- "Kinetic" :};

     
     

    OBJ b_AS "Specific decay rate for AA and sugar fermenting bacteria" : DecayCoefficient :=
         {: value <- 1.0 ; group <- "Kinetic" :};

    OBJ b_FA "Specific decay rate for FA oxidising anaerobic bacteria" : DecayCoefficient :=
         {: value <- 0.10 ; group <- "Kinetic" :};

    OBJ b_PRO "Specific decay rate for propionate oxidising anaerobic bacteria" : DecayCoefficient :=
         {: value <- 0.10 ; group <- "Kinetic" :};

    OBJ b_AC "Specific decay rate for acetate to methane converting bacteria" : DecayCoefficient :=
         {: value <- 0.10 ; group <- "Kinetic" :};

    OBJ b_H2 "Specific decay rate for hydrogen to methane converting bacteria" : DecayCoefficient :=
         {: value <- 0.4 ; group <- "Kinetic" :};

    OBJ k_HCO3 "Rate of bicarbonate protolysis" : PhysicalQuantityType :=
         {:
            unit <- "d-1.m3.Mol-1";
            value <- 10;
      group <- "Kinetic";
            interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};

         :};

    OBJ k_CO2 "Rate of carbon dioxide deprotolysis" : PhysicalQuantityType :=
         {:
            unit <- "d-1";
            value <- 0.0045;
      group <- "Kinetic";
            interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
         :};

 

    OBJ AnaerobicStoichiometry (* hidden = "1" *)
         "A matrix structure containing stoichiometry of anaerobic processes"
         : PhysicalQuantityType[NrOfAnaerobicReactions;][NrOfAnaerobicComponents;]

   };

  state <-
   {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all ASM components" : MassFluxVector;
    OBJ TemporaryInFluxS_S (* hidden = "1" *) "Temporary calculation of the incoming S_S after oxidizing with S_O and S_NO" : Real;
    OBJ InFluxS_S (* hidden = "1" *) "Influx of S_S after correction for oxidizing with incoming S_O and S_NO" : MassFlux;
    OBJ InFluxX_S (* hidden = "1" *) "Influx of X_S after correction for oxidizing with incoming S_O and S_NO" : MassFlux;
    OBJ StrippingRate "Stripping rate is linearly related to the total gas production" : Rate := {: group <- "Operational" :};
    OBJ AnaerobicKinetics (* hidden = "1" *) "A vector containing kinetics for all anaerobic reactions"
         : PhysicalQuantityType[NrOfAnaerobicReactions;];
    OBJ AnaerobicOutFluxPerComponent (* hidden = "1" *) "Vector containing outgoing fluxes for all Siegrist anaerobic components"
         : AnaerobicMassFluxVector;
    OBJ AnaerobicInFluxPerComponent (* hidden = "1" *)
         "Vector containing incoming fluxes for all the components of the Siegrist model"
         : AnaerobicMassFluxVector;
    OBJ AnaerobicConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all the components"
         : AnaerobicMassFluxVector;
    OBJ f_FA_S (* hidden = "1" *) 
         "Calculated fraction of S_S that are Fatty Acids - if lower than zero please change parameters f_AC_S, f_PRO_S and f_AS_S" 
     : Fraction;
    OBJ f_X_IN_H (* hidden = "1" *)
         "Calculated fraction of X_BH that becomes X_IN in the digester - if lower than zero please change parameters f_XSAn_H and f_AS_H" 
     : Fraction;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :}; 
    OBJ V_L "(Constant) volume of liquid phase in the digester" : Volume := {: group <- "Dimension" :};
    OBJ M_An "Vector containing masses for all components of the Siegrist model" : AnaerobicMassVector := {: group <- "Mass" :};
    OBJ C_An "Vector containing concentrations for all the components of the Siegrist model" : AnaerobicConcentrationVector := {: group <- "Concentration" :};
    OBJ pH_Reactor "pH in the Anaerobic Digester" : pH := {: group <- "Operational" :};
    OBJ MolProduced_H2 "Amount (expressed in Mol.d-1) of hydrogen gas produced in the digester" : MolFlowRate := {: group <- "Operational" :};
    OBJ MolProduced_CH4 "Amount (expressed in Mol.d-1) of methane gas produced in the digester" : MolFlowRate := {: group <- "Operational" :};
    OBJ MolProduced_CO2 "Amount (expressed in Mol.d-1) of carbon dioxide gas produced in the digester" : MolFlowRate := {: group <- "Operational" :};
    OBJ PreviousHelp_Q_Gas_Tot (* hidden = "1" *) "Help variable for the calculation of the previous value of Q_Gas_Tot" : GasFlowRate;
    OBJ Q_H2 (* is_favorite = "1" *) "Flow rate of hydrogen gas produced" : GasFlowRate := {: group <- "Operational" :};
    OBJ Q_CH4 (* is_favorite = "1" *) "Flow rate of methane gas produced" : GasFlowRate := {: group <- "Operational" :};
    OBJ Q_CO2 (* is_favorite = "1" *) "Flow rate of carbon dioxide gas produced" : GasFlowRate := {: group <- "Operational" :};
    OBJ Q_Gas_Prod "Flow rate of all gas produced" : GasFlowRate := {: group <- "Operational" :};
    OBJ Q_Gas_Tot "Total gas flow rate, i.e. stripping gas and gas produced" : GasFlowRate := {: group <- "Operational" :};
    OBJ C_H2 (* is_favorite = "1" *) "H2 concentration in total gas stream" : MolConcentration := {: group <- "Concentration" :};
    OBJ C_CH4 (* is_favorite = "1" *) "CH4 concentration in total gas stream" : MolConcentration := {: group <- "Concentration" :};
    OBJ C_CO2 (* is_favorite = "1" *) "CO2 concentration in total gas stream" : MolConcentration := {: group <- "Concentration" :};

   };

  initial <-
   {
    parameters.AnaerobicSpecificVolume[H2O_An] := 0.000001;

    parameters.TempCoef1 = exp(0.069 * (interface.T - 35));
    parameters.TempCoef2 = exp(0.085 * (interface.T - 35));

    parameters.CO2EquilibriumConstant = parameters.k_CO2 / parameters.k_HCO3;

    parameters.S_H_In = (pow(10, - parameters.pH_In)) * 1e+3;

    parameters.MolVolumeAtTempT = 22.4e-3 * ((interface.T + 273.15) / 273.15);

 
    parameters.AnaerobicStoichiometry[H2Stripping][S_H2] := - parameters.H_H2;
    parameters.AnaerobicStoichiometry[CH4Stripping][S_CH4] := - parameters.H_CH4;
    parameters.AnaerobicStoichiometry[CO2Stripping][S_CO2] := - parameters.H_CO2;

 
    parameters.AnaerobicStoichiometry[BiopolymHydrol][S_AS] := 0.50; 
    parameters.AnaerobicStoichiometry[BiopolymHydrol][S_FA] := 0.45;
    parameters.AnaerobicStoichiometry[BiopolymHydrol][S_IN] := 0.05;
    parameters.AnaerobicStoichiometry[BiopolymHydrol][X_S_An] := -1.00;

 
    parameters.AnaerobicStoichiometry[ASFermentation][S_H2] := 0.96;
    parameters.AnaerobicStoichiometry[ASFermentation][S_CO2] := 0.082;
    parameters.AnaerobicStoichiometry[ASFermentation][S_HCO3] := -0.051;
    parameters.AnaerobicStoichiometry[ASFermentation][S_NH4] := 0.187;
    parameters.AnaerobicStoichiometry[ASFermentation][S_AC] := 3.29;
    parameters.AnaerobicStoichiometry[ASFermentation][S_PRO] := 1.42;
    parameters.AnaerobicStoichiometry[ASFermentation][S_AS] := -6.67;
    parameters.AnaerobicStoichiometry[ASFermentation][X_AS] := 1.00;

 
    parameters.AnaerobicStoichiometry[AnOxOfS_FA][S_H2] := 6.70;
    parameters.AnaerobicStoichiometry[AnOxOfS_FA][S_CO2] := 0.199;
    parameters.AnaerobicStoichiometry[AnOxOfS_FA][S_HCO3] := -0.202;
    parameters.AnaerobicStoichiometry[AnOxOfS_FA][S_NH4] := -0.08;
    parameters.AnaerobicStoichiometry[AnOxOfS_FA][S_AC] := 14.3;
    parameters.AnaerobicStoichiometry[AnOxOfS_FA][S_FA] := -22.0;
    parameters.AnaerobicStoichiometry[AnOxOfS_FA][X_FA] := 1.00;

 
    parameters.AnaerobicStoichiometry[AnOxOfS_PRO][S_H2] := 8.20;
    parameters.AnaerobicStoichiometry[AnOxOfS_PRO][S_CO2] := 0.163;
    parameters.AnaerobicStoichiometry[AnOxOfS_PRO][S_HCO3] := 0.004;
    parameters.AnaerobicStoichiometry[AnOxOfS_PRO][S_NH4] := -0.08;
    parameters.AnaerobicStoichiometry[AnOxOfS_PRO][S_AC] := 10.8;
    parameters.AnaerobicStoichiometry[AnOxOfS_PRO][S_PRO] := -20.0;
    parameters.AnaerobicStoichiometry[AnOxOfS_PRO][X_PRO] := 1.00;

 
    parameters.AnaerobicStoichiometry[AcToCH4Conv][S_CH4] := 39.0;
    parameters.AnaerobicStoichiometry[AcToCH4Conv][S_CO2] := -0.007;
    parameters.AnaerobicStoichiometry[AcToCH4Conv][S_HCO3] := 0.619;
    parameters.AnaerobicStoichiometry[AcToCH4Conv][S_NH4] := -0.08;
    parameters.AnaerobicStoichiometry[AcToCH4Conv][S_AC] := -40.0;
    parameters.AnaerobicStoichiometry[AcToCH4Conv][X_AC] := 1.00;

 
    parameters.AnaerobicStoichiometry[H2ToCH4Conv][S_H2] := -22.0;
    parameters.AnaerobicStoichiometry[H2ToCH4Conv][S_CH4] := 21.0;
    parameters.AnaerobicStoichiometry[H2ToCH4Conv][S_CO2] := -0.291;
    parameters.AnaerobicStoichiometry[H2ToCH4Conv][S_HCO3] := -0.006;
    parameters.AnaerobicStoichiometry[H2ToCH4Conv][S_NH4] := -0.08;
    parameters.AnaerobicStoichiometry[H2ToCH4Conv][X_H2] := 1.00;

 
    parameters.AnaerobicStoichiometry[DecayOfX_AS][S_HCO3] := 0.004; 
    parameters.AnaerobicStoichiometry[DecayOfX_AS][S_NH4] := 0.056; 
    parameters.AnaerobicStoichiometry[DecayOfX_AS][X_S_An] := 0.80; 
    parameters.AnaerobicStoichiometry[DecayOfX_AS][X_AS] := -1.00; 
    parameters.AnaerobicStoichiometry[DecayOfX_AS][X_IN] := 0.20;

 
    parameters.AnaerobicStoichiometry[DecayOfX_FA][S_HCO3] := 0.004;
    parameters.AnaerobicStoichiometry[DecayOfX_FA][S_NH4] := 0.056;
    parameters.AnaerobicStoichiometry[DecayOfX_FA][X_S_An] := 0.80;
    parameters.AnaerobicStoichiometry[DecayOfX_FA][X_FA] := -1.00;
    parameters.AnaerobicStoichiometry[DecayOfX_FA][X_IN] := 0.20;

 
    parameters.AnaerobicStoichiometry[DecayOfX_PRO][S_HCO3] := 0.004;
    parameters.AnaerobicStoichiometry[DecayOfX_PRO][S_NH4] := 0.056;
    parameters.AnaerobicStoichiometry[DecayOfX_PRO][X_S_An] := 0.80;
    parameters.AnaerobicStoichiometry[DecayOfX_PRO][X_PRO] := -1.00;
    parameters.AnaerobicStoichiometry[DecayOfX_PRO][X_IN] := 0.20;

 
    parameters.AnaerobicStoichiometry[DecayOfX_AC][S_HCO3] := 0.004;
    parameters.AnaerobicStoichiometry[DecayOfX_AC][S_NH4] := 0.056;
    parameters.AnaerobicStoichiometry[DecayOfX_AC][X_S_An] := 0.80;
    parameters.AnaerobicStoichiometry[DecayOfX_AC][X_AC] := -1.00;
    parameters.AnaerobicStoichiometry[DecayOfX_AC][X_IN] := 0.20;

 
    parameters.AnaerobicStoichiometry[DecayOfX_H2][S_HCO3] := 0.004; 
    parameters.AnaerobicStoichiometry[DecayOfX_H2][S_NH4] := 0.056;
    parameters.AnaerobicStoichiometry[DecayOfX_H2][X_S_An] := 0.80;
    parameters.AnaerobicStoichiometry[DecayOfX_H2][X_H2] := -1.00; 
    parameters.AnaerobicStoichiometry[DecayOfX_H2][X_IN] := 0.20;

 
    parameters.AnaerobicStoichiometry[ProtolysisOfHCO3][S_CO2] := 1.00;
    parameters.AnaerobicStoichiometry[ProtolysisOfHCO3][S_HCO3] := -1.00; 
    parameters.AnaerobicStoichiometry[ProtolysisOfHCO3][S_H] := -1.00;

 
    parameters.AnaerobicStoichiometry[DeprotolysisOfCO2][S_CO2] := -1.00;
    parameters.AnaerobicStoichiometry[DeprotolysisOfCO2][S_HCO3] := 1.00;
    parameters.AnaerobicStoichiometry[DeprotolysisOfCO2][S_H] := 1.00;

   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

  equations <-
   {

 

     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        (In_Terminal[Comp_Index]);
    };

     

     

    state.AnaerobicInFluxPerComponent[H2O_An] =
     state.InFluxPerComponent[IndexOfSolvent];

     

    state.AnaerobicInFluxPerComponent[S_H2] = 0;

    state.AnaerobicInFluxPerComponent[S_CH4] = 0;

     
     
     

    state.AnaerobicInFluxPerComponent[S_H] =
     parameters.S_H_In * (parameters.AnaerobicSpecificVolume[H2O_An] * state.AnaerobicInFluxPerComponent[H2O_An]);

    state.AnaerobicInFluxPerComponent[S_CO2] =
     (parameters.S_H_In / (parameters.S_H_In + parameters.CO2EquilibriumConstant)) * state.InFluxPerComponent[S_ALK];

    state.AnaerobicInFluxPerComponent[S_HCO3] =
     (parameters.CO2EquilibriumConstant / (parameters.S_H_In + parameters.CO2EquilibriumConstant)) * state.InFluxPerComponent[S_ALK];

     
     
     

    state.AnaerobicInFluxPerComponent[S_NH4] =
     state.InFluxPerComponent[S_NH]
     + state.InFluxPerComponent[S_ND]
     + state.InFluxPerComponent[X_ND]
     + parameters.i_X_B * (state.InFluxPerComponent[X_BH] + state.InFluxPerComponent[X_BA])
     + parameters.i_X_P * (state.InFluxPerComponent[X_P] + state.InFluxPerComponent[X_I])
     - parameters.i_S_AS * state.AnaerobicInFluxPerComponent[S_AS]
     - parameters.i_X_S_An * state.AnaerobicInFluxPerComponent[X_S_An]
     - parameters.i_X_An * state.AnaerobicInFluxPerComponent[X_AS]
     - parameters.i_X_IN * state.AnaerobicInFluxPerComponent[X_IN];

     
     

    state.TemporaryInFluxS_S = state.InFluxPerComponent[S_S]
                                - state.InFluxPerComponent[S_O]
                                - (4.57 * state.InFluxPerComponent[S_NO]);

    state.InFluxS_S =
     IF (state.TemporaryInFluxS_S < 0)
     THEN 0
     ELSE state.TemporaryInFluxS_S;

    state.InFluxX_S =
     IF (state.TemporaryInFluxS_S < 0)
     THEN state.InFluxPerComponent[X_S] + state.TemporaryInFluxS_S
     ELSE state.InFluxPerComponent[X_S];

     

    state.AnaerobicInFluxPerComponent[S_AC] =
     parameters.f_AC_S * state.InFluxS_S;

    state.AnaerobicInFluxPerComponent[S_PRO] =
     parameters.f_PRO_S * state.InFluxS_S;

    state.AnaerobicInFluxPerComponent[S_AS] =
     parameters.f_AS_S * state.InFluxS_S;

    state.f_FA_S = 1 - (parameters.f_AC_S + parameters.f_PRO_S + parameters.f_AS_S);

    state.AnaerobicInFluxPerComponent[S_FA] =
     state.f_FA_S * state.InFluxS_S;

     

    state.AnaerobicInFluxPerComponent[S_IN] =
     state.InFluxPerComponent[S_I];

     
     

    state.AnaerobicInFluxPerComponent[X_S_An] =
     state.InFluxX_S
     + parameters.f_XSAn_I * state.InFluxPerComponent[X_I]
     + parameters.f_XSAn_H * state.InFluxPerComponent[X_BH]
     + parameters.f_XSAn_A * state.InFluxPerComponent[X_BA]
     + parameters.f_XSAn_P * state.InFluxPerComponent[X_P];

     

    state.AnaerobicInFluxPerComponent[X_AS] =
     parameters.f_AS_H * state.InFluxPerComponent[X_BH];

     

    state.AnaerobicInFluxPerComponent[X_FA] = 0;

    state.AnaerobicInFluxPerComponent[X_PRO] = 0;

    state.AnaerobicInFluxPerComponent[X_AC] = 0;

    state.AnaerobicInFluxPerComponent[X_H2] = 0;

     
     

    state.f_X_IN_H = 1 - (parameters.f_XSAn_H + parameters.f_AS_H);

    state.AnaerobicInFluxPerComponent[X_IN] =
     ((1 - parameters.f_XSAn_I) * state.InFluxPerComponent[X_I])
      + (state.f_X_IN_H * state.InFluxPerComponent[X_BH])
      + ((1 - parameters.f_XSAn_A) * state.InFluxPerComponent[X_BA])
      + ((1 - parameters.f_XSAn_P) * state.InFluxPerComponent[X_P]);

 

    state.PreviousHelp_Q_Gas_Tot =
     IF (previous(independent.t) >= independent.t)
     THEN parameters.Initial_Q_Gas_Tot
     ELSE previous(state.Q_Gas_Tot);

    state.StrippingRate =
     (state.PreviousHelp_Q_Gas_Tot/(state.V_L * (parameters.UniversalGasConstant / parameters.p) * (273.15 + interface.T)));

    state.AnaerobicKinetics[H2Stripping] =
     state.StrippingRate * state.C_An[S_H2];

    state.AnaerobicKinetics[CH4Stripping] =
     state.StrippingRate * state.C_An[S_CH4];

    state.AnaerobicKinetics[CO2Stripping] =
     state.StrippingRate * state.C_An[S_CO2];

    state.AnaerobicKinetics[BiopolymHydrol] =
     parameters.k_R * state.C_An[X_S_An] * parameters.TempCoef1;

    state.AnaerobicKinetics[ASFermentation] =
     parameters.mu_AS * (state.C_An[S_AS] / (parameters.K_S_AS + state.C_An[S_AS]))
                       * state.C_An[X_AS] * parameters.TempCoef1;

    state.AnaerobicKinetics[AnOxOfS_FA] =
     parameters.mu_FA * (state.C_An[S_FA] / (parameters.K_S_FA + state.C_An[S_FA]))
                       * (parameters.K_I_AC_FA / (parameters.K_I_AC_FA + state.C_An[S_AC]))
                       * (parameters.K_I_H2_FA / (parameters.K_I_H2_FA + state.C_An[S_H2]))
                       * state.C_An[X_FA] * parameters.TempCoef1;

    state.AnaerobicKinetics[AnOxOfS_PRO] =
     parameters.mu_PRO * (state.C_An[S_PRO] / (parameters.K_S_PRO + state.C_An[S_PRO]))
                        * (parameters.K_I_AC_PRO / (parameters.K_I_AC_PRO + state.C_An[S_AC]))
                        * (parameters.K_I_H2_PRO / (parameters.K_I_H2_PRO + state.C_An[S_H2]))
                        * (state.C_An[S_H] / (parameters.K_S_H_PRO + state.C_An[S_H]))
                        * (parameters.K_I_H_PRO / (parameters.K_I_H_PRO + state.C_An[S_H]))
                        * state.C_An[X_PRO] * parameters.TempCoef2;

    state.AnaerobicKinetics[AcToCH4Conv] =
     parameters.mu_AC * (state.C_An[S_AC] / (parameters.K_S_AC + state.C_An[S_AC]))
                       * (state.C_An[S_H] / (parameters.K_S_H_AC + state.C_An[S_H]))
                       * (parameters.K_I_H_AC / (parameters.K_I_H_AC + state.C_An[S_H]))
                       * state.C_An[X_AC] * parameters.TempCoef2;

    state.AnaerobicKinetics[H2ToCH4Conv] =
     parameters.mu_H2 * (state.C_An[S_H2] / (parameters.K_S_H2 + state.C_An[S_H2]))
                       * (state.C_An[S_H] / (parameters.K_S_H_H2 + state.C_An[S_H]))
                       * (parameters.K_I_H_H2 / (parameters.K_I_H_H2 + state.C_An[S_H]))
                       * state.C_An[X_H2] * parameters.TempCoef2;

    state.AnaerobicKinetics[DecayOfX_AS] =
     parameters.b_AS * state.C_An[X_AS] * parameters.TempCoef1;

    state.AnaerobicKinetics[DecayOfX_FA] =
     parameters.b_FA * state.C_An[X_FA] * parameters.TempCoef1;

    state.AnaerobicKinetics[DecayOfX_PRO] =
     parameters.b_PRO * state.C_An[X_PRO] * parameters.TempCoef2;

    state.AnaerobicKinetics[DecayOfX_AC] =
     parameters.b_AC * state.C_An[X_AC] * parameters.TempCoef2;

    state.AnaerobicKinetics[DecayOfX_H2] =
     parameters.b_H2 * state.C_An[X_H2] * parameters.TempCoef2;

    state.AnaerobicKinetics[ProtolysisOfHCO3] =
     parameters.k_HCO3 * state.C_An[S_HCO3] * state.C_An[S_H];

    state.AnaerobicKinetics[DeprotolysisOfCO2] =
     parameters.k_CO2 * state.C_An[S_CO2];

    state.pH_Reactor = - log10(state.C_An[S_H] / 1000);
 
 

    state.V_L = SUMOVER Comp_Index IN {1 .. NrOfAnaerobicComponents}:
     (parameters.AnaerobicSpecificVolume[Comp_Index] * state.M_An[Comp_Index]);

    {FOREACH Comp_Index IN {1 .. NrOfAnaerobicComponents}:
      state.AnaerobicConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfAnaerobicReactions}:
        (parameters.AnaerobicStoichiometry[Reaction_Index][Comp_Index]
         * state.AnaerobicKinetics[Reaction_Index])
        * state.V_L;
    };

    {FOREACH Comp_Index IN {1 .. NrOfAnaerobicComponents}:
      DERIV(state.M_An[Comp_Index],[independent.t]) =
       state.AnaerobicInFluxPerComponent[Comp_Index]
       + state.AnaerobicOutFluxPerComponent[Comp_Index]
       + state.AnaerobicConversionTermPerComponent[Comp_Index];
    };
      
    state.Q_In = SUMOVER Comp_Index IN {1 .. NrOfAnaerobicComponents}:
     (parameters.AnaerobicSpecificVolume[Comp_Index] * state.AnaerobicInFluxPerComponent[Comp_Index]);

    {FOREACH Comp_Index IN {1 .. NrOfAnaerobicComponents}:
     state.C_An[Comp_Index] = state.M_An[Comp_Index] / state.V_L;
    };

 

    {FOREACH Comp_Index IN {H2O_An .. S_IN}:
     state.AnaerobicOutFluxPerComponent[Comp_Index] =
      - state.C_An[Comp_Index] * state.Q_In;
    };

   
   
   

    {FOREACH Comp_Index IN {X_S_An .. X_IN}:
     state.AnaerobicOutFluxPerComponent[Comp_Index] =
      parameters.f_X_Out * (- state.C_An[Comp_Index] * state.Q_In);
    };

 

 
 

     

    state.MolProduced_H2 = - (parameters.AnaerobicStoichiometry[H2Stripping][S_H2]
                               * state.AnaerobicKinetics[H2Stripping]
                               * state.V_L)
                             / 16.0;

     

    state.MolProduced_CH4 = - (parameters.AnaerobicStoichiometry[CH4Stripping][S_CH4]
                                * state.AnaerobicKinetics[CH4Stripping]
                                * state.V_L)
                              / 64.0;

     

    state.MolProduced_CO2 = - (parameters.AnaerobicStoichiometry[CO2Stripping][S_CO2]
                                * state.AnaerobicKinetics[CO2Stripping]
                                * state.V_L);

    state.Q_H2 = state.MolProduced_H2 * parameters.MolVolumeAtTempT;
    state.Q_CH4 = state.MolProduced_CH4 * parameters.MolVolumeAtTempT;
    state.Q_CO2 = state.MolProduced_CO2 * parameters.MolVolumeAtTempT;

     

    state.Q_Gas_Prod = state.Q_H2 + state.Q_CH4 + state.Q_CO2;

    state.Q_Gas_Tot = state.Q_Gas_Prod + interface.Q_Gas;

     

    state.C_H2 = state.MolProduced_H2 / state.Q_Gas_Tot;

    state.C_CH4 = state.MolProduced_CH4 / state.Q_Gas_Tot;

    state.C_CO2 = state.MolProduced_CO2 / state.Q_Gas_Tot;

 

     

     

    interface.Outflow[IndexOfSolvent] = state.AnaerobicOutFluxPerComponent[H2O_An];

     

    interface.Outflow[S_I] = state.AnaerobicOutFluxPerComponent[S_IN];

     

    interface.Outflow[S_S] = state.AnaerobicOutFluxPerComponent[S_AC]
                              + state.AnaerobicOutFluxPerComponent[S_PRO]
                              + state.AnaerobicOutFluxPerComponent[S_AS]
                              + state.AnaerobicOutFluxPerComponent[S_FA];

     

    interface.Outflow[S_O] = 0;

    interface.Outflow[S_NO] = 0;

     

    interface.Outflow[S_NH] = state.AnaerobicOutFluxPerComponent[S_NH4];

     

    interface.Outflow[S_ND] = parameters.i_S_AS * state.AnaerobicOutFluxPerComponent[S_AS];

     
     

    interface.Outflow[S_ALK] = state.AnaerobicOutFluxPerComponent[S_HCO3] + state.AnaerobicOutFluxPerComponent[S_CO2];

     

    interface.Outflow[X_I] = state.AnaerobicOutFluxPerComponent[X_IN];

     

    interface.Outflow[X_BH] = parameters.f_H_AS * state.AnaerobicOutFluxPerComponent[X_AS];

     

    interface.Outflow[X_P] =
     parameters.f_P_An * (SUMOVER Comp_Index IN {X_AS .. X_H2}:
                           (state.AnaerobicOutFluxPerComponent[Comp_Index]));

     

    interface.Outflow[X_S] =
     state.AnaerobicOutFluxPerComponent[X_S_An]
     + (1 - (parameters.f_P_An + parameters.f_H_AS)) * state.AnaerobicOutFluxPerComponent[X_AS]
     + (1 - parameters.f_P_An) * (SUMOVER Comp_Index IN {X_FA .. X_H2}:
                                   (state.AnaerobicOutFluxPerComponent[Comp_Index]));

     

    interface.Outflow[X_BA] = 0;

     
     
     

    interface.Outflow[X_ND] =
     parameters.i_X_S_An * state.AnaerobicOutFluxPerComponent[X_S_An]
     + parameters.i_X_IN * state.AnaerobicOutFluxPerComponent[X_IN]
     + parameters.i_X_An * (SUMOVER Comp_Index IN {X_AS .. X_H2}:
                             (state.AnaerobicOutFluxPerComponent[Comp_Index]))
     - parameters.i_X_P * (interface.Outflow[X_I] + interface.Outflow[X_P])
     - parameters.i_X_B * (interface.Outflow[X_BH] + interface.Outflow[X_BA]);

   };

 :};




# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.anaerobic_digestion.msl" 2



# 43 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 1
 


















CLASS Sensor
  "sensor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    interface <-
    {
		OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent":};
		OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
    };
    parameters <- 
    {
		OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components" : SpecificVolumeVector ;
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    state <- 
    {
		OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector ;
		OBJ Q_In "Influent flow rate" : PhysicalQuantityType := {: group <- "Operational" :};
    };
    initial <- 
    {
		parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
    };
    equations <- 
    {
		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
			state.InFluxPerComponent[Comp_Index] =
				SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };

		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
			interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] ; }; 

		state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent] ;
    };
  :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_flow.msl" 1
 














 




CLASS Sensor_Flow
  (* icon = "sensor_flow" ; is_default = "true" *)
  "Flow sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the flow rate";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    };

    equations <-
    {
      {interface.y_M = state.Q_In ;};
    };
 :};





# 59 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_do.msl" 1
 



















CLASS Sensor_DO
  (* icon = "sensor_do" ; is_default = "true" *)
  "Oxygen sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a sensor measuring the dissolved oxygen";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
       {interface.y_M = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[S_O] / state.Q_In ; };
     };
  :};




# 60 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_nh4.msl" 1
 



















CLASS Sensor_NH4
  (* icon = "sensor_nh4" ; is_default = "true" *)
  "Ammonia sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a sensor measuring the ammonia concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
   
    equations <-
    {
       {interface.y_M = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[S_NH] / state.Q_In ; };
    };
  :};




# 61 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_no3.msl" 1
 



















CLASS Sensor_NO3
  (* icon = "sensor_no3" ; is_default = "true" *)
  "Nitrate sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the nitrate concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE interface.Inflow[S_NO] / state.Q_In ; };
    };
  :};




# 62 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tss.msl" 1
 



















CLASS Sensor_TSS
  (* icon = "sensor_tss" ; is_default = "true" *)
  "Suspended solids sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the particulate concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {
      OBJ F_TSS_COD "Fraction TSS/COD" : Ratio := {: value <- 0.75 ; group <- "Conversion factors":};
    };

    equations <-
    {

 

       interface.y_M = IF (state.Q_In == 0)
              THEN 0
            ELSE (interface.Inflow[X_BH] + interface.Inflow[X_BA] +
                      interface.Inflow[X_S] + interface.Inflow[X_I] +
                      interface.Inflow[X_P]) 
                     * parameters.F_TSS_COD / state.Q_In ; 







    };
  :};




# 63 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl" 1
 



















CLASS Sensor_COD
  (* icon = "sensor_cod" ; is_default = "true" *)
  "COD sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the Chemical Oxygen Demand";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {

       interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE (interface.Inflow[S_S] + interface.Inflow[X_S] + 
             interface.Inflow[S_I] + interface.Inflow[X_I] + interface.Inflow[X_P] + 
             interface.Inflow[X_BH] + interface.Inflow[X_BA]) 
            / state.Q_In ; 
   


# 55 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"


# 66 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"


# 77 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"

  };
    :};




# 64 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl" 1
 



















CLASS Sensor_BOD
  (* icon = "sensor_bod" ; is_default = "true" *)
  "BOD sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the Biodegradable Oxygen Demand";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {

     OBJ f_P      "Fraction Of Biomass Converted To Inert Matter"
      : FractOfBiomassLeadingToPartProd := {:value<- 0.20 ; group <- "Stoichiometry" :};









     OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};
     };

    equations <-
    {

       interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE parameters.F_BOD_COD * 
            (interface.Inflow[S_S] + interface.Inflow[X_S] 
             + (1 - parameters.f_P) * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) )
            / state.Q_In ; 
   


# 71 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl"


# 81 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl"


# 91 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl"

  };
    :};




# 65 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl" 1
 














 




CLASS Sensor_TN
  (* icon = "sensor_tn" ; is_default = "true" *)
  "Total nitrogen sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the total nitrogen concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {

     OBJ i_X_B     "Mass Of Nitrogen Per Mass Of COD In Biomass"
      : MassOfNitrogenPerMassOfCODInBiomass := {:value <- 0.086 ; group <- "Composition parameters" :};
     OBJ i_X_P     "Mass Of Nitrogen Per Mass Of COD In Products Formed"
      : MassOfNitrogenPerMassOfCODInProdFromBiomass := {:value <- 0.06 ; group <- "Composition parameters" :};


# 54 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"


# 67 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"


# 80 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"

     };

    equations <-
    {

      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE 
  (interface.Inflow[S_NO] + interface.Inflow[S_NH] + interface.Inflow[S_ND] + interface.Inflow[X_ND]
   + parameters.i_X_B * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) 
       + parameters.i_X_P * (interface.Inflow[X_P] + interface.Inflow[X_I])) 
  / state.Q_In ; };


# 106 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"


# 119 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"


# 132 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"

    };
  :};




# 66 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl" 1
 














 




CLASS Sensor_TKN
  (* icon = "sensor_tkn" ; is_default = "true" *)
  "Total Kjeldal nitrogen sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the total Kjeldal nitrogen concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {

     OBJ i_X_B     "Mass Of Nitrogen Per Mass Of COD In Biomass"
      : MassOfNitrogenPerMassOfCODInBiomass := {:value <- 0.086 ; group <- "Composition parameters" :};
     OBJ i_X_P     "Mass Of Nitrogen Per Mass Of COD In Products Formed"
      : MassOfNitrogenPerMassOfCODInProdFromBiomass := {:value <- 0.06 ; group <- "Composition parameters" :};


# 54 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"


# 67 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"


# 80 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"

     };

    equations <-
    {

      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE 
  (interface.Inflow[S_NH] + interface.Inflow[S_ND] + interface.Inflow[X_ND]
   + parameters.i_X_B * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) 
       + parameters.i_X_P * (interface.Inflow[X_P] + interface.Inflow[X_I])) 
  / state.Q_In ; };


# 106 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"


# 119 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"


# 132 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"

    };
  :};




# 67 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tp.msl" 1
 


















# 94 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_tp.msl"




# 68 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_po4.msl" 1
 


















# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_po4.msl"




# 69 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_multi.msl" 1
 














 




CLASS MultiSensor (* icon = "sensor_multi"; is_default = "true" *) "Multi-probe sensor" EXTENDS Sensor WITH 
  {:
    comments <- "A model for a multi-probe sensor";
    interface <-
    {
		OBJ y_Q (* terminal = "out_2"; is_favorite = "1" *) "Flow rate" : FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
		
		OBJ y_DO (* terminal = "out_2"; is_favorite = "1" *) "Oxygen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_NH (* terminal = "out_2"; is_favorite = "1" *) "Ammonia concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_NO (* terminal = "out_2"; is_favorite = "1" *) "Nitrate concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TSS (* terminal = "out_2"; is_favorite = "1" *) "Particulates concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_COD (* terminal = "out_2"; is_favorite = "1" *) "COD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_BOD (* terminal = "out_2"; is_favorite = "1" *) "BOD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TN (* terminal = "out_2"; is_favorite = "1" *) "Total Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TKN (* terminal = "out_2"; is_favorite = "1" *) "Total Kjeldahl Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		
		



    };
    parameters <- 
    {
		OBJ F_TSS_COD "Fraction TSS/COD" : Ratio := {: value <- 0.75 ; group <- "Conversion factors":};

		
		OBJ f_P "Fraction Of Biomass Converted To Inert Matter" : FractOfBiomassLeadingToPartProd := {: value<- 0.20 ; group <- "Stoichiometry" :};
		
		


		


		OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};

		
		OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {:value <- 0.086 ; group <- "Composition parameters" :};
		OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {:value <- 0.06 ; group <- "Composition parameters" :};
		
		






		






		







		






		






    };
    equations <- 
    {
		interface.y_Q = state.Q_In ;

		
		interface.y_DO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_O] / state.Q_In ;

		interface.y_NH = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_NH] / state.Q_In ;

		interface.y_NO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_NO] / state.Q_In ;
		 
		 
		
		interface.y_TSS = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[X_BH] + interface.Inflow[X_BA] + interface.Inflow[X_S] +
			interface.Inflow[X_I] + interface.Inflow[X_P]) * parameters.F_TSS_COD / state.Q_In ; 
		
		



		 
		 
		
		interface.y_COD = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_S] + interface.Inflow[X_S] + interface.Inflow[S_I] +
			interface.Inflow[X_I] + interface.Inflow[X_P] + interface.Inflow[X_BH] + interface.Inflow[X_BA]) / state.Q_In ; 
		
		





		




		





		 
		 
		
		interface.y_BOD = IF (state.Q_In == 0) THEN 0
			ELSE parameters.F_BOD_COD * (interface.Inflow[S_S] + interface.Inflow[X_S] +
			(1 - parameters.f_P) * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) ) / state.Q_In ; 
		
		





		




		





		 
		 
		
		interface.y_TN = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_NO] + interface.Inflow[S_NH] + interface.Inflow[S_ND] +
			interface.Inflow[X_ND] + parameters.i_X_B * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) +
			parameters.i_X_P * (interface.Inflow[X_P] + interface.Inflow[X_I])) / state.Q_In ;
		
		






		





		






		 
		 
		
		interface.y_TKN = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_NH] + interface.Inflow[S_ND] + interface.Inflow[X_ND] +
			parameters.i_X_B * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) + parameters.i_X_P * (interface.Inflow[X_P] +
			interface.Inflow[X_I])) / state.Q_In ;
		
		






		





		






		 
		 
		






		






		 
		 
		




		
    };

  :};




# 72 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.quality_index.msl" 1
 





 



  

 CLASS EffluentQualityIndex 
 
   (* icon = "sensor_multi" *)
   "sensor"
   EXTENDS Sensor WITH 
   {:
     comments <- "A model for a sensor measuring BOD, COD, TN, TP, NH4 and NO3, PUBOD, PUCOD, PUTP, PUNH4 and PUNO3";
 
 	interface <-
     {
 	 OBJ y_M (* terminal = "out_2" *)"measurement" :Real:= {: causality <- "COUT" ; group <- "Measurement data" :};
     };
     	
 
 
 parameters <-
   {
    OBJ F_TSS_COD "Conversion factor TSS/COD" : Real := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ F_BOD5_BOD20 "Conversion factor BOD5/BOD20": Fraction := {: value <- 0.25 ; group <- "Conversion factors" :};
    OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass" : MassOfNitrogenPerMassOfCODInBiomass := {:value <- 0.086 ; group <- "Composition parameters" :};
    OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed" : MassOfNitrogenPerMassOfCODInProdFromBiomass := {:value <- 0.06 ; group <- "Composition parameters" :};
   






 };
 
 state <-
   {
    OBJ S_COD "Soluble COD" : ChemOxDemand := {: group <- "Influent characterization" :};
    OBJ X_COD "Particulate COD" : ChemOxDemand := {: group <- "Influent characterization" :};
    OBJ BOD20 "BOD20" : BiolOxDemand := {: group <- "Influent characterization" :};
    OBJ COD "COD" : ChemOxDemand := {: group <- "Influent characterization" :};
    OBJ BOD5 "BOD5" : BiolOxDemand := {: group <- "Influent characterization" :};
    OBJ TSS "TSS" : Concentration := {: group <- "Influent characterization" :};
    OBJ TN "Total Nitrogen" : Concentration := {: group <- "Influent characterization" :};
    OBJ TKN "Total Nitrogen" : Concentration := {: group <- "Influent characterization" :};
    OBJ NH_4 "Ammonia" : Concentration := {: group <- "Influent characterization" :};
    OBJ NO_3 "Nitrates" : Concentration := {: group <- "Influent characterization" :};
    
   



   
   };
   
     equations <-
   {
    interface.y_M = state.Q_In;
     
    state.S_COD = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE
    			   (interface.Inflow[S_I] + interface.Inflow[S_S]) / state.Q_In; 
    state.X_COD = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE   
    			   (interface.Inflow[X_I] + interface.Inflow[X_S] 
 		     + interface.Inflow[X_BH] + interface.Inflow[X_BA] + interface.Inflow[X_P]) / state.Q_In;
    state.BOD20 = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE
 			   (interface.Inflow[S_S] + interface.Inflow[X_S] 
 		     + interface.Inflow[X_BH] + interface.Inflow[X_BA]) / state.Q_In;
 
    state.COD  = state.S_COD + state.X_COD;
    state.BOD5 = parameters.F_BOD5_BOD20 * state.BOD20;
    state.TSS  = parameters.F_TSS_COD * state.X_COD;
 
    state.TKN = IF (state.Q_In == 0)
    			THEN 0
 			   	ELSE
 			   (interface.Inflow[S_NH] + interface.Inflow[S_ND] + interface.Inflow[X_ND]
 	 		+ (parameters.i_X_B * (interface.Inflow[X_BH] + interface.Inflow[X_BA])) 
        		+ (parameters.i_X_P * (interface.Inflow[X_P] + interface.Inflow[X_I]))) / state.Q_In;
    
    state.TN = state.TKN + state.NO_3;
    
    state.NH_4  = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE interface.Inflow[S_NH] / state.Q_In;
    
    state.NO_3  = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE interface.Inflow[S_NO] / state.Q_In;
    
   
# 115 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.quality_index.msl"

   
   };
  :};
 
  
  
  
# 277 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.quality_index.msl"

 




# 74 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_od.msl" 1
 









CLASS OD
  (* icon = "sensor_od" *)
  "sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring Oxygen Demand - only implemented for ASM2dTemp";

    interface <-
    {
      OBJ y_M (* terminal = "out_2" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
	state <-
   {
      OBJ OD_C  "Oxygen demand for carbon" : ChemOxDemand := {: group <- "Influent characterization" :};
	    OBJ OD_NH  "oxygen demand for ammonia" : ChemOxDemand := {: group <- "Influent characterization" :};	 
	};
	
    parameters <-
    {

     OBJ f_P      "Fraction Of Biomass Converted To Inert Matter"
      : FractOfBiomassLeadingToPartProd := {:value<- 0.20 ; group <- "Stoichiometry" :};









     OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};
     };

    equations <-
    {

	   interface.y_M = IF (state.Q_In == 0)
			     THEN 0
			     ELSE parameters.F_BOD_COD * 
				    (interface.Inflow[S_S] + interface.Inflow[X_S] 
				     + (1 - parameters.f_P) * (interface.Inflow[X_BH] + interface.Inflow[X_BA]) )
				    / state.Q_In ; 
	 


# 68 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_od.msl"


# 78 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_od.msl"


# 88 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sensor/wwtp.base.sensors.sensor_od.msl"

	};
    :};





# 75 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sensors.msl" 2



# 44 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.onoffideal.msl" 1
 


















CLASS OnOffIdeal
  (* icon = "controller_on_off" ; is_default = "" *)
  "Ideal On-off controller"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
         Real := {: causality <- "CIN" ; value <- 2  ; group <- "Operational":};
    OBJ u_Off (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when off" : 
    Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_On  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when on"  : 
    Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
     OBJ help_t (* hidden = "1" *) "Previous t help variable" : Real;
    };

    equations <-
    {
    state.e = interface.y_S - interface.y_M;

    state.help_u = interface.u;
    state.help_t = independent.t;
    interface.u = IF (interface.y_M > interface.y_S)
                  THEN interface.u_Off
                  ELSE interface.u_On;
   };

 :};

 


# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.onoffband.msl" 1
 


















CLASS OnOffBand
  (* icon = "controller_on_off" ; is_default = "true" *)
  "On-off controller with a band"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
         Real := {: causality <- "CIN" ; value <- 2  ; group <- "Operational":};
    OBJ y_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum allowed measured value" : 
         Real := {: causality <- "CIN" ; value <- 1.8  ; group <- "Operational":};
    OBJ y_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum allowed measured value" : 
         Real := {: causality <- "CIN" ; value <- 2.2  ; group <- "Operational":};
    OBJ u_Off (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when off" : 
    Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_On  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when on"  : 
    Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
     OBJ help_t (* hidden = "1" *) "Previous t help variable" : Real;
    };

    equations <-
    {
    state.e = interface.y_S - interface.y_M;

    state.help_u = interface.u;
    state.help_t = independent.t;
    interface.u = IF(interface.y_M < interface.y_Min)
                  THEN interface.u_On
                  ELSE
                    IF (interface.y_M > interface.y_Max)
                    THEN interface.u_Off
                    ELSE
            IF (previous(state.help_t) >= independent.t)
              THEN interface.u_On
              ELSE previous(state.help_u) ;
   };

 :};

 


# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.constantratio.msl" 1
 


















CLASS ConstantRatio
  (* icon = "controller_ratio" *)
  "Ratio controller"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a ratio controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" :
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" :
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ ConstantRatio (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Ratio between measured value and controller output" :
        Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    equations <-
    {

    interface.u = interface.ConstantRatio * interface.y_M;

    };
  :};

 


# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.p_saturation.msl" 1
 


















CLASS P_Saturation
  (* icon = "controller_p" *)
  "P controller with saturation"

 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable " : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) " Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

     state.e = interface.y_S - interface.y_M ;
     state.uhelp = interface.u0 + interface.K_P * state.e;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
   };

 :};

 


# 23 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.pi_saturation.msl" 1
 


















CLASS PI_Saturation
  (* icon = "controller_pi"; is_default = "true" *)
  "PI controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1" *) "Setpoint value for controlled variable" : 
     Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};
     OBJ T_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : 
     Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ;value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
     OBJ Prev_t (* hidden = "1" *) : Time;
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

     DERIV(state.Integ_e, [independent.t]) = state.e ;

     state.uhelp = interface.u0 + interface.K_P 
                     * (state.e + (1 / interface.T_I) * state.Integ_e); 

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
    };
  :};
 

 


# 24 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.pid_saturation.msl" 1
 


















CLASS PID_Saturation
  (* icon = "controller_pid" *)
  "PID controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral-derivative controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ K_P (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Factor of proportionality" : 
        Real := {: causality <- "CIN" ; value <- 11.31977725 ; group <- "Operational" :};
      OBJ T_I (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Integral time" : 
        Time := {: causality <- "CIN" ; value <- 0.5062161847 ; group <- "Operational" :};
      OBJ T_D (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Derivative time" : 
        Time := {: causality <- "CIN" ; value <- 0.2531080923 ; group <- "Operational" :};
      OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
        Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
      OBJ u0  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
        Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
      OBJ u_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
        Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
      OBJ u_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
        Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral-derivative control action" : Real;
     OBJ Deriv_e  "Derivative of error" : Real := {: group <- "Operational" :};
     OBJ Prev_t (* hidden = "1" *) : Time;
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

   state.Deriv_e = IF (previous(state.help) != state.help)
             THEN (previous(state.e) - state.e) / (previous(state.help) - state.help)
             ELSE previous(state.Deriv_e);  

     DERIV(state.Integ_e, [independent.t]) = state.e ;

     state.uhelp = interface.u0 
           + interface.K_P * (state.e + interface.T_D * state.Deriv_e 
                       + state.Integ_e / interface.T_I); 
                      
     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
    };
  :};

 


# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.linear_saturation.msl" 1
 








CLASS linear_Saturation
  (* icon = "controller" *)
  "Linear controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a linear controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    };

    parameters <-
    {
     OBJ a "u=a+b*y_M" : Real := {: value <- 0 ; group <- "Operational" :};
     OBJ b "u=a+b*y_M" : Real := {: value <- 1 ; group <- "Operational" :};
     OBJ u_Min "Minimum control action" : Real := {: value <- 0 ; group <- "Operational" :};
     OBJ u_Max "Maximum control action" : Real := {: value <- 1000 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
    };

    equations <-
    {
     state.uhelp = parameters.a + parameters.b * interface.y_M; 

     interface.u = IF(state.uhelp < parameters.u_Min)
                   THEN (parameters.u_Min)
                   ELSE
                     IF (state.uhelp > parameters.u_Max)
                     THEN parameters.u_Max
                     ELSE state.uhelp;
    };
  :};

 


# 26 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.pi_saturation_recB_EHV.msl" 1
 








  CLASS PI_Saturation_recB_EHV
  (* icon = "controller" *)
  "PI controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with saturation";
    interface <-
    {
     OBJ y_MA (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ y_MB (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
     OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_SA (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
				 Real := {: causality <- "CIN" ; value <- 3 ; group <- "Operational" :};
	   OBJ temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature" : 
				 CelsiusTemperature := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :};
	   OBJ switch (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "1=A, 2=B, 0=min(A,B)" : 
				 Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
    };

    parameters <-
    {
     OBJ K_PA "Factor of proportionality" : Real := {: value <- 25 ; group <- "Operational" :};
	   OBJ K_PB "Factor of proportionality" : Real := {: value <- 25 ; group <- "Operational" :};
     OBJ T_I "Integral time" : Time := {: value <- 0.1 ; group <- "Operational" :};
     OBJ u0A "No error action" : Real := {: value <- 50 ; group <- "Operational" :};
	   OBJ u0B "No error action" : Real := {: value <- 50 ; group <- "Operational" :};
     OBJ u_Min "Minimum control action" : Real := {: value <- 0 ; group <- "Operational" :};
     OBJ u_Max "Maximum control action" : Real := {: value <- 1000 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ eA "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_eA "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelpA (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
	   OBJ uA (* hidden = "0" *) "" : Real;
	 
	   OBJ eB "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_eB "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelpB (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
	   OBJ y_SB (* hidden = "0" *) "Setpoint value for controlled variable" : Real;
	   OBJ uB (* hidden = "0" *) "" : Real;
	     };

    equations <-
    {
     state.eA = interface.y_SA - interface.y_MA;

     DERIV(state.Integ_eA, [independent.t]) = state.eA ;

     state.uhelpA = parameters.u0A + parameters.K_PA 
	 			  				   * (state.eA + (1 / parameters.T_I) * state.Integ_eA); 

     state.uA = IF(state.uhelpA < parameters.u_Min)
                   THEN (parameters.u_Min)
                   ELSE
                     IF (state.uhelpA > parameters.u_Max)
                     THEN parameters.u_Max
                     ELSE state.uhelpA;
	
	 state.y_SB = IF(interface.temp < 11)
	 			  		 THEN 11.8
				  			ELSE
				  	  		IF(interface.temp < 12) 
					  			THEN 11.0
				      		ELSE
					  	  		IF(interface.temp < 13) 
					      		THEN 10.8
				          	ELSE
						  	  		IF(interface.temp < 14) 
					          	THEN 10.5
				              ELSE
							  	  		IF(interface.temp < 15) 
					              THEN 10.2
				                ELSE
								  	  		IF(interface.temp < 16) 
					                THEN 3.3
				                  ELSE
									  	  		IF(interface.temp < 17) 
					                  THEN 2.4
				                    ELSE
										  	  		IF(interface.temp < 18) 
					                    THEN 2.2
				                      ELSE 2.1;
					 
	 state.eB = state.y_SB - interface.y_MB;

   DERIV(state.Integ_eB, [independent.t]) = state.eB ;

   state.uhelpB = parameters.u0B + parameters.K_PB 
	 			  				   * (state.eB + (1 / parameters.T_I) * state.Integ_eB); 

   state.uB = IF(state.uhelpB < parameters.u_Min)
              THEN (parameters.u_Min)
              ELSE
                IF (state.uhelpB > parameters.u_Max)
                THEN parameters.u_Max
                ELSE state.uhelpB;				
	 
	 interface.u = IF (interface.switch == 1)
	 			   		 THEN state.uA
				   			ELSE
				   	   	 IF (interface.switch == 2)
					   			THEN state.uB
					   			ELSE
								 		IF (state.uB < state.uA)
	 			   				 THEN state.uB
				   				  ELSE state.uA;
				   
    };
  :};

 


# 27 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.raintank_EHV.msl" 1
 








   CLASS raintank_Eindhoven
   (* icon = "controller" *)
   "Ratio controller"
 
  
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ y_M1 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ y_M2 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ u (* terminal = "out_1" *) "Controlled variable" :
                Real := {: causality <- "COUT" ; group <- "Control action" :};
       OBJ Q_empty (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow when emptying" :
          FlowRate := {: causality <- "CIN" ; value <- 9600 ; group <- "Operational" :};
	  	 OBJ max_bio (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when Q_In = 0" :
          FlowRate := {: causality <- "CIN" ; value <- 9600 ; group <- "Operational" :};
};
 
     parameters <-
     {
      };
 
 
     equations <-
     {
     interface.u = IF (interface.y_M1 > 0)
 				   			 THEN 0
 				   			 ELSE 
		 								IF (interface.y_M2 > interface.max_bio)
				   					THEN 0
										 ELSE interface.Q_empty;
     };
  :};

 


# 28 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.constant_ratio_with_offset_Saturation.msl" 1
 








CLASS ConstantRatioWithOffset_Saturation
  (* icon = "controller" *)
  "Ratio controller with offset"

 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a ratio controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" :
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" :
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    	OBJ ConstantRatio (* terminal = "in_2"; manip = "1" *) "Ratio between measured value and controller output" :
         			Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
			OBJ Offset (* terminal = "in_2"; manip = "1" *) "Offset to be added to the calculated value" :
		 				  Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};	 
			OBJ u_Min (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
							 Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
			OBJ u_Max (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
							 Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
};

    parameters <-
    {

     
        
	 
	 
      
      
      
    };

    state <-  
    {
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

    state.uhelp = interface.ConstantRatio * interface.y_M + interface.Offset;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;

    };
  :};

 


# 29 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.pid_antiwindup_saturation.msl" 1
 








CLASS PID_AntiWindup_Saturation
  (* icon = "controller" *)
  "PID controller with anti-windup and saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with anti-windup and saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ y_S  (* terminal = "in_2"; manip = "1" *) "Setpoint value for controlled variable" : 
     				Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
      OBJ K_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" : 
     				Real := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};
      OBJ T_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : 
      			 Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ T_D (* terminal = "in_2"; manip = "1" *) "Derivative time" : 
						 Time := {: causality <- "CIN" ; value <- 0.2531080923 ; group <- "Operational" :};
      OBJ T_t (* terminal = "in_2"; manip = "1" *) "Tracking time (anti-windup)" : 
						 Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
     				Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
      OBJ u_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
     				Real := {: causality <- "CIN" ;value <- 0 ; group <- "Operational" :};
      OBJ u_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
     				Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Operational" :};

    };

    parameters <-
    {
 
 
 
 
 
 
 
 
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ u_Unsat (* hidden = "1" *) "Unsaturated output of the proportional-integral control action" : Real;
     OBJ u_Sat (* hidden = "1" *) "Saturated output of the proportional-integral control action" : Real;
     OBJ Deriv_e  "Derivative of error" : Real := {: group <- "Operational" :};
 
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

	 state.Deriv_e = IF (previous(state.help) != state.help)
				   	 THEN (previous(state.e) - state.e) / (previous(state.help) - state.help)
				   	 ELSE previous(state.Deriv_e);	

     DERIV(state.Integ_e, [independent.t]) = (interface.K_P * state.e / interface.T_I) + ((state.u_Sat - state.u_Unsat) / interface.T_t) ;

     state.u_Unsat = interface.u0 + interface.K_P * state.e + state.Integ_e + interface.K_P * interface.T_D * state.Deriv_e; 

	 state.u_Sat = IF(state.u_Unsat < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.u_Unsat > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.u_Unsat;
	 
     interface.u = state.u_Sat;
    };
  :};

 


# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.operator_delayed.msl" 1
 








CLASS OperatorDelayed 
  (* icon = "controller" *)
  "operator control with loop breaker"

 
 
 
 
 
 
 
 


  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
              Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
              FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ y_S_Lower (* terminal = "in_2"; manip = "1" *) "Lower limit setpoint value for controlled variable " : 
							Concentration := {: causality <- "CIN" ; value <- 3.2 ; group <- "Operational" :};
      OBJ y_S_Upper (* terminal = "in_2"; manip = "1" *) "Upper limit setpoint value for controlled variable " : 
							Concentration := {: causality <- "CIN" ; value <- 3.5 ; group <- "Operational" :};
      OBJ K_P (* terminal = "in_2"; manip = "1" *) " Factor of proportionality" : 
							Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
      OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
							FlowRate := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
      OBJ u_Min (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
							FlowRate := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
      OBJ u_Max (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
							FlowRate := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
      OBJ T (* terminal = "in_2"; manip = "1" *) "Control window" : 
							Time := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
      
};

    parameters <-
    {
 
 
 
 
 
 
      
 
      
	 OBJ Tau "Implicit loop breaker time constant, d" : Time := {: value <- 0.0005 ; group <- "Miscellaneous" :};
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ uhelp (* hidden = "0" *) "Help variable to calculate the proportional control action" : Real;
     OBJ uhelp_control (* hidden = "0" *) "Help variable: calculated control action" : Real;
     OBJ uhelp_loopbreaker (* hidden = "0" *) "Help variable: loopbreaker/delay on calculated control action" : Real;
     OBJ Prev_t (* hidden = "0" *) "Help variable to calculate the begin of each period" : Time ;
    };

    initial <-  
    {
    state.Prev_t = 0;
 
    };	
    equations <-
    {

    state.Prev_t = 	IF	(independent.t - previous(state.Prev_t) < (interface.T))
			 	 	THEN	previous(state.Prev_t)
			 		ELSE	previous(state.Prev_t) + interface.T;

	
	
     state.uhelp = IF (independent.t == 0)
	 			   THEN interface.u0
				   ELSE
	 			     IF (independent.t - previous(state.Prev_t) < interface.T)
	 			   	 THEN	previous(state.uhelp)
				   	 ELSE
				       IF(interface.y_M < interface.y_S_Lower)
                   	   THEN previous(state.uhelp) - interface.K_P * (interface.y_S_Lower - interface.y_M)
                   	   ELSE
                         IF (interface.y_M > interface.y_S_Upper)
                       	 THEN previous(state.uhelp) + interface.K_P * (interface.y_M - interface.y_S_Upper)
                       	 ELSE previous(state.uhelp);

	 
     state.uhelp_control = IF(state.uhelp < interface.u_Min)
                   		   THEN (interface.u_Min)
                   		   ELSE
                     	     IF (state.uhelp > interface.u_Max)
                     		 THEN interface.u_Max
                     		 ELSE state.uhelp;


      DERIV(state.uhelp_loopbreaker,[independent.t]) =
       - (1 / parameters.Tau) * (state.uhelp_loopbreaker - state.uhelp_control);

      interface.u = state.uhelp_loopbreaker;


   };

 :};


 


# 31 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.aerationmodel.msl" 1
 








	CLASS Irvine_Aeration_model_Carbon_foot_print
    (* icon = "controller" *)
    "Irvine Carbon foot print"
  
   
   
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
    comments <- "A model that calculates Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
   	OBJ TSS_Anaerobic (* terminal = "in_1" *) "TSS concentration in the aeration tank (g/m3)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ TSS_Aerobic (* terminal = "in_1" *) "TSS concentration in the aeration tank (g/m3)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ TSS_Anoxic (* terminal = "in_1" *) "TSS concentration in the aeration tank (g/m3)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ Q_was   (* terminal = "in_1" *) " Load Sludge Flow  (kg/d)" :
    			 FlowRate := {: causality <- "CIN" ; group <- "Control action" :};
     OBJ Kla   	 (* terminal = "out_1" *) "Calculated Kla (1/d)" :
                 OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
	   OBJ O2_tank  (* terminal = "in_1" *) "Actual oxygen concentration in the aeration tank (g/m)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ Volume   (* terminal = "in_1" *) "Aeration tank volume (m)" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ O2_rsat_average   (* terminal = "out_1" *) "Average oxygen saturation depending on water temperature and tank depth for fine bubble aeration (g/m)" :
    			 Concentration := {: causality <- "COUT" ; group <- "Control action" :};
		 OBJ Q_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Air flow rate of the fine bubble aerators under standard conditions (Nm/d)": 
			     FlowRate := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
	   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature (C)": 
				   CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Local conditions of the situ" :};
	   OBJ P_atm (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Standard atmospheric pressure (Pa)": 
			     Real := {: causality <- "CIN" ; value <- 101325; group <- "Local conditions of the situ" :};
	   OBJ Temp_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature (C)": 
			     CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Local conditions of the situ" :};

	 
    };
  
 parameters <-
    {
	OBJ Depth "Depth of fine bubble aerator below the watersurface (m)": Real := {: value <- 6 ; group <- "Geometry of the tank and aerators" :};
	OBJ H "altitudine": Real := {: value <- 10 ; group <- "Local conditions of the situ" :};
	OBJ p_site "Vapour pressure (Pa)": Real := {: value <- 2334; group <- "Local conditions of the situ" :};
	OBJ P_st_atm "Standard atmospheric pressure (Pa)": Real := {: value <- 101325; group <- "Local conditions of the situ" :};
	OBJ Rho_sludge "Density of sludge (kg/m)": Real := {: value <- 988 ; group <- "Characteristic of the sludge and air" :};
	OBJ Rho_air "Air Density (kg/m)": Real := {: value <- 1.23 ; group <- "Characteristic of the sludge and air" :};
	OBJ Beta "Beta factor (-)": Real := {: value <- 0.98 ; group <- "Characteristic of the sludge and air" :};
	OBJ Phi "Phi factor (-)": Real := {: value <- 1.024 ; group <- "Characteristic of the sludge and air" :};
	OBJ O2_air "Oxygen concentration in the atmosphere (%)": Real := {: value <- 20.85 ; group <- "Characteristic of the sludge and air" :};
	OBJ CO2_in "CO2 concentration in the atmosphere (%)": Real := {: value <- 0.03 ; group <- "Characteristic of the sludge and air" :};
	OBJ O2_sat20 "Oxygen saturation of water under standard conditions (g/m): 1 atm, 20 C, no salts": Real := {: value <- 10.50 ; group <- "Characteristic of the sludge and air" :};
	OBJ g "Strength of the gravitational field (m/s)": Real := {: value <- 9.82 ; group <- "Characteristic of the sludge and air" :};
	OBJ a "diffuser specific aerea (m2)": Real := {: value <- 2 ; group <- "Geometry of the tank and aerators" :};
	OBJ A "dimensionaless Aeration model": Real := {: value <- 5.717 ; group <- "Aeration model" :};
	OBJ B "dimensionaless Aeration model": Real := {: value <- 6.815 ; group <- "Aeration model" :};
	OBJ f "fraction of the tank": Real := {: value <- 0.44 ; group <- "Aeration model" :};
	OBJ Nd "Total diffuser number (-)": Real := {: value <- 504 ; group <- "Geometry of the tank and aerators" :};
	OBJ SOTE "standard oxygen transfer efficiency (%)": Real := {: value <- 42 ; group <- "Operational" :};
	OBJ Anaerobic_Volume_biological "anaerobic volume biological reactor  (mc)": Real := {: value <- 11200 ; group <- "Operational" :};
	OBJ Anoxic_Volume_biological "anoxic volume biological reactor  (mc)": Real := {: value <- 28750 ; group <- "Operational" :};
	OBJ Aerobic_Volume_biological "aerobic volume biological reactor  (mc)": Real := {: value <- 50100 ; group <- "Operational" :};
	 
	OBJ P_out "Outut Pressure from the Blower (Pa)": Real := {: value <- 80000; group <- "Power consumption" :};
	OBJ landa "costant for air (-)": Real := {: value <- 1.395 ; group <- "Power consumption" :};
	OBJ epsilon "efficiency of the motor (-)": Real := {: value <- 0.58 ; group <- "Power consumption" :};
	OBJ fCO2 "factor of CO2 production (-)": Real := {: value <- 0.718 ; group <- "Power consumption" :};
	OBJ Tin "absolute inlet temperature  (K)": Real := {: value <- 293.15 ; group <- "Power consumption" :};
	};	 
		
	independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
     };
		
	state <-
    {
	OBJ p_site_variable "Vapour pressure (Pa)": Real := {: group <- "Local conditions of the situ" :};
	OBJ MCRT "Age slduge(d)": Real := {: group <- "Operational" :};
	OBJ Alpha "alphafactor ": Real := {: group <- "Operational" :};
	OBJ AlphaSOTE "Oxygen transfer efficiency for new fine bubble aeration in wastewater ": Real := {: group <- "Aeration" :};
	OBJ Chi "Characteristic number (-)": Real := {: group <- "Aeration" :};
	OBJ lgChi "Characteristic number (-)": Real := {: group <- "Aeration":};
	OBJ Qn "Normalized air flow (-)": Real := {: group <- "Aeration" :};
    OBJ SOTR "Standard oxygen transfer rate for fine bubble aeration (g/d)": Real := {: group <- "Aeration" :};
	OBJ AOTR "Actual oxygen transfer rate for fine bubble aeration (g/d)": Real := {: group <- "Aeration" :};
	OBJ	AOTRspecific "Oxygen transfer for diffuser (kg/d/m2)": Real := {: group <- "Aeration" :};
	OBJ O2_rsat "Oxygen saturation depending on water temperature (g/m3)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ O2sat_std "Oxygen saturation depending on water depth (g/m3)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ MRi "mole ratio of oxygen to inters in ambient air and off gas (%)": Real := {: group <- "Aeration" :};
	OBJ MRe "mole ratio of oxygen to leave from aeration tank (%)": Real := {: group <- "Aeration" :};
	OBJ P_depth "Pressure at the bottom of the tank (Pa)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ OTEf "Oxygen transfer efficiency under field conditions (%)": Real := {: group <- "Aeration" :};
	 
	OBJ CO2 "CO2 production (kg/d)": Real := {: group <- "Power consumption" :};
	OBJ k "costant power factor (kW/(m3/s))": Real := {: group <- "Power consumption" :};
	OBJ Energy_consume "energy consume (kWh)": Real := {: group <- "Power consumption" :};
	OBJ Integ_energy_consume "Integral energy consume(kWh)" : Real:= {: group <- "Power consumption" :} ;
	OBJ Integ_emissione_CO2 "Integral CO2(kg)" : Real:= {: group <- "Power consumption" :} ;
	OBJ Power_blowers "Power(kW)" : Real:= {: group <- "Power consumption" :};
	};
    
		 
    equations <-
    { 
	 
	state.MCRT = (parameters.Anoxic_Volume_biological * interface.TSS_Anoxic + parameters.Anaerobic_Volume_biological * interface.TSS_Anaerobic + parameters.Aerobic_Volume_biological * interface.TSS_Aerobic) / 1000 /(interface.Q_was + 1);
	state.Qn = interface.Q_air / (24*3600*(parameters.a * parameters.Nd * parameters.Depth));
 
       state.Chi = IF (state.Qn == 0.0)
                   THEN 0.0
                   ELSE state.MCRT/state.Qn;
	
 
       state.lgChi = IF (state.Chi == 0.0)
                     THEN 0.0
                     ELSE log10(state.Chi);
 
       state.AlphaSOTE = IF (state.Chi == 0.0)
                         THEN 0.0
                         ELSE (parameters.A * log10(state.Chi) - parameters.B)/100;

	state.Alpha = state.AlphaSOTE / parameters.SOTE * 100;	
	 
	state.MRi = parameters.O2_air/100/(1 - parameters.O2_air/100 - parameters.CO2_in/100);
	state.MRe =  state.MRi*(1-state.OTEf);
	state.OTEf = state.AlphaSOTE * (parameters.Beta * interface.O2_rsat_average - interface.O2_tank) / ( state.O2sat_std) * pow(parameters.Phi,(interface.Temp-20));
	 
	state.P_depth = parameters.Rho_sludge * parameters.g * parameters.Depth;
	state.p_site_variable = pow(10, 0.6979 + 0.02618* interface.Temp_air)* 133.33;
	state.O2_rsat = 14.65 - 0.41 * (interface.Temp) + 0.00799 * (interface.Temp) * (interface.Temp) - 0.0000778 * (interface.Temp) * (interface.Temp) * (interface.Temp);
	interface.O2_rsat_average = state.O2_rsat * (state.P_depth * parameters.f + interface.P_atm - state.p_site_variable)/ (parameters.P_st_atm - parameters.p_site);
	state.O2sat_std =  parameters.O2_sat20;
	 
	state.SOTR =  interface.Q_air * parameters.Rho_air  * parameters.SOTE * parameters.O2_air / 10000;
	state.AOTR = state.Alpha * state.SOTR * (parameters.Beta * interface.O2_rsat_average - interface.O2_tank) /state.O2sat_std * pow(parameters.Phi,(interface.Temp-20));
	interface.Kla = 1000 * state.AOTR/((parameters.Beta * interface.O2_rsat_average - interface.O2_tank) * interface.Volume);
	state.AOTRspecific = state.AOTR /(interface.Volume);
	 
	state.k = (parameters.P_st_atm * parameters.landa * parameters.Tin) / (2.73 * 100000 * parameters.epsilon * (parameters.landa - 1)) * (pow((parameters.P_out + parameters.P_st_atm)/parameters.P_st_atm,1-1/parameters.landa)-1);
	state.Power_blowers = state.k * interface.Q_air/(24*3600);
	state.CO2 = state.Power_blowers * parameters.fCO2;
	DERIV(state.Integ_energy_consume, [independent.t]) = 24 * state.Power_blowers ;
	DERIV(state.Integ_emissione_CO2, [independent.t]) = state.CO2 ;
	};
    :};

 


# 32 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\controller/wwtp.base.controllers.pi_antiwindup_saturation.msl" 1
 








CLASS PI_AntiWindup_Saturation
  (* icon = "controller_pi" *)
  "PID controller with anti-windup and saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with anti-windup and saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ y_S  (* terminal = "in_2"; manip = "1" *) "Setpoint value for controlled variable" : 
     				Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
      OBJ K_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" : 
     				Real := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};
      OBJ T_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : 
      			 Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ T_t (* terminal = "in_2"; manip = "1" *) "Tracking time (anti-windup)" : 
						 Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
     				Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
      OBJ u_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
     				Real := {: causality <- "CIN" ;value <- 0 ; group <- "Operational" :};
      OBJ u_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
     				Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Operational" :};

    };

    parameters <-
    {
 
 
 
 
 
 
 
 
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
      
     OBJ u_Unsat (* hidden = "1" *) "Unsaturated output of the proportional-integral control action" : Real;
     OBJ u_Sat (* hidden = "1" *) "Saturated output of the proportional-integral control action" : Real;
 
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

      

     DERIV(state.Integ_e, [independent.t]) = (interface.K_P * state.e / interface.T_I) + ((state.u_Sat - state.u_Unsat) / interface.T_t) ;

     state.u_Unsat = interface.u0 + interface.K_P * state.e + state.Integ_e; 

	   state.u_Sat = IF(state.u_Unsat < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.u_Unsat > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.u_Unsat;
	 
     interface.u = state.u_Sat;
    };
  :};

 


# 34 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.controllers.msl" 2

 


# 45 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer21.msl" 1
 














 



CLASS Timer21
  (* icon = "timer" ; is_default = "true" *)
  "Timer with 2 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
     OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
     OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
      THEN  interface.u11
      ELSE  interface.u12;

    };
  :};

  

# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer22.msl" 1
 


















CLASS Timer22
  (* icon = "timer" *)
  "Timer with 2 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE  interface.u12;

    interface.u2 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE  interface.u22;
    };
  :};

  

# 21 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer31.msl" 1
 


















CLASS Timer31
  (* icon = "timer" *)
  "Timer with 3 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};     
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
       THEN interface.u11
       ELSE
         IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
         THEN interface.u12
         ELSE interface.u13;
    };
  :};

  


# 22 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer32.msl" 1
 


















CLASS Timer32
  (* icon = "timer" *)
  "Timer with 3 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u12
          ELSE  interface.u13;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u22
          ELSE  interface.u23;

    };
  :};

  


# 23 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer41.msl" 1
 


















CLASS Timer41
  (* icon = "timer" *)
  "Timer with 4 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};      
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;
    };
  :};

  


# 24 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer42.msl" 1
 


















CLASS Timer42
  (* icon = "timer" *)
  "Timer with 4 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE  interface.u24;
    };
  :};

  


# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer51.msl" 1
 


















CLASS Timer51
  (* icon = "timer" *)
  "Timer with 5 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;
    };
  :};

  


# 26 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer52.msl" 1
 


















CLASS Timer52
  (* icon = "timer" *)
  "Timer with 5 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u24
              ELSE  interface.u25;

    };
  :};

  


# 27 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer61.msl" 1
 


















CLASS Timer61
  (* icon = "timer" *)
  "Timer with 6 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;
    };
  :};

  


# 28 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer62.msl" 1
 


















CLASS Timer62
  (* icon = "timer" *)
  "Timer with 6 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE  interface.u26;

    };
  :};

  


# 29 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer71.msl" 1
 


















CLASS Timer71
  (* icon = "timer" *)
  "Timer with 7 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;
    };
  :};

  


# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer72.msl" 1
 


















CLASS Timer72
  (* icon = "timer" *)
  "Timer with 7 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE  interface.u27;

    };
  :};

  

# 31 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer81.msl" 1
 














 



CLASS Timer81
  (* icon = "timer" *)
  "Timer with 8 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eight period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eight period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;
    };
  :};

  

# 32 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\timer/wwtp.base.timers.timer82.msl" 1
 


















CLASS Timer82
  (* icon = "timer" *)
  "Timer with 8 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u28 (* terminal = "in_2"; manip = "1" *) "Output 2 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eigth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u27
                       ELSE  interface.u28;

    };
  :};

  

# 33 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.timers.msl" 2

  

# 46 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.loopbreaker.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\loopbreaker/wwtp.base.loopbreaker.differentialloopbreaker.msl" 1
 


















CLASS DifferentialLoopBreaker
(* icon = "loop_breaker" ; is_default = "true" *)
"An Explicit Implicit Algebraic Loop Breaker using differential equations "

SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for a loopbreaker without differential equations";
  interface <-
  {
   OBJ Inflow (* terminal = "in_1" *) "inflow" :
        InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "outflow" :
        OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
   OBJ Tau "Implicit loop breaker time constant, d" : Time := {: value <- 0.0005 ; group <- "Miscellaneous" :};
  };

  independent <- 
  { 
   OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
   OBJ FluxPerComponent (* hidden = "0" *) : MassFluxVector;
  };

  equations <-
  {

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.FluxPerComponent[Comp_Index],[independent.t]) =
       - (1 / parameters.Tau) *
       (state.FluxPerComponent[Comp_Index] - interface.Inflow[Comp_Index]);
   };

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.FluxPerComponent[Comp_Index];
   };

  };

:};




# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.loopbreaker.msl" 2





# 47 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.process_calculator.msl" 1
 


















CLASS BaseParameters
  "Base class for all process calculators, ie cost and process parameters"

  SPECIALISES
  PhysicalDAEModelType :=
  {:

    interface <-
    {
   
  OBJ V1 (* terminal = "in_1" *)"Volume of unit 1" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V2 (* terminal = "in_1" *)"Volume of unit 2" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V3 (* terminal = "in_1" *)"Volume of unit 3" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V4 (* terminal = "in_1" *)"Volume of unit 4" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V5 (* terminal = "in_1" *)"Volume of unit 5" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V6 (* terminal = "in_1" *)"Volume of unit 6" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V7 (* terminal = "in_1" *)"Volume of unit 7" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V8 (* terminal = "in_1" *)"Volume of unit 8" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V9 (* terminal = "in_1" *)"Volume of unit 9" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V10 (* terminal = "in_1" *)"Volume of unit 10" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
   
  OBJ TSS1 (* terminal = "in_1" *) "Tot.susp.solids (unit 1)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS2 (* terminal = "in_1" *) "Tot.susp.solids (unit 2)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS3 (* terminal = "in_1" *) "Tot.susp.solids (unit 3)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS4 (* terminal = "in_1" *) "Tot.susp.solids (unit 4)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS5 (* terminal = "in_1" *) "Tot.susp.solids (unit 5)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS6 (* terminal = "in_1" *) "Tot.susp.solids (unit 6)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS7 (* terminal = "in_1" *) "Tot.susp.solids (unit 7)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS8 (* terminal = "in_1" *) "Tot.susp.solids (unit 8)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS9 (* terminal = "in_1" *) "Tot.susp.solids (unit 9)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS10 (* terminal = "in_1" *) "Tot.susp.solids (unit 10)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
   
   
  OBJ Q_Waste (*terminal = "in_1" *) "Flow rate of waste sludge": FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
  OBJ TSS_waste (* terminal = "in_1" *) "Suspended solids in the waste sludge" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    };
  
  independent <-
    {
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

  parameters <-
    {
    };

  state <-
    {
  OBJ m_TSS (* hidden = "1" *) "Amount of sludge accumulated in the system" : Mass :={:group <- "Measurement data":};
    OBJ V (* hidden = "1" *) "Total volume of the tanks" : Volume := {: group <- "Dimension" :};
    };

  equations <-
    {
  state.m_TSS = interface.V1 * interface.TSS1 + interface.V2 * interface.TSS2 + interface.V3 * interface.TSS3
         + interface.V4 * interface.TSS4 + interface.V5 * interface.TSS5 + interface.V6 * interface.TSS6
         + interface.V7 * interface.TSS7 + interface.V8 * interface.TSS8 + interface.V9 * interface.TSS9
         + interface.V10 * interface.TSS10 ;
  state.V = interface.V1 + interface.V2 + interface.V3 + interface.V4 + interface.V5
        + interface.V6 + interface.V7 + interface.V8 + interface.V9 + interface.V10 ;
    };

  :};

  
CLASS OperationalParameters
  (* icon = "process_calculator" ; is_default = "true" *)
  "Calculation of the basic operational parameters of the plant: eg SRT, HRT"
 
 
 
 

  EXTENDS BaseParameters WITH
  {:
    comments <- "A model for the calculation of basic operational parameters";
    interface <-
    {
   
    OBJ TSS_out (* terminal = "in_1" *) "Sludge concentration in the effluent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
   
  OBJ Q_In (* terminal = "in_1" *) "Influent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational":};
  OBJ Q_Out (* terminal = "in_1" *) "Effluent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational" :};
   
    OBJ BOD_In (* terminal = "in_1" *) "BOD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ COD_In (* terminal = "in_1" *) "COD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    };

    state <-
    {
    OBJ SRT "Instantenous Sludge retention time" : Time := {: group <- "Operational" :};
    OBJ HRT "Hydraulic retention time" : Time := {: group <- "Operational" :};
    OBJ F_M_BOD "Food to microorganism ratio on BOD basis" : Rate := {: group <- "Operational" :};
    OBJ F_M_COD "Food to microorganism ratio on COD basis" : Rate := {: group <- "Operational" :};
    };

    equations <-
    {
   
    state.SRT =  IF ((interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste) <= 0)
                 THEN 0
                 ELSE state.m_TSS / (interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste);
   
    state.HRT = IF (interface.Q_In == 0)
        THEN 0
        ELSE state.V / interface.Q_In;
    state.F_M_BOD = IF (interface.Q_In == 0)
        THEN 0
        ELSE interface.BOD_In / (state.m_TSS / interface.Q_In);
    state.F_M_COD = IF (interface.Q_In == 0)
        THEN 0
        ELSE interface.COD_In / (state.m_TSS / interface.Q_In);
     };
  :};


# 48 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.evaluator.msl" 1
 


















CLASS OperationalCost
  (* icon = "cost" ; is_default = "true" *)
  "Calculation of the operational cost of the plant"

 
 
 
 
 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
   
    OBJ AerationEnergy1 (* terminal = "in_1" *) "AerationEnergy unit 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy2 (* terminal = "in_1" *) "AerationEnergy unit 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy3 (* terminal = "in_1" *) "AerationEnergy unit 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy4 (* terminal = "in_1" *) "AerationEnergy unit 4" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy5 (* terminal = "in_1" *) "AerationEnergy unit 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy6 (* terminal = "in_1" *) "AerationEnergy unit 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy7 (* terminal = "in_1" *) "AerationEnergy unit 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy8 (* terminal = "in_1" *) "AerationEnergy unit 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy9 (* terminal = "in_1" *) "AerationEnergy unit 9" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy10 (* terminal = "in_1" *) "AerationEnergy unit 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
   
   
    OBJ PumpingEnergy1 (* terminal = "in_1" *) "PumpingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy2 (* terminal = "in_1" *) "PumpingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy3 (* terminal = "in_1" *) "PumpingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy4 (* terminal = "in_1" *) "PumpingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy5 (* terminal = "in_1" *) "PumpingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy6 (* terminal = "in_1" *) "PumpingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy7 (* terminal = "in_1" *) "PumpingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy8 (* terminal = "in_1" *) "PumpingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy9 (* terminal = "in_1" *) "PumpingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy10 (* terminal = "in_1" *) "PumpingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy11 (* terminal = "in_1" *) "PumpingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy12 (* terminal = "in_1" *) "PumpingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy13 (* terminal = "in_1" *) "PumpingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy14 (* terminal = "in_1" *) "PumpingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy15 (* terminal = "in_1" *) "PumpingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy16 (* terminal = "in_1" *) "PumpingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy17 (* terminal = "in_1" *) "PumpingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy18 (* terminal = "in_1" *) "PumpingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy19 (* terminal = "in_1" *) "PumpingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy20 (* terminal = "in_1" *) "PumpingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
   
   
    OBJ MixingEnergy1 (* terminal = "in_1" *) "MixingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy2 (* terminal = "in_1" *) "MixingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy3 (* terminal = "in_1" *) "MixingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy4 (* terminal = "in_1" *) "MixingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy5 (* terminal = "in_1" *) "MixingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy6 (* terminal = "in_1" *) "MixingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy7 (* terminal = "in_1" *) "MixingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy8 (* terminal = "in_1" *) "MixingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy9 (* terminal = "in_1" *) "MixingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy10 (* terminal = "in_1" *) "MixingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy11 (* terminal = "in_1" *) "MixingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy12 (* terminal = "in_1" *) "MixingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy13 (* terminal = "in_1" *) "MixingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy14 (* terminal = "in_1" *) "MixingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy15 (* terminal = "in_1" *) "MixingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy16 (* terminal = "in_1" *) "MixingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy17 (* terminal = "in_1" *) "MixingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy18 (* terminal = "in_1" *) "MixingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy19 (* terminal = "in_1" *) "MixingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy20 (* terminal = "in_1" *) "MixingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
   
   
    OBJ TSS1 (* terminal = "in_1" *) "TSS1" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 1" :};
    OBJ TSS2 (* terminal = "in_1" *) "TSS2" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 2" :};
    OBJ Q_Pump_Waste1 (* terminal = "in_1" *) "Q_Pump sludge wastage 1" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ Q_Pump_Waste2 (* terminal = "in_1" *) "Q_Pump sludge wastage 2" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
   
   
    OBJ Q1_COD (* terminal = "in_1" *) "External COD dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q1_MeOH (* terminal = "in_1" *) "Metal dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_COD (* terminal = "in_1" *) "External COD dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_MeOH (* terminal = "in_1" *) "Metal dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_COD (* terminal = "in_1" *) "External COD dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_MeOH (* terminal = "in_1" *) "Metal dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    };

    parameters <-
    {
    OBJ F_AC "Aeration cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_PC "Pumping cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_MC "Mixing cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_SC "Sludge cost factor (Euro/kg)" : Ratio := {: value <- 0.58 ; group <- "Cost" :};
  OBJ C1_COD "COD cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C1_MeOH "Metal hydroxide cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_COD "COD cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_MeOH "Metal hydroxide cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_COD "COD cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_MeOH "Metal hydroxide cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
   
    OBJ TotalAerationEnergy "Aeration energy" : ElectricalEnergy := {: group <- "Energy" :};
   
    OBJ TotalPumpingEnergy "Pumping energy" : ElectricalEnergy := {: group <- "Energy" :};
   
    OBJ TotalMixingEnergy "Mixing energy" : ElectricalEnergy := {: group <- "Energy" :};
   
 
    OBJ SludgeProduction "Sludge production" : Mass := {: group <- "Sludge" :};
    OBJ Integ_SP (* hidden = "1" *)"Integral sludge production" : Mass ;
   
  OBJ CODdosed "External COD dosed" : Volume := {: group <- "Chemicals" :};
  OBJ MeOHdosed "Metal hydroxide dosed" : Volume := {: group <- "Chemicals" :};
    OBJ Integ_COD (* hidden = "1" *) "Integral ext.COD addition" : Volume ;
    OBJ Integ_MeOH (* hidden = "1" *) "Integral MeOH addition" : Volume ;
    OBJ Integ_ChemicalCost (* hidden = "1" *) "Integral cost of chemicals" : Euro ;
   
    OBJ AerationCost "Aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PumpingCost "Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MixingCost "Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SludgeCost "Sludge cost" : Euro := {: group <- "Cost" :};
    OBJ ChemicalCost "Cost of chemicals" : Euro := {: group <- "Chemicals" :};
    OBJ TotalCost "Total cost" : Euro := {: group <- "Cost" :};
    OBJ Prev_t (* hidden = "1" *) "Help variable for time" : Time ;
    OBJ Prev_TotalAerationEnergy (* hidden = "1" *) "Help variable to calculate the Periodical aeration cost" : ElectricalEnergy ;
    OBJ Prev_TotalPumpingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical pumping cost" : ElectricalEnergy ;
    OBJ Prev_TotalMixingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical mixing cost" : ElectricalEnergy ;
    OBJ Prev_Integ_SP (* hidden = "1" *) "Help variable to calculate the Periodical sludge cost" : Mass ;
    OBJ Prev_Integ_ChemicalCost (* hidden = "1" *) "Help variable to calculate the Periodical chemical cost (carbon addition)" : Euro ;
    OBJ AC_Period "Periodical aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PC_Period "Periodical Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MC_Period "Periodical Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SC_Period "Periodical sludge cost" : Euro := {: group <- "Cost" :};
    OBJ CC_Period "Periodical cost of COD addition" : Euro := {: group <- "Cost" :};
    OBJ TC_Period "Periodical total cost" : Euro := {: group <- "Cost" :};
    };

    equations <-
    {
   
   
  state.TotalAerationEnergy = interface.AerationEnergy1 + interface.AerationEnergy2 + interface.AerationEnergy3
                    + interface.AerationEnergy4 + interface.AerationEnergy5+ interface.AerationEnergy6 
                + interface.AerationEnergy7 + interface.AerationEnergy8 + interface.AerationEnergy9 
                + interface.AerationEnergy10;
   
   
   
   
   
  state.TotalPumpingEnergy = interface.PumpingEnergy1 + interface.PumpingEnergy2 + interface.PumpingEnergy3 + interface.PumpingEnergy4 
                 + interface.PumpingEnergy5 + interface.PumpingEnergy6  + interface.PumpingEnergy7 + interface.PumpingEnergy8 
                 + interface.PumpingEnergy9 + interface.PumpingEnergy10 + interface.PumpingEnergy11 + interface.PumpingEnergy12 
                 + interface.PumpingEnergy13 + interface.PumpingEnergy14 + interface.PumpingEnergy15+ interface.PumpingEnergy16 
                 + interface.PumpingEnergy17 + interface.PumpingEnergy18 + interface.PumpingEnergy19 + interface.PumpingEnergy20;
   
   
  state.TotalMixingEnergy = interface.MixingEnergy1 + interface.MixingEnergy2 + interface.MixingEnergy3 + interface.MixingEnergy4 
                + interface.MixingEnergy5 + interface.MixingEnergy6 + interface.MixingEnergy7 + interface.MixingEnergy8 
                + interface.MixingEnergy9 + interface.MixingEnergy10 + interface.MixingEnergy11 + interface.MixingEnergy12 
                + interface.MixingEnergy13 + interface.MixingEnergy14 + interface.MixingEnergy15+ interface.MixingEnergy16 
                + interface.MixingEnergy17 + interface.MixingEnergy18 + interface.MixingEnergy19 + interface.MixingEnergy20;
   
   
  DERIV(state.Integ_SP,[independent.t])= interface.TSS1 * interface.Q_Pump_Waste1 + interface.TSS2 * interface.Q_Pump_Waste2;
  state.SludgeProduction = state.Integ_SP ;
   
   
  DERIV(state.Integ_COD,[independent.t]) = interface.Q1_COD + interface.Q2_COD + interface.Q3_COD;
  DERIV(state.Integ_MeOH,[independent.t]) = interface.Q1_MeOH + interface.Q2_MeOH + interface.Q3_MeOH;
  state.CODdosed = state.Integ_COD;
  state.MeOHdosed = state.Integ_MeOH;
   
   
   
  state.AerationCost = state.TotalAerationEnergy * parameters.F_AC;
  state.PumpingCost = state.TotalPumpingEnergy * parameters.F_PC;
  state.SludgeCost = state.SludgeProduction * parameters.F_SC / 1000.0;
  state.MixingCost = state.TotalMixingEnergy * parameters.F_MC;
  DERIV(state.Integ_ChemicalCost,[independent.t]) =
      interface.Q1_COD * parameters.C1_COD + interface.Q2_COD  * parameters.C2_COD
      + interface.Q3_COD * parameters.C3_COD + interface.Q1_MeOH * parameters.C1_MeOH
      + interface.Q2_MeOH * parameters.C2_MeOH + interface.Q3_MeOH * parameters.C3_MeOH ;
  state.ChemicalCost = state.Integ_ChemicalCost;
  state.TotalCost = state.AerationCost + state.PumpingCost + state.SludgeCost + state.MixingCost + state.ChemicalCost;
   
    state.Prev_t =  IF (independent.t < previous(state.Prev_t))
          THEN 0
          ELSE
            IF  (independent.t - previous(state.Prev_t) < parameters.Period)
            THEN  previous(state.Prev_t)
            ELSE  independent.t;
  state.Prev_TotalAerationEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
              THEN previous(state.Prev_TotalAerationEnergy)
              ELSE state.TotalAerationEnergy;
  state.Prev_TotalPumpingEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_TotalPumpingEnergy)
                ELSE state.TotalPumpingEnergy;
  state.Prev_TotalMixingEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_TotalMixingEnergy)
                ELSE state.TotalMixingEnergy;
  state.Prev_Integ_SP = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_Integ_SP)
                ELSE state.Integ_SP;
  state.Prev_Integ_ChemicalCost = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Integ_ChemicalCost)
                ELSE state.Integ_ChemicalCost;
     
  state.AC_Period = parameters.F_AC * (state.TotalAerationEnergy - state.Prev_TotalAerationEnergy);
  state.PC_Period = parameters.F_PC * (state.TotalPumpingEnergy - state.Prev_TotalPumpingEnergy);
  state.MC_Period = parameters.F_MC * (state.TotalMixingEnergy - state.Prev_TotalMixingEnergy);
  state.SC_Period = parameters.F_SC * (state.Integ_SP - state.Prev_Integ_SP) / 1000.0 ;
  state.CC_Period = state.Integ_ChemicalCost - state.Prev_Integ_ChemicalCost;
  state.TC_Period = state.AC_Period + state.PC_Period + state.SC_Period + state.CC_Period + state.MC_Period;
    };
  :};

  
  

# 49 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.dosing_units.msl" 1
 


















 CLASS DosingUnit
 "A dosing unit model"
 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-
  {
   
   
   
  OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ Q_Dose (* terminal = "in_1"; manip = "1" *) "Flowrate of the solution" : 
      FlowRate := {: causality <- "CIN"; value <- 10 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };

  parameters <-
  {
  OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components"
        : SpecificVolumeVector;
  OBJ C_Dose "Concentration of the solution" : 
       Concentration := {: value <- 1 ; group <- "Concentration" :};
  OBJ MW (* hidden = "1" *) "Molecular weight of the chemical species dosed"
        : Real := {: group <- "System" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
  };

  independent <-
  {
  OBJ t "Time": Time := {: group <- "Time" :};
  };

  state <-
  {
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };
  initial <-
  {
  parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  };

  equations <-
  {
  interface.Outflow[IndexOfSolvent] = - interface.Q_Dose
      / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
  DERIV(state.Integ_PE,[independent.t])=  interface.Q_Dose;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };

 :};


 CLASS AdditionOfFermentationProducts
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {

   interface.Outflow[S_S] = - interface.Q_Dose * parameters.C_Dose *
      (parameters.COD / parameters.MW) ;

    




  };

:};



 CLASS AdditionOfFermentableCOD
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {

   interface.Outflow[S_S] = - interface.Q_Dose * parameters.C_Dose *
      (parameters.COD / parameters.MW) ;

    




  };

:};


# 153 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.dosing_units.msl"


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.acetate.msl" 1
 














 




 CLASS Acetate
 (* icon = "dosing_unit_acetate"; is_default = "true" *)
 "A simple model for dosage of acetate"
 EXTENDS AdditionOfFermentationProducts WITH
 {:
  comments <- "A model for the addition of acetate as external carbon source";
  
  interface <-
  {
  OBJ M_Acetate (* terminal = "out_2" *) "Amount of acetate dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Acetate (* terminal = "out_2" *) "Flow rate of acetate dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  
  OBJ C_Alk (* hidden = "1" *) "1/Alkalinity 'released' by acetate uptake" : 
       Mass := {: value <- 64.0 ; group <- "Concentration" :};
  
  };
  
  initial <-
  {
  parameters.COD = 64;
  parameters.MW = 60;
  };

  equations <-
  {
  
  interface.Outflow[S_ALK] = interface.Outflow[S_S] / parameters.C_Alk ;
  
   
  interface.M_Acetate = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Acetate = interface.Q_Dose ;
  };

:};


 


# 155 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.methanol.msl" 1
 



















 CLASS Methanol
 (* icon = "dosing_unit_methanol" *)
 "A simple model for dosage of methanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of methanol as external carbon source";

  interface <-
  {
  OBJ M_Methanol (* terminal = "out_2" *) "Amount of methanol dosed" : MassFlux
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Methanol (* terminal = "out_2" *) "Flow rate of methanol dosed" : FlowRate
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  initial <-
  {
  parameters.COD = 48;
  parameters.MW = 32;
  };

  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  equations <-
  {





   
  interface.M_Methanol = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Methanol = interface.Q_Dose ;
  };

:};



# 156 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.ethanol.msl" 1
 



















 CLASS Ethanol
 (* icon = "dosing_unit_ethanol" *)
 "A simple model for dosage of ethanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of ethanol as external carbon source";

  interface <-
  {
  OBJ M_Ethanol (* terminal = "out_2" *) "Amount of ethanol dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Ethanol (* terminal = "out_2" *) "Flow rate of ethanol dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  initial <-
  {
  parameters.COD = 96;
  parameters.MW = 46;
  };

  equations <-
  {





   
  interface.M_Ethanol = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Ethanol = interface.Q_Dose ;
  };

:};




# 157 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.alum.msl" 1
 


















# 49 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.alum.msl"


# 79 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.alum.msl"



# 158 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.ironhydroxide.msl" 1
 


















# 49 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\dosing_unit/wwtp.base.dosing_units.ironhydroxide.msl"



# 159 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.dosing_units.msl" 2



# 52 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sludge_dewatering.msl" 1
 


















CLASS SolidSeparationModel EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ OutflowPermeate (* terminal = "out_1" *) "Permeate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   OBJ OutflowConcentrate (* terminal = "out_3" *) "Concentrate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    
   };

   parameters <-
   { 
   OBJ rho_sludge "Specific gravity of dewatered sludge" : Concentration := {: value <- 1.07e6 ; group <- "Operational" :};
    
   OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    
   };

   state <-
   {
   OBJ Q_Permeate "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   OBJ Q_Concentrate_Actual "Concentrate flow rate" : FlowRate := {: group <- "Operational" :};
    
   OBJ Help_X_Sludge (* hidden = "1" *) "Working variable to calculate TSS in the concentrate" : MassFlux;
   OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the outflow" : Fraction ;
   };

   equations <-
   {
    
   
   state.Help_X_Sludge = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
               (- interface.OutflowConcentrate[Comp_Index]) * parameters.F_TSS_COD);
   
    
    
   


   };

 :};

 
 
 
CLASS EfficiencyDewateringModel
 "efficiency-based dewatering"
 EXTENDS SolidSeparationModel WITH
 {:

  interface <-
  {
  OBJ DS (* terminal = "out_2" *) "Dry solids" : Real := {: causality <- "COUT" ; group <- "Measurement" :};
  OBJ e_X (* terminal = "in_2"; manip = "1" *) "Separation efficiency (fraction of solids going to sludge flow)" :
    Fraction := {: causality <- "CIN" ; value <- 0.96; group <- "Operational" :}; 
  OBJ Q_Concentrate (* terminal = "in_2"; manip = "1" *) "Desired flow rate of the concentrated sludge" :
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
  };

  parameters <-
  { 
  };
 
  state <-
  {
  OBJ DrySolids "Dry solid content (of the cake)" : Real := {: group <- "Operational" :};
  };
  
  equations <-
  {
   
   
   
   
   
   
   
   
   
  state.DrySolids = IF (state.Q_Concentrate_Actual == 0.0)
              THEN 0.0
            ELSE 100.0 * (state.Help_X_Sludge / (state.Q_Concentrate_Actual * parameters.rho_sludge));
   
   
  state.Q_Concentrate_Actual = IF (state.Q_In <= interface.Q_Concentrate)
                     THEN state.Q_In
                     ELSE interface.Q_Concentrate;
   
  state.Q_Permeate = state.Q_In - state.Q_Concentrate_Actual;
   
   
   
  state.f_Out = IF (state.Q_In <= interface.Q_Concentrate)
            THEN 0
            ELSE (state.Q_In - interface.Q_Concentrate) / state.Q_In ;
   
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowPermeate[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out;
  };
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowConcentrate[Comp_Index] =
         - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out);
  };
   
   
   
   
   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowPermeate[Comp_Index] = IF (state.Q_Concentrate_Actual == 0.0)
                         THEN - state.InFluxPerComponent[Comp_Index]
                       ELSE - state.InFluxPerComponent[Comp_Index] * (1-interface.e_X);
  };   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowConcentrate[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * interface.e_X;
  };
   
  interface.DS = state.DrySolids ;
  }; 
 
 :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencythickener.msl" 1
 


















CLASS EfficiencyThickener
  (* icon = "dewatering_unit"; is_default = "true" *)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge thickener based on dewatering efficiency";
  :};


# 149 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencycentrifuge.msl" 1
 


















CLASS EfficiencyCentrifuge
  (* icon = "centrifuge"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 150 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencybeltpress.msl" 1
 


















CLASS EfficiencyBeltPress
  (* icon = "beltpress"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 151 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.sludge_dewatering.msl" 2





# 53 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl" 1
 














 





 CLASS AtomicBiofilm "The base equations for the Biofilm"
     SPECIALISES PhysicalDAEModelType :=
   {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal
       := {: causality <- "CIN" ; group <- "Influent":};
   OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal
       := {: causality <- "COUT" ; group <- "Effluent":};
   };
   
   parameters <- 
   {  
   OBJ Stoichiometry (* hidden = "1" *) "stoichiometry of the reactions" :
         PhysicalQuantityType[NrOfReactions;][NrOfComponents;];
   };

   independent <-
   {
   OBJ t "Time": Time := {: group <- "Time" :};
   };

   state <-
   {  
   OBJ Kla_Actual "Gas transfer coefficient" : OxygenTransferCoefficient := {: group <- "Operational" :};     
   OBJ Temp_Actual "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   OBJ Kinetics_Biofilm (* hidden = "1" *) "Kinetics of the biological processes within the biofilm" :
          Rate[NrOfReactions;][NrOfLayers;];
   OBJ Kinetics (* hidden = "1" *) "Kinetics of the biological processes in the bulk liquid" :
          Rate[NrOfReactions;];
   OBJ ConversionTermPerComponent (* hidden = "1" *) "Reaction term in the bulk liquid phase" : Rate[NrOfComponents;];   
    
   OBJ C_Biofilm "Concentration of each component per biofilm layer" : LayerConcentrationMatrix
          := {: group <- "Concentration" :};
   OBJ M_Biofilm "Mass of each component per biofilm layer" : Mass[NrOfComponents;][NrOfLayers;]

   := [{: value <- 4500 :}, {: value <- 0.01 :}, {: value <- 0.01 :},
   {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 0.01 :} ,
   {: value <- 0.01 :}, {: value <- 0.01 :},
   {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 1000 :},
   {: value <- 100 :}, {: value <- 0.01 :}, {: value <- 0.01 :}; ]

# 74 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl"
















;
   OBJ C "Concentration of each component in the bulk liquid": ConcentrationVector
          := {: group <- "Concentration" :};     
   OBJ V "Volume of the bulk liquid phase" : Volume:= {: group <- "Operational" :};
   };
 
   :};

 CLASS AtomicConversionBiofilm EXTENDS AtomicBiofilm WITH
   {:
    
   
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 1
 
















   interface <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.interface.msl" 1
 















 
    
    OBJ DO (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4 (* terminal = "out_2"; is_favorite = "1" *)"Ammonium concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ NO3 (* terminal = "out_2"; is_favorite = "1" *)"Nitrate+Nitrite concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2"; is_favorite = "1" *)"Total suspended solids concentration" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD (* terminal = "out_2" *)"Chemical Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   
    OBJ OfflineBOD (* terminal = "out_2" *)"Biological Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN (* terminal = "out_2" *)"Total nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   

    OBJ V_ASU (* terminal = "out_2" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU (* terminal = "out_2" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR (* terminal = "out_2" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR (* terminal = "out_2" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR (* terminal = "out_2" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU (* terminal = "out_2" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   parameters <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   state <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.state.msl" 1
 














 

    OBJ X_TSS "Total suspended solids" 
  : Concentration := {: group <- "Concentration" :};
  OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
  OBJ mu_H_Temp "mu_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ mu_A_Temp "mu_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_H_Temp  "b_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_A_Temp  "b_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_h_Temp  "k_h at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_a_Temp  "k_a at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ K_X_Temp  "K_X at the system temperature"
  : Real := {: group <- "Kinetic" :};

# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   initial <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 
















  parameters.Stoichiometry[AerGrowthHetero][S_S] :=  - 1 / (parameters.Y_H);
  parameters.Stoichiometry[AerGrowthHetero][S_O] :=  - (1 - parameters.Y_H) / parameters.Y_H;
  parameters.Stoichiometry[AerGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AerGrowthHetero][S_ALK] :=  - parameters.i_X_B / 14;
  parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AnGrowthHetero][S_S] :=  - 1 / parameters.Y_H;
  parameters.Stoichiometry[AnGrowthHetero][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
  parameters.Stoichiometry[AnGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
  parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AerGrowthAuto][S_O] :=  - (4.57 - parameters.Y_A) / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NH] :=  - parameters.i_X_B - 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_ALK] :=  - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
  parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
  parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_BH] :=  - 1;
  parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_BA] :=  - 1;
  parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] :=  - 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.0 / 14.0;
  parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrg][X_S] :=  - 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] :=  - 1;
  parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   equations <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 
















    state.X_TSS := (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

  state.Kinetics[AerGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
  state.Kinetics[AnGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
  state.Kinetics[AerGrowthAuto] := state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
  state.Kinetics[DecayOfHetero] := state.b_H_Temp * state.C[X_BH];
  state.Kinetics[DecayOfAuto] := state.b_A_Temp * state.C[X_BA];
  state.Kinetics[AmmonOfSolOrgN] := state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrg] := state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrgN] := (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);
  state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.sensors.msl" 1
 















 

  interface.DO = state.C[S_O];
  
  interface.NH4 = state.C[S_NH];
  
  interface.NO3 = state.C[S_NO];
  
  interface.TSS = state.X_TSS ; 
      
  interface.OnlineCOD = ( state.C[S_S] + state.C[S_I] + 
        state.C[X_BH] + state.C[X_BA] + state.C[X_S] 
          + state.C[X_I] + state.C[X_P]); 
          
  
  interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] 
             + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA])) ;
             
             
  interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
     + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OfflineTKN = ( state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
       + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OUR_ASU = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_O] / state.V)
     + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];

  interface.NUR = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_NO] / state.V)
     + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
   
  interface.NPR = IF (state.V == 0)
              THEN 0
              ELSE
     parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];   

  interface.AUR = IF (state.V == 0)
            THEN 0
            ELSE
     - (state.ConversionTermPerComponent[S_NH] / state.V);    
   
  interface.Kla_ASU = state.Kla_Actual;

  interface.V_ASU = state.V;

         
      
  
  

# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



























# 101 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl" 2

   :};

 CLASS AtomicConversionBiofilmBulk EXTENDS AtomicConversionBiofilm WITH
   {:
    
   
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.layer.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.layer.body.msl" 1
 

















   interface <-
   {
 
   };

   parameters <-
   {
 
   };

   state <-
   {
    
    
    
   };

   initial <-
   {
 
   };

   equations <-
   {
   
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.layer.kinetics.msl" 1
 
















    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;

  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerGrowthHetero][Layer_Index] := state.mu_H_Temp * (state.C_Biofilm[S_S][Layer_Index] / (parameters.K_S + state.C_Biofilm[S_S][Layer_Index])) * (state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NH][Layer_Index] / (parameters.K_NH_H + state.C_Biofilm[S_NH][Layer_Index])) * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnGrowthHetero][Layer_Index] := state.mu_H_Temp * (state.C_Biofilm[S_S][Layer_Index] / (parameters.K_S + state.C_Biofilm[S_S][Layer_Index])) * (parameters.K_OH / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NO][Layer_Index] / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index])) * (state.C_Biofilm[S_NH][Layer_Index] / (parameters.K_NH_H + state.C_Biofilm[S_NH][Layer_Index])) * parameters.n_g * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerGrowthAuto][Layer_Index] := state.mu_A_Temp * (state.C_Biofilm[S_NH][Layer_Index] / (parameters.K_NH + state.C_Biofilm[S_NH][Layer_Index])) * (state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OA + state.C_Biofilm[S_O][Layer_Index])) * state.C_Biofilm[X_BA][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[DecayOfHetero][Layer_Index] := state.b_H_Temp * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[DecayOfAuto][Layer_Index] := state.b_A_Temp * state.C_Biofilm[X_BA][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AmmonOfSolOrgN][Layer_Index] := state.k_a_Temp * state.C_Biofilm[S_ND][Layer_Index] * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[HydrolOfEntrOrg][Layer_Index] := state.k_h_Temp * (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index]) / (state.K_X_Temp + (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index])) * ((state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NO][Layer_Index] / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index]))) * state.C_Biofilm[X_BH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[HydrolOfEntrOrgN][Layer_Index] := (state.k_h_Temp * (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index]) / (state.K_X_Temp + (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_BH][Layer_Index])) * ((state.C_Biofilm[S_O][Layer_Index] / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C_Biofilm[S_O][Layer_Index])) * (state.C_Biofilm[S_NO][Layer_Index] / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index]))) * state.C_Biofilm[X_BH][Layer_Index]) * (state.C_Biofilm[X_ND][Layer_Index] / state.C_Biofilm[X_S][Layer_Index]);
  };
  
  

# 43 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.layer.body.msl" 2

 
   };
   


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.layer.body.msl" 2














# 107 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl" 2

   
   terminal <-  
   {
   };
   
   :};


 CLASS BaseBiofilm1D EXTENDS AtomicConversionBiofilmBulk WITH
 {:
 interface <-  
 {
 OBJ Kla (* terminal = "in_2"; manip = "1" *) "Gas transfer coefficient for oxygen" : 
   OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 750 ; group <- "Operational" :}; 
 OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
 }; 
 parameters <- 
 {  
 OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolume[NrOfComponents;];
  
  
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.BiofilmsDiffusivity.msl" 1
 















 OBJ D_x "Diffusivity coefficient for biomass" : Diffusivity := {: value <- 1e-10 ; group <- "Transport" :};
 OBJ D_i "Diffusivity coefficient" : Diffusivity[NrOfComponents;] 
 
 
   :=[{: value <- 1.0e-10 ; group <- "Transport":},{: value <- 1.0e-4 ;group <- "Transport":} , {: value <- 5.8e-5 ;group <- "Transport":},
   {: value <- 2.2e-4 ;group <- "Transport":} ,{: value <- 1.7e-4 ;group <- "Transport":} , {: value <- 1.7e-4 ;group <- "Transport":} ,
   {: value <- 1.4e-4 ;group <- "Transport":} ,{: value <- 2.2e-4 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} ,
   {: value <- 0 ;group <- "Transport":} ,{: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} ,
   {: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":}; ] 
 
 
 
# 36 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.BiofilmsDiffusivity.msl"

 
 






 
 







 ;
# 131 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl" 2

 OBJ dcmin (* hidden = "1" *) "Min concentration gradient that results in diffusion": Concentration := {: value <- 1E-6 ; group <- "System" :};
  
  
 OBJ d_ini "Initial biofilm thickness" : Length := {: value <- 0.0002 ; group <- "System" :};
 OBJ d_max "Maximum biofilm thickness" : Length := {: value <- 0.0005 ; group <- "Dimension" :};
 OBJ d_min (* hidden = "0" *) "Min biofilm thickness" : Length := {: value <- 5e-7 ; group <- "Dimension" :};
 OBJ A (* fixed = "1" *) "Total biofilm surface area" : Area := {: value <- 400; group <- "Dimension" :};
 OBJ eta "Porosity of the biofilm" : Ratio := {:value <- 1.0 ; group <- "Transport" :};
 OBJ deltao "Boundary layer" : Length := {:value <- 1E-5 ; group <- "Transport" :};
 OBJ rho "Biofilm density" : Density := {:value <- 40000 ;group <- "System" :};
 OBJ rho_layer (* hidden = "1" *) "Biofilm density of a layer": Density[NrOfLayers;] := {: group <- "System" :}; 
  
 OBJ k_At "Coefficient for attachment of particulates" : RateConstant:= {:value <- 0.1 ;group <- "Transport" :}; 
 OBJ k_detach "Factor of proportionality for the detachment controller": Real := {: value <- 1E5 ; group <- "System" :};
  
  
 OBJ V_R (* fixed = "1" *) "volume of the reactor" : Volume := {: value <- 1.0 ; group <- "Dimension" :};
 OBJ L "Length of the reactor" : Length := {:value <- 1.0 ; group <- "Dimension" :};
 OBJ H "Height of the reactor" : Length := {:value <- 1.0 ;group <- "Dimension" :};
 OBJ W "Width of reactor" : Length := {:value <- 1.0 ;group <- "Dimension" :};
  
  
 OBJ fc_real (* hidden = "1" *) "Portion of the reactor volume occupied by the solid support for the biofilm (true)" : Ratio := {: group <- "Dimension" :} ;
 OBJ fc (* hidden = "1" *) "Portion of the reactor volume occupied by the solid support for the biofilm (apparent)" : Ratio := {: value<- 0.5; group <- "Dimension" :} ;
 OBJ area_sp (* hidden = "1" *) "Specific surface area" : SpecificAreaVolume := {: value<- 80; group <- "System" :};
 OBJ Vc_real (* hidden = "1"; fixed = "1" *) "(true) volume of the carrier" : Volume := {: value <- 0.5 ; group <- "Dimension" :} ;
 OBJ Vc (* hidden = "1"; fixed = "1" *) "(apparent) volume of the carrier" : Volume := {: value <- 1 ; group <- "Dimension" :} ;

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 };
 
 state <-
 {    
 OBJ S_Sat (* hidden ="1" *) "Saturation concentration" : Concentration[NrOfComponents;];
  
 OBJ InFluxPerComponent (* hidden = "1" *) "Fluxes of all components through the process unit" : MassFluxVector; 
 OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
 OBJ Q_In "Influent flow rate" : FlowRate:= {: group <- "Operational" :};
  
 OBJ Total_Mass "Total mass of the biofilm ": Mass:= {: group <- "Mass" :};
 OBJ Mass_Layer "Mass of each component per layer" : Mass[NrOfLayers;] := {: group <- "Mass" :};  
 
 OBJ M "Mass of each component in the bulk liquid": MassVector   
 
   :=[{: value <- 4500 :}, {: value <- 10 :}, {: value <- 10 :},
   {: value <- 10 :}, {: value <- 10 :}, {: value <- 10 :} ,
   {: value <- 10 :}, {: value <- 10 :},
   {: value <- 10 :}, {: value <- 10 :}, {: value <- 100 :},
   {: value <- 100 :}, {: value <- 10 :}, {: value <- 10 :}; ]
 
 
# 193 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl"

 






 







 ;
  
 OBJ V_biofilm "Volume of the biofilm" : Volume:= {: group <- "Operational" :};
 OBJ V_layer "Volume of each biofilm layer" : VolumeVector := {: group <- "System" :}; 
  
  
 OBJ Detach_Term (* hidden = "1" *) "Detachment of each biofilm component": MassFluxVector := {: group <- "Transport" :};
 OBJ Reaction_Term_Biofilm (* hidden = "1" *) "Reaction term in the biofilm matrix" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_Term_Biofilm (* hidden = "1" *) "Diffustion term in the biofilm matrix" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_In (* hidden = "1" *) "Diffustion between layer 1 and bulk liquid" : Rate[NrOfComponents;];
 OBJ Diffusion_Through_Up (* hidden = "1" *) "Upward diffustion in layers 2 to ButOne" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_Through_Down (* hidden = "1" *) "Downward diffustion in layers 2 to Last" : Rate[NrOfComponents;][NrOfLayers;];
  
  
 OBJ u_Dt "Velocity of biofilm growth" : TakacsVelocityVector := {: group <- "System" :};
 OBJ d "Thickness of the biofilm" : Length:= {: group <- "Operational" :};
 OBJ d_layer "Thickness of each layer": LengthVector := {: group <- "System" :};  
 OBJ d_layer_calc (* hidden = "1" *) "Thickness of each layer" : LengthVector := {: group <- "System" :};
 OBJ d_test (* hidden = "1" *) "Thickness of the biofilm" : Length;
 OBJ delta (* hidden = "1" *) "Boundary layer for each component" : Length[NrOfComponents;]:= {: group <- "Transport" :};
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 };
 
 initial <-
 {
 parameters.WWTPSpecificVolume[H2O] := 1e-6;
 };

 equations <-
 {
  
 state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow[IndexOfSolvent] ;
 
 { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.InFluxPerComponent[Comp_Index] =
      SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
      In_Terminal[Comp_Index] ; };
  
  
  
 
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.Mass_Layer[Layer_Index] =
      SUMOVER Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
      state.M_Biofilm[Comp_Index][Layer_Index] ; };
 
 




 {state.Total_Mass = SUMOVER Layer_Index IN {1 .. NrOfLayers}: state.Mass_Layer[Layer_Index] ;};
  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.d_layer_calc[Layer_Index] =
          state.Mass_Layer[Layer_Index]/(parameters.A * parameters.rho_layer[Layer_Index]) ; };
  
  
  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.d_layer[Layer_Index] =
        IF (state.d_layer_calc[Layer_Index] >= (parameters.d_min/NrOfLayers))
           THEN state.d_layer_calc[Layer_Index]
           ELSE parameters.d_min/NrOfLayers ; };
  
  
  
 state.d = SUMOVER Layer_Index IN {1 .. NrOfLayers} : state.d_layer[Layer_Index] ;
  
  
  
  
  
  
 state.V = (parameters.V_R - parameters.Vc_real) - state.V_biofilm ;
 
 {FOREACH Layer_Index IN {1 .. NrOfLayers}: state.V_layer[Layer_Index] = parameters.A * state.d_layer[Layer_Index] ; };
 
 {state.V_biofilm = SUMOVER Layer_Index IN {1 .. NrOfLayers} : state.V_layer[Layer_Index] ; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}: state.delta[Comp_Index] = parameters.deltao ;};
  
  
 state.Kla_Actual = interface.Kla ;
 
      state.S_Sat[S_O] = state.S_O_Saturation;
 
  
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.ConversionTermPerComponent[Comp_Index] =
      SUMOVER Reaction_Index IN {1 .. NrOfReactions} :
      (state.Kinetics[Reaction_Index] * parameters.Stoichiometry[Reaction_Index][Comp_Index]) * state.V ; };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      state.Reaction_Term_Biofilm[Comp_Index][Layer_Index] =
      SUMOVER Reaction_Index IN {1 .. NrOfReactions} :
      (state.Kinetics_Biofilm[Reaction_Index][Layer_Index] * parameters.Stoichiometry[Reaction_Index][Comp_Index]) ; }; };
  
 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
      (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index])+
      (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}: Out_Terminal[Comp_Index]);};
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_In[Comp_Index][1] =
          IF (fabs(state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1]) > parameters.dcmin)
           THEN parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
           ELSE 0.0 ;  };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayersButOne} :
      state.Diffusion_Through_Down[Comp_Index][Layer_Index] =
          IF (fabs(state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) > parameters.dcmin)
           THEN parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
           ELSE 0.0 ; }; };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {2 .. NrOfLayers} :
      state.Diffusion_Through_Up[Comp_Index][Layer_Index] =
          IF (fabs(state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) > parameters.dcmin)
           THEN parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1]
           ELSE 0.0 ; }; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_Term_Biofilm[Comp_Index][1] =
        state.Diffusion_In[Comp_Index][1] - state.Diffusion_Through_Down[Comp_Index][1] ; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      state.Diffusion_Term_Biofilm[Comp_Index][Layer_Index] =
        state.Diffusion_Through_Up[Comp_Index][Layer_Index] - state.Diffusion_Through_Down[Comp_Index][Layer_Index] ; }; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_Term_Biofilm[Comp_Index][NrOfLayers] = state.Diffusion_Through_Up[Comp_Index][NrOfLayers] ; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.C[Comp_Index] = IF (state.V > 0.0)
      THEN state.M[Comp_Index] / state.V
      ELSE 0.0 ;};
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      state.C_Biofilm[Comp_Index][Layer_Index] =
      IF (state.V_layer[Layer_Index] > 0.0)
      THEN state.M_Biofilm[Comp_Index][Layer_Index] / state.V_layer[Layer_Index]
      ELSE 0.0 ; }; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      state.Detach_Term[Comp_Index] =
      SUMOVER Layer_Index IN {1 .. NrOfLayers} :
      (state.u_Dt[Layer_Index] * parameters.A * state.C_Biofilm[Comp_Index][Layer_Index]) ; };
 
 
  
 DERIV(state.M[IndexOfSolvent], [independent.t]) = 0.0 ; 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      DERIV(state.M[Comp_Index], [independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index]
      + state.ConversionTermPerComponent[Comp_Index]
 
      - parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
      ; };  
{FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV(state.M[Comp_Index], [independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index]
      + state.ConversionTermPerComponent[Comp_Index]
      - parameters.k_At * state.V * state.C[Comp_Index]
      + state.Detach_Term[Comp_Index] ; };  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      DERIV (state.M_Biofilm[IndexOfSolvent][Layer_Index], [independent.t])=0.0 ; };
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
        DERIV (state.M_Biofilm[Comp_Index][1], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][1] * state.V_layer[1]
 
      + parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
      - parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index] [1] - state.C_Biofilm[Comp_Index] [2]) * parameters.A / state.d_layer[1]
      ; };
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][1], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][1] * state.V_layer[1]
      + parameters.k_At * state.V * state.C[Comp_Index]
      - state.u_Dt[1] * parameters.A * state.C_Biofilm[Comp_Index][1]
      - parameters.D_x * (state.C_Biofilm[Comp_Index][1] - state.C_Biofilm[Comp_Index][2]) * parameters.A / state.d_layer[1] ; }; 
  
 {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
      DERIV (state.M_Biofilm[Comp_Index][Layer_Index], [independent.t]) =
          state.Reaction_Term_Biofilm [Comp_Index][Layer_Index] * state.V_layer[Layer_Index]
 
      + parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1]
      - parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
      ; }; };
 
 {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][Layer_Index], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][Layer_Index] * state.V_layer[Layer_Index]
      - state.u_Dt[Layer_Index]* parameters.A * state.C_Biofilm[Comp_Index][Layer_Index]
      - parameters.D_x * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
      + parameters.D_x * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1] ; }; };
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
      DERIV (state.M_Biofilm[Comp_Index][NrOfLayers], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][NrOfLayers] * state.V_layer[NrOfLayers]
 
      + parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][NrOfLayersButOne] - state.C_Biofilm[Comp_Index][NrOfLayers]) * parameters.A / state.d_layer[NrOfLayersButOne]
      ;};
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][NrOfLayers], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][NrOfLayers] * state.V_layer[NrOfLayers]
      - state.u_Dt[NrOfLayers]* parameters.A * state.C_Biofilm[Comp_Index][NrOfLayers]
      + parameters.D_x * (state.C_Biofilm[Comp_Index][NrOfLayersButOne] - state.C_Biofilm[Comp_Index][NrOfLayers]) * parameters.A / state.d_layer[NrOfLayersButOne] ; };
  
  
 interface.Outflow[IndexOfSolvent] = - interface.Inflow[IndexOfSolvent] ;
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      interface.Outflow[Comp_Index] = - state.Q_In * state.C[Comp_Index] ; };

    state.Temp_Actual = interface.Temp;

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 }; 
 
:};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\biofilm/wwtp.base.biofilms.ifas1D.msl" 1
 


















CLASS IFAS1D (* icon = "ifas"; is_default = "true" *)
 "A model for an Integrated Fixed film Activated Sludge unit, based on the biofilm model by Van Hulle and Vanrolleghem"
 EXTENDS BaseBiofilm1D WITH
 {:
    
    comments <- "A model for an Integrated Fixed film Activated Sludge unit. Detachment when d>dmax and proportional to (d-dmax)^2";
    interface <-
    {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };
    parameters <- 
    {  
       OBJ f_solid "Fraction of the solid support to the total volume of the reactor" : Ratio := {:value <- 0.05 ; group <- "Dimension" :} ;
     OBJ A_Sp_C "(carrier) Specific surface area" : SpecificAreaVolume := {:value <- 400 ; group <- "System" :};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
    };
    
      state <-
    {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
    };
     
    initial <-
    {
      
     parameters.fc = parameters.f_solid ;
     parameters.fc_real = parameters.f_solid ;
     parameters.area_sp = parameters.A_Sp_C ;
      
      
     parameters.V_R = parameters.L * parameters.W * parameters.H ;
     parameters.Vc_real = parameters.fc_real * parameters.V_R ;
     parameters.Vc = parameters.fc * parameters.V_R ;
      
     parameters.A = parameters.area_sp * parameters.Vc ;
      
      
     {FOREACH Layer_Index IN {1 .. NrOfLayers}:
          parameters.rho_layer[Layer_Index]=parameters.eta*parameters.rho ; };
      
     state.M[IndexOfSolvent] = ((parameters.V_R - parameters.Vc_real) - (parameters.A*parameters.d_ini)) / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    };
 
    equations <-
    {
     
    {FOREACH Layer_Index IN {1 .. NrOfLayers} : state.u_Dt[Layer_Index] =
           IF ( state.d_layer_calc[Layer_Index] <= (parameters.d_max/NrOfLayers) )
            THEN 0.0
          ELSE parameters.k_detach * pow(( state.d_layer_calc[Layer_Index] - (parameters.d_max/NrOfLayers) ),2) ; 
       };

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
          
    }; 

 :};


# 446 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\biofilm/wwtp.base.biofilms.tricklingfilter1D.msl" 1
 


















CLASS TricklingFilter1D (* icon = "trickling_filter"; is_default = "true" *)
 "A model for a 1D-biofilm by Van Hulle and Vanrolleghem"
 EXTENDS BaseBiofilm1D WITH
 {:
    
    comments <- "A model for a trickling filter. Detachment when d>dmax and proportional to (d-dmax)^2";
    
    parameters <- 
    {  
       OBJ f_void "Void space of the media" : Ratio := {:value <- 0.5 ; group <- "Dimension" :} ;
     OBJ A_Sp_R "(reactor) Specific surface area" : SpecificAreaVolume := {:value <- 400 ; group <- "System" :};
    };
 
    initial <-
    {
     parameters.fc = 1.0 ;   
     parameters.fc_real = 1.0 - parameters.f_void ;
     parameters.area_sp = parameters.A_Sp_R ;
      
      
     parameters.V_R = parameters.L * parameters.W * parameters.H ;
     parameters.Vc_real = parameters.fc_real * parameters.V_R ;
     parameters.Vc = parameters.fc * parameters.V_R ;
      
     parameters.A = parameters.area_sp * parameters.fc * parameters.V_R ;
      
      
     {FOREACH Layer_Index IN {1 .. NrOfLayers}:
          parameters.rho_layer[Layer_Index]=parameters.eta*parameters.rho ; };
      
     state.M[IndexOfSolvent] = ((parameters.V_R - parameters.Vc_real) - (parameters.A*parameters.d_ini)) / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
    };
 
    equations <-
    {
     
    {FOREACH Layer_Index IN {1 .. NrOfLayers} : state.u_Dt[Layer_Index] =
           IF ( state.d_layer_calc[Layer_Index] <= (parameters.d_max/NrOfLayers) )
            THEN 0.0
          ELSE parameters.k_detach * pow(( state.d_layer_calc[Layer_Index] - (parameters.d_max/NrOfLayers) ),2) ; };
    }; 

 :};



# 447 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.biofilms.msl" 2





# 55 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 1
 




















 CLASS WWTPAtomicModelWithMembraneVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:

  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
  OBJ Outflow (* terminal = "out_1" *)"Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ OutflowConcentrate (* terminal = "out_3" *) "Concentrate flow rate" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ A_0 (* terminal = "in_2"; manip = "1" *) "Initial membrane surface area" : 
      Area := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
  };

  parameters <-
  {
  OBJ f_nr "Non-retainable fraction of suspended solids" : Fraction := {: value <- 0.000 ; group <- "Settling" :};
  };

  state <-
  {
  OBJ Q_Out_Membrane_Help (* hidden = "1" *) "Permeate flowrate" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Out_Membrane "Effluent flow rate through the membrane" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Concentrate "Concentrate flow rate" : FlowRate := {: group <- "Operational" :};
  };
  
  initial <-
  {
  };
 
  equations <-
  {
  state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow[IndexOfSolvent];

   
   
  state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

   
  {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
         state.C[Comp_Index] = IF (state.V == 0.0)
          THEN 0.0
        ELSE state.M[Comp_Index]/state.V ; };

  interface.OutflowConcentrate[IndexOfSolvent] = - state.Q_Concentrate / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
         interface.OutflowConcentrate[Comp_Index] = - state.C[Comp_Index] * state.Q_Concentrate ;};

  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
         interface.OutflowConcentrate[Comp_Index] = - state.C[Comp_Index] * state.Q_Concentrate * (1- parameters.f_nr) ; };
  };

 :};

 CLASS IdealMembraneVolumeClass EXTENDS WWTPAtomicModelWithMembraneVolume WITH
 {:
  interface <-  
  {
  OBJ T1 (* terminal = "in_2"; manip = "1" *) "Relaxation1 period" :   
      Time := {: causality <- "CIN" ; value <- 0.00008101851852 ; group <- "Operational" :};
  OBJ T2 (* terminal = "in_2"; manip = "1" *) "Filtration period" : 
      Time := {: causality <- "CIN" ; value <- 0.005208333 ; group <- "Operational" :};
  OBJ T3 (* terminal = "in_2"; manip = "1" *) "Relaxation2 period" : 
      Time := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ T4 (* terminal = "in_2"; manip = "1" *) "Backwashing period" : 
      Time := {: causality <- "CIN" ; value <- 0.000208333 ; group <- "Operational" :};
   
  OBJ J11 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation1 period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J12 (* terminal = "in_2"; manip = "1" *) "Filtration flux in filtration period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};   
  OBJ J13 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation2 period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J14 (* terminal = "in_2"; manip = "1" *) "Filtration flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ u14 (* terminal = "in_2"; manip = "1" *) "Backwash flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};

  };
  parameters <-
  {
  };

  state <-  
  {
  OBJ J1 "Average Filtration flux" : Velocity := {: group <- "Operational" :};   
  };
  initial <-
  {
  };
  
  equations <-
  {
  state.J1 =
      (interface.J11 * interface.T1 + interface.J12 * interface.T2 + interface.J13 * interface.T3 + (interface.J14 - interface.u14) * interface.T4 )
    / (interface.T1 + interface.T2 + interface.T3 + interface.T4);

  state.Q_Out_Membrane_Help = state.J1 * interface.A_0 ;     
  state.Q_Out = state.Q_Out_Membrane;
  
  interface.Outflow[IndexOfSolvent] = - state.Q_Out_Membrane / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
         interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out_Membrane; };

  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
         interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out_Membrane * parameters.f_nr; };
  };

 :};


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\internal_membrane/wwtp.base.internal_membrane.membraneideal.msl" 1
 


















CLASS MembraneIdeal
 (* icon = "membrane" *)
 "Simple membrane filtration model"
 EXTENDS IdealMembraneVolumeClass WITH
 {:

  comments <- "A model for an external membrane unit (fouling is not modelled)";

  interface <-
  {
  OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Permeate" :};
  OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Concentrate" :};
  OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };

  parameters <-
  {
  OBJ V_Tank "Tank volume " : Volume := {: value <- 100; group <- "Dimension" :};
  
  OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  
 
    OBJ TMP "Trans-membrane pressure" : PressureDifference := {: value <- 35000 ; group <- "Energy" :};
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
  };

  state <-
  {
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
  };
    
  initial <-
  {
  state.M[IndexOfSolvent] = parameters.V_Tank / parameters.WWTPSpecificVolume[IndexOfSolvent]; 
  };

  equations <-
  {
  state.Q_Out_Membrane = IF ((state.Q_In - state.Q_Out_Membrane_Help) <= 0)
      THEN state.Q_In
    ELSE state.Q_Out_Membrane_Help;

  state.Q_Concentrate = IF ((state.Q_In - state.Q_Out_Membrane) <= 0)
      THEN 0
    ELSE state.Q_In - state.Q_Out_Membrane;

  
  interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
      (- interface.Outflow[Comp_Index]) * parameters.F_TSS_COD);
  interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
      (- interface.OutflowConcentrate[Comp_Index]) * parameters.F_TSS_COD);
  
   
  




 
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * parameters.TMP / (3600000.0 * parameters.n_Pump_Membrane);
 
 
  interface.PumpingEnergy = state.Integ_PE_Membrane;
  };

 :};


# 134 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2


 CLASS InternalIdealMembraneVolumeModel EXTENDS IdealMembraneVolumeClass WITH
 {:

  interface <-
  {
  OBJ Overflow (* terminal = "out_4" *)"Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ Q_Pump (* terminal = "in_2"; manip = "1" *) "Concentrate flow rate" : 
      FlowRate := {: causality <- "CIN" ; group <- "Operational" :} ;
  };

  parameters <-
  {
  OBJ V_Min "Minimum allowed tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  OBJ V_Tank "Tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  };

  state <-
  {
  OBJ Q_Over "Overflow rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
  state.Q_Out_Membrane = IF (state.V > parameters.V_Min)
                 THEN state.Q_Out_Membrane_Help
             ELSE 0.0 ;

  state.Q_Concentrate = IF (state.V > parameters.V_Min)
      THEN interface.Q_Pump
    ELSE 0.0 ;

  state.Q_Over = IF (state.V > parameters.V_Tank)
      THEN
      IF (state.Q_In  >= (state.Q_Out_Membrane + state.Q_Concentrate))
         THEN state.Q_In - state.Q_Out_Membrane - state.Q_Concentrate
         ELSE 0.0
    ELSE 0.0 ;

  interface.Overflow[IndexOfSolvent] = - state.Q_Over / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      interface.Overflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Over ;};
  };

 :};
 
 
 
 CLASS InternalIdealMembraneVolumeConversionModel EXTENDS InternalIdealMembraneVolumeModel WITH
 {:
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 186 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2

 :};

  

 CLASS InternalIdealMembraneVolumeASMConversionModel EXTENDS InternalIdealMembraneVolumeConversionModel WITH
 {:
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 1
 
















   interface <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.interface.msl" 1
 















 
    
    OBJ DO (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4 (* terminal = "out_2"; is_favorite = "1" *)"Ammonium concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ NO3 (* terminal = "out_2"; is_favorite = "1" *)"Nitrate+Nitrite concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2"; is_favorite = "1" *)"Total suspended solids concentration" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD (* terminal = "out_2" *)"Chemical Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   
    OBJ OfflineBOD (* terminal = "out_2" *)"Biological Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN (* terminal = "out_2" *)"Total nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   

    OBJ V_ASU (* terminal = "out_2" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU (* terminal = "out_2" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR (* terminal = "out_2" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR (* terminal = "out_2" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR (* terminal = "out_2" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU (* terminal = "out_2" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   parameters <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   state <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.state.msl" 1
 














 

    OBJ X_TSS "Total suspended solids" 
  : Concentration := {: group <- "Concentration" :};
  OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
  OBJ mu_H_Temp "mu_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ mu_A_Temp "mu_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_H_Temp  "b_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_A_Temp  "b_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_h_Temp  "k_h at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_a_Temp  "k_a at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ K_X_Temp  "K_X at the system temperature"
  : Real := {: group <- "Kinetic" :};

# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   initial <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 
















  parameters.Stoichiometry[AerGrowthHetero][S_S] :=  - 1 / (parameters.Y_H);
  parameters.Stoichiometry[AerGrowthHetero][S_O] :=  - (1 - parameters.Y_H) / parameters.Y_H;
  parameters.Stoichiometry[AerGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AerGrowthHetero][S_ALK] :=  - parameters.i_X_B / 14;
  parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AnGrowthHetero][S_S] :=  - 1 / parameters.Y_H;
  parameters.Stoichiometry[AnGrowthHetero][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
  parameters.Stoichiometry[AnGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
  parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AerGrowthAuto][S_O] :=  - (4.57 - parameters.Y_A) / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NH] :=  - parameters.i_X_B - 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_ALK] :=  - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
  parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
  parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_BH] :=  - 1;
  parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_BA] :=  - 1;
  parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] :=  - 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.0 / 14.0;
  parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrg][X_S] :=  - 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] :=  - 1;
  parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   equations <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 
















    state.X_TSS := (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

  state.Kinetics[AerGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
  state.Kinetics[AnGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
  state.Kinetics[AerGrowthAuto] := state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
  state.Kinetics[DecayOfHetero] := state.b_H_Temp * state.C[X_BH];
  state.Kinetics[DecayOfAuto] := state.b_A_Temp * state.C[X_BA];
  state.Kinetics[AmmonOfSolOrgN] := state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrg] := state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrgN] := (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);
  state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.sensors.msl" 1
 















 

  interface.DO = state.C[S_O];
  
  interface.NH4 = state.C[S_NH];
  
  interface.NO3 = state.C[S_NO];
  
  interface.TSS = state.X_TSS ; 
      
  interface.OnlineCOD = ( state.C[S_S] + state.C[S_I] + 
        state.C[X_BH] + state.C[X_BA] + state.C[X_S] 
          + state.C[X_I] + state.C[X_P]); 
          
  
  interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] 
             + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA])) ;
             
             
  interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
     + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OfflineTKN = ( state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
       + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OUR_ASU = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_O] / state.V)
     + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];

  interface.NUR = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_NO] / state.V)
     + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
   
  interface.NPR = IF (state.V == 0)
              THEN 0
              ELSE
     parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];   

  interface.AUR = IF (state.V == 0)
            THEN 0
            ELSE
     - (state.ConversionTermPerComponent[S_NH] / state.V);    
   
  interface.Kla_ASU = state.Kla_Actual;

  interface.V_ASU = state.V;

         
      
  
  

# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



























# 193 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2

 :};

 CLASS InternalIdealMembraneVolumeClass
 EXTENDS InternalIdealMembraneVolumeASMConversionModel WITH
 {:
  
  interface <-
  {
  OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Permeate" :};
  OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Concentrate" :};
  };

  equations <-
  {
  
  interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
             (- interface.Outflow[Comp_Index]) / state.Q_Out_Membrane * parameters.F_TSS_COD);
  interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
           (- interface.OutflowConcentrate[Comp_Index]) / state.Q_Concentrate * parameters.F_TSS_COD);
  
   
  



  };

:};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\mbr/wwtp.base.mbr.mbrideal.msl" 1
 


















 CLASS MBRIdeal
 (* icon = "mbr" *)
 "Simple MBR filtration model"
 EXTENDS InternalIdealMembraneVolumeClass WITH
 {:
  comments <- "A model for an MBR unit (fouling is not modelled)";
  interface <-  
  {
   OBJ Kla (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };   
  
  parameters <-
  {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ TMP "Trans-membrane pressure" : PressureDifference := {: value <- 35000 ; group <- "Energy" :};
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ F_Energy_FlowRate_Concentrate "Conversion factor Energy needed/Pump flow rate for the concentrate pump" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
    OBJ Integ_PE_Concentrate (* hidden = "1" *)"Integral Pumping energy for the concentrate pump" : ElectricalEnergy ;
  };
  
  initial <-
  {
  };

  equations <-
  {
  state.Kla_Actual = interface.Kla;
  state.Temp_Actual = interface.Temp;

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * parameters.TMP / (3600000.0 * parameters.n_Pump_Membrane);
 
 
  DERIV(state.Integ_PE_Concentrate,[independent.t])=  state.Q_Concentrate;
  interface.PumpingEnergy = state.Integ_PE_Membrane + parameters.F_Energy_FlowRate_Concentrate * state.Integ_PE_Concentrate;
  };
:};


# 223 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2


 CLASS FoulingMembraneVolumeClass EXTENDS WWTPAtomicModelWithMembraneVolume WITH
 {:

  interface <-
  {
  OBJ Inflow_Backwash (* terminal = "in_3" *) "Backwash" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   
  OBJ Q_Backwash_Control (* terminal = "out_2" *) "Backwash trigger" : 
   Real := {: causality <- "COUT" ; group <- "Control action" :};
  OBJ P_TMP (* terminal = "out_2" *) "TMP" : 
      PressureDifference := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ T1 (* terminal = "in_2"; manip = "1" *) "Relaxation1 period" : 
      Time := {: causality <- "CIN" ; value <- 0.00008101851852 ; group <- "Operational" :};
  OBJ T2 (* terminal = "in_2"; manip = "1" *) "Filtration period" : 
      Time := {: causality <- "CIN" ; value <- 0.005208333 ; group <- "Operational" :};
  OBJ T3 (* terminal = "in_2"; manip = "1" *) "Relaxation2 period" : 
      Time := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ T4 (* terminal = "in_2"; manip = "1" *) "Backwashing period" : Time := {: causality <- "CIN" ; value <- 0.000208333 ; group <- "Operational" :};
   
  OBJ J11 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation1 period" :    
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J12 (* terminal = "in_2"; manip = "1" *) "Filtration flux in filtration period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};   
  OBJ J13 (* terminal = "in_2"; manip = "1" *) "Filtration flux in relaxation2 period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
  OBJ J14 (* terminal = "in_2"; manip = "1" *) "Filtration flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.0 ; group <- "Operational" :};
   
  OBJ u14 (* terminal = "in_2"; manip = "1" *) "Backwash flux in backwashing period" : 
      Velocity := {: causality <- "CIN" ; value <- 0.7632 ; group <- "Operational" :};
  OBJ C_SMP (* terminal = "in_2"; manip = "1" *) "Concentration of Colloidal material" : 
      Concentration  := {: causality <- "CIN" ; value <- 100.0 ; group <- "Operational" :} ;
  };

  parameters <-
  {
  OBJ J_crit "Critical filtration flux" : Velocity := {: value <- 2.3 ; group <- "Operational" :};
  OBJ eta_20 "Viscosity of the permeate at 20 degrees" : DynamicViscosity := {: value <- 1.16E-8 ; group <- "Operational" :};
  OBJ E_alfa "Factor for temperature correction of viscosity" : Real := {: value <- 1.94 ; group <- "Operational" :}; 
  OBJ E_beta "Factor for temperature correction of viscosity" : Real := {: value <- 4.80 ; group <- "Operational" :}; 
  OBJ E_gamma "Factor for temperature correction of viscosity" : Real := {: value <- 6.74 ; group <- "Operational" :}; 
   
  OBJ R_m "Membrane resistance" : FiltrationResistance := {: value <- 4.1E+11 ; group <- "Operational" :};
  OBJ R_alfa "Specific cake resistance [m/g]"  : SpecificLength := {: value <- 3.6E+12 ; group <- "Operational" :}; 
  OBJ R_beta "Semi-empirical exponent for solid deposition"  : Real := {: value <- 3.5 ; group <- "Operational" :}; 
  OBJ sigma_X_TSS "Irreversibly blocked membrane area per unit of TSS" : Real := {: value <- 0.0003 ; group <- "Operational" :};
   
  };

  state <-
  {
  OBJ T "Complete cycle" : Time := {: group <- "Operational" :};
  OBJ t_rel (* hidden = "1" *) "Time relative to the beginning of each cycle" : Time ;
  OBJ Q_Backwash "Backwashing flowrate" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Out_Backwash "Excess flow of the backwash going to the outflow" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Backwash_Help (* hidden = "1" *) "Backwash flow based on the flux" : FlowRate := {: group <- "Operational" :};
  OBJ Q_Backwash_Available "Available flow for backwash" : FlowRate := {: group <- "Operational" :};
  OBJ f_Out_Backwash (* hidden = "1" *) "fraction of the backwash flow going to the outflow" : Fraction := {: group <- "Operational" :};
  OBJ K_Temp (* hidden = "1" *) "Operating temperature" : KelvinTemperature ;
  OBJ eta_T "Viscosity of the permeate" : DynamicViscosity := {: group <- "Operational" :};
   
  OBJ R_c "(reversible) Cake resistance" : FiltrationResistance := {: group <- "Operational" :};
  OBJ R_irr "Irreversible resistance" : FiltrationResistance := {: group <- "Operational" :};
  OBJ R_tot "Total filtration resistance" : FiltrationResistance := {: group <- "Operational" :};
  OBJ A "Membrane surface area" : Area := {: group <- "Operational" :};
  OBJ A_Blocked "Blocked membrane surface area" : Area := {: group <- "Operational" :};
  OBJ Solids (* hidden = "1" *) "Solids concentration in the stream" : Concentration := {: group <- "Operational" :};
   
  OBJ TMP "Trans-membrane pressure" : PressureDifference := {: group <- "Operational" :};
  OBJ J_act "Actual filtration flux" : Velocity := {: group <- "Operational" :};
  OBJ J_app "Apparent filtration flux" : Velocity := {: group <- "Operational" :};
   
  OBJ C_cake "Concentration of total solids in the cake" : Concentration := {: group <- "Concentration" :};
  OBJ M_cake "Mass of the cake" : Mass := {: group <- "Mass" :};
   
  OBJ M_cake_Help (* hidden = "1" *) "Computed mass of the cake" : Mass := {: group <- "Mass" :};
  OBJ M_cake_cumul "Mass of the cake at the end of each cycle" : Mass := {: group <- "Mass" :};
  };

  initial <-
  {
  state.M_cake_cumul = 0.0 ;  
  };
  
  equations <-
  {
  state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;
  
  state.t_rel = IF (independent.t < state.T)
      THEN independent.t
    ELSE independent.t - state.T * (floor(independent.t/state.T)) ;

  state.Q_Out_Membrane_Help = IF (state.t_rel < interface.T1)
      THEN interface.J11 * interface.A_0             
    ELSE
      IF (state.t_rel < (interface.T1 + interface.T2))
            THEN interface.J12 * interface.A_0         
          ELSE
            IF (state.t_rel < (interface.T1 + interface.T2 + interface.T3))
                  THEN interface.J13 * interface.A_0       
                ELSE interface.J14 * interface.A_0 ;     

  state.Q_Backwash_Help = IF (state.t_rel < interface.T1)
      THEN 0.0             
    ELSE
      IF (state.t_rel < (interface.T1 + interface.T2))
            THEN 0.0         
          ELSE
            IF (state.t_rel < (interface.T1 + interface.T2 + interface.T3))
                  THEN 0.0       
                      ELSE interface.u14 * interface.A_0 ;     

  state.Q_Backwash_Available = IF (interface.Inflow_Backwash[IndexOfSolvent] <= 0.0)
      THEN 0.0
    ELSE parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow_Backwash[IndexOfSolvent];
  
  state.Q_Backwash = IF (state.Q_Backwash_Available <= state.Q_Backwash_Help)
      THEN state.Q_Backwash_Available
    ELSE state.Q_Backwash_Help;

   
  state.Q_Out_Backwash = state.Q_Backwash_Available - state.Q_Backwash ;
   
  state.f_Out_Backwash = IF (state.Q_Backwash_Available == 0.0)
      THEN 0.0
    ELSE state.Q_Out_Backwash / state.Q_Backwash_Available; 

  state.Q_Out = state.Q_Out_Membrane + state.Q_Out_Backwash;
  
 

   
   
  state.eta_T = parameters.eta_20 * exp(- parameters.E_alfa - parameters.E_beta * (293/state.K_Temp)
      + parameters.E_gamma * pow(293/state.K_Temp, 2) ) ;
   
   
   
   
  DERIV(state.A_Blocked, [independent.t]) = parameters.sigma_X_TSS * interface.C_SMP * state.Q_Out_Membrane ;
  state.A = interface.A_0 - state.A_Blocked;
   
   
  state.R_irr = parameters.R_m * (interface.A_0/state.A - 1) ;
   
   
  state.J_act = state.Q_Out_Membrane / state.A ;
  state.J_app = IF (state.t_rel < interface.T1)
      THEN 0.0                                   
    ELSE
      IF (state.t_rel < (interface.T1 + interface.T2))
            THEN state.Q_Out_Membrane / interface.A_0            
          ELSE
            IF (state.t_rel < (interface.T1 + interface.T2 + interface.T3))
                  THEN 0.0                           
                ELSE - state.Q_Backwash / interface.A_0 ;    
   
   
  state.C_cake = state.Solids * pow((state.J_act/parameters.J_crit), parameters.R_beta) ;
  DERIV(state.M_cake_Help,[independent.t]) = state.C_cake * state.Q_Out_Membrane ;
  state.M_cake_cumul = IF (state.t_rel <= (interface.T1+interface.T2+interface.T3))
      THEN previous(state.M_cake_cumul)
    ELSE state.M_cake_Help ;
  state.M_cake = fabs(state.M_cake_cumul - state.M_cake_Help) ;
   
  state.R_c = parameters.R_alfa * state.M_cake / interface.A_0 ;
   
   
  state.R_tot = parameters.R_m + state.R_irr + state.R_c ;
   
   
  state.TMP = state.eta_T * state.J_app * state.R_tot ;
   
  interface.Outflow[IndexOfSolvent] = - (state.Q_Out_Membrane + state.Q_Out_Backwash) / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
  
  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
         interface.Outflow[Comp_Index] = - (state.C[Comp_Index] * state.Q_Out_Membrane + state.f_Out_Backwash * interface.Inflow_Backwash[Comp_Index]); };

  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
         interface.Outflow[Comp_Index] = - (state.C[Comp_Index] * state.Q_Out_Membrane * parameters.f_nr + state.f_Out_Backwash * interface.Inflow_Backwash[Comp_Index]); };

   
  interface.P_TMP = state.TMP ;
  interface.Q_Backwash_Control = state.Q_Backwash_Help ;
  };

 :};

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\internal_membrane/wwtp.base.internal_membrane.membranewithfouling.msl" 1
 


















 CLASS MembraneWithFouling
 (* icon = "membrane"; is_default = "true" *)
 "Membrane filtration model extended with the computation of the TMP"
 EXTENDS FoulingMembraneVolumeClass WITH
 {:

  comments <- "A model for an external membrane unit, subjected to fouling (the trans-membrane pressure is computed)";

  interface <-
  {
  OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Permeate" :};
  OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Concentrate" :};
  OBJ Temp (* terminal = "in_2"; manip = "1" *)   "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
  OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };

  parameters <-
  {
  OBJ V_Tank "Tank volume " : Volume := {: value <- 100; group <- "Dimension" :};
  
  OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  
 
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ n_Pump_Backwash "Pump efficiency of the backwash pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
    OBJ Integ_PE_Backwash (* hidden = "1" *)"Integral Pumping energy for the backwash pump" : ElectricalEnergy ;
  };

  initial <-
  {
  state.M[IndexOfSolvent] = parameters.V_Tank / parameters.WWTPSpecificVolume[IndexOfSolvent]; 
  };

  equations <-
  {
  state.K_Temp = interface.Temp + 273 ;

  state.Q_Out_Membrane = IF ((state.Q_In + state.Q_Backwash - state.Q_Out_Membrane_Help) < 0.0)
      THEN state.Q_In + state.Q_Backwash
    ELSE state.Q_Out_Membrane_Help;

  state.Q_Concentrate = IF ((state.Q_In + state.Q_Backwash - state.Q_Out_Membrane) < 0.0)
      THEN 0.0
    ELSE state.Q_In + state.Q_Backwash - state.Q_Out_Membrane;

  
  state.Solids = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: state.C[Comp_Index] * parameters.F_TSS_COD );
  
  


   
  
  interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (- interface.Outflow[Comp_Index]) * parameters.F_TSS_COD);
  interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: (- interface.OutflowConcentrate[Comp_Index]) * parameters.F_TSS_COD);
  
   
  




 
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * state.TMP / (3600000.0 * parameters.n_Pump_Membrane);
  DERIV(state.Integ_PE_Backwash,[independent.t])=  state.Q_Backwash * state.TMP / (3600000.0 * parameters.n_Pump_Backwash);
 
 
  interface.PumpingEnergy = state.Integ_PE_Membrane + state.Integ_PE_Backwash;
  };

 :};
  


# 414 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2


  
  
  
  
  
 CLASS InternalFoulingMembraneVolumeModel EXTENDS FoulingMembraneVolumeClass WITH
 {:

  interface <-
  {
  OBJ Overflow (* terminal = "out_4" *)"Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ Q_Pump (* terminal = "in_2"; manip = "1" *) "Concentrate flow rate" : 
      FlowRate := {: causality <- "CIN" ; group <- "Operational" :} ;
  };

  parameters <-
  {
  OBJ V_Min "Minimum allowed tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  OBJ V_Tank "Tank volume " : Volume := {: value <- 1900; group <- "Dimension" :};
  };

  state <-
  {
  OBJ Q_Over "Overflow rate" : FlowRate := {: group <- "Operational" :};
  };

  equations <-
  {
  state.Q_Out_Membrane = IF (state.V > parameters.V_Min)
      THEN state.Q_Out_Membrane_Help
    ELSE 0.0 ;

  state.Q_Concentrate = IF (state.V > parameters.V_Min)
      THEN interface.Q_Pump
    ELSE 0.0 ;

  state.Q_Over = IF (state.V > parameters.V_Tank)
      THEN
      IF ((state.Q_In + state.Q_Backwash) >= (state.Q_Out_Membrane + state.Q_Concentrate))
         THEN state.Q_In + state.Q_Backwash - state.Q_Out_Membrane - state.Q_Concentrate
         ELSE 0.0
    ELSE 0.0 ;

  interface.Overflow[IndexOfSolvent] = - state.Q_Over / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

  {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      interface.Overflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Over ; };

  };

 :};
 

 
 CLASS InternalFoulingMembraneVolumeConversionModel EXTENDS InternalFoulingMembraneVolumeModel WITH
 {:
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 472 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2

 :};
 
  

 CLASS InternalFoulingMembraneVolumeASMConversionModel EXTENDS InternalFoulingMembraneVolumeConversionModel WITH
 {:
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 
















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 1
 
















   interface <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.interface.msl" 1
 















 
    
    OBJ DO (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4 (* terminal = "out_2"; is_favorite = "1" *)"Ammonium concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    
    OBJ NO3 (* terminal = "out_2"; is_favorite = "1" *)"Nitrate+Nitrite concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2"; is_favorite = "1" *)"Total suspended solids concentration" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD (* terminal = "out_2" *)"Chemical Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   
    OBJ OfflineBOD (* terminal = "out_2" *)"Biological Oxygen Demand measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN (* terminal = "out_2" *)"Total nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
   

    OBJ V_ASU (* terminal = "out_2" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU (* terminal = "out_2" *)"Oxygen Uptake Rate measurement data" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR (* terminal = "out_2" *)"Nitrate Uptake Rate measurement data" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR (* terminal = "out_2" *)"Nitrate Production Rate measurement data" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR (* terminal = "out_2" *)"Ammonium Uptake Rate measurement data" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU (* terminal = "out_2" *)"Kla measurement data" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   parameters <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.parameters.msl" 1
 
















 
 
  OBJ Temp_Ref  "Reference temperature of the activated sludge"
  : CelsiusTemperature  := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ theta_mu_H  "Temperature correction factor for mu_H"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_mu_A  "Temperature correction factor for mu_A"
  : Real  := {: value <- 1.103 ; group <- "Kinetic" :}; 
  OBJ theta_b_H "Temperature correction factor for b_H"
  : Real  := {: value <- 1.12 ; group <- "Kinetic" :}; 
  OBJ theta_b_A "Temperature correction factor for b_A"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_h "Temperature correction factor for k_h"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ theta_k_a "Temperature correction factor for k_a"
  : Real  := {: value <- 1.072 ; group <- "Kinetic" :}; 
  OBJ theta_K_X "Temperature correction factor for K_X"
  : Real  := {: value <- 1.116 ; group <- "Kinetic" :}; 
  OBJ Y_H "Yield For Heterotrophic Biomass"
  : YieldForHeterotrophicBiomass  := {: value <- 0.67 ; group <- "Stoichiometry" :}; 
  OBJ i_X_B "Mass Of Nitrogen Per Mass Of COD In Biomass"
  : MassOfNitrogenPerMassOfCODInBiomass := {: value <- 0.086 ; group <- "Composition parameters" :}; 
  OBJ Y_A "Yield For Autotrophic Biomass"
  : YieldForAutotrophicBiomass  := {: value <- 0.24 ; group <- "Stoichiometry" :}; 
  OBJ f_P "Fraction Of Biomass Converted To Inert Matter"
  : FractOfBiomassLeadingToPartProd := {: value <- 0.08 ; group <- "Stoichiometry" :}; 
  OBJ i_X_P "Mass Of Nitrogen Per Mass Of COD In Products Formed"
  : MassOfNitrogenPerMassOfCODInProdFromBiomass := {: value <- 0.06 ; group <- "Composition parameters" :}; 
  OBJ mu_H  "Maximum Specific Growth Rate For Heterotrophic Biomass"
  : MaxSpecifGrowthRateHetero := {: value <- 6 ; group <- "Kinetic" :}; 
  OBJ mu_A  "Maximum Specific Growth Rate For Autotrophic Biomass"
  : MaxSpecifGrowthRateAutotr := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ K_S "Half-Saturation Coefficient For Heterotrophic Biomass"
  : HalfSatCoeffForHetero := {: value <- 20 ; group <- "Kinetic" :}; 
  OBJ K_OH  "Oxygen Half-Saturation Coefficient For Heterotrophic Biomass"
  : OxygenHalfSatCoeffForHetero := {: value <- 0.2 ; group <- "Kinetic" :}; 
  OBJ K_X "Half Saturation Coefficient For Hydrolysis Of Slowly Biodegradable Substrate"
  : HalfSatCoeffForHydrolSlowBioDegradeSubstr := {: value <- 0.03 ; group <- "Kinetic" :}; 
  OBJ b_H "Decay Coefficient For Heterotrophic Biomass"
  : DecayCoeffHeterotr  := {: value <- 0.62 ; group <- "Kinetic" :}; 
  OBJ b_A "Decay Coefficient For Autotrophic Biomass"
  : DecayCoeffAutotr  := {: value <- 0.15 ; group <- "Kinetic" :}; 
  OBJ n_h "Correction Factor For Anoxic Hydrolysis"
  : CorrectionFactor  := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ n_g "Correction Factor For Anoxic Growth Of Heteritrophs"
  : CorrectionFactor  := {: value <- 0.8 ; group <- "Kinetic" :}; 
  OBJ k_a "Maximum Specific Ammonification Rate"
  : AmmonificationRate  := {: value <- 0.08 ; group <- "Kinetic" :}; 
  OBJ k_h "Maximum Specific Hydrolysis Rate"
  : MaxSpecificHydrolysisRate := {: value <- 3 ; group <- "Kinetic" :}; 
  OBJ K_NO  "Nitrate Half-Saturation Coefficient For Denitrifying Heterotrophic Biomass"
  : NitrateHalfSatCoeffForDenitrifHetero  := {: value <- 0.5 ; group <- "Kinetic" :}; 
  OBJ K_NH  "Ammonia Half-Saturation Coefficient For Autotrophic Biomass"
  : AmmonHalfSatCoeffForAutotr  := {: value <- 1 ; group <- "Kinetic" :}; 
  OBJ K_NH_H  "Saturation coeff of heterotrophs for ammonium"
  : SaturationCoefficient := {: value <- 0.05 ; group <- "Kinetic" :}; 
  OBJ K_OA  "Oxygen Half-Saturation Coefficient For Autotrophic Biomass"
  : OxygenHalfSatCoeffForAutotr := {: value <- 0.4 ; group <- "Kinetic" :}; 
  OBJ F_TSS_COD "Fraction TSS/COD"
  : Fraction  := {: value <- 0.75 ; group <- "Conversion factors" :}; 
  OBJ F_BOD_COD "Conversion factor BOD/COD"
  : Fraction  := {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   state <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.state.msl" 1
 














 

    OBJ X_TSS "Total suspended solids" 
  : Concentration := {: group <- "Concentration" :};
  OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
  OBJ mu_H_Temp "mu_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ mu_A_Temp "mu_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_H_Temp  "b_H at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ b_A_Temp  "b_A at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_h_Temp  "k_h at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ k_a_Temp  "k_a at the system temperature"
  : Real := {: group <- "Kinetic" :};
  OBJ K_X_Temp  "K_X at the system temperature"
  : Real := {: group <- "Kinetic" :};

# 30 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   initial <-
   {
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.stoichiometry.msl" 1
 
















  parameters.Stoichiometry[AerGrowthHetero][S_S] :=  - 1 / (parameters.Y_H);
  parameters.Stoichiometry[AerGrowthHetero][S_O] :=  - (1 - parameters.Y_H) / parameters.Y_H;
  parameters.Stoichiometry[AerGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AerGrowthHetero][S_ALK] :=  - parameters.i_X_B / 14;
  parameters.Stoichiometry[AerGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AnGrowthHetero][S_S] :=  - 1 / parameters.Y_H;
  parameters.Stoichiometry[AnGrowthHetero][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
  parameters.Stoichiometry[AnGrowthHetero][S_NH] :=  - parameters.i_X_B;
  parameters.Stoichiometry[AnGrowthHetero][S_ALK] := ((1 - parameters.Y_H) / (14 * 2.86 * parameters.Y_H)) - (parameters.i_X_B / 14);
  parameters.Stoichiometry[AnGrowthHetero][X_BH] := 1;
  parameters.Stoichiometry[AerGrowthAuto][S_O] :=  - (4.57 - parameters.Y_A) / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NO] := 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_NH] :=  - parameters.i_X_B - 1 / parameters.Y_A;
  parameters.Stoichiometry[AerGrowthAuto][S_ALK] :=  - (parameters.i_X_B / 14) - (1 / (7 * parameters.Y_A));
  parameters.Stoichiometry[AerGrowthAuto][X_BA] := 1;
  parameters.Stoichiometry[DecayOfHetero][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_BH] :=  - 1;
  parameters.Stoichiometry[DecayOfHetero][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfHetero][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[DecayOfAuto][X_S] := 1 - parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_BA] :=  - 1;
  parameters.Stoichiometry[DecayOfAuto][X_P] := parameters.f_P;
  parameters.Stoichiometry[DecayOfAuto][X_ND] := parameters.i_X_B - parameters.f_P * parameters.i_X_P;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ND] :=  - 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_NH] := 1;
  parameters.Stoichiometry[AmmonOfSolOrgN][S_ALK] := 1.0 / 14.0;
  parameters.Stoichiometry[HydrolOfEntrOrg][S_S] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrg][X_S] :=  - 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][S_ND] := 1;
  parameters.Stoichiometry[HydrolOfEntrOrgN][X_ND] :=  - 1;
  parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };

   equations <-
   {
  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.kinetics.msl" 1
 
















    state.X_TSS := (state.C[X_BH] + state.C[X_BA] + state.C[X_I] + state.C[X_S] + state.C[X_P]) * parameters.F_TSS_COD;

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_A_Temp = parameters.mu_A * pow(parameters.theta_mu_A,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.b_A_Temp = parameters.b_A * pow(parameters.theta_b_A,state.Temp_Actual - parameters.Temp_Ref);
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.k_a_Temp = parameters.k_a * pow(parameters.theta_k_a,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);

  state.Kinetics[AerGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (state.C[S_O] / (parameters.K_OH + state.C[S_O])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * state.C[X_BH];
  state.Kinetics[AnGrowthHetero] := state.mu_H_Temp * (state.C[S_S] / (parameters.K_S + state.C[S_S])) * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO])) * (state.C[S_NH] / (parameters.K_NH_H + state.C[S_NH])) * parameters.n_g * state.C[X_BH];
  state.Kinetics[AerGrowthAuto] := state.mu_A_Temp * (state.C[S_NH] / (parameters.K_NH + state.C[S_NH])) * (state.C[S_O] / (parameters.K_OA + state.C[S_O])) * state.C[X_BA];
  state.Kinetics[DecayOfHetero] := state.b_H_Temp * state.C[X_BH];
  state.Kinetics[DecayOfAuto] := state.b_A_Temp * state.C[X_BA];
  state.Kinetics[AmmonOfSolOrgN] := state.k_a_Temp * state.C[S_ND] * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrg] := state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH];
  state.Kinetics[HydrolOfEntrOrgN] := (state.k_h_Temp * (state.C[X_S] / state.C[X_BH]) / (state.K_X_Temp + (state.C[X_S] / state.C[X_BH])) * ((state.C[S_O] / (parameters.K_OH + state.C[S_O])) + parameters.n_h * (parameters.K_OH / (parameters.K_OH + state.C[S_O])) * (state.C[S_NO] / (parameters.K_NO + state.C[S_NO]))) * state.C[X_BH]) * (state.C[X_ND] / state.C[X_S]);
  state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempModel.sensors.msl" 1
 















 

  interface.DO = state.C[S_O];
  
  interface.NH4 = state.C[S_NH];
  
  interface.NO3 = state.C[S_NO];
  
  interface.TSS = state.X_TSS ; 
      
  interface.OnlineCOD = ( state.C[S_S] + state.C[S_I] + 
        state.C[X_BH] + state.C[X_BA] + state.C[X_S] 
          + state.C[X_I] + state.C[X_P]); 
          
  
  interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_S] + state.C[X_S] 
             + (1 - parameters.f_P) * (state.C[X_BH] + state.C[X_BA])) ;
             
             
  interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
     + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OfflineTKN = ( state.C[S_NH] + state.C[S_ND] + state.C[X_ND]
       + parameters.i_X_B * (state.C[X_BH] + state.C[X_BA]) 
         + parameters.i_X_P * (state.C[X_P] + state.C[X_I])) ;
         
  interface.OUR_ASU = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_O] / state.V)
     + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];

  interface.NUR = IF (state.V == 0)
              THEN 0
              ELSE
     - (state.ConversionTermPerComponent[S_NO] / state.V)
     + parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];
   
  interface.NPR = IF (state.V == 0)
              THEN 0
              ELSE
     parameters.Stoichiometry[AerGrowthAuto][S_NO] * state.Kinetics[AerGrowthAuto];   

  interface.AUR = IF (state.V == 0)
            THEN 0
            ELSE
     - (state.ConversionTermPerComponent[S_NH] / state.V);    
   
  interface.Kla_ASU = state.Kla_Actual;

  interface.V_ASU = state.V;

         
      
  
  

# 41 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASM1TempConversionModel.body.msl" 2

   };


# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



























# 479 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2

 :};

 CLASS InternalFoulingMembraneVolumeClass EXTENDS InternalFoulingMembraneVolumeASMConversionModel WITH
 {:
  
  interface <-
  {
  OBJ X_Out (* terminal = "out_2" *) "TSS in the outflow" : Concentration := {: causality <- "COUT" ; group <- "Permeate" :};
  OBJ X_Concentrate (* terminal = "out_2" *) "TSS in the concentrate" : Concentration := {: causality <- "COUT" ; group <- "Concentrate" :};
  };
  
  equations <-
  {
  
    state.Solids = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}: state.C[Comp_Index] * parameters.F_TSS_COD );
  
  


  
   interface.X_Out = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
             (- interface.Outflow[Comp_Index]) / (state.Q_Out_Membrane + state.Q_Out_Backwash) * parameters.F_TSS_COD);
   interface.X_Concentrate = (SUMOVER Comp_Index IN {IndexOfFirstTSSComponent .. IndexOfLastTSSComponent}:
               (- interface.OutflowConcentrate[Comp_Index]) / state.Q_Concentrate * parameters.F_TSS_COD);
  
   
  



  };

 :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\MBR/wwtp.base.mbr.mbrwithfouling.msl" 1
 


















 CLASS MBRWithFouling
 (* icon = "mbr"; is_default = "true" *)
 "MBR model extended with the computation of the TMP"
 EXTENDS InternalFoulingMembraneVolumeClass WITH
 {:
  comments <- "A model for an MBR unit, subjected to fouling (the trans-membrane pressure is computed)";
  interface <-  
  {
   OBJ Kla (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };   
  
  parameters <-
  {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ n_Pump_Membrane "Pump efficiency of the membrane pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ n_Pump_Backwash "Pump efficiency of the backwash pump" : Fraction := {: value <- 0.75 ; group <- "Energy":};
    OBJ F_Energy_FlowRate_Concentrate "Conversion factor Energy needed/Pump flow rate for the concentrate pump" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE_Membrane (* hidden = "1" *)"Integral Pumping energy for the transmembrane pump" : ElectricalEnergy ;
    OBJ Integ_PE_Backwash (* hidden = "1" *)"Integral Pumping energy for the backwash pump" : ElectricalEnergy ;
    OBJ Integ_PE_Concentrate (* hidden = "1" *)"Integral Pumping energy for the concentrate pump" : ElectricalEnergy ;
  };
  
  initial <-
  {
  };

  equations <-
  {
  state.Temp_Actual = interface.Temp;
  state.K_Temp = interface.Temp + 273 ;
  state.Kla_Actual = interface.Kla;
 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE_Membrane,[independent.t])=  state.Q_Out_Membrane * state.TMP / (3600000.0 * parameters.n_Pump_Membrane);
  DERIV(state.Integ_PE_Backwash,[independent.t])=  state.Q_Backwash * state.TMP / (3600000.0 * parameters.n_Pump_Backwash);
 
 
  DERIV(state.Integ_PE_Concentrate,[independent.t])=  state.Q_Concentrate;
  interface.PumpingEnergy = state.Integ_PE_Membrane + state.Integ_PE_Backwash + parameters.F_Energy_FlowRate_Concentrate * state.Integ_PE_Concentrate;
  };

:};



# 514 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.internal_membrane.msl" 2





# 56 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.ADM1.msl" 1
 















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.definitionsADM1.msl" 1
 


















 
 

 


 CLASS CarbonContentOfAminoAcids
   "carbon content of amino acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfAcetate
   "carbon content of acetate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfBiomass
   "carbon content of biomass"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfButyrate
   "carbon content of butyrate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfMethane
   "carbon content of methane"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfLCFattyAcids
   "carbon content of long chain fatty acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfPropionate
   "carbon content of propionate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfSolubleInertCOD
   "carbon content of soluble inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfValerate
   "carbon content of valerate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfComplexParticulateCOD
   "carbon content of complex particulate COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfParticulateInertCOD
   "carbon content of particulate inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};
CLASS CarbonContentOfLipids
   "carbon content of particulate inert COD"
    SPECIALISES PhysicalQuantityType :=
       {:
        unit     <- "mole.g COD-1";
        :};

CLASS CarbonContentOfSugars
   "carbon content of particulate inert COD"
    SPECIALISES PhysicalQuantityType :=
       {:
        unit     <- "mole.g COD-1";
        :};

 

CLASS NitrogenContentOfAminoAcids
   "Nitrogen content of amino acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

CLASS NitrogenContentOfBiomass
   "Nitrogen content of  biomass"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

CLASS NitrogenContentOfSolubleInertCOD
   "nitrogen content of Soluble inert"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};
CLASS NitrogenContentOfParticulateDegradableCOD
   "nitrogen content of particulate degradable COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

CLASS NitrogenContentOfParticulateInertCOD
   "nitrogen content of particulate inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

 

CLASS pKa
   "A class for pKa"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "pKa";
    interval  <- {: lowerBound <- 0; upperBound <- 14 :};
   :};

CLASS Acidity
   "A class for Acidity"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Acidity";
    unit     <- "M";
   :};

 

CLASS HydrogenInhibitoryConcentrationForFADegradingOrganisms
   "hydrogen inhibitory concentration for FA degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
   
CLASS HydrogenInhibitoryConcentrationForC4DegradingOrganisms
   "hydrogen inhibitory concentration for C4 degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS InhibitoryHydrogenConcentrationForPropionateDegradingOrganisms
   "inhibitory hydrogen concentration for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS InhibitoryFreeAmmoniaConcentrationForAcetateDegradingOrganisms
   "inhibitory free ammonia concentration for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "M";
   :};

 

CLASS KineticConstantForCO2andHCO3AcidBaseReaction
   "kinetic constant for CO2-HCO3 acid-base reaction"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS DecayRateForAminoAcidDegradingOrganisms
   "decay rate for amino acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForAcetateDegradingOrganisms
   "decay rate for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForButyrateAndValerateDegradingOrganisms
   "decay rate for butyrate and valerate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForLongChainFattyAcidDegradingOrganisms
   "decay rate for long chain fatty acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS DecayRateForHydrogenDegradingOrganisms
   "decay rate for hydrogen degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS DecayRateForPropionateDegradingOrganisms
   "decay rate for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForMonosaccharideDegradingOrganisms
   "decay rate for monosaccharide degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS ComplexParticulateDisintegrationFirstOrderConstant
   "complex particulate disintegration first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS CarbohydrateHydrolysisFirstOrderConstant
   "carbohydrate hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS LipidHydrolysisFirstOrderConstant
   "lipid hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS ProteinHydrolysisFirstOrderConstant
   "protein hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS GasLiquidTransferCoefficientForReactor
   "gas liquid transfer coefficient for reactor"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
 

CLASS PhysChemRate 
   "Phiscal or chemical reaction rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "KMole.d-1";
   :};
 

CLASS MaximumUptakeRateAminoAcidDegradingOrganisms
   "maximum uptake rate amino acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForAcetateDegradingOrganisms
   "maximum uptake rate for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForC4DegradingOrganisms
   "maximum uptake rate for c4 degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS MaximumUptakeRateForLongChainFattyAcidDegradingOrganisms
   "maximum uptake rate for long chain fatty acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateFForHydrogenDegradingOrganisms
   "maximum uptake rate for hydrogen degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForPropionateDegradingOrganisms
   "maximum uptake rate for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForMonosaccharideDegradingOrganisms
   "maximum uptake rate for monosaccharide degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS HalfSaturationConstantForAminoAcidDegradation
   "half saturation constant for amino acid degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS HalfSaturationConstantForAcetateDegradation
   "half saturation constant for acetate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForButyrateAndValerateDegradation
   "half saturation constant for butyrate and valerate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForLongChainFattyAcidsDegradation
   "half saturation constant for long chain fatty acids degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS HalfSaturationConstantForUptakeOfHydrogen
   "half saturation constant for uptake of hydrogen"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS InorganicNitrogenConcentrationAtWhichGrowthCeases
   "inorganic nitrogen concentration at which growth ceases"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "M";
   :};
CLASS HalfSaturationConstantForPropionateDegradation
   "half saturation constant for propionate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForMonosaccharideDegradation
   "half saturation constant for monosaccharide degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

 

CLASS BarPressure
   "pressure "
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "bar";
   :};

CLASS GasLawConstant
   "Gas law constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "bar.M-1.K-1";
   :};

CLASS SolidsRetentionTimeInAdditionToHydraulicRetentionTime
   "solids retention time in addition to hydraulic retention time"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "K";
   :};

  

CLASS KgDensity
   "Water Density"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kg/m3";
   :};

CLASS KgCODConcentration
   "Concentration of COD components"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m";
   :};

CLASS InhibitionFactor
   "Inhibition Factor"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "_";
   :};

   CLASS ADMMass "A class for (kg, kmol) mass in the scope of ADM1"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "kg";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS ADMConcentration "A class for (kg, kmol) concentration in the scope of ADM1"
   SPECIALISES PhysicalQuantityType :=
   {:
    nature <- "ACROSS";
    quantity <- "Concentration";
    unit <- "kg/m3";
    interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};
   
  
 
 

 
TYPE ADM1Components
  "The biological components considered in the ADM1 model"
  = ENUM { H2O_An, S_INN, S_IC, S_ch4, S_h2, S_aa, S_ac, S_bu, S_fa, S_Inert, S_pro, S_su, S_va, X_aa, X_ac, X_c, X_c4, X_ch, X_fa, X_h2, X_Inert, X_li, X_pr, X_pro, X_su, S_an, S_cat};

TYPE ADM1IonComponents
  "The ion components considered in the ADM1 model"
  = ENUM { S_ac_ion, S_bu_ion, S_pro_ion, S_va_ion, S_hco3_ion, S_nh3};

TYPE ADM1GasVesselComponents
  "The gaseous components considered in the ADM1 model in the gas phase"
  = ENUM { S_ch4_gas, S_co2_gas, S_h2_gas};
  
TYPE ADM1GasComponentsInliquid
    "The gaseous components considered in the ADM1 model dissolved in the liquid phase"
  = ENUM { S_ch4_liq, S_IC_liq, S_h2_liq};

  
  
  
  
  
  
 
 TYPE ADM1Reactions
  "The anaerobic reactions between biological components considered in the ADM1 model"
  = ENUM {decay_aa, decay_ac, decay_c4, decay_fa, decay_h2, decay_pro, decay_su,
  	dis, hyd_ch, hyd_li, hyd_pr,
	uptake_aa, uptake_ac, uptake_bu, uptake_fa, uptake_h2, uptake_pro, uptake_su, uptake_va, };

TYPE ADM1IonReactions
  "The equilibrium reactions between biological components considered in the ADM1 model"
  = ENUM {dissociation_va, dissociation_bu, dissociation_pro, dissociation_ac, hco3_co2, ammonia_production, };

TYPE ADM1GasTransfer
  "The anaerobic gas transfer considered in the ADM1 model"
  = ENUM {transfer_ch4, transfer_co2, transfer_h2, };

 
 
 

 
 
 
 

 

 OBJ NrOfADM1GasComponents "The number of anaerobic components considered in the gas"
  : Integer := Cardinality(ADM1GasVesselComponents);

OBJ NrOfADM1GasComponentsInliquid "The number of gaseous anaerobic components dissolved in the liquid"
  : Integer := Cardinality(ADM1GasComponentsInliquid);

 OBJ NrOfADM1Components "The number of anaerobic components considered in the ADM1 model"
  : Integer := Cardinality(ADM1Components);

OBJ NrOfADM1IonComponents "The number of anaerobic ion components considered in the ADM1 model"
  : Integer := Cardinality(ADM1IonComponents);
  
 
 OBJ NrOfADM1Reactions "The number of anaerobic reactions considered in the ADM1 model"
  : Integer := Cardinality(ADM1Reactions);

OBJ NrOfADM1IonReactions "The number of anaerobic ion reactions considered in the ADM1 model"
  : Integer := Cardinality(ADM1IonReactions);

OBJ NrOfADM1GasTransfer "The number of anaerobic gas transfers considered in the ADM1 model"
  : Integer := Cardinality(ADM1GasTransfer);

CLASS ADM1GasOutFromTheADVessel "The variables which are passed between WWTP model building blocks here in concentrations"
  = PhysicalQuantityType[NrOfADM1GasComponents;];

CLASS ADM1MassVector "The mass of components in the reactor"
  = ADMMass[NrOfADM1Components;];		  

CLASS ADM1GasMassVector "The mass of gasses in the reactor"
  = ADMMass[NrOfADM1GasComponents;];		  
  
CLASS ADM1ConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1Components;];		  

CLASS ADM1IonConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1IonComponents;];		  

CLASS ADM1GasConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1GasComponents;];		  

CLASS ADM1ConcTerminal "The variables which are passed between WWTP model building blocks here in General concentrations"
  = Concentration[NrOfADM1Components;];		  


CLASS InADM1ConcTerminal SPECIALISES ADM1ConcTerminal;  
CLASS OutADM1ConcTerminal SPECIALISES ADM1ConcTerminal;  
CLASS ADM1MassFluxVector = PhysicalQuantityType[NrOfADM1Components;];
CLASS ADM1GasMassFluxVector = PhysicalQuantityType[NrOfADM1GasComponents;];
CLASS ADM1IonConcentrationVector = PhysicalQuantityType[NrOfADM1IonComponents;];

 


# 17 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.ADM1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.ADM1.msl" 1
 




















CLASS AnaerobicDigestionAtomicModel
    "anaerobic digester"
    SPECIALISES PhysicalDAEModelType :=
{:
   comments <- "ADM1 model for anaerobic digestion according to BSM2. This is different from the STR 
   implementation in terms of the Hill functions used for inhibition and the alternative simple equation 
   for the gas flow calculation. This implementation uses an algebraic model to calculate S_H for speeding 
   up calculations (DAE2 - both pH and H2 are calculated algebraically)";
   interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InADM1ConcTerminal := {: causality <- "CIN"; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : OutADM1ConcTerminal := {: causality <- "COUT"; group <- "Effluent" :};
    OBJ T_op (* terminal = "in_2"; manip = "1" *) "Operating temperature": CelsiusTemperature := {: causality <- "CIN"; value <- 35; group <- "Operational" :};
	OBJ pH_ADM (* terminal = "out_4" *) "pH_ADM" : pH := {: causality <- "COUT"; group <- "Data" :};
	OBJ T_oper  (* terminal = "out_4" *) "Measured temperature" : CelsiusTemperature := {: causality <- "COUT"; group <- "Data" :};
	OBJ p_gas_ch4 (* terminal = "out_4" *) "Partial methane pressure" : Pressure := {: causality <- "COUT"; group <- "Data" :};
	OBJ p_gas_tot (* terminal = "out_4" *) "Total headspace pressure" : Pressure := {: causality <- "COUT"; group <- "Data" :};
	OBJ gas_flowrate  (* terminal = "out_4" *) "Gas flow rate" : FlowRate := {: causality <- "COUT"; group <- "Data" :};
	OBJ V_liquid  (* terminal = "out_4" *) "Liquor volume" : Volume := {: causality <- "COUT"; group <- "Data" :};
	OBJ V_tot   (* terminal = "out_4" *) "Total volume" : Volume := {: causality <- "COUT"; group <- "Data" :};
	OBJ Q_Gas_LD (* terminal = "out_3" *) "Gasflow" : ADM1GasOutFromTheADVessel := {: causality <- "COUT"; group <- "Data" :};
	 
	OBJ Conc_An (* terminal = "out_4" *) "Vector containing masses for components of ADM1" : ADM1ConcVector := {: causality <- "COUT"; group <- "Concentration" :};
	OBJ Conc_AnIon (* terminal = "out_4" *) "Vector containing masses for all ion components of ADM1" : ADM1IonConcVector := {: causality <- "COUT"; group <- "Concentration" :};
	OBJ Conc_AnGas (* terminal = "out_4" *) "Vector containing masses for gas phase components of ADM1" : ADM1GasConcVector := {: causality <- "COUT"; group <- "Concentration" :};
    };

  parameters <- 
   { 
 
OBJ C_aa "Carbon content of amino acids" : CarbonContentOfAminoAcids := {: value <- 0.03; group <- "Stoichiometry" :};
OBJ C_pr "Carbon content of proteines" : CarbonContentOfAminoAcids := {: value <- 0.03; group <- "Stoichiometry" :};
OBJ C_ac "Carbon content of acetate" : CarbonContentOfAcetate := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_biom "Carbon content of biomass" : CarbonContentOfBiomass := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_bu "Carbon content of butyrate" : CarbonContentOfButyrate := {: value <- 0.025; group <- "Stoichiometry" :};
OBJ C_ch4 "Carbon content of methane" : CarbonContentOfMethane := {: value <- 0.0156; group <- "Stoichiometry" :};
OBJ C_fa "Carbon content of long chain fatty acids" : CarbonContentOfLCFattyAcids := {: value <- 0.0217; group <- "Stoichiometry" :};
OBJ C_li "Carbon content of lipids" : CarbonContentOfLipids := {: value <- 0.022; group <- "Stoichiometry" :};
OBJ C_pro "Carbon content of propionate" : CarbonContentOfPropionate := {: value <- 0.0268; group <- "Stoichiometry" :};
OBJ C_SI "Carbon content of soluble inert COD" : CarbonContentOfSolubleInertCOD := {: value <- 0.03; group <- "Stoichiometry" :};
OBJ C_su "Carbon content of sugars" : CarbonContentOfSugars := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_ch "Carbon content of carbohydrates" : CarbonContentOfSugars := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_va "Carbon content of valerate" : CarbonContentOfValerate := {: value <- 0.024; group <- "Stoichiometry" :};
OBJ C_Xc "Carbon content of complex particulate COD" : CarbonContentOfComplexParticulateCOD := {: value <- 0.02786; group <- "Stoichiometry" :};
OBJ C_XI "Carbon content of particulate inert COD" : CarbonContentOfParticulateInertCOD := {: value <- 0.03; group <- "Stoichiometry" :};

 

OBJ N_aa "Nitrogen content of amino acids" : NitrogenContentOfAminoAcids := {: value <- 0.007; group <- "Stoichiometry" :};
OBJ N_biom "Nitrogen content of  biomass" : NitrogenContentOfBiomass := {: value <- 0.00571428571428571; group <- "Stoichiometry" :};
OBJ N_SI "Nitrogen content of soluble inert COD" : NitrogenContentOfSolubleInertCOD := {: value <- 0.00428571428571429; group <- "Stoichiometry" :};
OBJ N_Xc "Nitrogen content of particulate degradable COD" : NitrogenContentOfParticulateDegradableCOD := {: value <- 0.00268571428571429; group <- "Stoichiometry" :};
OBJ N_XI "Nitrogen content of particulate inert COD" : NitrogenContentOfParticulateInertCOD := {: value <- 0.00428571428571429; group <- "Stoichiometry" :};

 

OBJ f_ac_su "Yield of acetate from sugar degradation" : Ratio := {: value <- 0.41; group <- "Stoichiometry" :};
OBJ f_ac_aa "Yield of acetate from amino acid degradation" : Ratio := {: value <- 0.4; group <- "Stoichiometry" :};
OBJ f_bu_aa "Yield of butyrate from amino acid degradation" : Ratio := {: value <- 0.26; group <- "Stoichiometry" :};
OBJ f_ch_xc "Yield of carbohydrates from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
OBJ f_fa_li "Yield of long chain fatty acids (as opposed to glycerol) from lipids" : Ratio := {: value <- 0.95; group <- "Stoichiometry" :};
OBJ f_h2_aa "Yield of hydrogen from amino acid degradation" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ f_pro_aa "Yield of propionate from amino acid degradation" : Ratio := {: value <- 0.05; group <- "Stoichiometry" :};
OBJ f_pro_su "Yield of propionate from monosaccharide degradation" : Ratio:= {: value <- 0.27; group <- "Stoichiometry" :};
OBJ f_pr_xc "Yield of proteins from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
OBJ f_SI_xc "Yield of soluble inerts from disintegration of complex particulates" : Ratio := {: value <- 0.1; group <- "Stoichiometry" :};
OBJ f_va_aa "Yield of valerate from amino acid degradation" : Ratio := {: value <- 0.23; group <- "Stoichiometry" :};
OBJ f_XI_xc "Yield of particulate inerts from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
OBJ f_bu_su "Yield of butyrate from monosaccharide degradation" : Ratio:= {: value <- 0.13; group <- "Stoichiometry" :};
OBJ f_h2_su "Yield of hydrogen from monosaccharide degradation" : Ratio:= {: value <- 0.19; group <- "Stoichiometry" :};
OBJ f_li_xc "Yield of lipids from disintegration of complex particulates" : Ratio:= {: value <- 0.3; group <- "Stoichiometry" :};

 

OBJ Y_aa "Yield of biomass on uptake of amino acids" : Ratio := {: value <- 0.08; group <- "Stoichiometry" :};
OBJ Y_ac "Yield of biomass on uptake of acetate" : Ratio := {: value <- 0.05; group <- "Stoichiometry" :};
OBJ Y_c4  "Yield of biomass on uptake of valerate or butyrate" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ Y_fa "Yield of biomass on uptake of long chain fatty acids" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ Y_h2 "Yield of biomass on uptake of elemental hydrogen" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ Y_pro "Yield of biomass on uptake of propionate" : Ratio := {: value <- 0.04; group <- "Stoichiometry" :};
OBJ Y_su "Yield of biomass on uptake of monosaccharides" : Ratio := {: value <- 0.1; group <- "Stoichiometry" :};

 

OBJ pH_ac_ll "pH level at which there is full inhibition of acetate degradation" : pH:= {: value <- 6; group <- "Kinetics" :};
OBJ pH_ac_ul "pH level at which there is no inhibition of acetate degrading organisms" : pH := {: value <- 7; group <- "Kinetics" :};
OBJ pH_bac_ll "pH level at which there is full inhibition" : pH := {: value <- 4; group <- "Kinetics" :};
OBJ pH_bac_ul "pH level at which there is no inhibition" : pH := {: value <- 5.5; group <- "Kinetics" :};
OBJ pH_h2_ll "pH level at which there is full inhibition of hydrogen degrading organisms" : pH := {: value <- 5; group <- "Kinetics" :};
OBJ pH_h2_ul "pH level at which there is no inhibition of hydrogen degrading organisms" : pH := {: value <- 6; group <- "Kinetics" :};

 

OBJ Ka_ac "Acetate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 1.74e-5; group <- "System" :}; 
OBJ Ka_bu "Butyrate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 1.51e-5; group <- "System" :};
OBJ Ka_co2 "CO2 acidity constant (temperature correction needed)" : Acidity:= {: value <- 4.94e-7; group <- "System" :};
OBJ Ka_h2o "Water acidity constant (temperature correction needed)" : Acidity:= {: value <- 2.08e-14; group <- "System" :};
OBJ Ka_nh4 "NH4+ acidity constant (temperature correction needed)" : Acidity:= {: value <- 1.11e-9; group <- "System" :};
OBJ Ka_pro "Propionate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 1.32e-5; group <- "System" :};
OBJ Ka_va "Valerate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 1.38e-5; group <- "System" :};

 
OBJ KI_h2_fa "Hydrogen inhibitory concentration for FA degrading organisms" : HydrogenInhibitoryConcentrationForFADegradingOrganisms := {: value <- 5E-006; group <- "Kinetics" :};
OBJ KI_h2_c4 "Hydrogen inhibitory concentration for C4 degrading organisms" : HydrogenInhibitoryConcentrationForC4DegradingOrganisms := {: value <- 1E-005; group <- "Kinetics" :};
OBJ KI_h2_pro "Inhibitory hydrogen concentration for propionate degrading organisms" : InhibitoryHydrogenConcentrationForPropionateDegradingOrganisms := {: value <- 3.5E-006; group <- "Kinetics" :};
OBJ KI_nh3_ac "Inhibitory free ammonia concentration for acetate degrading organisms" : InhibitoryFreeAmmoniaConcentrationForAcetateDegradingOrganisms := {: value <- 0.0018; group <- "Kinetics" :};

 

OBJ kdec_xaa "Decay rate for amino acid degrading organisms" : DecayRateForAminoAcidDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xac "Decay rate for acetate degrading organisms" : DecayRateForAcetateDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xc4 "Decay rate for butyrate and valerate degrading organisms" : DecayRateForButyrateAndValerateDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xfa "Decay rate for long chain fatty acid degrading organisms" : DecayRateForLongChainFattyAcidDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xh2 "Decay rate for hydrogen degrading organisms" : DecayRateForHydrogenDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xpro "Decay rate for propionate degrading organisms" : DecayRateForPropionateDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xsu "Decay rate for monosaccharide degrading organisms" : DecayRateForMonosaccharideDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdis "Complex particulate disintegration first order rate constant" : ComplexParticulateDisintegrationFirstOrderConstant := {: value <- 0.5; group <- "Kinetics" :};

 

OBJ khyd_ch "Carbohydrate hydrolysis first order rate constant" : CarbohydrateHydrolysisFirstOrderConstant := {: value <- 10; group <- "Kinetics" :};
OBJ khyd_li "Lipid hydrolysis first order rate constant" : LipidHydrolysisFirstOrderConstant := {: value <- 10; group <- "Kinetics" :};
OBJ khyd_pr "Protein hydrolysis first order rate constant" : ProteinHydrolysisFirstOrderConstant := {: value <- 10; group <- "Kinetics" :};

 

OBJ kla "Gas liquid transfer coefficient" : GasLiquidTransferCoefficientForReactor := {: value <- 200; group <- "Operational" :};

 

OBJ km_aa "Maximum uptake rate amino acid degrading organisms" : MaximumUptakeRateAminoAcidDegradingOrganisms := {: value <- 50; group <- "Kinetics" :};
OBJ km_ac "Maximum uptake rate for acetate degrading organisms" : MaximumUptakeRateForAcetateDegradingOrganisms := {: value <- 8; group <- "Kinetics" :};
OBJ km_c4 "Maximum uptake rate for c4 degrading organisms" : MaximumUptakeRateForC4DegradingOrganisms := {: value <- 20; group <- "Kinetics" :};
OBJ km_fa "Maximum uptake rate for long chain fatty acid degrading organisms" : MaximumUptakeRateForLongChainFattyAcidDegradingOrganisms := {: value <- 6; group <- "Kinetics" :};
OBJ km_h2 "Maximum uptake rate for hydrogen degrading organisms" : MaximumUptakeRateFForHydrogenDegradingOrganisms := {: value <- 35; group <- "Kinetics" :};
OBJ km_pro "Maximum uptake rate for propionate degrading organisms" : MaximumUptakeRateForPropionateDegradingOrganisms := {: value <- 13; group <- "Kinetics" :};
OBJ km_su "Maximum uptake rate for monosaccharide degrading organisms" : MaximumUptakeRateForMonosaccharideDegradingOrganisms := {: value <- 30; group <- "Kinetics" :};
OBJ Ks_aa "Half saturation constant for amino acid degradation" : HalfSaturationConstantForAminoAcidDegradation := {: value <- 0.3; group <- "Kinetics" :};
OBJ Ks_ac "Half saturation constant for acetate degradation" : HalfSaturationConstantForAcetateDegradation := {: value <- 0.15; group <- "Kinetics" :};
OBJ Ks_c4 "Half saturation constant for butyrate and valerate degradation" : HalfSaturationConstantForButyrateAndValerateDegradation := {: value <- 0.2; group <- "Kinetics" :};
OBJ Ks_fa "Half saturation constant for long chain fatty acids degradation" : HalfSaturationConstantForLongChainFattyAcidsDegradation := {: value <- 0.4; group <- "Kinetics" :};
OBJ Ks_h2 "Half saturation constant for uptake of hydrogen" : HalfSaturationConstantForUptakeOfHydrogen := {: value <- 7E-006; group <- "Kinetics" :};
OBJ Ks_IN "Inorganic nitrogen concentration at which growth ceases" : InorganicNitrogenConcentrationAtWhichGrowthCeases := {: value <- 0.0001; group <- "Kinetics" :};
OBJ Ks_pro "Half saturation constant for propionate degradation" : HalfSaturationConstantForPropionateDegradation := {: value <- 0.1; group <- "Kinetics" :};
OBJ Ks_su "Half saturation constant for monosaccharide degradation" : HalfSaturationConstantForMonosaccharideDegradation := {: value <- 0.5; group <- "Kinetics" :};

 

OBJ K_p "gas flow constant": Real := {: value <- 5e4; group <- "System" :};
OBJ P_atm "Pressure of atmosphere" : BarPressure := {: value <- 1.013; group <- "Operational" :};
OBJ R "Gas law constant" : GasLawConstant := {: value <- 0.08314; group <- "System" :};
OBJ T "Temperature" : CelsiusTemperature := {: value <- 35; group <- "Operational" :};
OBJ help_T (* hidden = "0" *) "Temperature" : KelvinTemperature := {: group <- "temp" :};

 

 

OBJ V_gas "Volume of gas in the reactor" : Volume := {: value <- 300; group <- "Operational" :};
OBJ V_liq "Volume of liquid in the reactor" : Volume := {: value <- 3400; group <- "Operational" :};
OBJ f_X_Out "Fraction of the anaerobic particulate matter that leaves the reactor" : PhysicalQuantityType := {: value <- 1; group <- "Operational" :};

     
 

 

OBJ AnaerobicStoichiometry (* hidden = "1" *)"A matrix structure containing stoichiometry of anaerobic biological processes": Real[NrOfADM1Reactions;][NrOfADM1Components;];
OBJ AnaerobicGasStoichiometryInLiquid (* hidden = "1" *)"A matrix structure containing stoichiometry of anaerobic biological processes": PhysicalQuantityType[NrOfADM1GasTransfer;][NrOfADM1GasComponentsInliquid;];
OBJ AnaerobicGasStoichiometryInGas (* hidden = "1" *)"A matrix structure containing stoichiometry of anaerobic biological processes": PhysicalQuantityType[NrOfADM1GasTransfer;][NrOfADM1GasComponents;];

 
 
 
 
 

};

state <-
{
 
OBJ C_h2 "Hydrogen concentration" : Concentration := {: group <- "Concentration" :} ; 
OBJ C_An "Vector containing masses for components of ADM1" : ADM1ConcVector := {: group <- "Concentration" :};
OBJ C_AnIon "Vector containing masses for all ion components of ADM1" : ADM1IonConcVector := {: group <- "Concentration" :};
OBJ C_AnGas "Vector containing masses for gas phase components of ADM1" : ADM1GasConcVector := {: group <- "Concentration" :};

OBJ KH_ch4 "Henry's law constant (T-dep) for CH4 with temperature correction" : Ratio := {: group <- "System" :};
OBJ KH_co2 "Henry's law constant (T-dep) for CO2 with temperature correction" : Ratio:= {: group <- "System" :};
OBJ KH_h2 "Henry's law constant (T-dep) for H2 with temperature correction" : Ratio:= {: group <- "System" :};
 
OBJ M_An "Vector containing mass for all components of ADM1" : ADM1MassVector := [{: value <- 3400000 :},
	{: value <- 10 :}, {: value <- 10 :},{: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.1 :},
	{: value <- 0.1 :}, {: value <- 0.1 :},{: value <- 0.1 :}, {: value <- 0.1 :}, {: value <- 0.1 :},{: value <- 0.1 :},
	{: value <- 100 :},{: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :},{: value <- 100 :}, {: value <- 100 :},
	{: value <- 100 :},{: value <- 100 :}, {: value <- 100 :}, {: value <- 100 :},{: value <- 100 :}, {: value <- 100 :},
	{: value <- 0.1 :}, {: value <- 100 :}; ] ;
OBJ M_AnGas "Vector containing mass for all components of ADM1" : ADM1GasMassVector :=
	[{: value <- 10 :},{: value <- 0.01 :},{: value <- 0.01 :}; ];  
 
OBJ AnaerobicKinetics (* hidden = "1" *) "A vector containing kinetics for all anaerobic reactions" : PhysicalQuantityType[NrOfADM1Reactions;];
OBJ GasKinetics (* hidden = "1" *) "A vector containing kinetics for all anaerobic gas transfere" : PhysicalQuantityType[NrOfADM1GasTransfer;];

 

OBJ Q_In (* hidden = "1" *)"Influent flow rate" : FlowRate;
OBJ balance_COD_S (* hidden = "1" *)"total Cod of soluble substrate_kg COD.m-3" : KgCODConcentration;
OBJ balance_COD_X (* hidden = "1" *) "total Cod of particulate substrate_kg COD.m-3" : KgCODConcentration;

OBJ I_h2_fa "Hydrogen inhibition for LCFA degradation" : InhibitionFactor := {: group <- "Kinetics" :};
OBJ I_h2_c4 "Hydrogen inhibition for C4+ degradation" : InhibitionFactor := {: group <- "Kinetics" :};
OBJ I_h2_pro "Hydrogen inhibition for propionate " : InhibitionFactor := {: group <- "Kinetics" :};
OBJ I_nh3_ac "NH3 inhibition of acetoclastic methanogenesis" : InhibitionFactor := {: group <- "Kinetics" :};
OBJ I_NH_limit "Function to limit growth due to lack of inorganic nitrogen" : InhibitionFactor := {: group <- "Kinetics" :};

OBJ pH_ "pH" : pH := {: group <- "Operational" :};

OBJ Ka_in "Inorganic nitrogen acidity constant" : Real := {: group <- "System" :};
OBJ Ka_ic "Inorganic carbon acidity constant" : Real := {: group <- "System" :};
OBJ Kw "Water acidity constant" : Real := {: group <- "System" :};

OBJ p_ch4 "Partial pressure of ch4" : BarPressure := {: group <- "Operational" :};
OBJ p_co2 "Partial pressure of co2" : BarPressure := {: group <- "Operational" :};
OBJ p_h2 "Partial pressure of h2" : BarPressure := {: group <- "Operational" :};
OBJ P_headspace "Total gas phase pressure" : BarPressure := {: group <- "Operational" :};
OBJ p_h2o "Partial pressure of water" : BarPressure := {: group <- "Operational" :};

OBJ I_pH_ac "pH inhibition of acetate degrading organisms" : InhibitionFactor := {: group <- "Kinetics" :};
OBJ I_pH_bac "pH inhibition of acetogens and acidogens (lower inhibition only used here)" : InhibitionFactor := {: group <- "Kinetics" :};
OBJ I_pH_h2 "pH inhibition of hydrogen degrading organisms" : InhibitionFactor := {: group <- "Kinetics" :};

OBJ pHLim_ac "state needed in Hill function": Real := {: group <- "Kinetics" :};
OBJ pHLim_bac "state needed in Hill function": Real:= {: group <- "Kinetics" :};
OBJ pHLim_h2 "state needed in Hill function": Real := {: group <- "Kinetics" :};
OBJ n_ac "state needed in Hill function": Real := {: group <- "Kinetics" :};
OBJ n_bac "state needed in Hill function": Real := {: group <- "Kinetics" :};
OBJ n_h2 "state needed in Hill function": Real := {: group <- "Kinetics" :};

 
OBJ q (* hidden = "1" *)"Influent flow rate" : FlowRate;
OBJ q_gas "Gas flow rate" : FlowRate := {: group <- "Effluent" :};
OBJ q_gas_norm "Gas flow rate, normalised" : FlowRate := {: group <- "Effluent" :};

OBJ S_co2 "Carbon dioxide" : MolConcentration := {: group <- "Concentration" :};
OBJ S_nh4_ion "Ammonium ion" : MolConcentration := {: group <- "Concentration" :};
OBJ S_h_ion "Hydrogen ion" : MolConcentration := {: group <- "Concentration" :};

OBJ charge_balance "left hand-side of charge balance" : Real := {: group <- "Concentration" :};

    OBJ AnaerobicOutFluxPerComponent (* hidden = "1" *) "Vector containing outgoing fluxes for all ADM1 components" : ADM1MassFluxVector;
    OBJ AnaerobicInFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components of the ADM1" : ADM1MassFluxVector;
    OBJ AnaerobicConversionTermPerComponent (* hidden = "1" *) "Vector containing conversion terms for all components" : ADM1MassFluxVector;

OBJ AnaerobicGasOutFluxPerComponent (* hidden = "1" *) "Vector containing outgoing fluxes for all ADM1 components" : ADM1GasMassFluxVector;
    OBJ AnaerobicGasConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all  components" : ADM1GasMassFluxVector;
    
    OBJ AnaerobicOutIonConcentrationPerComponent (* hidden = "1" *) "Vector containing outgoing fluxes for all ADM1 components" : ADM1IonConcentrationVector;
    OBJ AnaerobicIonConcentrationConversionTermPerComponent (* hidden = "1" *) "Vector containing conversion terms for all components" : ADM1IonConcentrationVector;
OBJ help_T_op (* hidden = "0" *) "Temperature" : KelvinTemperature := {: group <- "temp" :};
   };

initial <-
{
   
  state.M_An[H2O_An] = 1000 * parameters.V_liq ;

 
 
 
 
 

 
    parameters.AnaerobicStoichiometry[decay_aa][X_c] := 1;
    parameters.AnaerobicStoichiometry[decay_aa][X_aa] := -1;
    parameters.AnaerobicStoichiometry[decay_aa][S_IC] := parameters.C_biom -parameters.C_Xc;
    parameters.AnaerobicStoichiometry[decay_aa][S_INN] := parameters.N_biom -parameters.N_Xc;

 
    parameters.AnaerobicStoichiometry[decay_ac][X_ac] := -1;
    parameters.AnaerobicStoichiometry[decay_ac][X_c] := 1;
    parameters.AnaerobicStoichiometry[decay_ac][S_IC] := parameters.C_biom -parameters.C_Xc;
    parameters.AnaerobicStoichiometry[decay_ac][S_INN] := parameters.N_biom -parameters.N_Xc;

 
    parameters.AnaerobicStoichiometry[decay_c4][X_c4] := -1;
    parameters.AnaerobicStoichiometry[decay_c4][X_c] := 1;
    parameters.AnaerobicStoichiometry[decay_c4][S_IC] := parameters.C_biom -parameters.C_Xc;
    parameters.AnaerobicStoichiometry[decay_c4][S_INN] := parameters.N_biom -parameters.N_Xc;

 
    parameters.AnaerobicStoichiometry[decay_fa][X_fa] := -1;
    parameters.AnaerobicStoichiometry[decay_fa][X_c] := 1;
    parameters.AnaerobicStoichiometry[decay_fa][S_IC] := parameters.C_biom -parameters.C_Xc;
    parameters.AnaerobicStoichiometry[decay_fa][S_INN] := parameters.N_biom -parameters.N_Xc;

 
    parameters.AnaerobicStoichiometry[decay_h2][X_h2] := -1;
    parameters.AnaerobicStoichiometry[decay_h2][X_c] := 1;
    parameters.AnaerobicStoichiometry[decay_h2][S_IC] := parameters.C_biom -parameters.C_Xc;
    parameters.AnaerobicStoichiometry[decay_h2][S_INN] := parameters.N_biom -parameters.N_Xc;

 
    parameters.AnaerobicStoichiometry[decay_pro][X_pro] := -1;
    parameters.AnaerobicStoichiometry[decay_pro][X_c] := 1;
    parameters.AnaerobicStoichiometry[decay_pro][S_IC] := parameters.C_biom -parameters.C_Xc;
    parameters.AnaerobicStoichiometry[decay_pro][S_INN] := parameters.N_biom -parameters.N_Xc;

 
    parameters.AnaerobicStoichiometry[decay_su][X_su] := -1;
    parameters.AnaerobicStoichiometry[decay_su][X_c] := 1;
    parameters.AnaerobicStoichiometry[decay_su][S_IC] := parameters.C_biom -parameters.C_Xc;
    parameters.AnaerobicStoichiometry[decay_su][S_INN] := parameters.N_biom -parameters.N_Xc;

 
    parameters.AnaerobicStoichiometry[dis][X_c] := -1;
    parameters.AnaerobicStoichiometry[dis][X_ch] := parameters.f_ch_xc;
    parameters.AnaerobicStoichiometry[dis][X_pr] := parameters.f_pr_xc;
    parameters.AnaerobicStoichiometry[dis][X_Inert] := parameters.f_XI_xc;
    parameters.AnaerobicStoichiometry[dis][X_li] := parameters.f_li_xc;
    parameters.AnaerobicStoichiometry[dis][S_Inert] := parameters.f_SI_xc;  
    parameters.AnaerobicStoichiometry[dis][S_IC] := parameters.C_Xc - parameters.f_ch_xc * parameters.C_ch - parameters.f_SI_xc * parameters.C_SI - parameters.f_pr_xc * parameters.C_pr -  parameters.f_XI_xc * parameters.C_XI - parameters.f_li_xc * parameters.C_li;
    parameters.AnaerobicStoichiometry[dis][S_INN] := parameters.N_Xc -parameters.f_XI_xc * parameters.N_XI -parameters.f_SI_xc * parameters.N_SI -parameters.f_pr_xc * parameters.N_aa;
    

 
    parameters.AnaerobicStoichiometry[hyd_ch][S_su] := 1;
    parameters.AnaerobicStoichiometry[hyd_ch][X_ch] := -1;
    parameters.AnaerobicStoichiometry[hyd_ch][S_IC] := parameters.C_ch - parameters.C_su;
    
 
    parameters.AnaerobicStoichiometry[hyd_li][S_su] := 1 -parameters.f_fa_li;
    parameters.AnaerobicStoichiometry[hyd_li][S_fa] := parameters.f_fa_li;
    parameters.AnaerobicStoichiometry[hyd_li][X_li] := -1;
    parameters.AnaerobicStoichiometry[hyd_li][S_IC] := (parameters.f_fa_li - 1) * parameters.C_su - parameters.f_fa_li * parameters.C_fa + parameters.C_li;

 
    parameters.AnaerobicStoichiometry[hyd_pr][S_aa] := 1;
    parameters.AnaerobicStoichiometry[hyd_pr][X_pr] := -1;
    parameters.AnaerobicStoichiometry[hyd_pr][S_IC] := parameters.C_aa - parameters.C_pr;
    
 
    parameters.AnaerobicStoichiometry[uptake_aa][S_h2] := (1-parameters.Y_aa)*parameters.f_h2_aa;
    parameters.AnaerobicStoichiometry[uptake_aa][S_IC] := parameters.C_aa - (1-parameters.Y_aa) * parameters.f_ac_aa * parameters.C_ac - (1-parameters.Y_aa) * parameters.f_bu_aa * parameters.C_bu -(1 -parameters.Y_aa) * parameters.f_pro_aa * parameters.C_pro -(1-parameters.Y_aa) * parameters.f_va_aa * parameters.C_va - parameters.Y_aa * parameters.C_biom;
    parameters.AnaerobicStoichiometry[uptake_aa][S_ac] := (1-parameters.Y_aa) * parameters.f_ac_aa;
    parameters.AnaerobicStoichiometry[uptake_aa][S_bu] := (1-parameters.Y_aa) * parameters.f_bu_aa;
    parameters.AnaerobicStoichiometry[uptake_aa][S_aa] := -1;
    parameters.AnaerobicStoichiometry[uptake_aa][S_pro] := (1-parameters.Y_aa) * parameters.f_pro_aa;
    parameters.AnaerobicStoichiometry[uptake_aa][S_va] := (1-parameters.Y_aa) * parameters.f_va_aa;
    parameters.AnaerobicStoichiometry[uptake_aa][S_INN] := parameters.N_aa -parameters.Y_aa * parameters.N_biom;
    parameters.AnaerobicStoichiometry[uptake_aa][X_aa] := parameters.Y_aa;

 
    parameters.AnaerobicStoichiometry[uptake_ac][S_ac] := -1;
    parameters.AnaerobicStoichiometry[uptake_ac][X_ac] := parameters.Y_ac;
    parameters.AnaerobicStoichiometry[uptake_ac][S_INN] := -parameters.N_biom * parameters.Y_ac;
    parameters.AnaerobicStoichiometry[uptake_ac][S_ch4] :=1-parameters.Y_ac;
    parameters.AnaerobicStoichiometry[uptake_ac][S_IC] := parameters.C_ac -parameters.Y_ac * parameters.C_biom -(1-parameters.Y_ac) * parameters.C_ch4;

 
    parameters.AnaerobicStoichiometry[uptake_bu][S_h2] := (1 -parameters.Y_c4 )*0.2;
    parameters.AnaerobicStoichiometry[uptake_bu][S_ac] := (1 -parameters.Y_c4 )*0.8;
    parameters.AnaerobicStoichiometry[uptake_bu][X_c4] := parameters.Y_c4 ;
    parameters.AnaerobicStoichiometry[uptake_bu][S_INN] := -parameters.N_biom * parameters.Y_c4;
    parameters.AnaerobicStoichiometry[uptake_bu][S_bu] := -1;
    parameters.AnaerobicStoichiometry[uptake_bu][S_IC] := parameters.C_bu - (1 -parameters.Y_c4 )* 0.8 * parameters.C_ac - parameters.Y_c4 * parameters.C_biom;

 
    parameters.AnaerobicStoichiometry[uptake_fa][S_h2] := (1-parameters.Y_fa)*0.3;
    parameters.AnaerobicStoichiometry[uptake_fa][S_ac] := (1-parameters.Y_fa)*0.7;
    parameters.AnaerobicStoichiometry[uptake_fa][X_fa] := parameters.Y_fa;
    parameters.AnaerobicStoichiometry[uptake_fa][S_INN] := -parameters.N_biom * parameters.Y_fa;
    parameters.AnaerobicStoichiometry[uptake_fa][S_fa] := -1;
    parameters.AnaerobicStoichiometry[uptake_fa][S_IC] := parameters.C_fa - (1-parameters.Y_fa) * 0.7 * parameters.C_ac - parameters.Y_fa * parameters.C_biom;

 
    parameters.AnaerobicStoichiometry[uptake_h2][S_h2] := -1;
    parameters.AnaerobicStoichiometry[uptake_h2][X_h2] := parameters.Y_h2;
    parameters.AnaerobicStoichiometry[uptake_h2][S_INN] := -parameters.N_biom * parameters.Y_h2;
    parameters.AnaerobicStoichiometry[uptake_h2][S_ch4] := 1 -parameters.Y_h2;
    parameters.AnaerobicStoichiometry[uptake_h2][S_IC] := -parameters.Y_h2 * parameters.C_biom - (1 -parameters.Y_h2) * parameters.C_ch4;
 
 
    parameters.AnaerobicStoichiometry[uptake_pro][S_h2] := (1-parameters.Y_pro)*0.43;
    parameters.AnaerobicStoichiometry[uptake_pro][S_ac] := (1-parameters.Y_pro)*0.57;
    parameters.AnaerobicStoichiometry[uptake_pro][X_pro] := parameters.Y_pro;
    parameters.AnaerobicStoichiometry[uptake_pro][S_INN] := -parameters.N_biom * parameters.Y_pro;
    parameters.AnaerobicStoichiometry[uptake_pro][S_pro] := -1;
    parameters.AnaerobicStoichiometry[uptake_pro][S_IC] := parameters.C_pro -(1 -parameters.Y_pro) * 0.57 * parameters.C_ac -parameters.Y_pro * parameters.C_biom;

 
    parameters.AnaerobicStoichiometry[uptake_su][S_h2] := (1-parameters.Y_su) * parameters.f_h2_su;
    parameters.AnaerobicStoichiometry[uptake_su][S_IC] := parameters.C_su -(1 - parameters.Y_su) * parameters.f_ac_su * parameters.C_ac -(1 -parameters.Y_su) * parameters.f_pro_su * parameters.C_pro -(1 -parameters.Y_su) * parameters.f_bu_su * parameters.C_bu -parameters.Y_su * parameters.C_biom;
    parameters.AnaerobicStoichiometry[uptake_su][S_ac] := (1 -parameters.Y_su) * parameters.f_ac_su;
    parameters.AnaerobicStoichiometry[uptake_su][X_su] := parameters.Y_su;
    parameters.AnaerobicStoichiometry[uptake_su][S_INN] := -parameters.N_biom * parameters.Y_su;
    parameters.AnaerobicStoichiometry[uptake_su][S_su] := -1;
    parameters.AnaerobicStoichiometry[uptake_su][S_bu] := (1-parameters.Y_su) * parameters.f_bu_su;
    parameters.AnaerobicStoichiometry[uptake_su][S_pro] := (1-parameters.Y_su) * parameters.f_pro_su;

 
    parameters.AnaerobicStoichiometry[uptake_va][S_h2] := (1-parameters.Y_c4)*0.15;
    parameters.AnaerobicStoichiometry[uptake_va][S_ac] := (1-parameters.Y_c4)*0.31;
    parameters.AnaerobicStoichiometry[uptake_va][X_c4] := parameters.Y_c4;
    parameters.AnaerobicStoichiometry[uptake_va][S_INN] := -parameters.N_biom * parameters.Y_c4;
    parameters.AnaerobicStoichiometry[uptake_va][S_va] := -1;
    parameters.AnaerobicStoichiometry[uptake_va][S_pro] := (1-parameters.Y_c4)*0.54;
    parameters.AnaerobicStoichiometry[uptake_va][S_IC] := parameters.C_va - (1-parameters.Y_c4)*0.54 * parameters.C_pro - parameters.Y_c4 * parameters.C_biom - (1-parameters.Y_c4) * 0.31 * parameters.C_ac;

 

 
    parameters.AnaerobicGasStoichiometryInLiquid[transfer_co2][S_IC_liq] := -1;
    parameters.AnaerobicGasStoichiometryInGas[transfer_co2][S_co2_gas] := 1;

 
    parameters.AnaerobicGasStoichiometryInLiquid[transfer_h2][S_h2_liq] := -1;
    parameters.AnaerobicGasStoichiometryInGas[transfer_h2][S_h2_gas] := 1; 

 
    parameters.AnaerobicGasStoichiometryInLiquid[transfer_ch4][S_ch4_liq] := -1;
    parameters.AnaerobicGasStoichiometryInGas[transfer_ch4][S_ch4_gas] := 1;

 
 
   parameters.help_T = parameters.T + 273.15 ;
};

independent <-
   { 
     OBJ t "Time"  : Time;
   };

equations <-
{

   state.help_T_op = interface.T_op + 273.15 ;

 
state.I_h2_fa = 1 / (state.C_h2 / parameters.KI_h2_fa + 1);
state.I_h2_c4 = 1 / (state.C_h2 / parameters.KI_h2_c4 + 1); 
state.I_h2_pro = 1 / ( state.C_h2 / parameters.KI_h2_pro + 1 );
state.I_nh3_ac = 1 / (state.C_AnIon[S_nh3] / parameters.KI_nh3_ac + 1);
state.I_NH_limit = IF (state.C_An[S_INN] < 0.00000001) THEN 0
     ELSE 1 / (parameters.Ks_IN / state.C_An[S_INN] + 1);
 











 
state.pHLim_ac = pow(10,(-(parameters.pH_ac_ul + parameters.pH_ac_ll)/2.0));
state.pHLim_bac = pow(10,(-(parameters.pH_bac_ul + parameters.pH_bac_ll)/2.0));
state.pHLim_h2 = pow(10,(-(parameters.pH_h2_ul + parameters.pH_h2_ll)/2.0));
state.n_ac = 3.0 / (parameters.pH_ac_ul - parameters.pH_ac_ll);
state.n_bac = 3.0 / (parameters.pH_bac_ul - parameters.pH_bac_ll);
state.n_h2 = 3.0 / (parameters.pH_h2_ul - parameters.pH_h2_ll);
state.I_pH_ac = pow(state.pHLim_ac,state.n_ac)/(pow(state.S_h_ion,state.n_ac)+pow(state.pHLim_ac ,state.n_ac));
state.I_pH_bac = pow(state.pHLim_bac,state.n_bac)/(pow(state.S_h_ion,state.n_bac)+pow(state.pHLim_bac ,state.n_bac));
state.I_pH_h2 = pow(state.pHLim_h2,state.n_h2)/(pow(state.S_h_ion,state.n_h2)+pow(state.pHLim_h2 ,state.n_h2));
 
 
 
 state.AnaerobicKinetics[decay_aa] = parameters.kdec_xaa * state.C_An[X_aa];
 
 state.AnaerobicKinetics[decay_ac] = parameters.kdec_xac * state.C_An[X_ac];
 
 state.AnaerobicKinetics[decay_c4] = parameters.kdec_xc4 * state.C_An[X_c4];
 
 state.AnaerobicKinetics[decay_fa] = parameters.kdec_xfa * state.C_An[X_fa];
 
 state.AnaerobicKinetics[decay_h2] = parameters.kdec_xh2 * state.C_An[X_h2];
 
 state.AnaerobicKinetics[decay_pro] = parameters.kdec_xpro * state.C_An[X_pro];
 
 state.AnaerobicKinetics[decay_su] = parameters.kdec_xsu * state.C_An[X_su];
 
 state.AnaerobicKinetics[dis] = parameters.kdis * state.C_An[X_c];
 
 state.AnaerobicKinetics[hyd_ch] = parameters.khyd_ch * state.C_An[X_ch];
 
 state.AnaerobicKinetics[hyd_li] = parameters.khyd_li * state.C_An[X_li];
 
 state.AnaerobicKinetics[hyd_pr] = parameters.khyd_pr * state.C_An[X_pr];
 
 state.AnaerobicKinetics[uptake_aa] = parameters.km_aa * state.C_An[X_aa] * state.C_An[S_aa] /(parameters.Ks_aa + state.C_An[S_aa]) * state.I_pH_bac * state.I_NH_limit;
 
 state.AnaerobicKinetics[uptake_ac] = parameters.km_ac * state.C_An[X_ac] * state.C_An[S_ac] / (parameters.Ks_ac + state.C_An[S_ac]) * state.I_pH_ac * state.I_nh3_ac * state.I_NH_limit;
 
 state.AnaerobicKinetics[uptake_bu] = parameters.km_c4 * state.C_An[X_c4] * state.C_An[S_bu] / (parameters.Ks_c4 + state.C_An[S_bu]) * state.C_An[S_bu] / (state.C_An[S_bu] + state.C_An[S_va] + 0.000001) * state.I_pH_bac * state.I_h2_c4 * state.I_NH_limit;
 
 state.AnaerobicKinetics[uptake_fa] = parameters.km_fa * state.C_An[X_fa] * state.C_An[S_fa] / (parameters.Ks_fa + state.C_An[S_fa]) * state.I_pH_bac * state.I_h2_fa * state.I_NH_limit;
 
 state.AnaerobicKinetics[uptake_h2] = parameters.km_h2 * state.C_An[X_h2] * state.C_h2 / (parameters.Ks_h2 + state.C_h2) * state.I_pH_h2 * state.I_NH_limit;
 
 state.AnaerobicKinetics[uptake_pro] = parameters.km_pro * state.C_An[X_pro] * state.C_An[S_pro] / (parameters.Ks_pro + state.C_An[S_pro]) * state.I_pH_bac * state.I_h2_pro * state.I_NH_limit;
 
 state.AnaerobicKinetics[uptake_su] = parameters.km_su * state.C_An[X_su] * state.C_An[S_su] / (parameters.Ks_su + state.C_An[S_su]) * state.I_pH_bac * state.I_NH_limit;
 
 state.AnaerobicKinetics[uptake_va] = parameters.km_c4 * state.C_An[X_c4] * state.C_An[S_va] / (parameters.Ks_c4 + state.C_An[S_va]) * state.C_An[S_va] / (state.C_An[S_va] + state.C_An[S_bu] + 0.000001) * state.I_pH_bac * state.I_h2_c4 * state.I_NH_limit;
 
 
state.KH_co2 = 0.035 * exp(-19410/(parameters.R*100)*(1/parameters.help_T - 1/state.help_T_op));
state.KH_h2 = 7.8e-4 * exp(-4180/(parameters.R*100)*(1/parameters.help_T - 1/state.help_T_op));
state.KH_ch4 = 0.0014 * exp(-14240/(parameters.R*100)*(1/parameters.help_T - 1/state.help_T_op));
 
 state.GasKinetics[transfer_co2] =  parameters.kla * ( state.S_co2 - state.KH_co2 * state.C_AnGas[S_co2_gas] * parameters.R * state.help_T_op );
 
 state.GasKinetics[transfer_h2] =  parameters.kla * ( state.C_h2 -  state.KH_h2 * state.C_AnGas[S_h2_gas] * parameters.R * state.help_T_op );
 
 state.GasKinetics[transfer_ch4] =  parameters.kla * ( state.C_An[S_ch4] -  state.KH_ch4 * state.C_AnGas[S_ch4_gas] * parameters.R * state.help_T_op );
 
state.Ka_in = pow(10,-9.25)*(exp(51965*(1/parameters.help_T - 1/state.help_T_op)/(100*parameters.R)));   
state.Ka_ic = pow(10,-6.35)*(exp(7646*(1/parameters.help_T - 1/state.help_T_op)/(100*parameters.R)));
state.Kw = pow(10,-14)*(exp(55900*(1/parameters.help_T - 1/state.help_T_op)/(100*parameters.R)));

 
  state.C_AnIon[S_nh3] = IF ((state.C_An[S_INN] - state.S_nh4_ion) <= 0) THEN 0.0
		ELSE (state.C_An[S_INN] - state.S_nh4_ion) ;
  state.S_co2 = IF ((state.C_An[S_IC] - state.C_AnIon[S_hco3_ion]) <= 0) THEN 0.0
		ELSE (state.C_An[S_IC] - state.C_AnIon[S_hco3_ion]) ;
  state.S_nh4_ion = IF (MSLU_NH_ion(state.Ka_in,state.C_An[S_INN],state.S_h_ion) <=0) THEN 0.0
  		ELSE MSLU_NH_ion(state.Ka_in,state.C_An[S_INN],state.S_h_ion) ;
  state.C_AnIon[S_hco3_ion] = IF (MSLU_HCO_ion(state.Ka_ic,state.C_An[S_IC],state.S_h_ion) <=0) THEN 0.0
  		ELSE MSLU_HCO_ion(state.Ka_ic,state.C_An[S_IC],state.S_h_ion) ;
  state.C_AnIon[S_ac_ion] = IF (MSLU_ac_ion(parameters.Ka_ac,state.C_An[S_ac],state.S_h_ion) <=0) THEN 0.0
  		ELSE MSLU_ac_ion(parameters.Ka_ac,state.C_An[S_ac],state.S_h_ion) ;
  state.C_AnIon[S_pro_ion] = IF (MSLU_pro_ion(parameters.Ka_pro,state.C_An[S_pro],state.S_h_ion) <=0) THEN 0.0
  		ELSE MSLU_pro_ion(parameters.Ka_pro,state.C_An[S_pro],state.S_h_ion) ;
  state.C_AnIon[S_bu_ion] = IF (MSLU_bu_ion(parameters.Ka_bu,state.C_An[S_bu],state.S_h_ion) <=0) THEN 0.0
  		ELSE MSLU_bu_ion(parameters.Ka_bu,state.C_An[S_bu],state.S_h_ion) ;
  state.C_AnIon[S_va_ion] = IF (MSLU_va_ion(parameters.Ka_va,state.C_An[S_va],state.S_h_ion) <=0) THEN 0.0
  		ELSE MSLU_va_ion(parameters.Ka_va,state.C_An[S_va],state.S_h_ion) ;
	
  state.S_h_ion= MSLUNewtonRaphson_pH(state.Ka_in,state.Ka_ic,parameters.Ka_ac,parameters.Ka_bu,parameters.Ka_va,parameters.Ka_pro,state.Kw,
        state.C_An[S_INN],state.C_An[S_IC],state.C_An[S_ac],state.C_An[S_bu],state.C_An[S_va],state.C_An[S_pro],state.C_An[S_cat],
		state.C_An[S_an],previous(state.S_h_ion)) ;
  state.pH_ = -log10(state.S_h_ion);
   
  state.charge_balance = state.S_h_ion + state.C_An[S_cat] + state.S_nh4_ion - state.C_An[S_an] -
  		state.Kw/state.S_h_ion - state.C_AnIon[S_hco3_ion] - state.C_AnIon[S_ac_ion]/64.0 -
		state.C_AnIon[S_pro_ion]/112.0 - state.C_AnIon[S_bu_ion]/160.0 - state.C_AnIon[S_va_ion]/208.0 ;
   
   
   
  state.p_ch4 = IF(state.C_AnGas[S_ch4_gas] <= 0) THEN 0.0
  		ELSE (state.C_AnGas[S_ch4_gas] * parameters.R * state.help_T_op / 64.0) ;
  state.p_co2 = IF(state.C_AnGas[S_co2_gas] <= 0) THEN 0.0
  		ELSE (state.C_AnGas[S_co2_gas] * parameters.R * state.help_T_op) ;
  state.p_h2 = IF(state.C_AnGas[S_h2_gas] <= 0) THEN 0.0
  		ELSE (state.C_AnGas[S_h2_gas] * parameters.R * state.help_T_op / 16.0) ;
  state.p_h2o = 0.0313 * exp(5290*(1.0/parameters.help_T - 1.0/state.help_T_op));
  state.P_headspace = state.p_co2 + state.p_h2 + state.p_ch4 + state.p_h2o;
   
  state.q = IF ((state.P_headspace - parameters.P_atm)*parameters.K_p <= 0.0) THEN 0.0
  		ELSE (state.P_headspace - parameters.P_atm) * parameters.K_p ;
  state.q_gas = state.q ;
  state.q_gas_norm = state.q_gas * state.P_headspace * (1.0 / parameters.P_atm);
  
 

 
   state.Q_In = interface.Inflow[H2O_An];
   
   {FOREACH Comp_Index IN {S_INN .. S_cat}:
         state.AnaerobicInFluxPerComponent[Comp_Index] =
          interface.Inflow[Comp_Index]
           * state.Q_In;
    };
  state.AnaerobicInFluxPerComponent[H2O_An]= state.Q_In * 1000;
  
   
 

     state.AnaerobicConversionTermPerComponent[S_INN] =
             SUMOVER Reaction_Index IN {1 .. NrOfADM1Reactions}:
              (parameters.AnaerobicStoichiometry[Reaction_Index][S_INN]
               * state.AnaerobicKinetics[Reaction_Index])
              * parameters.V_liq;
      
      state.AnaerobicConversionTermPerComponent[S_IC] =
                    parameters.AnaerobicGasStoichiometryInLiquid[transfer_co2][S_IC_liq]
         * state.GasKinetics[transfer_co2] * parameters.V_liq +
        ( SUMOVER Reaction_Index IN {1 .. NrOfADM1Reactions}:
                    (parameters.AnaerobicStoichiometry[Reaction_Index][S_IC]
                     * state.AnaerobicKinetics[Reaction_Index])
                    * parameters.V_liq) ;
   
    state.AnaerobicConversionTermPerComponent[S_ch4] =
                parameters.AnaerobicGasStoichiometryInLiquid[transfer_ch4][S_ch4_liq]
         * state.GasKinetics[transfer_ch4] * parameters.V_liq + 
        ( SUMOVER Reaction_Index IN {1 .. NrOfADM1Reactions}:
                 (parameters.AnaerobicStoichiometry[Reaction_Index][S_ch4]
                  * state.AnaerobicKinetics[Reaction_Index])
                 * parameters.V_liq );
       
 









         
   { FOREACH Comp_Index IN {S_aa .. S_cat}:
      state.AnaerobicConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfADM1Reactions}:
        (parameters.AnaerobicStoichiometry[Reaction_Index][Comp_Index]
         * state.AnaerobicKinetics[Reaction_Index])
        * parameters.V_liq;
    };
      
     
    
   {FOREACH Comp_Index IN {S_ch4_gas .. NrOfADM1GasComponents}:
             state.AnaerobicGasConversionTermPerComponent[Comp_Index] =
              SUMOVER Reaction_Index IN {1 .. NrOfADM1GasTransfer}:
               (parameters.AnaerobicGasStoichiometryInGas[Reaction_Index][Comp_Index]
             * state.GasKinetics[Reaction_Index])* parameters.V_liq;
    
    };
   

 

  state.C_h2 = MSLUNewtonRaphson_h2(state.Q_In, parameters.V_liq, 
           interface.Inflow[S_h2], previous(state.C_h2), parameters.Y_su, 
       parameters.f_h2_su, state.AnaerobicKinetics[uptake_su], parameters.Y_aa, parameters.f_h2_aa,
             state.AnaerobicKinetics[uptake_aa], parameters.Y_fa, 
       parameters.km_fa,state.C_An[S_fa],parameters.Ks_fa,state.C_An[X_fa],state.I_pH_bac,state.I_NH_limit, 
       parameters.KI_h2_fa, parameters.Y_c4,
       parameters.km_c4,state.C_An[S_va],parameters.Ks_c4,state.C_An[X_c4],state.C_An[S_bu],
             parameters.KI_h2_c4,parameters.Y_pro, 
       parameters.km_pro,state.C_An[S_pro],parameters.Ks_pro,state.C_An[X_pro],
       parameters.KI_h2_pro, parameters.km_h2, parameters.Ks_h2,state.C_An[X_h2],
       state.I_pH_h2, parameters.kla, state.KH_h2, state.p_h2);
  
    {FOREACH Comp_Index IN {S_INN .. S_ch4}:
      DERIV(state.M_An[Comp_Index],[independent.t]) =
       state.AnaerobicInFluxPerComponent[Comp_Index]
       - state.AnaerobicOutFluxPerComponent[Comp_Index]
       + state.AnaerobicConversionTermPerComponent[Comp_Index];
    };

    {FOREACH Comp_Index IN {S_aa .. X_su}:
      DERIV(state.M_An[Comp_Index],[independent.t]) =
       state.AnaerobicInFluxPerComponent[Comp_Index]
       - state.AnaerobicOutFluxPerComponent[Comp_Index]
       + state.AnaerobicConversionTermPerComponent[Comp_Index];
    };    
  
    {FOREACH Comp_Index IN {S_an .. S_cat}:
      DERIV(state.M_An[Comp_Index],[independent.t]) =
       state.AnaerobicInFluxPerComponent[Comp_Index]
       - state.AnaerobicOutFluxPerComponent[Comp_Index];
    };  
   
     DERIV(state.M_An[S_h2],[independent.t]) = 0;
    
   {FOREACH Comp_Index IN {1 .. NrOfADM1GasComponents}:
      DERIV(state.M_AnGas[Comp_Index],[independent.t]) =
              - state.AnaerobicGasOutFluxPerComponent[Comp_Index]
       + state.AnaerobicGasConversionTermPerComponent[Comp_Index];
    };  
   
   
   
   
  state.C_An[H2O_An] = 1000;
  {FOREACH Comp_Index IN {S_INN .. S_ch4}:
  		state.C_An[Comp_Index] = state.M_An[Comp_Index] / parameters.V_liq ; };
  {FOREACH Comp_Index IN {S_aa .. S_cat}:
  		state.C_An[Comp_Index] = state.M_An[Comp_Index] / parameters.V_liq ; };
   
  {FOREACH Comp_Index IN {1 .. NrOfADM1GasComponents}:
  		state.C_AnGas[Comp_Index] = state.M_AnGas[Comp_Index] / parameters.V_gas ; };
   
   
  {FOREACH Comp_Index IN {S_INN .. S_ch4}:
  		state.AnaerobicOutFluxPerComponent[Comp_Index] = state.C_An[Comp_Index] * state.Q_In ; };
  {FOREACH Comp_Index IN {S_aa .. S_va}:
  		state.AnaerobicOutFluxPerComponent[Comp_Index] = state.C_An[Comp_Index] * state.Q_In ; }; 
  state.AnaerobicOutFluxPerComponent[S_h2] = state.C_h2 * state.Q_In ;
  state.AnaerobicOutFluxPerComponent[S_an] = state.C_An[S_an] * state.Q_In ;
  state.AnaerobicOutFluxPerComponent[S_cat] = state.C_An[S_cat] * state.Q_In ;
   
  {FOREACH Comp_Index IN {1 .. NrOfADM1GasComponents}:
  		state.AnaerobicGasOutFluxPerComponent[Comp_Index] = state.C_AnGas[Comp_Index] * state.q_gas ; };
   
   
   
  {FOREACH Comp_Index IN {X_aa .. X_su}:
  		state.AnaerobicOutFluxPerComponent[Comp_Index] = parameters.f_X_Out * ( state.C_An[Comp_Index] * state.Q_In) ; };
  {FOREACH Comp_Index IN {S_INN .. S_ch4}:
  		interface.Outflow[Comp_Index] = state.C_An[Comp_Index] ; };
  {FOREACH Comp_Index IN {S_aa .. S_cat}:
  		interface.Outflow[Comp_Index] = state.C_An[Comp_Index] ; };
  interface.Outflow[S_h2] = state.C_h2; 
  {FOREACH Comp_Index IN {1 .. NrOfADM1GasComponents}:
  		interface.Q_Gas_LD[Comp_Index]= state.C_AnGas[Comp_Index] ; };
   
   
  interface.Outflow[H2O_An]= state.Q_In;  
  interface.pH_ADM = state.pH_;
  interface.T_oper = interface.T_op;
  interface.p_gas_ch4 = state.p_ch4;
  interface.p_gas_tot = state.P_headspace;
  interface.gas_flowrate = state.q_gas_norm;
  interface.V_liquid = parameters.V_liq;
  interface.V_tot = parameters.V_liq + parameters.V_gas;
   
  {FOREACH Comp_Index IN {1 .. NrOfADM1Components}: interface.Conc_An[Comp_Index] = state.C_An[Comp_Index] ; };
  {FOREACH Comp_Index IN {1 .. NrOfADM1IonComponents}: interface.Conc_AnIon[Comp_Index] = state.C_AnIon[Comp_Index] ; };
  {FOREACH Comp_Index IN {1 .. NrOfADM1GasComponents}: interface.Conc_AnGas[Comp_Index] = state.C_AnGas[Comp_Index] ; };
};
:};




# 18 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.ADM1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.transformers.ADM1.msl" 1
 




















CLASS ASM1toADM1
 "ASM1 to IWA ADM1 anaerobic model states flow transformer for use in BSM2"

 SPECIALISES PhysicalDAEModelType :=
 {:

  comments <- "Transforms a ASM1 influent to a ADM1 anaerobic influent type";

  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "Inflow in flux" : InWWTPTerminal  := {: causality <- "CIN"; group <- "Influent" :};
  OBJ Outflow (* terminal = "out_1" *) "Outflow" : InADM1ConcTerminal := {: causality <- "COUT"; group <- "Effluent" :};
  OBJ pH_adm (* terminal = "in_2"; manip = "1" *) "pH of the digester": Real:={: causality <- "CIN"; value <- 6.8; group <- "Operational" :};
  OBJ pH_as (* terminal = "in_2"; manip = "1" *) "pH of the activated sludge": Real:={: causality <- "CIN"; value <- 7; group <- "Operational" :};
  OBJ T_op (* terminal = "in_2"; manip = "1" *) "Operating temperature": CelsiusTemperature := {: causality <- "CIN"; value <- 35; group <- "Operational" :};
  };

  parameters <-
  {
   
  OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components" : SpecificVolumeVector;
   
  OBJ naa "Nitrogen content of amino acids (gN/gCOD)" : NitrogenContentOfAminoAcids := {: value <- 0.098; group <- "Stoichiometry" :};  
   
   
  OBJ nbac "nitrogen content of biomass (gN/gCOD)" : Fraction := {: value <- 0.08; group <- "Stoichiometry" :}; 
  OBJ nxc "nitrogen content of composites (gN/gCOD)" : Fraction := {: value <- 0.0376; group <- "Stoichiometry" :}; 
  OBJ nxi "nitrogen content of XI and XP (same in AS and AD) (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :}; 
  OBJ nsi "nitrogen content of SI in ASM (gN/gCOD)" : Fraction := {: value <- 0.00; group <- "Stoichiometry" :};
  OBJ nsi_adm "nitrogen content of SI in ADM (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
   
  OBJ frlixs "lipid fraction of non-nitrogenous Xs" : Fraction := {: value <- 0.7; group <- "Stoichiometry" :};
  OBJ frxs "anaerobically degradable fraction of biomass" : Fraction := {: value <- 0.68; group <- "Stoichiometry" :};
  OBJ frlixb "lipid fraction of non-nitrogenous XBA, XBH COD" : Fraction := {: value <- 0.4; group <- "Stoichiometry":};
  OBJ fdegrade "Fraction of X_BH and X_BA (ASM1) that is biodegradable in anaerobic conditions" : Fraction := {: value <- 0.0; group <- "ASM1 -> ADM1" :};
   
  OBJ T_ref "Reference temperature (ie 25 degC)": CelsiusTemperature := {: value <- 25; group <- "Operational":};
  OBJ help_TK_ref (* hidden = "1" *) "Reference temperature (K)": Real ;
 
  OBJ R "Gas law constant" : GasLawConstant := {: value <- 0.08314; group <- "System" :};
   
  OBJ pKa_ac "Acetate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 4.76; group <- "System":}; 
  OBJ pKa_bu "Butyrate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 4.82; group <- "System":};
  OBJ pKa_pro "Propionate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 4.88; group <- "System":};
  OBJ pKa_va "Valerate acidity constant (temperature correction can be ignored)" : Acidity:= {: value <- 4.86; group <- "System":};
   
 
 
  };
  
  initial <-
  {
  parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  parameters.help_TK_ref = parameters.T_ref + 273.15;
  };

  independent <- 
  {
  OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ InflowConcentration "Inflow" : InWWTPConcTerminal  := {: group <- "Influent" :};
   
   OBJ COD_Demand "the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
   OBJ temp1 "first COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
   OBJ temp2 "Second COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
   OBJ temp3 "Third COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};
   OBJ temp4 "Fourth COD level to compare the COD required to reduce the incoming electron acceptors i.e. S_O, S_NO in ASM1" : Concentration:= {: group <- "Concentration" :};

   OBJ S_S_reduced "reduced from the influent value to compensate for the incoming electron acceptors": Concentration:= {: group <- "Concentration" :};
   OBJ S_ND_reduced_1 "reduced from the influent value to compensate for the incoming electron acceptors (O2 and NO3)": Concentration:= {: group <- "Concentration" :};
   OBJ S_ND_reduced_2 "reduced after mapping of Ss to amino acids": Concentration:= {: group <- "Concentration" :};
   OBJ S_ND_reduced_3 "reduced after mapping of Si": Concentration:= {: group <- "Concentration" :};
   OBJ X_S_reduced "reduced from the influent value to compensate for the incoming electron acceptors if needed after S_S reduction" : Concentration:= {: group <- "Concentration" :};
   OBJ X_ND_reduced_1 "reduced from the influent value to compensate for the incoming electron acceptors if needed after S_S reduction" : Concentration:= {: group <- "Concentration" :};
   OBJ X_ND_reduced_2 "reduced after mapping of remaining COD" : Concentration:= {: group <- "Concentration" :};
   OBJ X_ND_reduced_3 "reduced after mapping of biomass" : Concentration:= {: group <- "Concentration" :};
   OBJ X_ND_reduced_4 "reduced after mapping of Si" : Concentration:= {: group <- "Concentration" :};
   OBJ X_BH_reduced "reduced from the influent value to compensate for the incoming electron acceptors if needed after X_S reduction": Concentration:= {: group <- "Concentration" :};
   OBJ X_BA_reduced "reduced from the influent value to compensate for the incoming electron acceptors if needed after XBH_S reduction": Concentration:= {: group <- "Concentration" :};
   OBJ inertS "temporary state for calculation of inert solubles": Concentration:= {: group <- "Concentration" :};
   OBJ S_NH_changed_1 "changed NH4 concentration when biomass is used to compensate for incoming electron acceptors ": Concentration:= {: group <- "Concentration" :};
   OBJ S_NH_changed_2 "changed NH4 concentration for compensating denitrification": Concentration:= {: group <- "Concentration" :};
   OBJ S_NH_changed_3 "changed NH4 concentration after mapping of Si": Concentration:= {: group <- "Concentration" :};
   OBJ S_NH_den_1 "ammonium correction from SND after denitrification":Concentration:= {: group <- "Concentration" :};
   OBJ S_NH_den_2 "ammonium correction from XND after denitrification":Concentration:= {: group <- "Concentration" :};
   
   OBJ ReqCODs "Required Saa in ADM1 (as if all Saa Nitrogen is corresponding to Snd from ASM1)" : Concentration:= {: group <- "Concentration" :};
   OBJ biomass "total incoming biomass"  : Concentration:= {: group <- "Concentration" :};
   OBJ biomass_nobio "biomass not anaerobically degradable"  : Concentration:= {: group <- "Concentration" :};
   OBJ biomass_bioN "nitrogen part of biological degradable biomass"  : Concentration:= {: group <- "Concentration" :};
   OBJ prot_XS "Proteins in XS" : Concentration:= {: group <- "Concentration" :};
   OBJ prot_biom "Proteins in biomass (X_BA + X_BH)" : Concentration:= {: group <- "Concentration" :};
   OBJ li_XS "Lipids in XS" : Concentration:= {: group <- "Concentration" :};
   OBJ li_biom "Lipids in biomass (X_BA + X_BH)" : Concentration:= {: group <- "Concentration" :};
   OBJ ch_XS "Carbohydrates in XS" : Concentration:= {: group <- "Concentration" :};
   OBJ ch_biom "Carbohydrates in biomass (X_BA + X_BH)" : Concentration:= {: group <- "Concentration" :};
   OBJ su_from_ss "Sugars created from Ss": Concentration:= {: group <- "Concentration" :};
   OBJ su_from_si "Sugars created from Si": Concentration:= {: group <- "Concentration" :};

   OBJ Snh_release "SNH released during NO3 removal" : Concentration:= {: group <- "Concentration" :};
   
   OBJ COD_in "Incoming COD to the interface": Concentration:= {: group <- "Concentration" :};
   OBJ COD_out "Outgoing COD from the interface": Concentration:= {: group <- "Concentration" :};
   OBJ COD_balance "difference between COD in and out": Real:= {: group <- "Concentration" :};
   OBJ N_in "Incoming N to the interface": Concentration:= {: group <- "Concentration" :};
   OBJ N_out "Outgoing N from the interface": Concentration:= {: group <- "Concentration" :};
   OBJ N_balance "difference between N in and out": Real:= {: group <- "Balance" :};
   OBJ degradability "degradability of the digester influent": Fraction:= {: group <- "Balance" :};

   OBJ alfa_ac "acetate charge": Real:= {: group <- "Balance" :};
   OBJ alfa_pro "propionate charge": Real:= {: group <- "Balance" :};
   OBJ alfa_bu "butyrate charge": Real:= {: group <- "Balance" :};
   OBJ alfa_va "valerate charge": Real:= {: group <- "Balance" :};
   OBJ alfa_in_adm "inorganic nitrogen charge in digester": Real:= {: group <- "Balance" :}; 
   OBJ alfa_ic "inorganic carbon charge": Real:= {: group <- "Balance" :};
   OBJ alfa_nh "ammonium charge": Real:= {: group <- "Balance" :};
   OBJ alfa_no "nitrate charge": Real:= {: group <- "Balance" :};
   OBJ alfa_alk "alkalinity charge": Real:= {: group <- "Balance" :};
   OBJ alfa_in_as "inorganic nitrogen charge in the activated sludge": Real:= {: group <- "Balance" :};
   OBJ cat_an "cations minus anions": Real:= {: group <- "Balance" :};
   
   OBJ pKa_in "Inorganic nitrogen acidity constant" : Real:= {: group <- "System" :};
   OBJ pKa_ic "Inorganic carbon acidity constant" : Real:= {: group <- "System" :};
   OBJ pKw "Water acidity constant" : Real:= {: group <- "System" :};
   
   OBJ help_TK_op (* hidden = "1" *) "Operational temperature (K)": Real ;
   };

  equations <-
  {
 
  {state.InflowConcentration[IndexOfSolvent] = interface.Inflow[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];}; 

     {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      state.InflowConcentration[Comp_Index] = IF (state.InflowConcentration[IndexOfSolvent] == 0)
                      THEN 0
                      ELSE interface.Inflow[Comp_Index] / state.InflowConcentration[IndexOfSolvent] ;};

 
 
    interface.Outflow[H2O_An] = state.InflowConcentration[H2O];
    
 
 
    state.COD_Demand = state.InflowConcentration[S_O]+ 2.86 * state.InflowConcentration[S_NO];
    
 
    state.temp1=state.InflowConcentration[S_S];
    state.temp2=state.InflowConcentration[S_S]+state.InflowConcentration[X_S];
    state.temp3=state.InflowConcentration[S_S]+state.InflowConcentration[X_S]+state.InflowConcentration[X_BH];
    state.temp4=state.InflowConcentration[S_S]+state.InflowConcentration[X_S]+state.InflowConcentration[X_BH]+interface.Inflow[X_BA];

    state.S_S_reduced=  
  IF(state.COD_Demand > state.temp1)
      THEN 0                                           
      ELSE state.InflowConcentration[S_S] - state.COD_Demand;   
                      
    state.X_S_reduced=  
  IF(state.COD_Demand > state.temp2)
      THEN 0
      ELSE 
       IF (state.COD_Demand > state.temp1)
          THEN state.InflowConcentration[X_S] - state.COD_Demand + state.InflowConcentration[S_S]
          ELSE state.InflowConcentration[X_S];
                      
    state.X_BH_reduced= 
  IF(state.COD_Demand > state.temp3)
      THEN 0
      ELSE 
        IF (state.COD_Demand > state.temp2)
           THEN state.InflowConcentration[X_BH] - state.COD_Demand + state.InflowConcentration[S_S] +state.InflowConcentration[X_S]
           ELSE state.InflowConcentration[X_BH];
                      
    state.X_BA_reduced=
  IF(state.COD_Demand > state.temp4)
      THEN 0                              
      ELSE 
       IF (state.COD_Demand > state.temp3)
            THEN state.InflowConcentration[X_BA] - state.COD_Demand + state.InflowConcentration[S_S] +state.InflowConcentration[X_S]+state.InflowConcentration[X_BH]
            ELSE state.InflowConcentration[X_BA];                 
 
  state.S_NH_changed_1= state.InflowConcentration[S_NH]+parameters.nbac
  *(state.InflowConcentration[X_BA]-state.X_BA_reduced+state.InflowConcentration[X_BH]-state.X_BH_reduced);                     

 
 
    state.S_ND_reduced_1= state.InflowConcentration[S_ND];
 
 
 
  state.X_ND_reduced_1=  state.InflowConcentration[X_ND];
 
 
 
 
 
    state.ReqCODs = state.InflowConcentration[S_ND] / parameters.naa;
  
  interface.Outflow[S_aa] = 
  IF(state.S_S_reduced <= state.ReqCODs)       
     THEN state.S_S_reduced/1000             
     ELSE state.ReqCODs/1000;                 
                
    state.su_from_ss = 
  IF(state.S_S_reduced <= state.ReqCODs)
       THEN 0
       ELSE (state.S_S_reduced-state.ReqCODs);   

    state.S_ND_reduced_2 = 
    IF(state.S_S_reduced <= state.ReqCODs)
     THEN state.S_ND_reduced_1 - state.S_S_reduced*parameters.naa    
     ELSE 0;   

 

    state.S_NH_den_1 = 
  IF (state.InflowConcentration[S_S] == 0)
     THEN state.InflowConcentration[S_ND]
     ELSE (state.InflowConcentration[S_S]- state.S_S_reduced)*state.InflowConcentration[S_ND]/state.InflowConcentration[S_S];
  
    state.S_NH_den_2 = 
  IF (state.InflowConcentration[X_S] == 0)
     THEN state.InflowConcentration[X_ND]
     ELSE (state.InflowConcentration[X_S]- state.X_S_reduced)*state.InflowConcentration[X_ND]/state.InflowConcentration[X_S];    

    state.S_NH_changed_2=state.S_NH_changed_1; 
  
 
 
 
    state.prot_XS = 
  IF(state.X_S_reduced <= state.X_ND_reduced_1 / parameters.naa)   
     THEN state.X_S_reduced   
     ELSE state.X_ND_reduced_1 / parameters.naa;   
    
  state.X_ND_reduced_2=  
  IF(state.X_S_reduced <= state.X_ND_reduced_1 / parameters.naa)  
     THEN state.X_ND_reduced_1 - state.X_S_reduced*parameters.naa
     ELSE 0;
  
  state.biomass=state.InflowConcentration[X_BA] +state.InflowConcentration[X_BH];
  state.biomass_nobio=state.biomass*(1-parameters.frxs);
  state.biomass_bioN=parameters.nbac*state.biomass - state.biomass_nobio*parameters.nxi;
  state.prot_biom = 
  IF (state.biomass_bioN / parameters.naa <= (state.biomass - state.biomass_nobio)) 
     THEN  
       IF(state.X_ND_reduced_2 / parameters.naa > (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa))  
         THEN state.biomass_bioN / parameters.naa + (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa)  
       ELSE state.biomass_bioN / parameters.naa + state.X_ND_reduced_2 / parameters.naa  
     ELSE state.biomass - state.biomass_nobio;
   

   state.X_ND_reduced_3=  
   IF (state.biomass_bioN / parameters.naa <= (state.biomass - state.biomass_nobio)) 
      THEN 
     IF (state.X_ND_reduced_2 / parameters.naa > (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa))
        THEN state.X_ND_reduced_2 - (state.biomass - state.biomass_nobio - state.biomass_bioN / parameters.naa)*parameters.naa
      ELSE 0
    ELSE state.X_ND_reduced_2 + state.biomass*parameters.nbac - state.biomass_nobio*parameters.nxi - (state.biomass - state.biomass_nobio)*parameters.naa;
   
 
    state.ch_XS = IF(state.X_S_reduced <= state.prot_XS)
                THEN 0
          ELSE  (state.X_S_reduced - state.prot_XS)*(1 - parameters.frlixs);
  state.ch_biom = IF(parameters.frxs * state.biomass <= state.prot_biom)  
                  THEN 0
          ELSE (parameters.frxs * state.biomass - state.prot_biom) * (1 - parameters.frlixb);

 
    state.li_XS = IF(state.X_S_reduced < state.prot_XS)
                THEN 0
          ELSE  (state.X_S_reduced - state.prot_XS)*parameters.frlixs;
  state.li_biom = IF(parameters.frxs * state.biomass < state.prot_biom)  
                  THEN 0
          ELSE (parameters.frxs * state.biomass - state.prot_biom) * parameters.frlixb;     

 
 
  interface.Outflow[X_Inert] = 
  ((1-parameters.fdegrade)*(state.InflowConcentration[X_P] +state.InflowConcentration[X_I]) 
  + state.biomass_nobio)/1000;
 
 
    state.inertS =
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN
      IF (state.S_NH_changed_2 <(state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm)
       THEN state.InflowConcentration[S_I]*parameters.nsi/parameters.nsi_adm + state.S_ND_reduced_2/parameters.nsi_adm + state.X_ND_reduced_3/parameters.nsi_adm + state.S_NH_changed_2/parameters.nsi_adm
       ELSE state.InflowConcentration[S_I]
     ELSE state.InflowConcentration[S_I]     
     ELSE state.InflowConcentration[S_I]  
   ELSE state.InflowConcentration[S_I];
  
  interface.Outflow[S_Inert] = state.inertS/1000;
 
    state.S_ND_reduced_3=
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN  0  
     ELSE state.S_ND_reduced_2 - (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm))*parameters.nsi_adm  
   ELSE state.S_ND_reduced_2 + state.InflowConcentration[S_I]*(parameters.nsi-parameters.nsi_adm);

    state.X_ND_reduced_4=
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN 0
     ELSE state.X_ND_reduced_3 - (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm     
     ELSE state.X_ND_reduced_3  
   ELSE state.X_ND_reduced_3;

    state.S_NH_changed_3=
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN
      IF (state.S_NH_changed_2 <(state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm)
       THEN 0
       ELSE state.S_NH_changed_2 - (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm
     ELSE state.S_NH_changed_2     
     ELSE state.S_NH_changed_2  
   ELSE state.S_NH_changed_2; 

 
  state.su_from_si = 
  IF (state.InflowConcentration[S_I]*parameters.nsi < state.InflowConcentration[S_I]*parameters.nsi_adm)
   THEN 
    IF (state.S_ND_reduced_2 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)*parameters.nsi_adm))
     THEN
    IF (state.X_ND_reduced_3 < (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm)*parameters.nsi_adm)
     THEN
      IF (state.S_NH_changed_2 <(state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm)*parameters.nsi_adm)
       THEN (state.InflowConcentration[S_I]*(1-parameters.nsi/parameters.nsi_adm)-state.S_ND_reduced_2/parameters.nsi_adm-state.X_ND_reduced_3/parameters.nsi_adm-state.S_NH_changed_2/parameters.nsi_adm)
       ELSE 0
     ELSE 0    
     ELSE 0  
   ELSE 0;
    
  interface.Outflow[S_su] = (state.su_from_si + state.su_from_ss)/1000;
  
  
    interface.Outflow[X_ch] = (state.ch_XS + state.ch_biom)/1000;
    interface.Outflow[X_pr] = (state.prot_XS + state.prot_biom)/1000;
  interface.Outflow[X_li] = (state.li_XS + state.li_biom)/1000;
  
  
  
   
    interface.Outflow[S_INN]= (state.S_ND_reduced_3+state.X_ND_reduced_4+state.S_NH_changed_3) / 14000 ;
 
 
 
 
   interface.Outflow[S_ch4] = 0;
   interface.Outflow[S_h2]=0;
   interface.Outflow[S_ac]=0;
   interface.Outflow[S_bu]=0;
   interface.Outflow[S_fa]=0;
   interface.Outflow[S_pro]=0;
   interface.Outflow[X_c]=0;
   interface.Outflow[S_va]=0;
   interface.Outflow[X_aa]=0;
   interface.Outflow[X_c4]=0;
   interface.Outflow[X_ac]=0;
   interface.Outflow[X_fa]=0;
   interface.Outflow[X_h2]=0;
   interface.Outflow[X_pro]=0;
   interface.Outflow[X_su]=0;
   
 
 
   state.COD_in = state.InflowConcentration[S_I] + state.InflowConcentration[S_S] + state.InflowConcentration[X_I] + state.InflowConcentration[X_S] +
          state.InflowConcentration[X_BH] + state.InflowConcentration[X_BA] + state.InflowConcentration[X_P];
 
   state.COD_out = interface.Outflow[S_aa] + interface.Outflow[S_su] + interface.Outflow[S_Inert] + interface.Outflow[X_c]
           + interface.Outflow[X_ch] + interface.Outflow[X_pr] + interface.Outflow[X_li] + interface.Outflow[X_Inert];  

 
   state.COD_balance = state.COD_in - state.COD_Demand - state.COD_out * 1000;
   
 
   state.N_in = state.InflowConcentration[S_NO] + state.InflowConcentration[S_NH] + state.InflowConcentration[S_ND] + state.InflowConcentration[X_ND] +
            parameters.nbac * ( state.InflowConcentration[X_BH] + state.InflowConcentration[X_BA])  +
        parameters.nsi*state.InflowConcentration[S_I]+ parameters.nxi * (state.InflowConcentration[X_P] + state.InflowConcentration[X_I]);
 
   state.N_out = (interface.Outflow[S_aa] + interface.Outflow[X_pr])*parameters.naa + interface.Outflow[S_INN]*14 + 
           (interface.Outflow[S_Inert] + interface.Outflow[X_Inert]) * parameters.nxi;
 
   state.N_balance = state.N_in - state.InflowConcentration[S_NO] - state.N_out * 1000;
   
 
   state.degradability = (interface.Outflow[S_aa] + interface.Outflow[S_su] + interface.Outflow[X_ch] + interface.Outflow[X_pr] 
               + interface.Outflow[X_li])/state.COD_out;

   state.help_TK_op = interface.T_op + 273.15;

 
   state.pKa_in = 9.25-log10(exp(51965*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
   state.pKa_ic = 6.35-log10(exp(7646*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
   state.pKw = 14-log10(exp(55900*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));

 
   state.alfa_ac = (-1/(1+pow(10,parameters.pKa_ac-interface.pH_adm)))/64.0;           
   state.alfa_pro = (-1/(1+pow(10,parameters.pKa_pro-interface.pH_adm)))/112.0;
   state.alfa_bu = (-1/(1+pow(10,parameters.pKa_bu-interface.pH_adm)))/160.0; 
   state.alfa_va = (-1/(1+pow(10,parameters.pKa_va-interface.pH_adm)))/208.0;
   state.alfa_in_adm = pow(10,state.pKa_in-interface.pH_adm)/(1+pow(10,state.pKa_in-interface.pH_adm)); 
   state.alfa_ic = (-1/(1+pow(10,(state.pKa_ic-interface.pH_adm))));
   state.alfa_in_as = pow(10,state.pKa_in-interface.pH_as)/(1+pow(10,state.pKa_in-interface.pH_as));
   state.alfa_nh = 1.0/14000.0;
   state.alfa_no = -1.0/14000.0;
   state.alfa_alk = -1.0/1000.0;  
           
 
   interface.Outflow[S_IC]=(((state.InflowConcentration[S_ALK]*state.alfa_alk+state.InflowConcentration[S_NH]*state.alfa_nh+state.InflowConcentration[S_NO]*state.alfa_no)-
   (interface.Outflow[S_ac]*state.alfa_ac + interface.Outflow[S_pro]*state.alfa_pro + interface.Outflow[S_bu]*state.alfa_bu + 
   interface.Outflow[S_va]*state.alfa_va + interface.Outflow[S_INN]*state.alfa_in_adm))/state.alfa_ic); 
  
 
   state.cat_an = interface.Outflow[S_ac]*state.alfa_ac + interface.Outflow[S_pro]*
          state.alfa_pro + interface.Outflow[S_bu]*state.alfa_bu +
          interface.Outflow[S_va]*state.alfa_va + interface.Outflow[S_INN]*state.alfa_in_adm +
          interface.Outflow[S_IC]*state.alfa_ic - pow(10,-interface.pH_adm)+ pow(10,-state.pKw+interface.pH_adm);
          
   interface.Outflow[S_an]=IF(state.cat_an < 0)
                           THEN -state.cat_an
               ELSE 0;
   interface.Outflow[S_cat]=IF(state.cat_an < 0)
                           THEN 0
               ELSE state.cat_an;          
                  
  };

 :};

 CLASS ADM1toASM1
 "ADM1 to ASM1 anaerobic model states flow transformer"
 SPECIALISES PhysicalDAEModelType :=
 {:
  
  comments <- "Transforms a ADM1 influent to a ASM1 anaerobic influent type";
  
  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "Inflow" : OutADM1ConcTerminal  := {: causality <- "CIN"; group <- "Influent" :};
  OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT"; group <- "Effluent" :};
 
  OBJ pH_adm (* terminal = "in_2"; manip = "1" *) "pH of the digester": Real:={: causality <- "CIN"; value <- 6.8; group <- "Operational" :};
  OBJ pH_as (* terminal = "in_2"; manip = "1" *) "pH of the activated sludge": Real:={: causality <- "CIN"; value <- 7; group <- "Operational" :};
  OBJ T_op (* terminal = "in_2"; manip = "1" *) "Operating temperature": CelsiusTemperature := {: causality <- "CIN"; value <- 35; group <- "Operational" :};
  };

  parameters <-
  {
  OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components" : SpecificVolumeVector;

   
  OBJ fdegrade_AS "Fraction of ADM Xi that is biodegradable in aerobic conditions" : Fraction := {: value <- 0.0; group <- "ADM1->ASM1" :};
  OBJ naa "Nitrogen content of amino acids_gN/gCOD " : NitrogenContentOfAminoAcids := {: value <- 0.098; group <- "Stoichiometry" :};
  OBJ nbac "nitrogen content of biomass (gN/gCOD)" : Fraction := {: value <- 0.08; group <- "Stoichiometry" :};
  OBJ nsi "nitrogen content of SI in ASM (gN/gCOD)" : Fraction := {: value <- 0.00; group <- "Stoichiometry" :};
  OBJ nsi_adm "nitrogen content of SI in ADM (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
  OBJ nxc "nitrogen content of composite material and X_P (gN/gCOD)" : Fraction := {: value <- 0.0376; group <- "Stoichiometry" :};
  OBJ nxi "nitrogen content of XI and XP (same in AS and AD) (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :}; 
   
   
  OBJ Ka_ac "acetate acidity constant without temperature correction_M" : Acidity:= {: value <- 1.74e-5; group <- "System":}; 
  OBJ Ka_bu "butyrate acidity constant without temperature correction_M" : Acidity:= {: value <- 1.5e-5; group <- "System":};
  OBJ Ka_co2 "CO2 acidity constant with temperature correction_M" : Acidity:= {: value <- 4.94e-7; group <- "System":};
  OBJ Ka_h2o "water acidity constant with temperature correction" : Acidity:= {: value <- 2.08e-14; group <- "System":};
  OBJ Ka_nh4 "NH4+ acidity constant with temperature correction" : Acidity:= {: value <- 1.11e-9; group <- "System":};
  OBJ Ka_pro "propionate acidity constant without temperature correction_M" : Acidity:= {: value <- 1.32e-5; group <- "System":};
  OBJ Ka_va "valerate acidity constant without temperature correction" : Acidity:= {: value <- 1.38e-5; group <- "System":};
   
   
  OBJ i_X_e "Mass of nitrogen per mass of COD in products formed and inert particulates(ASM1)" : MassOfNitrogenPerMassOfCODInProdFromBiomass :=
         {: value <- 0.0580; group <- "Stoichiometry" :};
  OBJ pKa_ac "Acetate acidity constant (temperature correction can be ignored)" : Real:= {: value <- 4.76; group <- "System":}; 
  OBJ pKa_bu "Butyrate acidity constant (temperature correction can be ignored)" : Real:= {: value <- 4.82; group <- "System":};
  OBJ pKa_pro "Propionate acidity constant (temperature correction can be ignored)" : Real:= {: value <- 4.88; group <- "System":};
  OBJ pKa_va "Valerate acidity constant (temperature correction can be ignored)" : Real:= {: value <- 4.86; group <- "System":};
   
 
 
   
  OBJ T_ref "Reference temperature (ie 25 degC)": CelsiusTemperature:={: value <- 25; group <- "Operational":};
  OBJ help_TK_ref (* hidden = "1" *) "Reference temperature (K)": Real ;
 
  OBJ R "Gas law constant" : GasLawConstant := {: value <- 0.08314; group <- "System" :};
   
  OBJ frxs_AS "aerobically degradable fraction of biomass" : Fraction := {: value <- 0.79; group <- "Stoichiometry" :};
  };
  
  initial <-
  {
  parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  parameters.help_TK_ref = parameters.T_ref + 273.15;
  };

  independent <- 
  {
  OBJ t "Time": Time:= {: group <- "Time" :} ;
  };

  state <-
  {
  OBJ OutflowConcentration "Outflow" : OutWWTPConcTerminal := {: group <- "Effluent" :};
   
  OBJ S_h_ion "Hydrogen ion_M" : MolConcentration :={: group <- "Concentration" :};
  OBJ S_nh4_i"amonium molar concentration" : MolConcentration :={: group <- "Concentration" :};
  OBJ S_hco3_i"bicarbonate ion molar concentration" : MolConcentration :={: group <- "Concentration" :};
   
  OBJ alfa_ac "acetate charge": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_pro "propionate charge": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_bu "butyrate charge": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_va "valerate charge": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_in_adm "inorganic nitrogen charge in digester": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_ic "inorganic carbon charge": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_nh "ammonium charge": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_no "nitrate charge": Real:={: group <- "Stoichiometry" :};
  OBJ alfa_alk "alkalinity charge": Real :={: group <- "Stoichiometry" :};
  OBJ alfa_in_as "inorganic nitrogen charge in the activated sludge": Real :={: group <- "Stoichiometry" :};
  OBJ cat_an "cations minus anions": Real :={: group <- "Stoichiometry" :};
   
  OBJ pKa_in "Inorganic nitrogen acidity constant" : Real :={: group <- "System" :};
  OBJ pKa_ic "Inorganic carbon acidity constant" : Real :={: group <- "System" :};
  OBJ pKw "Water acidity constant" : Real :={: group <- "System" :};
   
  OBJ COD_in "Incoming COD to the interface": Concentration :={: group <- "Concentration" :};
  OBJ COD_out "Outgoing COD from the interface": Concentration :={: group <- "Concentration" :};
  OBJ COD_balance "difference between COD in and out": Real :={: group <- "System" :};
  OBJ N_in "Incoming N to the interface": Concentration :={: group <- "Concentration" :};
  OBJ N_out "Outgoing N from the interface": Concentration :={: group <- "Concentration" :};
  OBJ N_balance "difference between N in and out": Real :={: group <- "System" :};
   
  OBJ biomass "total incoming biomass"  : Concentration :={: group <- "Concentration" :};
  OBJ biomass_nobio "biomass not anaerobically degradable"  : Concentration :={: group <- "Concentration" :};
  OBJ biomass_bioN "nitrogen part of biological degradable biomass"  : Concentration :={: group <- "Concentration" :}; 
   
  OBJ COD_remain "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ COD_remain_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ X_P_temp "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :}; 
  OBJ XS_temp "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ XS_temp2 "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ biomass_nobio_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};   
  OBJ biomass_bioN_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ S_INN_reduced "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :}; 
  OBJ inertX "temp state for inerts mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ noninertX "temp state for inerts mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ inertS "temp state for inerts mapping"  : Concentration :={: group <- "Concentration" :};
  OBJ S_INN_reduced2 "temp state for biomass mapping"  : Concentration :={: group <- "Concentration" :};
 
    OBJ help_TK_op (* hidden = "1" *) "Operational temperature (K)" : Real ;
 };

  equations <-
  {
 
     {interface.Outflow[IndexOfSolvent] = - state.OutflowConcentration[IndexOfSolvent] 
      / parameters.WWTPSpecificVolume[IndexOfSolvent] ;}; 

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
     interface.Outflow[Comp_Index] = - state.OutflowConcentration[Comp_Index] * 
     state.OutflowConcentration[IndexOfSolvent];};

 

     

     

    state.OutflowConcentration[H2O] = interface.Inflow[H2O_An];

 

  state.biomass=     1000*(interface.Inflow[X_su]  
           + interface.Inflow[X_aa]
               + interface.Inflow[X_fa]
               + interface.Inflow[X_c4]
               + interface.Inflow[X_pro]
               + interface.Inflow[X_ac]
           + interface.Inflow[X_h2]);
  state.biomass_nobio=state.biomass*(1-parameters.frxs_AS);  
  state.biomass_bioN=parameters.nbac*state.biomass - state.biomass_nobio*parameters.nxi;  
    state.COD_remain = 0;

  state.X_P_temp = 
  IF(state.biomass_bioN < 0)   
     THEN state.biomass*parameters.nbac/parameters.nxi
     ELSE state.biomass_nobio;
    state.biomass_nobio_reduced=
  IF(state.biomass_bioN < 0)
     THEN state.X_P_temp
     ELSE state.biomass_nobio;
  state.biomass_bioN_reduced=
  IF(state.biomass_bioN < 0)
     THEN 0
     ELSE state.biomass_bioN;

    state.OutflowConcentration[X_P]= state.X_P_temp; 
    
    state.XS_temp = 
  IF((state.biomass_bioN_reduced/parameters.nxc) <= (state.biomass - state.biomass_nobio))  
     THEN 
     IF(interface.Inflow[S_INN]*14000/parameters.nxc > (state.biomass - state.biomass_nobio - state.biomass_bioN_reduced/parameters.nxc))  
        THEN state.biomass - state.biomass_nobio  
      ELSE state.biomass_bioN_reduced/parameters.nxc
     ELSE state.biomass - state.biomass_nobio;   
     
  state.S_INN_reduced = interface.Inflow[S_INN] + state.biomass*parameters.nbac/14000.0 -
              state.X_P_temp*parameters.nxi/14000.0 - (state.XS_temp+state.XS_temp2)*parameters.nxc/14000.0;

     state.OutflowConcentration[X_S] = (interface.Inflow[X_c]
               + interface.Inflow[X_ch]               
           + interface.Inflow[X_pr]
               + interface.Inflow[X_li])*1000 + state.XS_temp;                
              
 
 
    
  state.inertX = (1-parameters.fdegrade_AS)*interface.Inflow[X_Inert]*1000;
  state.noninertX = parameters.fdegrade_AS*interface.Inflow[X_Inert]*1000;
    state.OutflowConcentration[X_I] = state.inertX;
  
 
 
    
  state.inertS =
  IF(interface.Inflow[S_Inert]*parameters.nsi_adm < interface.Inflow[S_Inert]*parameters.nsi)  
      THEN 
    IF(state.S_INN_reduced*14 < interface.Inflow[S_Inert]*parameters.nsi)  
       THEN interface.Inflow[S_Inert]*parameters.nsi_adm/parameters.nsi + state.S_INN_reduced*14/parameters.nsi
       ELSE interface.Inflow[S_Inert] 
    ELSE interface.Inflow[S_Inert];
    
    state.S_INN_reduced2 = 
  IF(interface.Inflow[S_Inert]*parameters.nsi_adm < interface.Inflow[S_Inert]*parameters.nsi)  
      THEN 
    IF(state.S_INN_reduced*14 < interface.Inflow[S_Inert]*parameters.nsi)  
       THEN 0
       ELSE state.S_INN_reduced - interface.Inflow[S_Inert]*(1-parameters.nsi_adm/parameters.nsi)*parameters.nsi/14.0 
    ELSE state.S_INN_reduced + interface.Inflow[S_Inert]*(parameters.nsi_adm-parameters.nsi)/14.0;  
  
    state.OutflowConcentration[S_I] =  state.inertS*1000;
    state.OutflowConcentration[S_NH] = state.S_INN_reduced2*14000 ;   

     

    state.OutflowConcentration[S_S] = (interface.Inflow[S_su]
                       +interface.Inflow[S_aa]
                             +interface.Inflow[S_fa]
                             +interface.Inflow[S_va]
                             +interface.Inflow[S_bu]
                             +interface.Inflow[S_pro]
                             +interface.Inflow[S_ac])*1000;                                          
                             
    

    state.OutflowConcentration[S_ND] = parameters.naa * interface.Inflow[S_aa] *1000;

   state.OutflowConcentration[X_ND] = parameters.nxc*(state.XS_temp)
               + (parameters.nxc * interface.Inflow[X_c]
               + parameters.naa * interface.Inflow[X_pr])*1000;
               
 

 
 

 

 

 












                
 
 

   state.help_TK_op = interface.T_op + 273.15;

 
   state.pKa_in = 9.25-log10(exp(51965*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
   state.pKa_ic = 6.35-log10(exp(7646*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));
   state.pKw = 14-log10(exp(55900*(1/parameters.help_TK_ref - 1/state.help_TK_op)/(100*parameters.R)));

 
   state.alfa_ac = (-1/(1+pow(10,parameters.pKa_ac-interface.pH_adm)))/64.0;           
   state.alfa_pro = (-1/(1+pow(10,parameters.pKa_pro-interface.pH_adm)))/112.0;
   state.alfa_bu = (-1/(1+pow(10,parameters.pKa_bu-interface.pH_adm)))/160.0; 
   state.alfa_va = (-1/(1+pow(10,parameters.pKa_va-interface.pH_adm)))/208.0;
   state.alfa_in_adm = pow(10,state.pKa_in-interface.pH_adm)/(1+pow(10,state.pKa_in-interface.pH_adm)); 
   state.alfa_ic = (-1/(1+pow(10,(state.pKa_ic-interface.pH_adm))));
   state.alfa_in_as = pow(10,state.pKa_in-interface.pH_as)/(1+pow(10,state.pKa_in-interface.pH_as));
   state.alfa_nh = 1.0/14000.0;
   state.alfa_no = -1.0/14000.0;
   state.alfa_alk = -1.0/1000.0;
  state.OutflowConcentration[S_O]= 0; 
  state.OutflowConcentration[S_NO]= 0;              
  state.OutflowConcentration[X_BH]= 0;              
  state.OutflowConcentration[X_BA]= 0;              

    
  state.OutflowConcentration[S_ALK]= ((interface.Inflow[S_ac]*state.alfa_ac + 
               interface.Inflow[S_pro]*state.alfa_pro + 
               interface.Inflow[S_bu]*state.alfa_bu +
               interface.Inflow[S_va]*state.alfa_va +
               interface.Inflow[S_INN]*state.alfa_in_adm +
               interface.Inflow[S_IC]*state.alfa_ic)-
                           (state.OutflowConcentration[S_NH]*state.alfa_nh +
               state.OutflowConcentration[S_NO]*state.alfa_no))/state.alfa_alk;

 
 
   state.COD_out = state.OutflowConcentration[S_I] + state.OutflowConcentration[S_S] + state.OutflowConcentration[X_I] + state.OutflowConcentration[X_S] +
          state.OutflowConcentration[X_BH] + state.OutflowConcentration[X_BA] + state.OutflowConcentration[X_P];
 
   state.COD_in = interface.Inflow[S_aa] + interface.Inflow[S_su] + interface.Inflow[S_fa] + interface.Inflow[S_va] +
                  interface.Inflow[S_bu] + interface.Inflow[S_pro] + interface.Inflow[S_ac] + interface.Inflow[S_h2] +
          interface.Inflow[S_ch4] + interface.Inflow[S_Inert] + interface.Inflow[X_c]
           + interface.Inflow[X_ch] + interface.Inflow[X_pr] + interface.Inflow[X_li] + interface.Inflow[X_Inert]
         + state.biomass/1000.0;  

 
   state.COD_balance = state.COD_in * 1000 - state.COD_out - (interface.Inflow[S_h2] +
          interface.Inflow[S_ch4])*1000; 
   
 
   state.N_out = state.OutflowConcentration[S_NO] + 
                 state.OutflowConcentration[S_NH] + 
         state.OutflowConcentration[S_ND] + 
         state.OutflowConcentration[X_ND] +
            parameters.nbac * ( state.OutflowConcentration[X_BH] + state.OutflowConcentration[X_BA])  +
        parameters.nsi*state.OutflowConcentration[S_I]+ 
        parameters.nxi * (state.OutflowConcentration[X_P] + state.OutflowConcentration[X_I]);
 
   state.N_in =  state.biomass/1000.0 * parameters.nbac + 
                 interface.Inflow[X_c]*parameters.nxc +
                 (interface.Inflow[S_aa] + interface.Inflow[X_pr])*parameters.naa + 
                 interface.Inflow[S_INN]*14 + 
         interface.Inflow[S_Inert] * parameters.nsi_adm + 
         interface.Inflow[X_Inert] * parameters.nxi;
 
   state.N_balance = state.N_in * 1000 - state.N_out; 
               
               
  };

 :};



# 19 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.ADM1.msl" 2

# 58 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion_units.msl" 1
 




















CLASS FixVolumeADU (* icon = "anaerobic_digester"; is_default = "true" *) SPECIALISES CoupledModelType :=
{:

comments <- "ADM1 model for anaerobic digestion according to BSM2, including the interface transformers from and to ASM1";

interface <-
{
OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- CIN ; group <- "Effluent" :};
OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- COUT ; group <- "Effluent" :};
OBJ GasOutflow (* terminal = "out_3" *) "Biogas" : ADM1GasOutFromTheADVessel := {: causality <- COUT ; group <- "Effluent" :};
OBJ AD_Conc (* terminal = "out_4" *) "Concentration of soluble and particulate components in the digester" : ADM1ConcVector := {: causality <- COUT ; group <- "Concentration" :};
OBJ AD_ConcIon (* terminal = "out_4" *) "Concentration of ionic species in the digester" : ADM1IonConcVector := {: causality <- COUT ; group <- "Concentration" :};
OBJ AD_Conc_Gas (* terminal = "out_4" *) "Concentration of gas components in the digester" : ADM1GasConcVector := {: causality <- COUT ; group <- "Concentration" :};
OBJ AD_pH (* terminal = "out_4" *) "pH" : pH := {: causality <- COUT ; group <- "System" :};
OBJ AD_p_ch4 (* terminal = "out_4" *) "Methane partial pressure" : Pressure := {: causality <- COUT ; group <- "System" :};
OBJ AD_p_gas (* terminal = "out_4" *) "Total pressure" : Pressure := {: causality <- COUT ; group <- "System" :};
OBJ AD_flow_gas (* terminal = "out_4" *) "Biogas flow rate" : FlowRate := {: causality <- COUT ; group <- "System" :};
OBJ T_op (* terminal = "in_2"; manip = "1" *) "Operating temperature": CelsiusTemperature := {: causality <- "CIN"; value <- 35; group <- "Operational" :};
OBJ pH_as (* terminal = "in_2"; manip = "1" *) "pH of the activated sludge": Real:={: causality <- "CIN"; value <- 7; group <- "Operational" :};
};
parameters <-
{
 
OBJ C_aa "Carbon content of amino acids" : CarbonContentOfAminoAcids := {: value <- 0.03; group <- "Stoichiometry" :};
OBJ C_pr "Carbon content of proteines" : CarbonContentOfAminoAcids := {: value <- 0.03; group <- "Stoichiometry" :};
OBJ C_ac "Carbon content of acetate" : CarbonContentOfAcetate := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_biom "Carbon content of biomass" : CarbonContentOfBiomass := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_bu "Carbon content of butyrate" : CarbonContentOfButyrate := {: value <- 0.025; group <- "Stoichiometry" :};
OBJ C_ch4 "Carbon content of methane" : CarbonContentOfMethane := {: value <- 0.0156; group <- "Stoichiometry" :};
OBJ C_fa "Carbon content of long chain fatty acids" : CarbonContentOfLCFattyAcids := {: value <- 0.0217; group <- "Stoichiometry" :};
OBJ C_li "Carbon content of lipids" : CarbonContentOfLipids := {: value <- 0.022; group <- "Stoichiometry" :};
OBJ C_pro "Carbon content of propionate" : CarbonContentOfPropionate := {: value <- 0.0268; group <- "Stoichiometry" :};
OBJ C_SI "Carbon content of soluble inert COD" : CarbonContentOfSolubleInertCOD := {: value <- 0.03; group <- "Stoichiometry" :};
OBJ C_su "Carbon content of sugars" : CarbonContentOfSugars := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_ch "Carbon content of carbohydrates" : CarbonContentOfSugars := {: value <- 0.0313; group <- "Stoichiometry" :};
OBJ C_va "Carbon content of valerate" : CarbonContentOfValerate := {: value <- 0.024; group <- "Stoichiometry" :};
OBJ C_Xc "Carbon content of complex particulate COD" : CarbonContentOfComplexParticulateCOD := {: value <- 0.02786; group <- "Stoichiometry" :};
OBJ C_XI "Carbon content of particulate inert COD" : CarbonContentOfParticulateInertCOD := {: value <- 0.03; group <- "Stoichiometry" :};
OBJ N_aa "Nitrogen content of amino acids" : NitrogenContentOfAminoAcids := {: value <- 0.007; group <- "Stoichiometry" :};
OBJ N_biom "Nitrogen content of  biomass" : NitrogenContentOfBiomass := {: value <- 0.00571428571428571; group <- "Stoichiometry" :};
OBJ N_SI "Nitrogen content of soluble inert COD" : NitrogenContentOfSolubleInertCOD := {: value <- 0.00428571428571429; group <- "Stoichiometry" :};
OBJ N_Xc "Nitrogen content of particulate degradable COD" : NitrogenContentOfParticulateDegradableCOD := {: value <- 0.00268571428571429; group <- "Stoichiometry" :};
OBJ N_XI "Nitrogen content of particulate inert COD" : NitrogenContentOfParticulateInertCOD := {: value <- 0.00428571428571429; group <- "Stoichiometry" :};
OBJ f_ac_su "Yield of acetate from sugar degradation" : Ratio := {: value <- 0.41; group <- "Stoichiometry" :};
OBJ f_ac_aa "Yield of acetate from amino acid degradation" : Ratio := {: value <- 0.4; group <- "Stoichiometry" :};
OBJ f_bu_aa "Yield of butyrate from amino acid degradation" : Ratio := {: value <- 0.26; group <- "Stoichiometry" :};
OBJ f_ch_xc "Yield of carbohydrates from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
OBJ f_fa_li "Yield of long chain fatty acids (as opposed to glycerol) from lipids" : Ratio := {: value <- 0.95; group <- "Stoichiometry" :};
OBJ f_h2_aa "Yield of hydrogen from amino acid degradation" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ f_pro_aa "Yield of propionate from amino acid degradation" : Ratio := {: value <- 0.05; group <- "Stoichiometry" :};
OBJ f_pro_su "Yield of propionate from monosaccharide degradation" : Ratio := {: value <- 0.27; group <- "Stoichiometry" :};
OBJ f_pr_xc "Yield of proteins from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
OBJ f_SI_xc "Yield of soluble inerts from disintegration of complex particulates" : Ratio := {: value <- 0.1; group <- "Stoichiometry" :};
OBJ f_va_aa "Yield of valerate from amino acid degradation" : Ratio := {: value <- 0.23; group <- "Stoichiometry" :};
OBJ f_XI_xc "Yield of particulate inerts from disintegration of complex particulates" : Ratio := {: value <- 0.2; group <- "Stoichiometry" :};
OBJ f_bu_su "Yield of butyrate from monosaccharide degradation" : Ratio := {: value <- 0.13; group <- "Stoichiometry" :};
OBJ f_h2_su "Yield of hydrogen from monosaccharide degradation" : Ratio := {: value <- 0.19; group <- "Stoichiometry" :};
OBJ f_li_xc "Yield of lipids from disintegration of complex particulates" : Ratio := {: value <- 0.3; group <- "Stoichiometry" :};
OBJ Y_aa "Yield of biomass on uptake of amino acids" : Ratio := {: value <- 0.08; group <- "Stoichiometry" :};
OBJ Y_ac "Yield of biomass on uptake of acetate" : Ratio := {: value <- 0.05; group <- "Stoichiometry" :};
OBJ Y_c4 "Yield of biomass on uptake of valerate or butyrate" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ Y_fa "Yield of biomass on uptake of long chain fatty acids" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ Y_h2 "Yield of biomass on uptake of elemental hydrogen" : Ratio := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ Y_pro "Yield of biomass on uptake of propionate" : Ratio := {: value <- 0.04; group <- "Stoichiometry" :};
OBJ Y_su "Yield of biomass on uptake of monosaccharides" : Ratio := {: value <- 0.1; group <- "Stoichiometry" :};
OBJ pH_ac_ll "pH level at which there is full inhibition of acetate degradation" : pH := {: value <- 6; group <- "Kinetics" :};
OBJ pH_ac_ul "pH level at which there is no inhibition of acetate degrading organisms" : pH := {: value <- 7; group <- "Kinetics" :};
OBJ pH_bac_ll "pH level at which there is full inhibition" : pH := {: value <- 4; group <- "Kinetics" :};
OBJ pH_bac_ul "pH level at which there is no inhibition" : pH := {: value <- 5.5; group <- "Kinetics" :};
OBJ pH_h2_ll "pH level at which there is full inhibition of hydrogen degrading organisms" : pH := {: value <- 5; group <- "Kinetics" :};
OBJ pH_h2_ul "pH level at which there is no inhibition of hydrogen degrading organisms" : pH := {: value <- 6; group <- "Kinetics" :};
OBJ KI_h2_fa "Hydrogen inhibitory concentration for FA degrading organisms" : HydrogenInhibitoryConcentrationForFADegradingOrganisms := {: value <- 5E-6; group <- "Kinetics" :};
OBJ KI_h2_c4 "Hydrogen inhibitory concentration for C4 degrading organisms" : HydrogenInhibitoryConcentrationForC4DegradingOrganisms := {: value <- 1E-5; group <- "Kinetics" :};
OBJ KI_h2_pro "Inhibitory hydrogen concentration for propionate degrading organisms" : InhibitoryHydrogenConcentrationForPropionateDegradingOrganisms := {: value <- 3.5E-6; group <- "Kinetics" :};
OBJ KI_nh3_ac "Inhibitory free ammonia concentration for acetate degrading organisms" : InhibitoryFreeAmmoniaConcentrationForAcetateDegradingOrganisms := {: value <- 0.0018; group <- "Kinetics" :};
OBJ kdec_xaa "Decay rate for amino acid degrading organisms" : DecayRateForAminoAcidDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xac "Decay rate for acetate degrading organisms" : DecayRateForAcetateDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xc4 "Decay rate for butyrate and valerate degrading organisms" : DecayRateForButyrateAndValerateDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xfa "Decay rate for long chain fatty acid degrading organisms" : DecayRateForLongChainFattyAcidDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xh2 "Decay rate for hydrogen degrading organisms" : DecayRateForHydrogenDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xpro "Decay rate for propionate degrading organisms" : DecayRateForPropionateDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdec_xsu "Decay rate for monosaccharide degrading organisms" : DecayRateForMonosaccharideDegradingOrganisms := {: value <- 0.02; group <- "Kinetics" :};
OBJ kdis "Complex particulate disintegration first order rate constant" : ComplexParticulateDisintegrationFirstOrderConstant := {: value <- 0.5; group <- "Kinetics" :};
OBJ khyd_ch "Carbohydrate hydrolysis first order rate constant" : CarbohydrateHydrolysisFirstOrderConstant := {: value <- 10; group <- "Kinetics" :};
OBJ khyd_li "Lipid hydrolysis first order rate constant" : LipidHydrolysisFirstOrderConstant := {: value <- 10; group <- "Kinetics" :};
OBJ khyd_pr "Protein hydrolysis first order rate constant" : ProteinHydrolysisFirstOrderConstant := {: value <- 10; group <- "Kinetics" :};
OBJ kla "Gas liquid transfer coefficient" : GasLiquidTransferCoefficientForReactor := {: value <- 200; group <- "Operational" :};
OBJ km_aa "Maximum uptake rate amino acid degrading organisms" : MaximumUptakeRateAminoAcidDegradingOrganisms := {: value <- 50; group <- "Kinetics" :};
OBJ km_ac "Maximum uptake rate for acetate degrading organisms" : MaximumUptakeRateForAcetateDegradingOrganisms := {: value <- 8; group <- "Kinetics" :};
OBJ km_c4 "Maximum uptake rate for c4 degrading organisms" : MaximumUptakeRateForC4DegradingOrganisms := {: value <- 20; group <- "Kinetics" :};
OBJ km_fa "Maximum uptake rate for long chain fatty acid degrading organisms" : MaximumUptakeRateForLongChainFattyAcidDegradingOrganisms := {: value <- 6; group <- "Kinetics" :};
OBJ km_h2 "Maximum uptake rate for hydrogen degrading organisms" : MaximumUptakeRateFForHydrogenDegradingOrganisms := {: value <- 35; group <- "Kinetics" :};
OBJ km_pro "Maximum uptake rate for propionate degrading organisms" : MaximumUptakeRateForPropionateDegradingOrganisms := {: value <- 13; group <- "Kinetics" :};
OBJ km_su "Maximum uptake rate for monosaccharide degrading organisms" : MaximumUptakeRateForMonosaccharideDegradingOrganisms := {: value <- 30; group <- "Kinetics" :};
OBJ Ks_aa "Half saturation constant for amino acid degradation" : HalfSaturationConstantForAminoAcidDegradation := {: value <- 0.3; group <- "Kinetics" :};
OBJ Ks_ac "Half saturation constant for acetate degradation" : HalfSaturationConstantForAcetateDegradation := {: value <- 0.15; group <- "Kinetics" :};
OBJ Ks_c4 "Half saturation constant for butyrate and valerate degradation" : HalfSaturationConstantForButyrateAndValerateDegradation := {: value <- 0.2; group <- "Kinetics" :};
OBJ Ks_fa "Half saturation constant for long chain fatty acids degradation" : HalfSaturationConstantForLongChainFattyAcidsDegradation := {: value <- 0.4; group <- "Kinetics" :};
OBJ Ks_h2 "Half saturation constant for uptake of hydrogen" : HalfSaturationConstantForUptakeOfHydrogen := {: value <- 7E-6; group <- "Kinetics" :};
OBJ Ks_IN "Inorganic nitrogen concentration at which growth ceases" : InorganicNitrogenConcentrationAtWhichGrowthCeases := {: value <- 0.0001; group <- "Kinetics" :};
OBJ Ks_pro "Half saturation constant for propionate degradation" : HalfSaturationConstantForPropionateDegradation := {: value <- 0.1; group <- "Kinetics" :};
OBJ Ks_su "Half saturation constant for monosaccharide degradation" : HalfSaturationConstantForMonosaccharideDegradation := {: value <- 0.5; group <- "Kinetics" :};
OBJ K_p "gas flow constant" : Real := {: value <- 50000; group <- "System" :};
OBJ P_atm "Pressure of atmosphere" : BarPressure := {: value <- 1.013; group <- "Operational" :};
 
OBJ T "Temperature" : CelsiusTemperature := {: value <- 35; group <- "Operational" :};
OBJ V_gas "Volume of gas in the reactor" : Volume := {: value <- 300; group <- "Operational" :};
OBJ V_liq "Volume of liquid in the reactor" : Volume := {: value <- 3400; group <- "Operational" :};
OBJ f_X_Out "Fraction of the anaerobic particulate matter that leaves the reactor" : PhysicalQuantityType := {: value <- 1; group <- "Operational" :};
OBJ naa "Nitrogen content of amino acids (gN/gCOD)" : NitrogenContentOfAminoAcids := {: value <- 0.098; group <- "Stoichiometry" :};
OBJ nbac "nitrogen content of biomass (gN/gCOD)" : Fraction := {: value <- 0.08; group <- "Stoichiometry" :};
OBJ nxc "nitrogen content of composites (gN/gCOD)" : Fraction := {: value <- 0.0376; group <- "Stoichiometry" :};
OBJ nxi "nitrogen content of XI and XP (same in AS and AD) (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ nsi "nitrogen content of SI in ASM (gN/gCOD)" : Fraction := {: value <- 0; group <- "Stoichiometry" :};
OBJ nsi_adm "nitrogen content of SI in ADM (gN/gCOD)" : Fraction := {: value <- 0.06; group <- "Stoichiometry" :};
OBJ T_ref "Reference temperature (i.e. 25degC)" : CelsiusTemperature := {: value <- 25; group <- "Operational" :};
 
};
sub_models <-
{
OBJ Trans_In : ASM1toADM1;
OBJ Digester1 : AnaerobicDigestionAtomicModel;
OBJ Trans_Out : ADM1toASM1;
};
coupling <-
{
 
 
 
sub_models.Digester1.parameters.C_aa.value := parameters.C_aa.value,
sub_models.Digester1.parameters.C_pr.value := parameters.C_pr.value,
sub_models.Digester1.parameters.C_ac.value := parameters.C_ac.value,
sub_models.Digester1.parameters.C_biom.value := parameters.C_biom.value,
sub_models.Digester1.parameters.C_bu.value := parameters.C_bu.value,
sub_models.Digester1.parameters.C_ch4.value := parameters.C_ch4.value,
sub_models.Digester1.parameters.C_fa.value := parameters.C_fa.value,
sub_models.Digester1.parameters.C_li.value := parameters.C_li.value,
sub_models.Digester1.parameters.C_pro.value := parameters.C_pro.value,
sub_models.Digester1.parameters.C_SI.value := parameters.C_SI.value,
sub_models.Digester1.parameters.C_su.value := parameters.C_su.value,
sub_models.Digester1.parameters.C_ch.value := parameters.C_ch.value,
sub_models.Digester1.parameters.C_va.value := parameters.C_va.value,
sub_models.Digester1.parameters.C_Xc.value := parameters.C_Xc.value,
sub_models.Digester1.parameters.C_XI.value := parameters.C_XI.value,
sub_models.Digester1.parameters.N_aa.value := parameters.N_aa.value,
sub_models.Digester1.parameters.N_biom.value := parameters.N_biom.value,
sub_models.Digester1.parameters.N_SI.value := parameters.N_SI.value,
sub_models.Digester1.parameters.N_Xc.value := parameters.N_Xc.value,
sub_models.Digester1.parameters.N_XI.value := parameters.N_XI.value,
sub_models.Digester1.parameters.f_ac_su.value := parameters.f_ac_su.value,
sub_models.Digester1.parameters.f_ac_aa.value := parameters.f_ac_aa.value,
sub_models.Digester1.parameters.f_bu_aa.value := parameters.f_bu_aa.value,
sub_models.Digester1.parameters.f_ch_xc.value := parameters.f_ch_xc.value,
sub_models.Digester1.parameters.f_fa_li.value := parameters.f_fa_li.value,
sub_models.Digester1.parameters.f_h2_aa.value := parameters.f_h2_aa.value,
sub_models.Digester1.parameters.f_pro_aa.value := parameters.f_pro_aa.value,
sub_models.Digester1.parameters.f_pro_su.value := parameters.f_pro_su.value,
sub_models.Digester1.parameters.f_pr_xc.value := parameters.f_pr_xc.value,
sub_models.Digester1.parameters.f_SI_xc.value := parameters.f_SI_xc.value,
sub_models.Digester1.parameters.f_va_aa.value := parameters.f_va_aa.value,
sub_models.Digester1.parameters.f_XI_xc.value := parameters.f_XI_xc.value,
sub_models.Digester1.parameters.f_bu_su.value := parameters.f_bu_su.value,
sub_models.Digester1.parameters.f_h2_su.value := parameters.f_h2_su.value,
sub_models.Digester1.parameters.f_li_xc.value := parameters.f_li_xc.value,
sub_models.Digester1.parameters.Y_aa.value := parameters.Y_aa.value,
sub_models.Digester1.parameters.Y_ac.value := parameters.Y_ac.value,
sub_models.Digester1.parameters.Y_c4.value := parameters.Y_c4.value,
sub_models.Digester1.parameters.Y_fa.value := parameters.Y_fa.value,
sub_models.Digester1.parameters.Y_h2.value := parameters.Y_h2.value,
sub_models.Digester1.parameters.Y_pro.value := parameters.Y_pro.value,
sub_models.Digester1.parameters.Y_su.value := parameters.Y_su.value,
sub_models.Digester1.parameters.pH_ac_ll.value := parameters.pH_ac_ll.value,
sub_models.Digester1.parameters.pH_ac_ul.value := parameters.pH_ac_ul.value,
sub_models.Digester1.parameters.pH_bac_ll.value := parameters.pH_bac_ll.value,
sub_models.Digester1.parameters.pH_bac_ul.value := parameters.pH_bac_ul.value,
sub_models.Digester1.parameters.pH_h2_ll.value := parameters.pH_h2_ll.value,
sub_models.Digester1.parameters.pH_h2_ul.value := parameters.pH_h2_ul.value,
sub_models.Digester1.parameters.KI_h2_fa.value := parameters.KI_h2_fa.value,
sub_models.Digester1.parameters.KI_h2_c4.value := parameters.KI_h2_c4.value,
sub_models.Digester1.parameters.KI_h2_pro.value := parameters.KI_h2_pro.value,
sub_models.Digester1.parameters.KI_nh3_ac.value := parameters.KI_nh3_ac.value,
sub_models.Digester1.parameters.kdec_xaa.value := parameters.kdec_xaa.value,
sub_models.Digester1.parameters.kdec_xac.value := parameters.kdec_xac.value,
sub_models.Digester1.parameters.kdec_xc4.value := parameters.kdec_xc4.value,
sub_models.Digester1.parameters.kdec_xfa.value := parameters.kdec_xfa.value,
sub_models.Digester1.parameters.kdec_xh2.value := parameters.kdec_xh2.value,
sub_models.Digester1.parameters.kdec_xpro.value := parameters.kdec_xpro.value,
sub_models.Digester1.parameters.kdec_xsu.value := parameters.kdec_xsu.value,
sub_models.Digester1.parameters.kdis.value := parameters.kdis.value,
sub_models.Digester1.parameters.khyd_ch.value := parameters.khyd_ch.value,
sub_models.Digester1.parameters.khyd_li.value := parameters.khyd_li.value,
sub_models.Digester1.parameters.khyd_pr.value := parameters.khyd_pr.value,
sub_models.Digester1.parameters.kla.value := parameters.kla.value,
sub_models.Digester1.parameters.km_aa.value := parameters.km_aa.value,
sub_models.Digester1.parameters.km_ac.value := parameters.km_ac.value,
sub_models.Digester1.parameters.km_c4.value := parameters.km_c4.value,
sub_models.Digester1.parameters.km_fa.value := parameters.km_fa.value,
sub_models.Digester1.parameters.km_h2.value := parameters.km_h2.value,
sub_models.Digester1.parameters.km_pro.value := parameters.km_pro.value,
sub_models.Digester1.parameters.km_su.value := parameters.km_su.value,
sub_models.Digester1.parameters.Ks_aa.value := parameters.Ks_aa.value,
sub_models.Digester1.parameters.Ks_ac.value := parameters.Ks_ac.value,
sub_models.Digester1.parameters.Ks_c4.value := parameters.Ks_c4.value,
sub_models.Digester1.parameters.Ks_fa.value := parameters.Ks_fa.value,
sub_models.Digester1.parameters.Ks_h2.value := parameters.Ks_h2.value,
sub_models.Digester1.parameters.Ks_IN.value := parameters.Ks_IN.value,
sub_models.Digester1.parameters.Ks_pro.value := parameters.Ks_pro.value,
sub_models.Digester1.parameters.Ks_su.value := parameters.Ks_su.value,
sub_models.Digester1.parameters.K_p.value := parameters.K_p.value,
sub_models.Digester1.parameters.P_atm.value := parameters.P_atm.value,
sub_models.Digester1.parameters.T.value := parameters.T.value,
sub_models.Digester1.parameters.V_gas.value := parameters.V_gas.value,
sub_models.Digester1.parameters.V_liq.value := parameters.V_liq.value,
sub_models.Digester1.parameters.f_X_Out.value := parameters.f_X_Out.value,
sub_models.Trans_In.parameters.naa.value := parameters.naa.value,
sub_models.Trans_Out.parameters.naa.value := parameters.naa.value,
sub_models.Trans_In.parameters.nbac.value := parameters.nbac.value,
sub_models.Trans_Out.parameters.nbac.value := parameters.nbac.value,
sub_models.Trans_In.parameters.nxc.value := parameters.nxc.value,
sub_models.Trans_Out.parameters.nxc.value := parameters.nxc.value,
sub_models.Trans_In.parameters.nxi.value := parameters.nxi.value,
sub_models.Trans_Out.parameters.nxi.value := parameters.nxi.value,
sub_models.Trans_In.parameters.nsi.value := parameters.nsi.value,
sub_models.Trans_Out.parameters.nsi.value := parameters.nsi.value,
sub_models.Trans_In.parameters.nsi_adm.value := parameters.nsi_adm.value,
sub_models.Trans_Out.parameters.nsi_adm.value := parameters.nsi_adm.value,
sub_models.Trans_In.parameters.T_ref.value := parameters.T_ref.value,
sub_models.Trans_Out.parameters.T_ref.value := parameters.T_ref.value,
 
 
connect(interface.Inflow, sub_models.Trans_In.interface.Inflow),
connect(sub_models.Trans_In.interface.Outflow, sub_models.Digester1.interface.Inflow),
connect(sub_models.Digester1.interface.Outflow, sub_models.Trans_Out.interface.Inflow),
connect(sub_models.Trans_Out.interface.Outflow, interface.Outflow),
 
 
connect(sub_models.Digester1.interface.pH_ADM, sub_models.Trans_In.interface.pH_adm),
connect(sub_models.Digester1.interface.pH_ADM, sub_models.Trans_Out.interface.pH_adm),
connect(interface.pH_as, sub_models.Trans_In.interface.pH_as),
connect(interface.pH_as, sub_models.Trans_Out.interface.pH_as),
connect(interface.T_op, sub_models.Trans_In.interface.T_op),
connect(interface.T_op, sub_models.Trans_Out.interface.T_op),
connect(interface.T_op, sub_models.Digester1.interface.T_op),
connect(sub_models.Digester1.interface.Q_Gas_LD, interface.GasOutflow),
connect(sub_models.Digester1.interface.Conc_An, interface.AD_Conc),
connect(sub_models.Digester1.interface.Conc_AnIon, interface.AD_ConcIon),
connect(sub_models.Digester1.interface.Conc_AnGas, interface.AD_Conc_Gas),
connect(sub_models.Digester1.interface.pH_ADM, interface.AD_pH),
connect(sub_models.Digester1.interface.p_gas_ch4, interface.AD_p_ch4),
connect(sub_models.Digester1.interface.p_gas_tot, interface.AD_p_gas),
connect(sub_models.Digester1.interface.gas_flowrate, interface.AD_flow_gas),
};
:};





 
# 59 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.data_treatment.msl" 1
 















 
 
 
 




CLASS DataTreatment "Data Treatment" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A general model for signal treatment";
    interface <-
    {
	 	OBJ u (* terminal = "in_1" *) "Signal input" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ y_M (* terminal = "out_1" *) "Output signal" : Real := {: causality <- "COUT" ; group <- "Measurement data" :};    
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
	state <-
    {
		OBJ signal (* hidden = "1" *) "Dummy variable to store the signal": Real ;
    };
	equations <-
    {
		 
		state.signal = interface.u ;  
    };
  :};

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\data_treatment/wwtp.base.datatreatment.response_time.msl" 1
 














 
 
 
 
 




CLASS Response_Time
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding response time to a signal";
    parameters <-
    {
		OBJ T90 "Response time" : Time := {: value <- 0.00694444444444444 ; group <- "System" :};
		OBJ n "Order for the response time (2-8)" : Integer := {: value <- 2 ; group <- "System" :};
    };
    state <-
    {
		OBJ signal_response1 (* hidden = "1" *) "variable for 1st order response time output": Real ;
		OBJ signal_response2 (* hidden = "1" *) "variable for 2nd order response time output": Real ;
		OBJ signal_response3 (* hidden = "1" *) "variable for 3rd order response time output": Real ;
		OBJ signal_response4 (* hidden = "1" *) "variable for 4th order response time output": Real ;
		OBJ signal_response5 (* hidden = "1" *) "variable for 5th order response time output": Real ;
		OBJ signal_response6 (* hidden = "1" *) "variable for 6th order response time output": Real ;
		OBJ signal_response7 (* hidden = "1" *) "variable for 7th order response time output": Real ;
		OBJ signal_response8 (* hidden = "1" *) "variable for 8th order response time output": Real ;
		 
 		OBJ Tau "Time constant" : Time := {: value <- 0.00006944444444 ; group <- "System" :};  
    };
    initial <-
    {
		 
		 
		 
		state.Tau = IF (parameters.n==1) THEN parameters.T90/2.3247
			ELSE IF (parameters.n==2) THEN parameters.T90/3.89
				 ELSE IF (parameters.n==3) THEN parameters.T90/5.3336
				 	  ELSE IF (parameters.n==4) THEN parameters.T90/6.6902
					  	   ELSE IF (parameters.n==5) THEN parameters.T90/8.0031
						   		ELSE IF (parameters.n==6) THEN parameters.T90/9.2680
									 ELSE IF (parameters.n==7) THEN parameters.T90/10.5357
									 	  ELSE parameters.T90/11.7724;
		 
		 
		 
    };
    equations <-
    {
		 
		DERIV(state.signal_response1,[independent.t]) = -(1/state.Tau)*(state.signal_response1 - state.signal);
		DERIV(state.signal_response2,[independent.t]) = -(1/state.Tau)*(state.signal_response2 - state.signal_response1);
		DERIV(state.signal_response3,[independent.t]) = -(1/state.Tau)*(state.signal_response3 - state.signal_response2);
		DERIV(state.signal_response4,[independent.t]) = -(1/state.Tau)*(state.signal_response4 - state.signal_response3);
		DERIV(state.signal_response5,[independent.t]) = -(1/state.Tau)*(state.signal_response5 - state.signal_response4);
		DERIV(state.signal_response6,[independent.t]) = -(1/state.Tau)*(state.signal_response6 - state.signal_response5);
		DERIV(state.signal_response7,[independent.t]) = -(1/state.Tau)*(state.signal_response7 - state.signal_response6);
		DERIV(state.signal_response8,[independent.t]) = -(1/state.Tau)*(state.signal_response8 - state.signal_response7);
		
		interface.y_M = IF (parameters.n==1) THEN state.signal_response1
			ELSE IF (parameters.n==2) THEN state.signal_response2
				 ELSE IF (parameters.n==3) THEN state.signal_response3
				 	  ELSE IF (parameters.n==4)	THEN state.signal_response4
					  	   ELSE IF (parameters.n==5) THEN state.signal_response5
						   		ELSE IF (parameters.n==6) THEN state.signal_response6
									 ELSE IF (parameters.n==7) THEN state.signal_response7
									 	  ELSE state.signal_response8;
    };
  :};
  

# 49 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\data_treatment/wwtp.base.datatreatment.delay.msl" 1
 














 
 
 
 
 




CLASS Delay
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding delay to a signal";
    parameters <-
    {
		OBJ t_Delay "Delay time" : Time := {: value <- 0 ; group <- "System" :};
    };
    state <-
    {
		OBJ temp (* hidden = "1" *) "dummy variable for initialisation" : Real ;
		OBJ ID (* hidden = "1" *) "dummy variable for buffer ID" : Integer ;
		OBJ Signal_Delay (* hidden = "1" *) "dummy variable for signal that is retrieved from buffer": Real ;
		OBJ Delta_t  "Time to get a value from the buffer" : Time:= {: group <- "System" :};
    };
    initial <-
    {
		 
		state.ID = MSLUBufferCreate(state.Signal_Delay, 0);
    };
    equations <-
    {
		 
		 
		 
		state.temp = MSLUBufferPut(state.ID, independent.t, state.signal);
		state.Delta_t = independent.t - parameters.t_Delay;
		state.Signal_Delay = MSLUBufferGet(state.ID,state.Delta_t);
		interface.y_M = state.Signal_Delay ;   
    };
  :};
  

# 50 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\data_treatment/wwtp.base.datatreatment.noise.msl" 1
 















 
 
 
 




CLASS Noise
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal, using random values sampled from a normal distribution";
    parameters <-
    {
		OBJ Percent_YMax "Percentage of the measuring range to define the standard deviation of the noise (%)" : Real := {: value <- 2.5 ; group <- "System" :};
		OBJ Noise_Sample_Time "Noise sampling interval": Time := {: value <- 0.000694444444444 ; group <- "System" :};
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
    };
    state <-
    {
		OBJ signal_noise (* hidden = "1" *) "Dummy variable to store the noisy signal": Real:= {: group <- "System" :};
		OBJ Noise "Random number sampled from Normal Distribution N(0,1)" : Real:= {: group <- "System" :};
		OBJ rand "Random number in the range [0,1[ sampled from Uniform distribution" : Real:= {: group <- "System" :};
		OBJ prev_nst (* hidden = "1" *) "Previous noise sampling time" : Real ;
		OBJ flag_noise (* hidden = "1" *)"Boolean variable related to a timer": Boolean ;
		OBJ Noise_Level "Noise level (Std Dev of the noise signal)" : Real := {: group <- "System" :};
    };
    initial <-
    {
		state.prev_nst = 0;
		 
		state.Noise_Level = parameters.Percent_YMax/100 * parameters.YMax;
    };
    equations <-
    {
		 
		 
		state.flag_noise = IF (independent.t > (previous(state.prev_nst) + parameters.Noise_Sample_Time)) THEN 1
			ELSE 0 ;

		state.rand = IF (state.flag_noise) THEN MSLUGetRandom()
			ELSE IF (independent.t == 0) THEN MSLUGetRandom()
				 ELSE previous(state.rand) ;

		state.prev_nst = IF (state.flag_noise) THEN previous(state.prev_nst) + parameters.Noise_Sample_Time
			ELSE previous(state.prev_nst) ;

		 
		 
		state.Noise = MSLU_normal_cdf_inv(state.rand,0,1);
		
		 
		interface.y_M = state.Noise*state.Noise_Level+state.signal ;
    };
    
  :};
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\data_treatment/wwtp.base.datatreatment.noise_file.msl" 1
 














 
 
 
 
 




CLASS Noise_File
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal using an input file";
    interface <-
    {
		OBJ u_file (* terminal = "in_2" *) "Signal input for noise file" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};  
    };
    parameters <-
    {
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
		OBJ Noise_Percent "Noise level (%)" : Real := {: value <- 2.5 ; group <- "System" :};  
    };
    state <-
    {
		OBJ Noise_Level "Noise level" : Real:= {: group <- "System" :};
    };
    initial <-
    {
		state.Noise_Level = parameters.Noise_Percent/100 * parameters.YMax ;
    };
    equations <-
    {
		interface.y_M = interface.u_file*state.Noise_Level + state.signal ; 
    };
  :};
  

# 52 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\data_treatment/wwtp.base.datatreatment.sample_and_hold.msl" 1
 














 
 
 
 
 




CLASS Sample_and_Hold
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for obtaining discrete signal: Zero Order Hold. Sample and Hold (SAH)";
    parameters <-
    {
		OBJ T_interval "Sampling interval": Time := {: value <- 0.00347222222222 ; group <- "System" :};  
    };
    state <-
    {
		OBJ signal_SAH (* hidden = "1" *) "dummy variable for concentration of sample and hold": Real ;
		OBJ prev_SAHst (* hidden = "1" *) "previous SAH sampling time" : Real ;
		OBJ flag_SAH (* hidden = "1" *) "flag for the sampling time": Boolean ;
    };
    initial <-
    {
		state.prev_SAHst = 0;
		state.flag_SAH = 0;
		state.signal_SAH= 0;  
    };
    equations <-
    {
		 
		state.prev_SAHst = IF (independent.t - previous(state.prev_SAHst) <= (parameters.T_interval)) THEN  previous(state.prev_SAHst)
			ELSE  previous(state.prev_SAHst) + parameters.T_interval;   

		state.flag_SAH = IF  (state.prev_SAHst != previous(state.prev_SAHst)) THEN  1
			ELSE  0;    
  
		 
		state.signal_SAH = IF (state.flag_SAH) THEN previous(state.signal)
			ELSE IF (independent.t == 0) THEN previous(state.signal)
				 ELSE previous(state.signal_SAH) ;
      
		 
		interface.y_M = state.signal_SAH ;
    };
  :};
  

# 53 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\data_treatment/wwtp.base.datatreatment.saturation_range.msl" 1
 














 
 
 
 
 




CLASS Saturation_Range
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding saturation to the signal";
    parameters <-
    {
		OBJ uMin "Minimum level for the signal" : Real := {: value <- 0 ; group <- "System" :};
		OBJ uMax "Minimum level for the signal" : Real := {: value <- 10 ; group <- "System" :};
    };
    equations <-
    {
		interface.u = IF (state.signal < parameters.uMin) THEN parameters.uMin
			ELSE IF (state.signal > parameters.uMax) THEN parameters.uMax
				 ELSE state.signal ;
    };
  :};
  

# 54 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.data_treatment.msl" 2

  
  


# 62 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.aeration.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\aeration/wwtp.irvine_carbon_footprint.msl" 1
 














 
 
 




   
   
CLASS Irvine_wCarbon_Footprint
  (* icon = "aerator" ; is_default = "true" *)
  "Irvine aeration model with carbon footprint" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A model that computes the Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
		OBJ O2_tank (* terminal = "in_1" *) "Actual oxygen concentration in the aeration tank" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ Vol_tank (* terminal = "in_1" *) "Volume of the aeration tank" : Volume := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ SRT (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge age" : Time := {: causality <- "CIN" ; value <- 6.5 ; group <- "Operational" :};   
		OBJ Kla (* terminal = "out_1" *) "Oxygen Transfer Coefficient" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
		OBJ O2_rsat_ave (* terminal = "out_1" *) "Average oxygen saturation f(T_water; Depth) for fine bubble aeration" : Concentration := {: causality <- "COUT" ; group <- "Control action" :};
 






    };
    parameters <- 
    {
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/s2)": Real := {: value <- 9.82 :};
		OBJ T_water "Temperature of the water": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ T_air "Temperature of the air": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ H "Altitude": Length := {: value <- 10 ; group <- "Operational" :};
		OBJ Rho_air "Air density": Concentration := {: value <- 1230 ; group <- "Operational" :};
		OBJ Q_air "Air flow rate under Standard Conditions": FlowRate := {: value <- 1000 ; group <- "Operational" :};
		OBJ O2_sat20 "Oxygen saturation of water under Standard Conditions and no salts": Concentration := {: value <- 10.50 ; group <- "Operational" :};
		OBJ SOTE "Standard Oxygen Transfer Efficiency (%)": Real := {: value <- 42 ; group <- "Operational"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};

		OBJ Rho_sludge "Sludge density": Concentration := {: value <- 988000 ; group <- "Sludge" :};
		OBJ Beta "Empirical factor": Real := {: value <- 0.98 ; group <- "Sludge" :};
		OBJ Phi "Empirical factor": Real := {: value <- 1.024 ; group <- "Sludge" :};

		OBJ P_atm "Atmospheric pressure": Pressure := {: value <- 101325; group <- "Local conditions" :};
		OBJ P_st_atm "Standard atmospheric pressure": Pressure := {: value <- 101325; group <- "Local conditions" :};
		OBJ P_water_ref "Vapour pressure": Pressure := {: value <- 2334; group <- "Local conditions" :};
		OBJ O2_air "O2 conc. in the atmosphere (%)": Real := {: value <- 20.85 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		OBJ CO2_air "CO2 conc. in the atmosphere (%)": Real := {: value <- 0.03 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};

		OBJ Depth "Depth of the (fine bubble) aerator": Length := {: value <- 6 ; group <- "Tank geometry" :};
		OBJ A_sp "Specific area of the diffusers": Area := {: value <- 2 ; group <- "Tank geometry" :};
		OBJ Nd "Number of diffusers": Real := {: value <- 504 ; group <- "Tank geometry"; interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :}; :};
		
		OBJ A "Empirical factor": Real := {: value <- 5.717 ; group <- "Aeration model" :};
		OBJ B "Empirical factor": Real := {: value <- 6.815 ; group <- "Aeration model" :};
		OBJ f "Fraction of tank depth (from surface) at which pressure corresponds to the average saturation concentration": Real := {: value <- 0.44 ; group <- "Aeration model" :};
 




		 
		OBJ P_out "Output pressure from the blowers": Pressure := {: value <- 80000; group <- "Power consumption" :};
		OBJ Lambda "Empirical constant for air": Real := {: value <- 1.395 ; group <- "Power consumption" :};
		OBJ Epsilon "Efficiency of the motor": Real := {: value <- 0.58 ; group <- "Power consumption"; interval <- {: lowerBound <- 0; upperBound <- 1; :}; :};
		OBJ fCO2 "CO2 production per unit of energy (kg/kWh)": Real := {: value <- 0.718 ; group <- "Power consumption" :};
		OBJ T_in "Inlet temperature": CelsiusTemperature := {: value <- 20 ; group <- "Power consumption" :};
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    state <- 
    {
		OBJ P_water "Vapour pressure": Pressure := {: group <- "Local conditions" :};
		OBJ O2_rsat "Oxygen saturation at the water temperature": Concentration := {: group <- "Local conditions" :};
 
		
 

		OBJ Alpha "Empirical factor ": Real := {: group <- "Operational" :};
		
		OBJ AlphaSOTE "Oxygen transfer efficiency for new aerators": Real := {: group <- "Aeration" :};
		OBJ SOTR "Standard Oxygen Transfer Rate": MassFlux := {: group <- "Aeration" :};
		OBJ OTR "Oxygen Transfer Rate (under field conditions)": MassFlux := {: group <- "Aeration" :};
		OBJ	OTR_sp "Specific Oxygen Transfer Rate": OxygenUptakeRate := {: group <- "Aeration" :};
		OBJ OTE "Oxygen Transfer Efficiency (under field conditions) (%)": Real := {: group <- "Aeration"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		OBJ MRi "Mole ratio of oxygen that enters air and off gas (%)": Real := {: group <- "Aeration" :};
		OBJ MRe "Mole ratio of oxygen that leaves aeration tank (%)": Real := {: group <- "Aeration" :};
		OBJ Qn "Normalized air flow": Real := {: group <- "Aeration" :};

		OBJ P_bottom "Pressure at the bottom of the tank": Pressure := {: group <- "Site" :};

		 
		OBJ Load_CO2 "CO2 production": MassFlux := {: group <- "Power consumption" :};
		OBJ Power_blowers "Power of the blowers" : Power := {: group <- "Power consumption" :};
		OBJ k "Power usage per cubic meter of air blown (kW/(m3/s))": Real := {: group <- "Power consumption" :};
		OBJ Emission_CO2 "Overall CO2 emission" : Mass := {: group <- "Power consumption" :} ;
		OBJ Consumption "Overall electrical energy (kWh)" : ElectricalEnergy := {: group <- "Power consumption" :} ;
		OBJ Chi (* hidden = "1" *) "Characteristic number": Real ;
		OBJ lgChi (* hidden = "1" *) "Characteristic number": Real ;
    };
    equations <- 
    {
		 
 
		state.Qn = parameters.Q_air / (24*3600*(parameters.A_sp * parameters.Nd * parameters.Depth)) ;
		state.Chi = IF (state.Qn == 0.0) THEN 0.0 ELSE interface.SRT/state.Qn ;
		state.lgChi = IF (state.Chi == 0.0) THEN 0.0 ELSE log10(state.Chi) ;
	
		state.AlphaSOTE = IF (state.Chi == 0.0) THEN 0.0 ELSE (parameters.A * log10(state.Chi) - parameters.B)/100 ;
		state.Alpha = state.AlphaSOTE / parameters.SOTE * 100 ;

		 
		state.MRi = parameters.O2_air/(100 - parameters.O2_air - parameters.CO2_air);
		state.MRe =  state.MRi*(1-state.OTE);
 
		state.OTE = state.AlphaSOTE *
			(parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) / parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));

		 
		state.P_bottom = (parameters.Rho_sludge/1000) * parameters.g * parameters.Depth;
		state.P_water = pow(10, 0.6979 + 0.02618 * parameters.T_air)* 133.33;
		state.O2_rsat = 14.65 - 0.41 * (parameters.T_water) + 0.00799 * pow(parameters.T_water,2) - 0.0000778 * pow(parameters.T_water,3);
 
 
		interface.O2_rsat_ave = parameters.O2_sat20 * (state.P_bottom * parameters.f + parameters.P_atm - state.P_water)/ (parameters.P_st_atm - parameters.P_water_ref);

		 
		state.SOTR =  parameters.Q_air * (parameters.Rho_air/1000)  * parameters.SOTE * (parameters.O2_air/10000);
 
		state.OTR = state.Alpha * state.SOTR * (parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) /parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));
		interface.Kla = 1000 * state.OTR/((parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) * interface.Vol_tank);
		state.OTR_sp = state.OTR /(interface.Vol_tank);
		
		 
		state.k = (parameters.P_st_atm * parameters.Lambda * (parameters.T_in + 273.15)) / (2.73 * 100000 * parameters.Epsilon * (parameters.Lambda - 1)) * (pow((parameters.P_out + parameters.P_st_atm)/parameters.P_st_atm,1-1/parameters.Lambda)-1);
		state.Power_blowers = state.k * parameters.Q_air/(24*3600);
		state.Load_CO2 = state.Power_blowers * parameters.fCO2 ;
		DERIV(state.Consumption, [independent.t]) = 24 * state.Power_blowers ;
		DERIV(state.Emission_CO2, [independent.t]) = state.Load_CO2 ;
    };

  :};


# 20 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.aeration.msl" 2

 


# 63 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.chemical_processes.msl" 1
 









# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\chemical_processes/wwtp.base.chemical_processes.me_dosing_unit.msl" 1
 









# 194 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\chemical_processes/wwtp.base.chemical_processes.me_dosing_unit.msl"




# 11 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.chemical_processes.msl" 2



# 66 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.influent.msl" 1
 











TYPE SewComponents 
 "The number of biological components considered in the input of a BODCOD transformer"
  = ENUM {H2O_sew, COD_part, COD_sol, X_TSS_sew, NH4_sew, PO4_sew};

OBJ NrOfSewComponents
  "The number of biological components considered in the output of the sewer model"
  : Integer := Cardinality(SewComponents); 

 CLASS SewTerminal
 "The parameters calculated by the sewer model"
 = MassFlux[NrOfSewComponents;];

 





TYPE HourlyTimeVector = ENUM {H00, H01, H02, H03, H04, H05, H06, H07,
                               H08, H09, H10, H11, H12, H13, H14, H15, 
                               H16, H17, H18, H19, H20, H21, H22, H23};
 
OBJ NrOfHourlyTimeVectorElements : 
      Integer := Cardinality(HourlyTimeVector);

CLASS HourlyDailyPattern "Daily pattern" = 
        Real[NrOfHourlyTimeVectorElements;];



# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\influent/wwtp.base.influent.msl" 1
 













 CLASS Sew_WWTPin_2
 (* icon = "sewer" *)
 "Generator of WWTP infuent pollutograph, second version"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Q_Meas (* terminal = "in_1"; manip = "1"; is_favorite = "1" *) "Measured" : 
      FlowRate  := {: causality <- "CIN" ; value <- 100000; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      SewTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	  OBJ FD (* terminal = "in_1"; manip = "1"; is_favorite = "1" *) "Filling Degree" : 
      Real  := {: causality <- "CIN" ; value <- 0.5; group <- "Influent" :};
  };
  
  parameters <-
  {
    OBJ SewSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SewSpecificVolumeVector;

   OBJ Q_event "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ Qsw_event8 "Flow sw value for start of event8" : FlowRate := {: value <- 12000 ; group <- "_Events" :};
	 OBJ Qsw_event9 "Flow sw value for start of event9" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ FD_event "Filling degree value for start of event3" : Real := {: value <- 0.21 ; group <- "_Events" :};
	 OBJ T_Average "Averaging time for Q_mean" : Time := {: value <- 0.02083; group <- "_Events" :};
	 
   OBJ Q_95_av "Daily average Q, 95%ile" : FlowRate := {: value <- 70000 ; group <- "_Averages" :};
   OBJ COD_av "COD daily average concentration" : Concentration := {: value <- 642 ; group <- "_Averages" :};
   OBJ CODs_av "CODs daily average concentration" : Concentration := {: value <- 197.3 ; group <- "_Averages" :};
   OBJ TSS_av "TSS daily average concentration" : Concentration := {: value <- 289.6 ; group <- "_Averages" :};
   OBJ NH4_av "NH4 daily average concentration" : Concentration := {: value <- 35 ; group <- "_Averages" :};
   OBJ PO4_av "PO4 daily average concentration" : Concentration := {: value <- 7 ; group <- "_Averages" :};
   
   OBJ alpha_COD "Alpha for COD, proc2" : Fraction := {: value <- 0.8 ; group <- "_proc2" :};
   OBJ alpha_CODs "Alpha for CODs, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_TSS "Alpha for TSS, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_NH4 "Alpha for NH4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_PO4 "Alpha for PO4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   
   OBJ beta_COD "Beta for COD, proc3" : Fraction := {: value <- 0.8 ; group <- "_proc3" :};
   OBJ beta_CODs "Beta for CODs, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_TSS "Beta for TSS, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_NH4 "Beta for NH4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_PO4 "Beta for PO4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
	 
	 OBJ proc4_slope1_COD "Slope1 for COD, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_CODs "Slope1 for CODs, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_TSS "Slope1 for TSS, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_NH4 "Slope1 for NH4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_PO4 "Slope1 for PO4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
	 
	 OBJ proc4_slope2_COD "Slope2 for COD, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_CODs "Slope2 for CODs, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_TSS "Slope2 for TSS, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_NH4 "Slope2 for NH4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_PO4 "Slope2 for PO4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
	 
   OBJ window_proc4_COD "Window length for COD, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_CODs "Window length for CODs, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_TSS "Window length for TSS, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_NH4 "Window length for NH4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_PO4 "Window length for PO4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
	 
	 OBJ proc5_slope_CODs "Slope for CODs, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_NH4 "Slope for NH4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_PO4 "Slope for PO4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
	 
   OBJ window_proc5_CODs "Window length for CODs, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_NH4 "Window length for NH4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_PO4 "Window length for PO4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
	 
	 OBJ Q_proc6 "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_proc6" :};
	 OBJ peak_COD_high "Proc6 high COD peak concentration" : Concentration := {: value <- 600 ; group <- "_proc6" :};
	 OBJ peak_COD_low "Proc6 low COD peak concentration" : Concentration := {: value <- 300 ; group <- "_proc6" :};
	 OBJ proc6_slope1_COD "Slope1 for COD, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_COD "Slope2 for COD, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ peak_TSS_high "Proc6 high TSS peak concentration" : Concentration := {: value <- 200 ; group <- "_proc6" :};
	 OBJ peak_TSS_low "Proc6 low TSS peak concentration" : Concentration := {: value <- 100 ; group <- "_proc6" :};
	 OBJ proc6_slope1_TSS "Slope1 for TSS, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_TSS "Slope2 for TSS, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ proc6_t1_COD "Time1 for COD high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_COD "Time2 for COD low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 OBJ proc6_t1_TSS "Time1 for TSS high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_TSS "Time2 for TSS low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 
	 OBJ proc7_slope1_COD "Slope1 for COD, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_COD "Slope2 for COD, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
	 OBJ proc7_slope1_TSS "Slope1 for TSS, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_TSS "Slope2 for TSS, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
   
   OBJ Q_95_norm_H00 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.04 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H01 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.00 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H02 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.94 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H03 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.87 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H04 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.80 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H05 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.75 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H06 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.72 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H07 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.74 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H08 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.84 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H09 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.97 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H10 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H11 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H12 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.11 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H13 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H14 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.15 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H15 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H16 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H17 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H18 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H19 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.07 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H20 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H21 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H22 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H23 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 
	 OBJ NH4_norm_H00 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H01 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H02 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H03 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H04 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H05 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H06 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H07 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H08 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H09 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H10 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H11 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H12 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H13 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H14 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H15 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H16 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H17 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H18 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H19 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H20 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H21 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H22 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H23 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 
	 OBJ COD_norm_H00 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.02 ; group <- "COD_norm" :};
	 OBJ COD_norm_H01 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H02 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.97 ; group <- "COD_norm" :};
	 OBJ COD_norm_H03 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.94 ; group <- "COD_norm" :};
	 OBJ COD_norm_H04 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H05 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.84 ; group <- "COD_norm" :};
	 OBJ COD_norm_H06 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H07 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.77 ; group <- "COD_norm" :};
	 OBJ COD_norm_H08 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.76 ; group <- "COD_norm" :};
	 OBJ COD_norm_H09 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H10 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H11 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H12 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.10 ; group <- "COD_norm" :};
	 OBJ COD_norm_H13 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.15 ; group <- "COD_norm" :};
	 OBJ COD_norm_H14 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H15 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H16 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.17 ; group <- "COD_norm" :};
	 OBJ COD_norm_H17 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.13 ; group <- "COD_norm" :};
	 OBJ COD_norm_H18 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.09 ; group <- "COD_norm" :};
	 OBJ COD_norm_H19 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H20 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H21 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H22 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H23 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 
	 OBJ CODs_norm_H00 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H01 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H02 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H03 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H04 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.97 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H05 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.94 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H06 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.92 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H07 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.89 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H08 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.87 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H09 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.91 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H10 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H11 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.09 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H12 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.13 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H13 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.10 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H14 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.04 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H15 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H16 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H17 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H18 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.06 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H19 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.07 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H20 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.03 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H21 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H22 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H23 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 
	 OBJ PO4_norm_H00 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H01 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H02 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H03 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H04 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H05 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H06 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H07 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H08 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H09 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H10 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H11 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H12 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H13 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H14 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H15 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H16 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H17 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H18 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H19 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H20 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H21 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H22 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H23 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 
	 OBJ TSS_norm_H00 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.02 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H01 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H02 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.97 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H03 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.94 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H04 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H05 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.84 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H06 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H07 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.77 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H08 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.76 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H09 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H10 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H11 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H12 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.10 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H13 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.15 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H14 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H15 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H16 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.17 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H17 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.13 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H18 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.09 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H19 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H20 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H21 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H22 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H23 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 
	 OBJ Q_95_norm (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : HourlyDailyPattern := {: group <- "z" :}; 
   OBJ COD_norm (* hidden = "0" *) "Normalized COD hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
   OBJ CODs_norm (* hidden = "0" *) "Normalized CODs hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ TSS_norm (* hidden = "0" *) "Normalized TSS hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :}; 
	 OBJ NH4_norm (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ PO4_norm (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate := {: group <- "_Results" :};
   OBJ Q_integral "Q in integral" : Volume;
	 OBJ Qsw "Qsw" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_DWF_UB "Q DWF UB" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_mean "Averaged influent flow rate" : FlowRate := {: group <- "_Results" :};
   
   OBJ Daytime(* hidden = "0" *) "Calculates hour of the day" : Real;
   OBJ Help_Time (* hidden = "0" *)"Time of the day expressed in days" : Real;
   OBJ Timestep (* hidden = "0" *)"Hour of the day" : Integer;
	 
	 OBJ event "Type of event" : Integer;
	 OBJ event8 "1 yes, 0 no" : Integer;
	 OBJ event8_h "1 yes, 0 no" : Integer;
	 OBJ t_start_event8 (* hidden = "0" *) "Time since event8 start" : Time;
	 OBJ t_end_event8_h (* hidden = "0" *) "Time since event8_h end" : Time;
   
   OBJ COD "COD" : Concentration := {: group <- "_Results" :};
   OBJ CODs "CODs" : Concentration := {: group <- "_Results" :};
   OBJ TSS "TSS" : Concentration := {: group <- "_Results" :};
   OBJ NH4 "NH4" : Concentration := {: group <- "_Results" :};
   OBJ PO4 "PO4" : Concentration := {: group <- "_Results" :};
   
   OBJ proc1_NH4 (* hidden = "0" *) "DWF, NH4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_NH4 (* hidden = "0" *) "Dilution in large events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc3_NH4 (* hidden = "0" *) "Dilution in medium events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc4_NH4 (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc4_NH4_h (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_NH4 (* hidden = "0" *) "Dilution and replenishment small events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_NH4 (* hidden = "0" *) "Dilution and replenishment first small event, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_NH4 (* hidden = "0" *) "Dilution and replenishment second small event, NH4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_CODs (* hidden = "0" *) "DWF, CODs" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_CODs (* hidden = "0" *) "Dilution in large events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc3_CODs (* hidden = "0" *) "Dilution in medium events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc4_CODs (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc4_CODs_h (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_CODs (* hidden = "0" *) "Dilution and replenishment small events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_CODs (* hidden = "0" *) "Dilution and replenishment first small event, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_CODs (* hidden = "0" *) "Dilution and replenishment second small event, CODs" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_PO4 (* hidden = "0" *) "DWF, PO4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_PO4 (* hidden = "0" *) "Dilution in large events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc3_PO4 (* hidden = "0" *) "Dilution in medium events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc4_PO4 (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc4_PO4_h (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_PO4 (* hidden = "0" *) "Dilution and replenishment small events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_PO4 (* hidden = "0" *) "Dilution and replenishment first small event, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_PO4 (* hidden = "0" *) "Dilution and replenishment second small event, PO4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_COD (* hidden = "0" *) "DWF, COD" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_COD (* hidden = "0" *) "Dilution in large events, COD" : Real := {: group <- "_Process" :};
   OBJ proc3_COD (* hidden = "0" *) "Dilution in medium events, COD" : Real := {: group <- "_Process" :};
   OBJ proc4_COD (* hidden = "0" *) "Replenishment large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD_h (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD_h (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_TSS (* hidden = "0" *) "DWF, TSS" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_TSS (* hidden = "0" *) "Dilution in large events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc3_TSS (* hidden = "0" *) "Dilution in medium events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc4_TSS (* hidden = "0" *) "Replenishment large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS_h (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS_h (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 
	 OBJ t_proc4 (* hidden = "1" *) "Time since proc4 start" : Time;
	 OBJ t_start_proc4 (* hidden = "1" *)"Proc4 start" : Time;
	 OBJ t_event39 (* hidden = "1" *)"Time since event3 or event9 end" : Time;
	 OBJ t_end_event39 (* hidden = "1" *)"Event3 or event9 end" : Time;
	 OBJ t_start_proc5_1 (* hidden = "1" *)"Proc5_1 start" : Time;
	 OBJ t_start_proc5_2 (* hidden = "1" *)"Proc5_2 start" : Time;
	};
  
  initial <-
  { 
    parameters.SewSpecificVolume[H2O_sew] := 0.000001;

	 state.proc2_NH4 = 1;
	 state.proc3_NH4 = 1;
	 state.proc4_NH4 = 1;
	 state.proc5_NH4 = 1;
	 state.proc2_CODs = 1;
	 state.proc3_CODs = 1;
	 state.proc4_CODs = 1;
	 state.proc5_CODs = 1;
	 state.proc2_PO4 = 1;
	 state.proc3_PO4 = 1;
	 state.proc4_PO4 = 1;
	 state.proc5_PO4 = 1;
	 state.proc2_COD = 1;
	 state.proc3_COD = 1;
	 state.proc4_COD = 1;
	 state.proc2_TSS = 1;
	 state.proc3_TSS = 1;
	 state.proc4_TSS = 1;
	 
	 parameters.Q_95_norm[H00] = parameters.Q_95_norm_H00;
	 parameters.Q_95_norm[H01] = parameters.Q_95_norm_H01;
	 parameters.Q_95_norm[H02] = parameters.Q_95_norm_H02;
	 parameters.Q_95_norm[H03] = parameters.Q_95_norm_H03;
	 parameters.Q_95_norm[H04] = parameters.Q_95_norm_H04;
	 parameters.Q_95_norm[H05] = parameters.Q_95_norm_H05;
	 parameters.Q_95_norm[H06] = parameters.Q_95_norm_H06;
	 parameters.Q_95_norm[H07] = parameters.Q_95_norm_H07;
	 parameters.Q_95_norm[H08] = parameters.Q_95_norm_H08;
	 parameters.Q_95_norm[H09] = parameters.Q_95_norm_H09;
	 parameters.Q_95_norm[H10] = parameters.Q_95_norm_H10;
	 parameters.Q_95_norm[H11] = parameters.Q_95_norm_H11;
	 parameters.Q_95_norm[H12] = parameters.Q_95_norm_H12;
	 parameters.Q_95_norm[H13] = parameters.Q_95_norm_H13;
	 parameters.Q_95_norm[H14] = parameters.Q_95_norm_H14;
	 parameters.Q_95_norm[H15] = parameters.Q_95_norm_H15;
	 parameters.Q_95_norm[H16] = parameters.Q_95_norm_H16;
	 parameters.Q_95_norm[H17] = parameters.Q_95_norm_H17;
	 parameters.Q_95_norm[H18] = parameters.Q_95_norm_H18;
	 parameters.Q_95_norm[H19] = parameters.Q_95_norm_H19;
	 parameters.Q_95_norm[H20] = parameters.Q_95_norm_H20;
	 parameters.Q_95_norm[H21] = parameters.Q_95_norm_H21;
	 parameters.Q_95_norm[H22] = parameters.Q_95_norm_H22;
	 parameters.Q_95_norm[H23] = parameters.Q_95_norm_H23;
	 
	 parameters.NH4_norm[H00] = parameters.NH4_norm_H00;
	 parameters.NH4_norm[H01] = parameters.NH4_norm_H01;
	 parameters.NH4_norm[H02] = parameters.NH4_norm_H02;
	 parameters.NH4_norm[H03] = parameters.NH4_norm_H03;
	 parameters.NH4_norm[H04] = parameters.NH4_norm_H04;
	 parameters.NH4_norm[H05] = parameters.NH4_norm_H05;
	 parameters.NH4_norm[H06] = parameters.NH4_norm_H06;
	 parameters.NH4_norm[H07] = parameters.NH4_norm_H07;
	 parameters.NH4_norm[H08] = parameters.NH4_norm_H08;
	 parameters.NH4_norm[H09] = parameters.NH4_norm_H09;
	 parameters.NH4_norm[H10] = parameters.NH4_norm_H10;
	 parameters.NH4_norm[H11] = parameters.NH4_norm_H11;
	 parameters.NH4_norm[H12] = parameters.NH4_norm_H12;
	 parameters.NH4_norm[H13] = parameters.NH4_norm_H13;
	 parameters.NH4_norm[H14] = parameters.NH4_norm_H14;
	 parameters.NH4_norm[H15] = parameters.NH4_norm_H15;
	 parameters.NH4_norm[H16] = parameters.NH4_norm_H16;
	 parameters.NH4_norm[H17] = parameters.NH4_norm_H17;
	 parameters.NH4_norm[H18] = parameters.NH4_norm_H18;
	 parameters.NH4_norm[H19] = parameters.NH4_norm_H19;
	 parameters.NH4_norm[H20] = parameters.NH4_norm_H20;
	 parameters.NH4_norm[H21] = parameters.NH4_norm_H21;
	 parameters.NH4_norm[H22] = parameters.NH4_norm_H22;
	 parameters.NH4_norm[H23] = parameters.NH4_norm_H23;
	 
	 parameters.COD_norm[H00] = parameters.COD_norm_H00;
	 parameters.COD_norm[H01] = parameters.COD_norm_H01;
	 parameters.COD_norm[H02] = parameters.COD_norm_H02;
	 parameters.COD_norm[H03] = parameters.COD_norm_H03;
	 parameters.COD_norm[H04] = parameters.COD_norm_H04;
	 parameters.COD_norm[H05] = parameters.COD_norm_H05;
	 parameters.COD_norm[H06] = parameters.COD_norm_H06;
	 parameters.COD_norm[H07] = parameters.COD_norm_H07;
	 parameters.COD_norm[H08] = parameters.COD_norm_H08;
	 parameters.COD_norm[H09] = parameters.COD_norm_H09;
	 parameters.COD_norm[H10] = parameters.COD_norm_H10;
	 parameters.COD_norm[H11] = parameters.COD_norm_H11;
	 parameters.COD_norm[H12] = parameters.COD_norm_H12;
	 parameters.COD_norm[H13] = parameters.COD_norm_H13;
	 parameters.COD_norm[H14] = parameters.COD_norm_H14;
	 parameters.COD_norm[H15] = parameters.COD_norm_H15;
	 parameters.COD_norm[H16] = parameters.COD_norm_H16;
	 parameters.COD_norm[H17] = parameters.COD_norm_H17;
	 parameters.COD_norm[H18] = parameters.COD_norm_H18;
	 parameters.COD_norm[H19] = parameters.COD_norm_H19;
	 parameters.COD_norm[H20] = parameters.COD_norm_H20;
	 parameters.COD_norm[H21] = parameters.COD_norm_H21;
	 parameters.COD_norm[H22] = parameters.COD_norm_H22;
	 parameters.COD_norm[H23] = parameters.COD_norm_H23;
	 
	 parameters.CODs_norm[H00] = parameters.CODs_norm_H00;
	 parameters.CODs_norm[H01] = parameters.CODs_norm_H01;
	 parameters.CODs_norm[H02] = parameters.CODs_norm_H02;
	 parameters.CODs_norm[H03] = parameters.CODs_norm_H03;
	 parameters.CODs_norm[H04] = parameters.CODs_norm_H04;
	 parameters.CODs_norm[H05] = parameters.CODs_norm_H05;
	 parameters.CODs_norm[H06] = parameters.CODs_norm_H06;
	 parameters.CODs_norm[H07] = parameters.CODs_norm_H07;
	 parameters.CODs_norm[H08] = parameters.CODs_norm_H08;
	 parameters.CODs_norm[H09] = parameters.CODs_norm_H09;
	 parameters.CODs_norm[H10] = parameters.CODs_norm_H10;
	 parameters.CODs_norm[H11] = parameters.CODs_norm_H11;
	 parameters.CODs_norm[H12] = parameters.CODs_norm_H12;
	 parameters.CODs_norm[H13] = parameters.CODs_norm_H13;
	 parameters.CODs_norm[H14] = parameters.CODs_norm_H14;
	 parameters.CODs_norm[H15] = parameters.CODs_norm_H15;
	 parameters.CODs_norm[H16] = parameters.CODs_norm_H16;
	 parameters.CODs_norm[H17] = parameters.CODs_norm_H17;
	 parameters.CODs_norm[H18] = parameters.CODs_norm_H18;
	 parameters.CODs_norm[H19] = parameters.CODs_norm_H19;
	 parameters.CODs_norm[H20] = parameters.CODs_norm_H20;
	 parameters.CODs_norm[H21] = parameters.CODs_norm_H21;
	 parameters.CODs_norm[H22] = parameters.CODs_norm_H22;
	 parameters.CODs_norm[H23] = parameters.CODs_norm_H23;
	 
	 parameters.PO4_norm[H00] = parameters.PO4_norm_H00;
	 parameters.PO4_norm[H01] = parameters.PO4_norm_H01;
	 parameters.PO4_norm[H02] = parameters.PO4_norm_H02;
	 parameters.PO4_norm[H03] = parameters.PO4_norm_H03;
	 parameters.PO4_norm[H04] = parameters.PO4_norm_H04;
	 parameters.PO4_norm[H05] = parameters.PO4_norm_H05;
	 parameters.PO4_norm[H06] = parameters.PO4_norm_H06;
	 parameters.PO4_norm[H07] = parameters.PO4_norm_H07;
	 parameters.PO4_norm[H08] = parameters.PO4_norm_H08;
	 parameters.PO4_norm[H09] = parameters.PO4_norm_H09;
	 parameters.PO4_norm[H10] = parameters.PO4_norm_H10;
	 parameters.PO4_norm[H11] = parameters.PO4_norm_H11;
	 parameters.PO4_norm[H12] = parameters.PO4_norm_H12;
	 parameters.PO4_norm[H13] = parameters.PO4_norm_H13;
	 parameters.PO4_norm[H14] = parameters.PO4_norm_H14;
	 parameters.PO4_norm[H15] = parameters.PO4_norm_H15;
	 parameters.PO4_norm[H16] = parameters.PO4_norm_H16;
	 parameters.PO4_norm[H17] = parameters.PO4_norm_H17;
	 parameters.PO4_norm[H18] = parameters.PO4_norm_H18;
	 parameters.PO4_norm[H19] = parameters.PO4_norm_H19;
	 parameters.PO4_norm[H20] = parameters.PO4_norm_H20;
	 parameters.PO4_norm[H21] = parameters.PO4_norm_H21;
	 parameters.PO4_norm[H22] = parameters.PO4_norm_H22;
	 parameters.PO4_norm[H23] = parameters.PO4_norm_H23;
	 
	 parameters.TSS_norm[H00] = parameters.TSS_norm_H00;
	 parameters.TSS_norm[H01] = parameters.TSS_norm_H01;
	 parameters.TSS_norm[H02] = parameters.TSS_norm_H02;
	 parameters.TSS_norm[H03] = parameters.TSS_norm_H03;
	 parameters.TSS_norm[H04] = parameters.TSS_norm_H04;
	 parameters.TSS_norm[H05] = parameters.TSS_norm_H05;
	 parameters.TSS_norm[H06] = parameters.TSS_norm_H06;
	 parameters.TSS_norm[H07] = parameters.TSS_norm_H07;
	 parameters.TSS_norm[H08] = parameters.TSS_norm_H08;
	 parameters.TSS_norm[H09] = parameters.TSS_norm_H09;
	 parameters.TSS_norm[H10] = parameters.TSS_norm_H10;
	 parameters.TSS_norm[H11] = parameters.TSS_norm_H11;
	 parameters.TSS_norm[H12] = parameters.TSS_norm_H12;
	 parameters.TSS_norm[H13] = parameters.TSS_norm_H13;
	 parameters.TSS_norm[H14] = parameters.TSS_norm_H14;
	 parameters.TSS_norm[H15] = parameters.TSS_norm_H15;
	 parameters.TSS_norm[H16] = parameters.TSS_norm_H16;
	 parameters.TSS_norm[H17] = parameters.TSS_norm_H17;
	 parameters.TSS_norm[H18] = parameters.TSS_norm_H18;
	 parameters.TSS_norm[H19] = parameters.TSS_norm_H19;
	 parameters.TSS_norm[H20] = parameters.TSS_norm_H20;
	 parameters.TSS_norm[H21] = parameters.TSS_norm_H21;
	 parameters.TSS_norm[H22] = parameters.TSS_norm_H22;
	 parameters.TSS_norm[H23] = parameters.TSS_norm_H23;
  };

  equations <-
  {
    
   state.Q_in = interface.Q_Meas;
	 
   DERIV(state.Q_integral,[independent.t]) = state.Q_in;
	 state.Q_DWF_UB = parameters.Q_95_av * parameters.Q_95_norm[state.Timestep];
	 state.Qsw = IF (state.Q_in < state.Q_DWF_UB)
	 						THEN 0
	 						ELSE state.Q_in - state.Q_DWF_UB;
	 state.Help_Time = independent.t - floor(independent.t);
   state.Daytime = state.Help_Time*24; 
   state.Timestep = floor(state.Daytime) + 1;
	 DERIV(state.Q_mean,[independent.t]) = (state.Q_in - state.Q_mean) / parameters.T_Average;
	 
	  
	 state.event = IF (state.Q_in < state.Q_DWF_UB)
	 							THEN 0
	 							ELSE IF (interface.FD > parameters.FD_event)
	 							 		THEN 3
	 									 ELSE IF ((state.Qsw > parameters.Qsw_event9) && (state.Q_mean > previous(state.Q_mean)))
	 												THEN 9
	 									 		 ELSE 0;
	 
	 state.event8_h = IF ((state.Qsw > parameters.Qsw_event8) && (state.event < 3) && (state.proc4_NH4 > 0.6))
	 								 THEN 1
	 								 ELSE 0;
	 state.event8 = IF (((state.event8_h == 1) || ((independent.t - state.t_end_event8_h) < 0.25)) && (state.event < 3) && (state.t_event39 > 0.25))
	 							 THEN 1
	 							 ELSE 0;
	 state.t_start_event8 = IF ((previous(state.event8) == 0) && (state.event8 == 1))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_start_event8);
	 state.t_end_event8_h = IF ((previous(state.event8_h) == 1) && (state.event8_h == 0))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_end_event8_h);
	 
	  
	 state.proc1_NH4 = parameters.NH4_av * parameters.NH4_norm[state.Timestep];
   
   state.proc2_NH4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_NH4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_NH4) == 1) && (state.proc4_NH4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_NH4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_NH4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_NH4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_NH4)
	 																   THEN previous(state.proc4_NH4) + parameters.proc4_slope1_NH4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_NH4) + parameters.proc4_slope2_NH4 * (independent.t - previous(independent.t));
	 
	 state.proc4_NH4 = IF (state.proc4_NH4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_NH4_h;
	 
	 state.proc5_NH4 = 1 + state.proc5_1_NH4 + state.proc5_2_NH4;
	 state.proc5_1_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_NH4 / 2))
	 												 THEN previous(state.proc5_1_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_NH4)
	 															THEN previous(state.proc5_1_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_NH4 / 2))
	 												 		 THEN previous(state.proc5_2_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_NH4)
	 																	 THEN previous(state.proc5_2_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_NH4) && (previous(state.proc5_2_NH4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.NH4 = state.proc1_NH4 * state.proc2_NH4 * state.proc3_NH4 * state.proc4_NH4 * state.proc5_NH4;
	 
	  
	 state.proc1_CODs = parameters.CODs_av * parameters.CODs_norm[state.Timestep];
   
   state.proc2_CODs = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_CODs = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_CODs) == 1) && (state.proc4_CODs < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_CODs_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_CODs)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_CODs)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_CODs)
	 																   THEN previous(state.proc4_CODs) + parameters.proc4_slope1_CODs * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_CODs) + parameters.proc4_slope2_CODs * (independent.t - previous(independent.t));
	 
	 state.proc4_CODs = IF (state.proc4_CODs_h > 1)
	 									THEN 1
	 									ELSE state.proc4_CODs_h;
	 
	 state.proc5_CODs = 1 + state.proc5_1_CODs + state.proc5_2_CODs;
	 state.proc5_1_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_CODs / 2))
	 												 THEN previous(state.proc5_1_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_CODs)
	 															THEN previous(state.proc5_1_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_CODs / 2))
	 												 		 THEN previous(state.proc5_2_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_CODs)
	 																	 THEN previous(state.proc5_2_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_CODs) && (previous(state.proc5_2_CODs) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.CODs = state.proc1_CODs * state.proc2_CODs * state.proc3_CODs * state.proc4_CODs * state.proc5_CODs;
	 
	  
	 state.proc1_PO4 = parameters.PO4_av * parameters.PO4_norm[state.Timestep];
   
   state.proc2_PO4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_PO4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_PO4) == 1) && (state.proc4_PO4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_PO4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_PO4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_PO4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_PO4)
	 																   THEN previous(state.proc4_PO4) + parameters.proc4_slope1_PO4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_PO4) + parameters.proc4_slope2_PO4 * (independent.t - previous(independent.t));
	 
	 state.proc4_PO4 = IF (state.proc4_PO4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_PO4_h;
	 
	 state.proc5_PO4 = 1 + state.proc5_1_PO4 + state.proc5_2_PO4;
	 state.proc5_1_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_PO4 / 2))
	 												 THEN previous(state.proc5_1_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_PO4)
	 															THEN previous(state.proc5_1_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_PO4 / 2))
	 												 		 THEN previous(state.proc5_2_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_PO4)
	 																	 THEN previous(state.proc5_2_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_PO4) && (previous(state.proc5_2_PO4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.PO4 = state.proc1_PO4 * state.proc2_PO4 * state.proc3_PO4 * state.proc4_PO4 * state.proc5_PO4;
	 
	  
	 state.proc1_COD = parameters.COD_av * parameters.COD_norm[state.Timestep];
   
   state.proc2_COD = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_COD = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_COD = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_COD)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_COD)
	 											 		 ELSE IF (previous(state.proc4_COD) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_COD)
	 																 		 THEN previous(state.proc4_COD) + parameters.proc4_slope1_COD * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_COD) + parameters.proc4_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_COD)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_COD)
	 														  THEN parameters.peak_COD_low
	 														  ELSE parameters.peak_COD_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_COD_h) - parameters.proc6_slope1_COD * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_COD_h) - parameters.proc6_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD = IF (state.proc6_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc6_COD_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_COD_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_COD_h) + parameters.proc7_slope1_COD * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_COD_h) - parameters.proc7_slope2_COD * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_COD = IF (state.proc7_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc7_COD_h;
	 
	 state.COD = state.proc1_COD * state.proc2_COD * state.proc3_COD * state.proc4_COD + state.proc6_COD + state.proc7_COD;
	 
	  
	 state.proc1_TSS = parameters.TSS_av * parameters.TSS_norm[state.Timestep];
   
   state.proc2_TSS = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_TSS = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_TSS = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_TSS)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_TSS)
	 											 		 ELSE IF (previous(state.proc4_TSS) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_TSS)
	 																 		 THEN previous(state.proc4_TSS) + parameters.proc4_slope1_TSS * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_TSS) + parameters.proc4_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_TSS)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_TSS)
	 														  THEN parameters.peak_TSS_low
	 														  ELSE parameters.peak_TSS_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_TSS_h) - parameters.proc6_slope1_TSS * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_TSS_h) - parameters.proc6_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS = IF (state.proc6_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc6_TSS_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_TSS_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_TSS_h) + parameters.proc7_slope1_TSS * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_TSS_h) - parameters.proc7_slope2_TSS * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_TSS = IF (state.proc7_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc7_TSS_h;
	 
	 state.TSS = state.proc1_TSS * state.proc2_TSS * state.proc3_TSS * state.proc4_TSS + state.proc6_TSS + state.proc7_TSS;

   interface.Outflow[H2O_sew] = -interface.Q_Meas/parameters.SewSpecificVolume[H2O_sew];
   interface.Outflow[COD_part] = -(state.COD - state.CODs) * state.Q_in;
   interface.Outflow[COD_sol] = -state.CODs * state.Q_in;
   interface.Outflow[X_TSS_sew] = -state.TSS * state.Q_in;
   interface.Outflow[NH4_sew] = -state.NH4 * state.Q_in;
   interface.Outflow[PO4_sew] = -state.PO4 * state.Q_in;
   
 };

:};


# 43 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.influent.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\influent/wwtp.base.influent.Qevents.msl" 1
 













 CLASS Sew_WWTPin_2_Q
 (* icon = "sewer" ; is_default = "true" *)
 "Generator of WWTP infuent pollutograph, second version"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "influent model";
  
  interface <-
  {
    OBJ Q_Meas (* terminal = "in_1"; manip = "1"; is_favorite = "1" *) "Measured" : 
      FlowRate  := {: causality <- "CIN" ; value <- 100000; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      SewTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
 
 
  };
  
  parameters <-
  {
    OBJ SewSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SewSpecificVolumeVector;

   OBJ Q_event "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ Qsw_event8 "Flow sw value for start of event8" : FlowRate := {: value <- 12000 ; group <- "_Events" :};
	 OBJ Qsw_event9 "Flow sw value for start of event9" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ FD_event "Filling degree value for start of event3" : Real := {: value <- 0.21 ; group <- "_Events" :};
	 OBJ Q_FD_event "Flow rate replacing the Filling degree value for start of event3" : Real := {: value <- 600000 ; group <- "_Events" :};
	 OBJ T_Average "Averaging time for Q_mean" : Time := {: value <- 0.02083; group <- "_Events" :};
	 
   OBJ Q_95_av "Daily average Q, 95%ile" : FlowRate := {: value <- 70000 ; group <- "_Averages" :};
   OBJ COD_av "COD daily average concentration" : Concentration := {: value <- 642 ; group <- "_Averages" :};
   OBJ CODs_av "CODs daily average concentration" : Concentration := {: value <- 197.3 ; group <- "_Averages" :};
   OBJ TSS_av "TSS daily average concentration" : Concentration := {: value <- 289.6 ; group <- "_Averages" :};
   OBJ NH4_av "NH4 daily average concentration" : Concentration := {: value <- 35 ; group <- "_Averages" :};
   OBJ PO4_av "PO4 daily average concentration" : Concentration := {: value <- 7 ; group <- "_Averages" :};
   
   OBJ alpha_COD "Alpha for COD, proc2" : Fraction := {: value <- 0.8 ; group <- "_proc2" :};
   OBJ alpha_CODs "Alpha for CODs, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_TSS "Alpha for TSS, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_NH4 "Alpha for NH4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_PO4 "Alpha for PO4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   
   OBJ beta_COD "Beta for COD, proc3" : Fraction := {: value <- 0.8 ; group <- "_proc3" :};
   OBJ beta_CODs "Beta for CODs, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_TSS "Beta for TSS, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_NH4 "Beta for NH4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_PO4 "Beta for PO4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
	 
	 OBJ proc4_slope1_COD "Slope1 for COD, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_CODs "Slope1 for CODs, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_TSS "Slope1 for TSS, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_NH4 "Slope1 for NH4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_PO4 "Slope1 for PO4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
	 
	 OBJ proc4_slope2_COD "Slope2 for COD, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_CODs "Slope2 for CODs, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_TSS "Slope2 for TSS, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_NH4 "Slope2 for NH4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_PO4 "Slope2 for PO4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
	 
   OBJ window_proc4_COD "Window length for COD, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_CODs "Window length for CODs, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_TSS "Window length for TSS, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_NH4 "Window length for NH4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_PO4 "Window length for PO4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
	 
	 OBJ proc5_slope_CODs "Slope for CODs, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_NH4 "Slope for NH4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_PO4 "Slope for PO4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
	 
   OBJ window_proc5_CODs "Window length for CODs, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_NH4 "Window length for NH4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_PO4 "Window length for PO4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
	 
	 OBJ Q_proc6 "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_proc6" :};
	 OBJ peak_COD_high "Proc6 high COD peak concentration" : Concentration := {: value <- 600 ; group <- "_proc6" :};
	 OBJ peak_COD_low "Proc6 low COD peak concentration" : Concentration := {: value <- 300 ; group <- "_proc6" :};
	 OBJ proc6_slope1_COD "Slope1 for COD, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_COD "Slope2 for COD, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ peak_TSS_high "Proc6 high TSS peak concentration" : Concentration := {: value <- 200 ; group <- "_proc6" :};
	 OBJ peak_TSS_low "Proc6 low TSS peak concentration" : Concentration := {: value <- 100 ; group <- "_proc6" :};
	 OBJ proc6_slope1_TSS "Slope1 for TSS, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_TSS "Slope2 for TSS, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ proc6_t1_COD "Time1 for COD high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_COD "Time2 for COD low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 OBJ proc6_t1_TSS "Time1 for TSS high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_TSS "Time2 for TSS low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 
	 OBJ proc7_slope1_COD "Slope1 for COD, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_COD "Slope2 for COD, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
	 OBJ proc7_slope1_TSS "Slope1 for TSS, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_TSS "Slope2 for TSS, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
   
   OBJ Q_95_norm_H00 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.04 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H01 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.00 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H02 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.94 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H03 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.87 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H04 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.80 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H05 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.75 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H06 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.72 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H07 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.74 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H08 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.84 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H09 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.97 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H10 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H11 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H12 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.11 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H13 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H14 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.15 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H15 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H16 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H17 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H18 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H19 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.07 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H20 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H21 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H22 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H23 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 
	 OBJ NH4_norm_H00 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H01 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H02 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H03 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H04 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H05 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H06 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H07 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H08 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H09 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H10 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H11 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H12 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H13 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H14 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H15 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H16 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H17 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H18 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H19 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H20 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H21 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H22 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H23 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 
	 OBJ COD_norm_H00 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.02 ; group <- "COD_norm" :};
	 OBJ COD_norm_H01 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H02 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.97 ; group <- "COD_norm" :};
	 OBJ COD_norm_H03 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.94 ; group <- "COD_norm" :};
	 OBJ COD_norm_H04 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H05 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.84 ; group <- "COD_norm" :};
	 OBJ COD_norm_H06 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H07 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.77 ; group <- "COD_norm" :};
	 OBJ COD_norm_H08 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.76 ; group <- "COD_norm" :};
	 OBJ COD_norm_H09 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H10 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H11 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H12 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.10 ; group <- "COD_norm" :};
	 OBJ COD_norm_H13 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.15 ; group <- "COD_norm" :};
	 OBJ COD_norm_H14 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H15 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H16 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.17 ; group <- "COD_norm" :};
	 OBJ COD_norm_H17 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.13 ; group <- "COD_norm" :};
	 OBJ COD_norm_H18 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.09 ; group <- "COD_norm" :};
	 OBJ COD_norm_H19 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H20 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H21 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H22 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H23 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 
	 OBJ CODs_norm_H00 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H01 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H02 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H03 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H04 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.97 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H05 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.94 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H06 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.92 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H07 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.89 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H08 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.87 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H09 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.91 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H10 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H11 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.09 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H12 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.13 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H13 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.10 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H14 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.04 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H15 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H16 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H17 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H18 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.06 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H19 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.07 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H20 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.03 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H21 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H22 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H23 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 
	 OBJ PO4_norm_H00 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H01 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H02 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H03 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H04 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H05 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H06 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H07 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H08 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H09 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H10 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H11 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H12 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H13 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H14 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H15 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H16 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H17 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H18 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H19 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H20 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H21 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H22 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H23 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 
	 OBJ TSS_norm_H00 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.02 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H01 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H02 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.97 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H03 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.94 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H04 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H05 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.84 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H06 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H07 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.77 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H08 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.76 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H09 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H10 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H11 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H12 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.10 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H13 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.15 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H14 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H15 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H16 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.17 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H17 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.13 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H18 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.09 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H19 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H20 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H21 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H22 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H23 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 
	 OBJ Q_95_norm (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : HourlyDailyPattern := {: group <- "z" :}; 
   OBJ COD_norm (* hidden = "0" *) "Normalized COD hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
   OBJ CODs_norm (* hidden = "0" *) "Normalized CODs hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ TSS_norm (* hidden = "0" *) "Normalized TSS hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :}; 
	 OBJ NH4_norm (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ PO4_norm (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate := {: group <- "_Results" :};
   OBJ Q_integral "Q in integral" : Volume;
	 OBJ Qsw "Qsw" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_DWF_UB "Q DWF UB" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_mean "Averaged influent flow rate" : FlowRate := {: group <- "_Results" :};
   
   OBJ Daytime(* hidden = "0" *) "Calculates hour of the day" : Real;
   OBJ Help_Time (* hidden = "0" *)"Time of the day expressed in days" : Real;
   OBJ Timestep (* hidden = "0" *)"Hour of the day" : Integer;
	 
	 OBJ event "Type of event" : Integer;
	 OBJ event8 "1 yes, 0 no" : Integer;
	 OBJ event8_h "1 yes, 0 no" : Integer;
	 OBJ t_start_event8 (* hidden = "0" *) "Time since event8 start" : Time;
	 OBJ t_end_event8_h (* hidden = "0" *) "Time since event8_h end" : Time;
   
   OBJ COD "COD" : Concentration := {: group <- "_Results" :};
   OBJ CODs "CODs" : Concentration := {: group <- "_Results" :};
   OBJ TSS "TSS" : Concentration := {: group <- "_Results" :};
   OBJ NH4 "NH4" : Concentration := {: group <- "_Results" :};
   OBJ PO4 "PO4" : Concentration := {: group <- "_Results" :};
   
   OBJ proc1_NH4 (* hidden = "0" *) "DWF, NH4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_NH4 (* hidden = "0" *) "Dilution in large events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc3_NH4 (* hidden = "0" *) "Dilution in medium events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc4_NH4 (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc4_NH4_h (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_NH4 (* hidden = "0" *) "Dilution and replenishment small events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_NH4 (* hidden = "0" *) "Dilution and replenishment first small event, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_NH4 (* hidden = "0" *) "Dilution and replenishment second small event, NH4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_CODs (* hidden = "0" *) "DWF, CODs" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_CODs (* hidden = "0" *) "Dilution in large events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc3_CODs (* hidden = "0" *) "Dilution in medium events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc4_CODs (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc4_CODs_h (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_CODs (* hidden = "0" *) "Dilution and replenishment small events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_CODs (* hidden = "0" *) "Dilution and replenishment first small event, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_CODs (* hidden = "0" *) "Dilution and replenishment second small event, CODs" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_PO4 (* hidden = "0" *) "DWF, PO4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_PO4 (* hidden = "0" *) "Dilution in large events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc3_PO4 (* hidden = "0" *) "Dilution in medium events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc4_PO4 (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc4_PO4_h (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_PO4 (* hidden = "0" *) "Dilution and replenishment small events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_PO4 (* hidden = "0" *) "Dilution and replenishment first small event, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_PO4 (* hidden = "0" *) "Dilution and replenishment second small event, PO4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_COD (* hidden = "0" *) "DWF, COD" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_COD (* hidden = "0" *) "Dilution in large events, COD" : Real := {: group <- "_Process" :};
   OBJ proc3_COD (* hidden = "0" *) "Dilution in medium events, COD" : Real := {: group <- "_Process" :};
   OBJ proc4_COD (* hidden = "0" *) "Replenishment large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD_h (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD_h (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_TSS (* hidden = "0" *) "DWF, TSS" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_TSS (* hidden = "0" *) "Dilution in large events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc3_TSS (* hidden = "0" *) "Dilution in medium events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc4_TSS (* hidden = "0" *) "Replenishment large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS_h (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS_h (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 
	 OBJ t_proc4 (* hidden = "1" *) "Time since proc4 start" : Time;
	 OBJ t_start_proc4 (* hidden = "1" *)"Proc4 start" : Time;
	 OBJ t_event39 (* hidden = "1" *)"Time since event3 or event9 end" : Time;
	 OBJ t_end_event39 (* hidden = "1" *)"Event3 or event9 end" : Time;
	 OBJ t_start_proc5_1 (* hidden = "1" *)"Proc5_1 start" : Time;
	 OBJ t_start_proc5_2 (* hidden = "1" *)"Proc5_2 start" : Time;
	};
  
  initial <-
  { 
    parameters.SewSpecificVolume[H2O_sew] := 0.000001;

	 state.proc2_NH4 = 1;
	 state.proc3_NH4 = 1;
	 state.proc4_NH4 = 1;
	 state.proc5_NH4 = 1;
	 state.proc2_CODs = 1;
	 state.proc3_CODs = 1;
	 state.proc4_CODs = 1;
	 state.proc5_CODs = 1;
	 state.proc2_PO4 = 1;
	 state.proc3_PO4 = 1;
	 state.proc4_PO4 = 1;
	 state.proc5_PO4 = 1;
	 state.proc2_COD = 1;
	 state.proc3_COD = 1;
	 state.proc4_COD = 1;
	 state.proc2_TSS = 1;
	 state.proc3_TSS = 1;
	 state.proc4_TSS = 1;
	 
	 parameters.Q_95_norm[H00] = parameters.Q_95_norm_H00;
	 parameters.Q_95_norm[H01] = parameters.Q_95_norm_H01;
	 parameters.Q_95_norm[H02] = parameters.Q_95_norm_H02;
	 parameters.Q_95_norm[H03] = parameters.Q_95_norm_H03;
	 parameters.Q_95_norm[H04] = parameters.Q_95_norm_H04;
	 parameters.Q_95_norm[H05] = parameters.Q_95_norm_H05;
	 parameters.Q_95_norm[H06] = parameters.Q_95_norm_H06;
	 parameters.Q_95_norm[H07] = parameters.Q_95_norm_H07;
	 parameters.Q_95_norm[H08] = parameters.Q_95_norm_H08;
	 parameters.Q_95_norm[H09] = parameters.Q_95_norm_H09;
	 parameters.Q_95_norm[H10] = parameters.Q_95_norm_H10;
	 parameters.Q_95_norm[H11] = parameters.Q_95_norm_H11;
	 parameters.Q_95_norm[H12] = parameters.Q_95_norm_H12;
	 parameters.Q_95_norm[H13] = parameters.Q_95_norm_H13;
	 parameters.Q_95_norm[H14] = parameters.Q_95_norm_H14;
	 parameters.Q_95_norm[H15] = parameters.Q_95_norm_H15;
	 parameters.Q_95_norm[H16] = parameters.Q_95_norm_H16;
	 parameters.Q_95_norm[H17] = parameters.Q_95_norm_H17;
	 parameters.Q_95_norm[H18] = parameters.Q_95_norm_H18;
	 parameters.Q_95_norm[H19] = parameters.Q_95_norm_H19;
	 parameters.Q_95_norm[H20] = parameters.Q_95_norm_H20;
	 parameters.Q_95_norm[H21] = parameters.Q_95_norm_H21;
	 parameters.Q_95_norm[H22] = parameters.Q_95_norm_H22;
	 parameters.Q_95_norm[H23] = parameters.Q_95_norm_H23;
	 
	 parameters.NH4_norm[H00] = parameters.NH4_norm_H00;
	 parameters.NH4_norm[H01] = parameters.NH4_norm_H01;
	 parameters.NH4_norm[H02] = parameters.NH4_norm_H02;
	 parameters.NH4_norm[H03] = parameters.NH4_norm_H03;
	 parameters.NH4_norm[H04] = parameters.NH4_norm_H04;
	 parameters.NH4_norm[H05] = parameters.NH4_norm_H05;
	 parameters.NH4_norm[H06] = parameters.NH4_norm_H06;
	 parameters.NH4_norm[H07] = parameters.NH4_norm_H07;
	 parameters.NH4_norm[H08] = parameters.NH4_norm_H08;
	 parameters.NH4_norm[H09] = parameters.NH4_norm_H09;
	 parameters.NH4_norm[H10] = parameters.NH4_norm_H10;
	 parameters.NH4_norm[H11] = parameters.NH4_norm_H11;
	 parameters.NH4_norm[H12] = parameters.NH4_norm_H12;
	 parameters.NH4_norm[H13] = parameters.NH4_norm_H13;
	 parameters.NH4_norm[H14] = parameters.NH4_norm_H14;
	 parameters.NH4_norm[H15] = parameters.NH4_norm_H15;
	 parameters.NH4_norm[H16] = parameters.NH4_norm_H16;
	 parameters.NH4_norm[H17] = parameters.NH4_norm_H17;
	 parameters.NH4_norm[H18] = parameters.NH4_norm_H18;
	 parameters.NH4_norm[H19] = parameters.NH4_norm_H19;
	 parameters.NH4_norm[H20] = parameters.NH4_norm_H20;
	 parameters.NH4_norm[H21] = parameters.NH4_norm_H21;
	 parameters.NH4_norm[H22] = parameters.NH4_norm_H22;
	 parameters.NH4_norm[H23] = parameters.NH4_norm_H23;
	 
	 parameters.COD_norm[H00] = parameters.COD_norm_H00;
	 parameters.COD_norm[H01] = parameters.COD_norm_H01;
	 parameters.COD_norm[H02] = parameters.COD_norm_H02;
	 parameters.COD_norm[H03] = parameters.COD_norm_H03;
	 parameters.COD_norm[H04] = parameters.COD_norm_H04;
	 parameters.COD_norm[H05] = parameters.COD_norm_H05;
	 parameters.COD_norm[H06] = parameters.COD_norm_H06;
	 parameters.COD_norm[H07] = parameters.COD_norm_H07;
	 parameters.COD_norm[H08] = parameters.COD_norm_H08;
	 parameters.COD_norm[H09] = parameters.COD_norm_H09;
	 parameters.COD_norm[H10] = parameters.COD_norm_H10;
	 parameters.COD_norm[H11] = parameters.COD_norm_H11;
	 parameters.COD_norm[H12] = parameters.COD_norm_H12;
	 parameters.COD_norm[H13] = parameters.COD_norm_H13;
	 parameters.COD_norm[H14] = parameters.COD_norm_H14;
	 parameters.COD_norm[H15] = parameters.COD_norm_H15;
	 parameters.COD_norm[H16] = parameters.COD_norm_H16;
	 parameters.COD_norm[H17] = parameters.COD_norm_H17;
	 parameters.COD_norm[H18] = parameters.COD_norm_H18;
	 parameters.COD_norm[H19] = parameters.COD_norm_H19;
	 parameters.COD_norm[H20] = parameters.COD_norm_H20;
	 parameters.COD_norm[H21] = parameters.COD_norm_H21;
	 parameters.COD_norm[H22] = parameters.COD_norm_H22;
	 parameters.COD_norm[H23] = parameters.COD_norm_H23;
	 
	 parameters.CODs_norm[H00] = parameters.CODs_norm_H00;
	 parameters.CODs_norm[H01] = parameters.CODs_norm_H01;
	 parameters.CODs_norm[H02] = parameters.CODs_norm_H02;
	 parameters.CODs_norm[H03] = parameters.CODs_norm_H03;
	 parameters.CODs_norm[H04] = parameters.CODs_norm_H04;
	 parameters.CODs_norm[H05] = parameters.CODs_norm_H05;
	 parameters.CODs_norm[H06] = parameters.CODs_norm_H06;
	 parameters.CODs_norm[H07] = parameters.CODs_norm_H07;
	 parameters.CODs_norm[H08] = parameters.CODs_norm_H08;
	 parameters.CODs_norm[H09] = parameters.CODs_norm_H09;
	 parameters.CODs_norm[H10] = parameters.CODs_norm_H10;
	 parameters.CODs_norm[H11] = parameters.CODs_norm_H11;
	 parameters.CODs_norm[H12] = parameters.CODs_norm_H12;
	 parameters.CODs_norm[H13] = parameters.CODs_norm_H13;
	 parameters.CODs_norm[H14] = parameters.CODs_norm_H14;
	 parameters.CODs_norm[H15] = parameters.CODs_norm_H15;
	 parameters.CODs_norm[H16] = parameters.CODs_norm_H16;
	 parameters.CODs_norm[H17] = parameters.CODs_norm_H17;
	 parameters.CODs_norm[H18] = parameters.CODs_norm_H18;
	 parameters.CODs_norm[H19] = parameters.CODs_norm_H19;
	 parameters.CODs_norm[H20] = parameters.CODs_norm_H20;
	 parameters.CODs_norm[H21] = parameters.CODs_norm_H21;
	 parameters.CODs_norm[H22] = parameters.CODs_norm_H22;
	 parameters.CODs_norm[H23] = parameters.CODs_norm_H23;
	 
	 parameters.PO4_norm[H00] = parameters.PO4_norm_H00;
	 parameters.PO4_norm[H01] = parameters.PO4_norm_H01;
	 parameters.PO4_norm[H02] = parameters.PO4_norm_H02;
	 parameters.PO4_norm[H03] = parameters.PO4_norm_H03;
	 parameters.PO4_norm[H04] = parameters.PO4_norm_H04;
	 parameters.PO4_norm[H05] = parameters.PO4_norm_H05;
	 parameters.PO4_norm[H06] = parameters.PO4_norm_H06;
	 parameters.PO4_norm[H07] = parameters.PO4_norm_H07;
	 parameters.PO4_norm[H08] = parameters.PO4_norm_H08;
	 parameters.PO4_norm[H09] = parameters.PO4_norm_H09;
	 parameters.PO4_norm[H10] = parameters.PO4_norm_H10;
	 parameters.PO4_norm[H11] = parameters.PO4_norm_H11;
	 parameters.PO4_norm[H12] = parameters.PO4_norm_H12;
	 parameters.PO4_norm[H13] = parameters.PO4_norm_H13;
	 parameters.PO4_norm[H14] = parameters.PO4_norm_H14;
	 parameters.PO4_norm[H15] = parameters.PO4_norm_H15;
	 parameters.PO4_norm[H16] = parameters.PO4_norm_H16;
	 parameters.PO4_norm[H17] = parameters.PO4_norm_H17;
	 parameters.PO4_norm[H18] = parameters.PO4_norm_H18;
	 parameters.PO4_norm[H19] = parameters.PO4_norm_H19;
	 parameters.PO4_norm[H20] = parameters.PO4_norm_H20;
	 parameters.PO4_norm[H21] = parameters.PO4_norm_H21;
	 parameters.PO4_norm[H22] = parameters.PO4_norm_H22;
	 parameters.PO4_norm[H23] = parameters.PO4_norm_H23;
	 
	 parameters.TSS_norm[H00] = parameters.TSS_norm_H00;
	 parameters.TSS_norm[H01] = parameters.TSS_norm_H01;
	 parameters.TSS_norm[H02] = parameters.TSS_norm_H02;
	 parameters.TSS_norm[H03] = parameters.TSS_norm_H03;
	 parameters.TSS_norm[H04] = parameters.TSS_norm_H04;
	 parameters.TSS_norm[H05] = parameters.TSS_norm_H05;
	 parameters.TSS_norm[H06] = parameters.TSS_norm_H06;
	 parameters.TSS_norm[H07] = parameters.TSS_norm_H07;
	 parameters.TSS_norm[H08] = parameters.TSS_norm_H08;
	 parameters.TSS_norm[H09] = parameters.TSS_norm_H09;
	 parameters.TSS_norm[H10] = parameters.TSS_norm_H10;
	 parameters.TSS_norm[H11] = parameters.TSS_norm_H11;
	 parameters.TSS_norm[H12] = parameters.TSS_norm_H12;
	 parameters.TSS_norm[H13] = parameters.TSS_norm_H13;
	 parameters.TSS_norm[H14] = parameters.TSS_norm_H14;
	 parameters.TSS_norm[H15] = parameters.TSS_norm_H15;
	 parameters.TSS_norm[H16] = parameters.TSS_norm_H16;
	 parameters.TSS_norm[H17] = parameters.TSS_norm_H17;
	 parameters.TSS_norm[H18] = parameters.TSS_norm_H18;
	 parameters.TSS_norm[H19] = parameters.TSS_norm_H19;
	 parameters.TSS_norm[H20] = parameters.TSS_norm_H20;
	 parameters.TSS_norm[H21] = parameters.TSS_norm_H21;
	 parameters.TSS_norm[H22] = parameters.TSS_norm_H22;
	 parameters.TSS_norm[H23] = parameters.TSS_norm_H23;
  };

  equations <-
  {
   state.Q_in = interface.Q_Meas;   
	  
   DERIV(state.Q_integral,[independent.t]) = state.Q_in;
	 state.Q_DWF_UB = parameters.Q_95_av * parameters.Q_95_norm[state.Timestep];
	 state.Qsw = IF (state.Q_in < state.Q_DWF_UB)
	 						THEN 0
	 						ELSE state.Q_in - state.Q_DWF_UB;
	 state.Help_Time = independent.t - floor(independent.t);
   state.Daytime = state.Help_Time*24; 
   state.Timestep = floor(state.Daytime) + 1;
	 DERIV(state.Q_mean,[independent.t]) = (state.Q_in - state.Q_mean) / parameters.T_Average;
	 
	  
	 state.event = IF (state.Q_in < state.Q_DWF_UB)
	 							THEN 0
	 							ELSE IF (state.Q_in > parameters.Q_FD_event)
	 							 		THEN 3
	 									 ELSE IF ((state.Qsw > parameters.Qsw_event9) && (state.Q_mean > previous(state.Q_mean)))
	 												THEN 9
	 									 		 ELSE 0;
	 
	 state.event8_h = IF ((state.Qsw > parameters.Qsw_event8) && (state.event < 3) && (state.proc4_NH4 > 0.6))
	 								 THEN 1
	 								 ELSE 0;
	 state.event8 = IF (((state.event8_h == 1) || ((independent.t - state.t_end_event8_h) < 0.25)) && (state.event < 3) && (state.t_event39 > 0.25))
	 							 THEN 1
	 							 ELSE 0;
	 state.t_start_event8 = IF ((previous(state.event8) == 0) && (state.event8 == 1))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_start_event8);
	 state.t_end_event8_h = IF ((previous(state.event8_h) == 1) && (state.event8_h == 0))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_end_event8_h);
	 
	  
	 state.proc1_NH4 = parameters.NH4_av * parameters.NH4_norm[state.Timestep];
   
   state.proc2_NH4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_NH4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_NH4) == 1) && (state.proc4_NH4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_NH4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_NH4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_NH4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_NH4)
	 																   THEN previous(state.proc4_NH4) + parameters.proc4_slope1_NH4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_NH4) + parameters.proc4_slope2_NH4 * (independent.t - previous(independent.t));
	 
	 state.proc4_NH4 = IF (state.proc4_NH4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_NH4_h;
	 
	 state.proc5_NH4 = 1 + state.proc5_1_NH4 + state.proc5_2_NH4;
	 state.proc5_1_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_NH4 / 2))
	 												 THEN previous(state.proc5_1_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_NH4)
	 															THEN previous(state.proc5_1_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_NH4 / 2))
	 												 		 THEN previous(state.proc5_2_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_NH4)
	 																	 THEN previous(state.proc5_2_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_NH4) && (previous(state.proc5_2_NH4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.NH4 = state.proc1_NH4 * state.proc2_NH4 * state.proc3_NH4 * state.proc4_NH4 * state.proc5_NH4;
	 
	  
	 state.proc1_CODs = parameters.CODs_av * parameters.CODs_norm[state.Timestep];
   
   state.proc2_CODs = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_CODs = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_CODs) == 1) && (state.proc4_CODs < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_CODs_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_CODs)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_CODs)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_CODs)
	 																   THEN previous(state.proc4_CODs) + parameters.proc4_slope1_CODs * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_CODs) + parameters.proc4_slope2_CODs * (independent.t - previous(independent.t));
	 
	 state.proc4_CODs = IF (state.proc4_CODs_h > 1)
	 									THEN 1
	 									ELSE state.proc4_CODs_h;
	 
	 state.proc5_CODs = 1 + state.proc5_1_CODs + state.proc5_2_CODs;
	 state.proc5_1_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_CODs / 2))
	 												 THEN previous(state.proc5_1_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_CODs)
	 															THEN previous(state.proc5_1_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_CODs / 2))
	 												 		 THEN previous(state.proc5_2_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_CODs)
	 																	 THEN previous(state.proc5_2_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_CODs) && (previous(state.proc5_2_CODs) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.CODs = state.proc1_CODs * state.proc2_CODs * state.proc3_CODs * state.proc4_CODs * state.proc5_CODs;
	 
	  
	 state.proc1_PO4 = parameters.PO4_av * parameters.PO4_norm[state.Timestep];
   
   state.proc2_PO4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_PO4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_PO4) == 1) && (state.proc4_PO4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_PO4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_PO4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_PO4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_PO4)
	 																   THEN previous(state.proc4_PO4) + parameters.proc4_slope1_PO4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_PO4) + parameters.proc4_slope2_PO4 * (independent.t - previous(independent.t));
	 
	 state.proc4_PO4 = IF (state.proc4_PO4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_PO4_h;
	 
	 state.proc5_PO4 = 1 + state.proc5_1_PO4 + state.proc5_2_PO4;
	 state.proc5_1_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_PO4 / 2))
	 												 THEN previous(state.proc5_1_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_PO4)
	 															THEN previous(state.proc5_1_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_PO4 / 2))
	 												 		 THEN previous(state.proc5_2_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_PO4)
	 																	 THEN previous(state.proc5_2_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_PO4) && (previous(state.proc5_2_PO4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.PO4 = state.proc1_PO4 * state.proc2_PO4 * state.proc3_PO4 * state.proc4_PO4 * state.proc5_PO4;
	 
	  
	 state.proc1_COD = parameters.COD_av * parameters.COD_norm[state.Timestep];
   
   state.proc2_COD = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_COD = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_COD = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_COD)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_COD)
	 											 		 ELSE IF (previous(state.proc4_COD) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_COD)
	 																 		 THEN previous(state.proc4_COD) + parameters.proc4_slope1_COD * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_COD) + parameters.proc4_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_COD)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_COD)
	 														  THEN parameters.peak_COD_low
	 														  ELSE parameters.peak_COD_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_COD_h) - parameters.proc6_slope1_COD * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_COD_h) - parameters.proc6_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD = IF (state.proc6_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc6_COD_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_COD_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_COD_h) + parameters.proc7_slope1_COD * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_COD_h) - parameters.proc7_slope2_COD * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_COD = IF (state.proc7_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc7_COD_h;
	 
	 state.COD = state.proc1_COD * state.proc2_COD * state.proc3_COD * state.proc4_COD + state.proc6_COD + state.proc7_COD;
	 
	  
	 state.proc1_TSS = parameters.TSS_av * parameters.TSS_norm[state.Timestep];
   
   state.proc2_TSS = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_TSS = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_TSS = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_TSS)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_TSS)
	 											 		 ELSE IF (previous(state.proc4_TSS) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_TSS)
	 																 		 THEN previous(state.proc4_TSS) + parameters.proc4_slope1_TSS * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_TSS) + parameters.proc4_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_TSS)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_TSS)
	 														  THEN parameters.peak_TSS_low
	 														  ELSE parameters.peak_TSS_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_TSS_h) - parameters.proc6_slope1_TSS * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_TSS_h) - parameters.proc6_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS = IF (state.proc6_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc6_TSS_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_TSS_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_TSS_h) + parameters.proc7_slope1_TSS * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_TSS_h) - parameters.proc7_slope2_TSS * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_TSS = IF (state.proc7_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc7_TSS_h;
	 
	 state.TSS = state.proc1_TSS * state.proc2_TSS * state.proc3_TSS * state.proc4_TSS + state.proc6_TSS + state.proc7_TSS;

   interface.Outflow[H2O_sew] = -interface.Q_Meas/parameters.SewSpecificVolume[H2O_sew];
   interface.Outflow[COD_part] = -(state.COD - state.CODs) * state.Q_in;
   interface.Outflow[COD_sol] = -state.CODs * state.Q_in;
   interface.Outflow[X_TSS_sew] = -state.TSS * state.Q_in;
   interface.Outflow[NH4_sew] = -state.NH4 * state.Q_in;
   interface.Outflow[PO4_sew] = -state.PO4 * state.Q_in;
   
 };

:};


# 44 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.influent.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\influent/wwtp.base.influent.level.msl" 1
 













 CLASS Sew_WWTPin_2_level
 (* icon = "sewer" *)
 "Generator of WWTP infuent pollutograph, second version, adaptation to use level instead of filling degree"
	 
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Q_Meas (* terminal = "in_1"; manip = "1"; is_favorite = "1" *) "Measured" : 
      FlowRate  := {: causality <- "CIN" ; value <- 100000; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      SewTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	  OBJ Level (* terminal = "in_1"; manip = "1"; is_favorite = "1" *) "measured influent level" : 
      Length  := {: causality <- "CIN" ; value <- 10; group <- "Influent" :};
  }; 
  
  parameters <-
  {
    OBJ SewSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SewSpecificVolumeVector;

   OBJ Q_event "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ Qsw_event8 "Flow sw value for start of event8" : FlowRate := {: value <- 12000 ; group <- "_Events" :};
	 OBJ Qsw_event9 "Flow sw value for start of event9" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ Level_event "Level of the influent pit for start of event3" : Length := {: value <- 11.3 ; group <- "_Events" :};
	 OBJ T_Average "Averaging time for Q_mean" : Time := {: value <- 0.02083; group <- "_Events" :};
	 
   OBJ Q_95_av "Daily average Q, 95%ile" : FlowRate := {: value <- 70000 ; group <- "_Averages" :};
   OBJ COD_av "COD daily average concentration" : Concentration := {: value <- 642 ; group <- "_Averages" :};
   OBJ CODs_av "CODs daily average concentration" : Concentration := {: value <- 197.3 ; group <- "_Averages" :};
   OBJ TSS_av "TSS daily average concentration" : Concentration := {: value <- 289.6 ; group <- "_Averages" :};
   OBJ NH4_av "NH4 daily average concentration" : Concentration := {: value <- 35 ; group <- "_Averages" :};
   OBJ PO4_av "PO4 daily average concentration" : Concentration := {: value <- 7 ; group <- "_Averages" :};
   
   OBJ alpha_COD "Alpha for COD, proc2" : Fraction := {: value <- 0.8 ; group <- "_proc2" :};
   OBJ alpha_CODs "Alpha for CODs, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_TSS "Alpha for TSS, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_NH4 "Alpha for NH4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_PO4 "Alpha for PO4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   
   OBJ beta_COD "Beta for COD, proc3" : Fraction := {: value <- 0.8 ; group <- "_proc3" :};
   OBJ beta_CODs "Beta for CODs, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_TSS "Beta for TSS, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_NH4 "Beta for NH4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_PO4 "Beta for PO4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
	 
	 OBJ proc4_slope1_COD "Slope1 for COD, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_CODs "Slope1 for CODs, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_TSS "Slope1 for TSS, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_NH4 "Slope1 for NH4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_PO4 "Slope1 for PO4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
	 
	 OBJ proc4_slope2_COD "Slope2 for COD, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_CODs "Slope2 for CODs, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_TSS "Slope2 for TSS, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_NH4 "Slope2 for NH4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_PO4 "Slope2 for PO4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
	 
   OBJ window_proc4_COD "Window length for COD, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_CODs "Window length for CODs, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_TSS "Window length for TSS, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_NH4 "Window length for NH4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_PO4 "Window length for PO4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
	 
	 OBJ proc5_slope_CODs "Slope for CODs, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_NH4 "Slope for NH4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_PO4 "Slope for PO4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
	 
   OBJ window_proc5_CODs "Window length for CODs, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_NH4 "Window length for NH4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_PO4 "Window length for PO4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
	 
	 OBJ Q_proc6 "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_proc6" :};
	 OBJ peak_COD_high "Proc6 high COD peak concentration" : Concentration := {: value <- 600 ; group <- "_proc6" :};
	 OBJ peak_COD_low "Proc6 low COD peak concentration" : Concentration := {: value <- 300 ; group <- "_proc6" :};
	 OBJ proc6_slope1_COD "Slope1 for COD, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_COD "Slope2 for COD, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ peak_TSS_high "Proc6 high TSS peak concentration" : Concentration := {: value <- 200 ; group <- "_proc6" :};
	 OBJ peak_TSS_low "Proc6 low TSS peak concentration" : Concentration := {: value <- 100 ; group <- "_proc6" :};
	 OBJ proc6_slope1_TSS "Slope1 for TSS, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_TSS "Slope2 for TSS, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ proc6_t1_COD "Time1 for COD high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_COD "Time2 for COD low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 OBJ proc6_t1_TSS "Time1 for TSS high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_TSS "Time2 for TSS low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 
	 OBJ proc7_slope1_COD "Slope1 for COD, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_COD "Slope2 for COD, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
	 OBJ proc7_slope1_TSS "Slope1 for TSS, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_TSS "Slope2 for TSS, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
   
   OBJ Q_95_norm_H00 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.04 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H01 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.00 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H02 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.94 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H03 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.87 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H04 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.80 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H05 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.75 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H06 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.72 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H07 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.74 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H08 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.84 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H09 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.97 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H10 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H11 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H12 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.11 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H13 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H14 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.15 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H15 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H16 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H17 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H18 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H19 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.07 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H20 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H21 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H22 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H23 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 
	 OBJ NH4_norm_H00 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H01 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H02 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H03 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H04 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H05 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H06 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H07 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H08 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H09 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H10 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H11 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H12 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H13 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H14 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H15 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H16 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H17 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H18 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H19 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H20 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H21 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H22 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H23 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 
	 OBJ COD_norm_H00 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.02 ; group <- "COD_norm" :};
	 OBJ COD_norm_H01 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H02 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.97 ; group <- "COD_norm" :};
	 OBJ COD_norm_H03 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.94 ; group <- "COD_norm" :};
	 OBJ COD_norm_H04 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H05 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.84 ; group <- "COD_norm" :};
	 OBJ COD_norm_H06 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H07 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.77 ; group <- "COD_norm" :};
	 OBJ COD_norm_H08 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.76 ; group <- "COD_norm" :};
	 OBJ COD_norm_H09 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H10 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H11 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H12 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.10 ; group <- "COD_norm" :};
	 OBJ COD_norm_H13 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.15 ; group <- "COD_norm" :};
	 OBJ COD_norm_H14 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H15 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H16 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.17 ; group <- "COD_norm" :};
	 OBJ COD_norm_H17 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.13 ; group <- "COD_norm" :};
	 OBJ COD_norm_H18 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.09 ; group <- "COD_norm" :};
	 OBJ COD_norm_H19 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H20 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H21 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H22 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H23 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 
	 OBJ CODs_norm_H00 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H01 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H02 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H03 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H04 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.97 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H05 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.94 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H06 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.92 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H07 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.89 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H08 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.87 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H09 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.91 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H10 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H11 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.09 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H12 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.13 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H13 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.10 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H14 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.04 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H15 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H16 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H17 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H18 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.06 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H19 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.07 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H20 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.03 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H21 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H22 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H23 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 
	 OBJ PO4_norm_H00 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H01 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H02 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H03 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H04 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H05 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H06 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H07 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H08 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H09 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H10 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H11 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H12 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H13 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H14 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H15 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H16 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H17 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H18 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H19 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H20 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H21 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H22 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H23 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 
	 OBJ TSS_norm_H00 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.02 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H01 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H02 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.97 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H03 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.94 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H04 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H05 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.84 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H06 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H07 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.77 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H08 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.76 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H09 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H10 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H11 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H12 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.10 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H13 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.15 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H14 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H15 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H16 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.17 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H17 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.13 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H18 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.09 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H19 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H20 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H21 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H22 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H23 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 
	 OBJ Q_95_norm (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : HourlyDailyPattern := {: group <- "z" :}; 
   OBJ COD_norm (* hidden = "0" *) "Normalized COD hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
   OBJ CODs_norm (* hidden = "0" *) "Normalized CODs hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ TSS_norm (* hidden = "0" *) "Normalized TSS hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :}; 
	 OBJ NH4_norm (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ PO4_norm (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate := {: group <- "_Results" :};
   OBJ Q_integral "Q in integral" : Volume;
	 OBJ Qsw "Qsw" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_DWF_UB "Q DWF UB" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_mean "Averaged influent flow rate" : FlowRate := {: group <- "_Results" :};
   
   OBJ Daytime(* hidden = "0" *) "Calculates hour of the day" : Real;
   OBJ Help_Time (* hidden = "0" *)"Time of the day expressed in days" : Real;
   OBJ Timestep (* hidden = "0" *)"Hour of the day" : Integer;
	 
	 OBJ event "Type of event" : Integer;
	 OBJ event8 "1 yes, 0 no" : Integer;
	 OBJ event8_h "1 yes, 0 no" : Integer;
	 OBJ t_start_event8 (* hidden = "0" *) "Time since event8 start" : Time;
	 OBJ t_end_event8_h (* hidden = "0" *) "Time since event8_h end" : Time;
   
   OBJ COD "COD" : Concentration := {: group <- "_Results" :};
   OBJ CODs "CODs" : Concentration := {: group <- "_Results" :};
   OBJ TSS "TSS" : Concentration := {: group <- "_Results" :};
   OBJ NH4 "NH4" : Concentration := {: group <- "_Results" :};
   OBJ PO4 "PO4" : Concentration := {: group <- "_Results" :};
   
   OBJ proc1_NH4 (* hidden = "0" *) "DWF, NH4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_NH4 (* hidden = "0" *) "Dilution in large events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc3_NH4 (* hidden = "0" *) "Dilution in medium events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc4_NH4 (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc4_NH4_h (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_NH4 (* hidden = "0" *) "Dilution and replenishment small events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_NH4 (* hidden = "0" *) "Dilution and replenishment first small event, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_NH4 (* hidden = "0" *) "Dilution and replenishment second small event, NH4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_CODs (* hidden = "0" *) "DWF, CODs" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_CODs (* hidden = "0" *) "Dilution in large events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc3_CODs (* hidden = "0" *) "Dilution in medium events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc4_CODs (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc4_CODs_h (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_CODs (* hidden = "0" *) "Dilution and replenishment small events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_CODs (* hidden = "0" *) "Dilution and replenishment first small event, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_CODs (* hidden = "0" *) "Dilution and replenishment second small event, CODs" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_PO4 (* hidden = "0" *) "DWF, PO4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_PO4 (* hidden = "0" *) "Dilution in large events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc3_PO4 (* hidden = "0" *) "Dilution in medium events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc4_PO4 (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc4_PO4_h (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_PO4 (* hidden = "0" *) "Dilution and replenishment small events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_PO4 (* hidden = "0" *) "Dilution and replenishment first small event, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_PO4 (* hidden = "0" *) "Dilution and replenishment second small event, PO4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_COD (* hidden = "0" *) "DWF, COD" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_COD (* hidden = "0" *) "Dilution in large events, COD" : Real := {: group <- "_Process" :};
   OBJ proc3_COD (* hidden = "0" *) "Dilution in medium events, COD" : Real := {: group <- "_Process" :};
   OBJ proc4_COD (* hidden = "0" *) "Replenishment large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD_h (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD_h (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_TSS (* hidden = "0" *) "DWF, TSS" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_TSS (* hidden = "0" *) "Dilution in large events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc3_TSS (* hidden = "0" *) "Dilution in medium events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc4_TSS (* hidden = "0" *) "Replenishment large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS_h (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS_h (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 
	 OBJ t_proc4 (* hidden = "1" *) "Time since proc4 start" : Time;
	 OBJ t_start_proc4 (* hidden = "1" *)"Proc4 start" : Time;
	 OBJ t_event39 (* hidden = "1" *)"Time since event3 or event9 end" : Time;
	 OBJ t_end_event39 (* hidden = "1" *)"Event3 or event9 end" : Time;
	 OBJ t_start_proc5_1 (* hidden = "1" *)"Proc5_1 start" : Time;
	 OBJ t_start_proc5_2 (* hidden = "1" *)"Proc5_2 start" : Time;
	};
  
  initial <-
  { 
    parameters.SewSpecificVolume[H2O_sew] := 0.000001;

	 state.proc2_NH4 = 1;
	 state.proc3_NH4 = 1;
	 state.proc4_NH4 = 1;
	 state.proc5_NH4 = 1;
	 state.proc2_CODs = 1;
	 state.proc3_CODs = 1;
	 state.proc4_CODs = 1;
	 state.proc5_CODs = 1;
	 state.proc2_PO4 = 1;
	 state.proc3_PO4 = 1;
	 state.proc4_PO4 = 1;
	 state.proc5_PO4 = 1;
	 state.proc2_COD = 1;
	 state.proc3_COD = 1;
	 state.proc4_COD = 1;
	 state.proc2_TSS = 1;
	 state.proc3_TSS = 1;
	 state.proc4_TSS = 1;
	 
	 parameters.Q_95_norm[H00] = parameters.Q_95_norm_H00;
	 parameters.Q_95_norm[H01] = parameters.Q_95_norm_H01;
	 parameters.Q_95_norm[H02] = parameters.Q_95_norm_H02;
	 parameters.Q_95_norm[H03] = parameters.Q_95_norm_H03;
	 parameters.Q_95_norm[H04] = parameters.Q_95_norm_H04;
	 parameters.Q_95_norm[H05] = parameters.Q_95_norm_H05;
	 parameters.Q_95_norm[H06] = parameters.Q_95_norm_H06;
	 parameters.Q_95_norm[H07] = parameters.Q_95_norm_H07;
	 parameters.Q_95_norm[H08] = parameters.Q_95_norm_H08;
	 parameters.Q_95_norm[H09] = parameters.Q_95_norm_H09;
	 parameters.Q_95_norm[H10] = parameters.Q_95_norm_H10;
	 parameters.Q_95_norm[H11] = parameters.Q_95_norm_H11;
	 parameters.Q_95_norm[H12] = parameters.Q_95_norm_H12;
	 parameters.Q_95_norm[H13] = parameters.Q_95_norm_H13;
	 parameters.Q_95_norm[H14] = parameters.Q_95_norm_H14;
	 parameters.Q_95_norm[H15] = parameters.Q_95_norm_H15;
	 parameters.Q_95_norm[H16] = parameters.Q_95_norm_H16;
	 parameters.Q_95_norm[H17] = parameters.Q_95_norm_H17;
	 parameters.Q_95_norm[H18] = parameters.Q_95_norm_H18;
	 parameters.Q_95_norm[H19] = parameters.Q_95_norm_H19;
	 parameters.Q_95_norm[H20] = parameters.Q_95_norm_H20;
	 parameters.Q_95_norm[H21] = parameters.Q_95_norm_H21;
	 parameters.Q_95_norm[H22] = parameters.Q_95_norm_H22;
	 parameters.Q_95_norm[H23] = parameters.Q_95_norm_H23;
	 
	 parameters.NH4_norm[H00] = parameters.NH4_norm_H00;
	 parameters.NH4_norm[H01] = parameters.NH4_norm_H01;
	 parameters.NH4_norm[H02] = parameters.NH4_norm_H02;
	 parameters.NH4_norm[H03] = parameters.NH4_norm_H03;
	 parameters.NH4_norm[H04] = parameters.NH4_norm_H04;
	 parameters.NH4_norm[H05] = parameters.NH4_norm_H05;
	 parameters.NH4_norm[H06] = parameters.NH4_norm_H06;
	 parameters.NH4_norm[H07] = parameters.NH4_norm_H07;
	 parameters.NH4_norm[H08] = parameters.NH4_norm_H08;
	 parameters.NH4_norm[H09] = parameters.NH4_norm_H09;
	 parameters.NH4_norm[H10] = parameters.NH4_norm_H10;
	 parameters.NH4_norm[H11] = parameters.NH4_norm_H11;
	 parameters.NH4_norm[H12] = parameters.NH4_norm_H12;
	 parameters.NH4_norm[H13] = parameters.NH4_norm_H13;
	 parameters.NH4_norm[H14] = parameters.NH4_norm_H14;
	 parameters.NH4_norm[H15] = parameters.NH4_norm_H15;
	 parameters.NH4_norm[H16] = parameters.NH4_norm_H16;
	 parameters.NH4_norm[H17] = parameters.NH4_norm_H17;
	 parameters.NH4_norm[H18] = parameters.NH4_norm_H18;
	 parameters.NH4_norm[H19] = parameters.NH4_norm_H19;
	 parameters.NH4_norm[H20] = parameters.NH4_norm_H20;
	 parameters.NH4_norm[H21] = parameters.NH4_norm_H21;
	 parameters.NH4_norm[H22] = parameters.NH4_norm_H22;
	 parameters.NH4_norm[H23] = parameters.NH4_norm_H23;
	 
	 parameters.COD_norm[H00] = parameters.COD_norm_H00;
	 parameters.COD_norm[H01] = parameters.COD_norm_H01;
	 parameters.COD_norm[H02] = parameters.COD_norm_H02;
	 parameters.COD_norm[H03] = parameters.COD_norm_H03;
	 parameters.COD_norm[H04] = parameters.COD_norm_H04;
	 parameters.COD_norm[H05] = parameters.COD_norm_H05;
	 parameters.COD_norm[H06] = parameters.COD_norm_H06;
	 parameters.COD_norm[H07] = parameters.COD_norm_H07;
	 parameters.COD_norm[H08] = parameters.COD_norm_H08;
	 parameters.COD_norm[H09] = parameters.COD_norm_H09;
	 parameters.COD_norm[H10] = parameters.COD_norm_H10;
	 parameters.COD_norm[H11] = parameters.COD_norm_H11;
	 parameters.COD_norm[H12] = parameters.COD_norm_H12;
	 parameters.COD_norm[H13] = parameters.COD_norm_H13;
	 parameters.COD_norm[H14] = parameters.COD_norm_H14;
	 parameters.COD_norm[H15] = parameters.COD_norm_H15;
	 parameters.COD_norm[H16] = parameters.COD_norm_H16;
	 parameters.COD_norm[H17] = parameters.COD_norm_H17;
	 parameters.COD_norm[H18] = parameters.COD_norm_H18;
	 parameters.COD_norm[H19] = parameters.COD_norm_H19;
	 parameters.COD_norm[H20] = parameters.COD_norm_H20;
	 parameters.COD_norm[H21] = parameters.COD_norm_H21;
	 parameters.COD_norm[H22] = parameters.COD_norm_H22;
	 parameters.COD_norm[H23] = parameters.COD_norm_H23;
	 
	 parameters.CODs_norm[H00] = parameters.CODs_norm_H00;
	 parameters.CODs_norm[H01] = parameters.CODs_norm_H01;
	 parameters.CODs_norm[H02] = parameters.CODs_norm_H02;
	 parameters.CODs_norm[H03] = parameters.CODs_norm_H03;
	 parameters.CODs_norm[H04] = parameters.CODs_norm_H04;
	 parameters.CODs_norm[H05] = parameters.CODs_norm_H05;
	 parameters.CODs_norm[H06] = parameters.CODs_norm_H06;
	 parameters.CODs_norm[H07] = parameters.CODs_norm_H07;
	 parameters.CODs_norm[H08] = parameters.CODs_norm_H08;
	 parameters.CODs_norm[H09] = parameters.CODs_norm_H09;
	 parameters.CODs_norm[H10] = parameters.CODs_norm_H10;
	 parameters.CODs_norm[H11] = parameters.CODs_norm_H11;
	 parameters.CODs_norm[H12] = parameters.CODs_norm_H12;
	 parameters.CODs_norm[H13] = parameters.CODs_norm_H13;
	 parameters.CODs_norm[H14] = parameters.CODs_norm_H14;
	 parameters.CODs_norm[H15] = parameters.CODs_norm_H15;
	 parameters.CODs_norm[H16] = parameters.CODs_norm_H16;
	 parameters.CODs_norm[H17] = parameters.CODs_norm_H17;
	 parameters.CODs_norm[H18] = parameters.CODs_norm_H18;
	 parameters.CODs_norm[H19] = parameters.CODs_norm_H19;
	 parameters.CODs_norm[H20] = parameters.CODs_norm_H20;
	 parameters.CODs_norm[H21] = parameters.CODs_norm_H21;
	 parameters.CODs_norm[H22] = parameters.CODs_norm_H22;
	 parameters.CODs_norm[H23] = parameters.CODs_norm_H23;
	 
	 parameters.PO4_norm[H00] = parameters.PO4_norm_H00;
	 parameters.PO4_norm[H01] = parameters.PO4_norm_H01;
	 parameters.PO4_norm[H02] = parameters.PO4_norm_H02;
	 parameters.PO4_norm[H03] = parameters.PO4_norm_H03;
	 parameters.PO4_norm[H04] = parameters.PO4_norm_H04;
	 parameters.PO4_norm[H05] = parameters.PO4_norm_H05;
	 parameters.PO4_norm[H06] = parameters.PO4_norm_H06;
	 parameters.PO4_norm[H07] = parameters.PO4_norm_H07;
	 parameters.PO4_norm[H08] = parameters.PO4_norm_H08;
	 parameters.PO4_norm[H09] = parameters.PO4_norm_H09;
	 parameters.PO4_norm[H10] = parameters.PO4_norm_H10;
	 parameters.PO4_norm[H11] = parameters.PO4_norm_H11;
	 parameters.PO4_norm[H12] = parameters.PO4_norm_H12;
	 parameters.PO4_norm[H13] = parameters.PO4_norm_H13;
	 parameters.PO4_norm[H14] = parameters.PO4_norm_H14;
	 parameters.PO4_norm[H15] = parameters.PO4_norm_H15;
	 parameters.PO4_norm[H16] = parameters.PO4_norm_H16;
	 parameters.PO4_norm[H17] = parameters.PO4_norm_H17;
	 parameters.PO4_norm[H18] = parameters.PO4_norm_H18;
	 parameters.PO4_norm[H19] = parameters.PO4_norm_H19;
	 parameters.PO4_norm[H20] = parameters.PO4_norm_H20;
	 parameters.PO4_norm[H21] = parameters.PO4_norm_H21;
	 parameters.PO4_norm[H22] = parameters.PO4_norm_H22;
	 parameters.PO4_norm[H23] = parameters.PO4_norm_H23;
	 
	 parameters.TSS_norm[H00] = parameters.TSS_norm_H00;
	 parameters.TSS_norm[H01] = parameters.TSS_norm_H01;
	 parameters.TSS_norm[H02] = parameters.TSS_norm_H02;
	 parameters.TSS_norm[H03] = parameters.TSS_norm_H03;
	 parameters.TSS_norm[H04] = parameters.TSS_norm_H04;
	 parameters.TSS_norm[H05] = parameters.TSS_norm_H05;
	 parameters.TSS_norm[H06] = parameters.TSS_norm_H06;
	 parameters.TSS_norm[H07] = parameters.TSS_norm_H07;
	 parameters.TSS_norm[H08] = parameters.TSS_norm_H08;
	 parameters.TSS_norm[H09] = parameters.TSS_norm_H09;
	 parameters.TSS_norm[H10] = parameters.TSS_norm_H10;
	 parameters.TSS_norm[H11] = parameters.TSS_norm_H11;
	 parameters.TSS_norm[H12] = parameters.TSS_norm_H12;
	 parameters.TSS_norm[H13] = parameters.TSS_norm_H13;
	 parameters.TSS_norm[H14] = parameters.TSS_norm_H14;
	 parameters.TSS_norm[H15] = parameters.TSS_norm_H15;
	 parameters.TSS_norm[H16] = parameters.TSS_norm_H16;
	 parameters.TSS_norm[H17] = parameters.TSS_norm_H17;
	 parameters.TSS_norm[H18] = parameters.TSS_norm_H18;
	 parameters.TSS_norm[H19] = parameters.TSS_norm_H19;
	 parameters.TSS_norm[H20] = parameters.TSS_norm_H20;
	 parameters.TSS_norm[H21] = parameters.TSS_norm_H21;
	 parameters.TSS_norm[H22] = parameters.TSS_norm_H22;
	 parameters.TSS_norm[H23] = parameters.TSS_norm_H23;
  };

  equations <-
  {
    
   state.Q_in = interface.Q_Meas;
	 
   DERIV(state.Q_integral,[independent.t]) = state.Q_in;
	 state.Q_DWF_UB = parameters.Q_95_av * parameters.Q_95_norm[state.Timestep];
	 state.Qsw = IF (state.Q_in < state.Q_DWF_UB)
	 						THEN 0
	 						ELSE state.Q_in - state.Q_DWF_UB;
	 state.Help_Time = independent.t - floor(independent.t);
   state.Daytime = state.Help_Time*24; 
   state.Timestep = floor(state.Daytime) + 1;
	 DERIV(state.Q_mean,[independent.t]) = (state.Q_in - state.Q_mean) / parameters.T_Average;
	 
	  
	 state.event = IF (state.Q_in < state.Q_DWF_UB)
	 							THEN 0
	 							ELSE IF (interface.Level > parameters.Level_event)
	 							 		THEN 3
	 									 ELSE IF ((state.Qsw > parameters.Qsw_event9) && (state.Q_mean > previous(state.Q_mean)))
	 												THEN 9
	 									 		 ELSE 0;
	 
	 state.event8_h = IF ((state.Qsw > parameters.Qsw_event8) && (state.event < 3) && (state.proc4_NH4 > 0.6))
	 								 THEN 1
	 								 ELSE 0;
	 state.event8 = IF (((state.event8_h == 1) || ((independent.t - state.t_end_event8_h) < 0.25)) && (state.event < 3) && (state.t_event39 > 0.25))
	 							 THEN 1
	 							 ELSE 0;
	 state.t_start_event8 = IF ((previous(state.event8) == 0) && (state.event8 == 1))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_start_event8);
	 state.t_end_event8_h = IF ((previous(state.event8_h) == 1) && (state.event8_h == 0))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_end_event8_h);
	 
	  
	 state.proc1_NH4 = parameters.NH4_av * parameters.NH4_norm[state.Timestep];
   
   state.proc2_NH4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_NH4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_NH4) == 1) && (state.proc4_NH4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_NH4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_NH4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_NH4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_NH4)
	 																   THEN previous(state.proc4_NH4) + parameters.proc4_slope1_NH4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_NH4) + parameters.proc4_slope2_NH4 * (independent.t - previous(independent.t));
	 
	 state.proc4_NH4 = IF (state.proc4_NH4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_NH4_h;
	 
	 state.proc5_NH4 = 1 + state.proc5_1_NH4 + state.proc5_2_NH4;
	 state.proc5_1_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_NH4 / 2))
	 												 THEN previous(state.proc5_1_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_NH4)
	 															THEN previous(state.proc5_1_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_NH4 / 2))
	 												 		 THEN previous(state.proc5_2_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_NH4)
	 																	 THEN previous(state.proc5_2_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_NH4) && (previous(state.proc5_2_NH4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.NH4 = state.proc1_NH4 * state.proc2_NH4 * state.proc3_NH4 * state.proc4_NH4 * state.proc5_NH4;
	 
	  
	 state.proc1_CODs = parameters.CODs_av * parameters.CODs_norm[state.Timestep];
   
   state.proc2_CODs = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_CODs = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_CODs) == 1) && (state.proc4_CODs < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_CODs_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_CODs)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_CODs)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_CODs)
	 																   THEN previous(state.proc4_CODs) + parameters.proc4_slope1_CODs * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_CODs) + parameters.proc4_slope2_CODs * (independent.t - previous(independent.t));
	 
	 state.proc4_CODs = IF (state.proc4_CODs_h > 1)
	 									THEN 1
	 									ELSE state.proc4_CODs_h;
	 
	 state.proc5_CODs = 1 + state.proc5_1_CODs + state.proc5_2_CODs;
	 state.proc5_1_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_CODs / 2))
	 												 THEN previous(state.proc5_1_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_CODs)
	 															THEN previous(state.proc5_1_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_CODs / 2))
	 												 		 THEN previous(state.proc5_2_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_CODs)
	 																	 THEN previous(state.proc5_2_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_CODs) && (previous(state.proc5_2_CODs) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.CODs = state.proc1_CODs * state.proc2_CODs * state.proc3_CODs * state.proc4_CODs * state.proc5_CODs;
	 
	  
	 state.proc1_PO4 = parameters.PO4_av * parameters.PO4_norm[state.Timestep];
   
   state.proc2_PO4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_PO4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_PO4) == 1) && (state.proc4_PO4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_PO4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_PO4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_PO4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_PO4)
	 																   THEN previous(state.proc4_PO4) + parameters.proc4_slope1_PO4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_PO4) + parameters.proc4_slope2_PO4 * (independent.t - previous(independent.t));
	 
	 state.proc4_PO4 = IF (state.proc4_PO4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_PO4_h;
	 
	 state.proc5_PO4 = 1 + state.proc5_1_PO4 + state.proc5_2_PO4;
	 state.proc5_1_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_PO4 / 2))
	 												 THEN previous(state.proc5_1_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_PO4)
	 															THEN previous(state.proc5_1_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_PO4 / 2))
	 												 		 THEN previous(state.proc5_2_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_PO4)
	 																	 THEN previous(state.proc5_2_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_PO4) && (previous(state.proc5_2_PO4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.PO4 = state.proc1_PO4 * state.proc2_PO4 * state.proc3_PO4 * state.proc4_PO4 * state.proc5_PO4;
	 
	  
	 state.proc1_COD = parameters.COD_av * parameters.COD_norm[state.Timestep];
   
   state.proc2_COD = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_COD = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_COD = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_COD)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_COD)
	 											 		 ELSE IF (previous(state.proc4_COD) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_COD)
	 																 		 THEN previous(state.proc4_COD) + parameters.proc4_slope1_COD * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_COD) + parameters.proc4_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_COD)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_COD)
	 														  THEN parameters.peak_COD_low
	 														  ELSE parameters.peak_COD_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_COD_h) - parameters.proc6_slope1_COD * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_COD_h) - parameters.proc6_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD = IF (state.proc6_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc6_COD_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_COD_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_COD_h) + parameters.proc7_slope1_COD * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_COD_h) - parameters.proc7_slope2_COD * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_COD = IF (state.proc7_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc7_COD_h;
	 
	 state.COD = state.proc1_COD * state.proc2_COD * state.proc3_COD * state.proc4_COD + state.proc6_COD + state.proc7_COD;
	 
	  
	 state.proc1_TSS = parameters.TSS_av * parameters.TSS_norm[state.Timestep];
   
   state.proc2_TSS = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_TSS = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_TSS = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_TSS)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_TSS)
	 											 		 ELSE IF (previous(state.proc4_TSS) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_TSS)
	 																 		 THEN previous(state.proc4_TSS) + parameters.proc4_slope1_TSS * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_TSS) + parameters.proc4_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_TSS)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_TSS)
	 														  THEN parameters.peak_TSS_low
	 														  ELSE parameters.peak_TSS_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_TSS_h) - parameters.proc6_slope1_TSS * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_TSS_h) - parameters.proc6_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS = IF (state.proc6_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc6_TSS_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_TSS_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_TSS_h) + parameters.proc7_slope1_TSS * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_TSS_h) - parameters.proc7_slope2_TSS * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_TSS = IF (state.proc7_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc7_TSS_h;
	 
	 state.TSS = state.proc1_TSS * state.proc2_TSS * state.proc3_TSS * state.proc4_TSS + state.proc6_TSS + state.proc7_TSS;

   interface.Outflow[H2O_sew] = -interface.Q_Meas/parameters.SewSpecificVolume[H2O_sew];
   interface.Outflow[COD_part] = -(state.COD - state.CODs) * state.Q_in;
   interface.Outflow[COD_sol] = -state.CODs * state.Q_in;
   interface.Outflow[X_TSS_sew] = -state.TSS * state.Q_in;
   interface.Outflow[NH4_sew] = -state.NH4 * state.Q_in;
   interface.Outflow[PO4_sew] = -state.PO4 * state.Q_in;
   
 };

:};


# 45 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.influent.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\influent/wwtp.base.influent.level.modif.msl" 1
 














 CLASS Sew_WWTPin_2_level_modif
 (* icon = "sewer" *)
 "Generator of WWTP infuent pollutograph, second version, adaptation to use level instead of filling degree"
	 
	 
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Q_Meas (* terminal = "in_1"; manip = "1"; is_favorite = "1" *) "Measured" : 
      FlowRate  := {: causality <- "CIN" ; value <- 100000; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      SewTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	  OBJ Level (* terminal = "in_1"; manip = "1"; is_favorite = "1" *) "measured influent level" : 
      Length  := {: causality <- "CIN" ; value <- 10; group <- "Influent" :};
	  
	 OBJ Q_95_norm (* terminal = "in_1"; manip = "1"; is_favorite = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: causality <- "CIN" ; value <- 1; group <- "DWF" :}; 
   OBJ COD_norm (* terminal = "in_1"; manip = "1"; is_favorite = "0" *) "Normalized COD hourly pattern, average" : Real := {: causality <- "CIN" ; value <- 1; group <- "DWF" :};  
   OBJ CODs_norm (* terminal = "in_1"; manip = "1"; is_favorite = "0" *) "Normalized CODs hourly pattern, average" : Real := {: causality <- "CIN" ; value <- 1; group <- "DWF" :};  
	 OBJ TSS_norm (* terminal = "in_1"; manip = "1"; is_favorite = "0" *) "Normalized TSS hourly pattern, average" : Real := {: causality <- "CIN" ; value <- 1; group <- "DWF" :}; 
	 OBJ NH4_norm (* terminal = "in_1"; manip = "1"; is_favorite = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: causality <- "CIN" ; value <- 1; group <- "DWF" :};  
	 OBJ PO4_norm (* terminal = "in_1"; manip = "1"; is_favorite = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: causality <- "CIN" ; value <- 1; group <- "DWF" :};
	 
  }; 
  
  parameters <-
  {
    OBJ SewSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SewSpecificVolumeVector;

   OBJ Q_event "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ Qsw_event8 "Flow sw value for start of event8" : FlowRate := {: value <- 12000 ; group <- "_Events" :};
	 OBJ Qsw_event9 "Flow sw value for start of event9" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ Level_event "Level of the influent pit for start of event3" : Length := {: value <- 11.3 ; group <- "_Events" :};
	 OBJ T_Average "Averaging time for Q_mean" : Time := {: value <- 0.02083; group <- "_Events" :};
	 
   OBJ Q_95_av "Daily average Q, 95%ile" : FlowRate := {: value <- 70000 ; group <- "_Averages" :};
   OBJ COD_av "COD daily average concentration" : Concentration := {: value <- 642 ; group <- "_Averages" :};
   OBJ CODs_av "CODs daily average concentration" : Concentration := {: value <- 197.3 ; group <- "_Averages" :};
   OBJ TSS_av "TSS daily average concentration" : Concentration := {: value <- 289.6 ; group <- "_Averages" :};
   OBJ NH4_av "NH4 daily average concentration" : Concentration := {: value <- 35 ; group <- "_Averages" :};
   OBJ PO4_av "PO4 daily average concentration" : Concentration := {: value <- 7 ; group <- "_Averages" :};
   
   OBJ alpha_COD "Alpha for COD, proc2" : Fraction := {: value <- 0.8 ; group <- "_proc2" :};
   OBJ alpha_CODs "Alpha for CODs, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_TSS "Alpha for TSS, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_NH4 "Alpha for NH4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_PO4 "Alpha for PO4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   
   OBJ beta_COD "Beta for COD, proc3" : Fraction := {: value <- 0.8 ; group <- "_proc3" :};
   OBJ beta_CODs "Beta for CODs, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_TSS "Beta for TSS, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_NH4 "Beta for NH4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_PO4 "Beta for PO4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
	 
	 OBJ proc4_slope1_COD "Slope1 for COD, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_CODs "Slope1 for CODs, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_TSS "Slope1 for TSS, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_NH4 "Slope1 for NH4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_PO4 "Slope1 for PO4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
	 
	 OBJ proc4_slope2_COD "Slope2 for COD, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_CODs "Slope2 for CODs, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_TSS "Slope2 for TSS, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_NH4 "Slope2 for NH4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_PO4 "Slope2 for PO4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
	 
   OBJ window_proc4_COD "Window length for COD, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_CODs "Window length for CODs, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_TSS "Window length for TSS, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_NH4 "Window length for NH4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_PO4 "Window length for PO4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
	 
	 OBJ proc5_slope_CODs "Slope for CODs, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_NH4 "Slope for NH4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_PO4 "Slope for PO4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
	 
   OBJ window_proc5_CODs "Window length for CODs, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_NH4 "Window length for NH4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_PO4 "Window length for PO4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
	 
	 OBJ Q_proc6 "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_proc6" :};
	 OBJ peak_COD_high "Proc6 high COD peak concentration" : Concentration := {: value <- 600 ; group <- "_proc6" :};
	 OBJ peak_COD_low "Proc6 low COD peak concentration" : Concentration := {: value <- 300 ; group <- "_proc6" :};
	 OBJ proc6_slope1_COD "Slope1 for COD, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_COD "Slope2 for COD, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ peak_TSS_high "Proc6 high TSS peak concentration" : Concentration := {: value <- 200 ; group <- "_proc6" :};
	 OBJ peak_TSS_low "Proc6 low TSS peak concentration" : Concentration := {: value <- 100 ; group <- "_proc6" :};
	 OBJ proc6_slope1_TSS "Slope1 for TSS, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_TSS "Slope2 for TSS, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ proc6_t1_COD "Time1 for COD high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_COD "Time2 for COD low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 OBJ proc6_t1_TSS "Time1 for TSS high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_TSS "Time2 for TSS low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 
	 OBJ proc7_slope1_COD "Slope1 for COD, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_COD "Slope2 for COD, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
	 OBJ proc7_slope1_TSS "Slope1 for TSS, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_TSS "Slope2 for TSS, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
 





























































































































































  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate := {: group <- "_Results" :};
   OBJ Q_integral "Q in integral" : Volume;
	 OBJ Qsw "Qsw" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_DWF_UB "Q DWF UB" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_mean "Averaged influent flow rate" : FlowRate := {: group <- "_Results" :};
   
   OBJ Daytime(* hidden = "0" *) "Calculates hour of the day" : Real;
   OBJ Help_Time (* hidden = "0" *)"Time of the day expressed in days" : Real;
 
	 
	 OBJ event "Type of event" : Integer;
	 OBJ event8 "1 yes, 0 no" : Integer;
	 OBJ event8_h "1 yes, 0 no" : Integer;
	 OBJ t_start_event8 (* hidden = "0" *) "Time since event8 start" : Time;
	 OBJ t_end_event8_h (* hidden = "0" *) "Time since event8_h end" : Time;
   
   OBJ COD "COD" : Concentration := {: group <- "_Results" :};
   OBJ CODs "CODs" : Concentration := {: group <- "_Results" :};
   OBJ TSS "TSS" : Concentration := {: group <- "_Results" :};
   OBJ NH4 "NH4" : Concentration := {: group <- "_Results" :};
   OBJ PO4 "PO4" : Concentration := {: group <- "_Results" :};
   
   OBJ proc1_NH4 (* hidden = "0" *) "DWF, NH4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_NH4 (* hidden = "0" *) "Dilution in large events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc3_NH4 (* hidden = "0" *) "Dilution in medium events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc4_NH4 (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc4_NH4_h (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_NH4 (* hidden = "0" *) "Dilution and replenishment small events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_NH4 (* hidden = "0" *) "Dilution and replenishment first small event, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_NH4 (* hidden = "0" *) "Dilution and replenishment second small event, NH4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_CODs (* hidden = "0" *) "DWF, CODs" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_CODs (* hidden = "0" *) "Dilution in large events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc3_CODs (* hidden = "0" *) "Dilution in medium events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc4_CODs (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc4_CODs_h (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_CODs (* hidden = "0" *) "Dilution and replenishment small events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_CODs (* hidden = "0" *) "Dilution and replenishment first small event, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_CODs (* hidden = "0" *) "Dilution and replenishment second small event, CODs" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_PO4 (* hidden = "0" *) "DWF, PO4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_PO4 (* hidden = "0" *) "Dilution in large events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc3_PO4 (* hidden = "0" *) "Dilution in medium events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc4_PO4 (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc4_PO4_h (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_PO4 (* hidden = "0" *) "Dilution and replenishment small events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_PO4 (* hidden = "0" *) "Dilution and replenishment first small event, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_PO4 (* hidden = "0" *) "Dilution and replenishment second small event, PO4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_COD (* hidden = "0" *) "DWF, COD" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_COD (* hidden = "0" *) "Dilution in large events, COD" : Real := {: group <- "_Process" :};
   OBJ proc3_COD (* hidden = "0" *) "Dilution in medium events, COD" : Real := {: group <- "_Process" :};
   OBJ proc4_COD (* hidden = "0" *) "Replenishment large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD_h (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD_h (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_TSS (* hidden = "0" *) "DWF, TSS" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_TSS (* hidden = "0" *) "Dilution in large events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc3_TSS (* hidden = "0" *) "Dilution in medium events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc4_TSS (* hidden = "0" *) "Replenishment large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS_h (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS_h (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 
	 OBJ t_proc4 (* hidden = "1" *) "Time since proc4 start" : Time;
	 OBJ t_start_proc4 (* hidden = "1" *)"Proc4 start" : Time;
	 OBJ t_event39 (* hidden = "1" *)"Time since event3 or event9 end" : Time;
	 OBJ t_end_event39 (* hidden = "1" *)"Event3 or event9 end" : Time;
	 OBJ t_start_proc5_1 (* hidden = "1" *)"Proc5_1 start" : Time;
	 OBJ t_start_proc5_2 (* hidden = "1" *)"Proc5_2 start" : Time;
	};
  
  initial <-
  { 
    parameters.SewSpecificVolume[H2O_sew] := 0.000001;

	 state.proc2_NH4 = 1;
	 state.proc3_NH4 = 1;
	 state.proc4_NH4 = 1;
	 state.proc5_NH4 = 1;
	 state.proc2_CODs = 1;
	 state.proc3_CODs = 1;
	 state.proc4_CODs = 1;
	 state.proc5_CODs = 1;
	 state.proc2_PO4 = 1;
	 state.proc3_PO4 = 1;
	 state.proc4_PO4 = 1;
	 state.proc5_PO4 = 1;
	 state.proc2_COD = 1;
	 state.proc3_COD = 1;
	 state.proc4_COD = 1;
	 state.proc2_TSS = 1;
	 state.proc3_TSS = 1;
	 state.proc4_TSS = 1;
 






















































































































































  };

  equations <-
  {
    
   state.Q_in = interface.Q_Meas;
	 
   DERIV(state.Q_integral,[independent.t]) = state.Q_in;
	 state.Q_DWF_UB = parameters.Q_95_av * interface.Q_95_norm;
 
	 state.Qsw = IF (state.Q_in < state.Q_DWF_UB)
	 						THEN 0
	 						ELSE state.Q_in - state.Q_DWF_UB;
	 state.Help_Time = independent.t - floor(independent.t);
   state.Daytime = state.Help_Time*24; 
 
	 DERIV(state.Q_mean,[independent.t]) = (state.Q_in - state.Q_mean) / parameters.T_Average;
	 
	  
	 state.event = IF (state.Q_in < state.Q_DWF_UB)
	 							THEN 0
	 							ELSE IF (interface.Level > parameters.Level_event)
	 							 		THEN 3
	 									 ELSE IF ((state.Qsw > parameters.Qsw_event9) && (state.Q_mean > previous(state.Q_mean)))
	 												THEN 9
	 									 		 ELSE 0;
	 
	 state.event8_h = IF ((state.Qsw > parameters.Qsw_event8) && (state.event < 3) && (state.proc4_NH4 > 0.6))
	 								 THEN 1
	 								 ELSE 0;
	 state.event8 = IF (((state.event8_h == 1) || ((independent.t - state.t_end_event8_h) < 0.25)) && (state.event < 3) && (state.t_event39 > 0.25))
	 							 THEN 1
	 							 ELSE 0;
	 state.t_start_event8 = IF ((previous(state.event8) == 0) && (state.event8 == 1))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_start_event8);
	 state.t_end_event8_h = IF ((previous(state.event8_h) == 1) && (state.event8_h == 0))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_end_event8_h);
	 
	  
	 state.proc1_NH4 = parameters.NH4_av * interface.NH4_norm;
 
   
   state.proc2_NH4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_NH4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_NH4) == 1) && (state.proc4_NH4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_NH4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_NH4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_NH4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_NH4)
	 																   THEN previous(state.proc4_NH4) + parameters.proc4_slope1_NH4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_NH4) + parameters.proc4_slope2_NH4 * (independent.t - previous(independent.t));
	 
	 state.proc4_NH4 = IF (state.proc4_NH4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_NH4_h;
	 
	 state.proc5_NH4 = 1 + state.proc5_1_NH4 + state.proc5_2_NH4;
	 state.proc5_1_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_NH4 / 2))
	 												 THEN previous(state.proc5_1_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_NH4)
	 															THEN previous(state.proc5_1_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_NH4 / 2))
	 												 		 THEN previous(state.proc5_2_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_NH4)
	 																	 THEN previous(state.proc5_2_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_NH4) && (previous(state.proc5_2_NH4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.NH4 = state.proc1_NH4 * state.proc2_NH4 * state.proc3_NH4 * state.proc4_NH4 * state.proc5_NH4;
	 
	  
	 state.proc1_CODs = parameters.CODs_av * interface.CODs_norm;
 
   
   state.proc2_CODs = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_CODs = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_CODs) == 1) && (state.proc4_CODs < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_CODs_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_CODs)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_CODs)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_CODs)
	 																   THEN previous(state.proc4_CODs) + parameters.proc4_slope1_CODs * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_CODs) + parameters.proc4_slope2_CODs * (independent.t - previous(independent.t));
	 
	 state.proc4_CODs = IF (state.proc4_CODs_h > 1)
	 									THEN 1
	 									ELSE state.proc4_CODs_h;
	 
	 state.proc5_CODs = 1 + state.proc5_1_CODs + state.proc5_2_CODs;
	 state.proc5_1_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_CODs / 2))
	 												 THEN previous(state.proc5_1_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_CODs)
	 															THEN previous(state.proc5_1_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_CODs / 2))
	 												 		 THEN previous(state.proc5_2_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_CODs)
	 																	 THEN previous(state.proc5_2_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_CODs) && (previous(state.proc5_2_CODs) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.CODs = state.proc1_CODs * state.proc2_CODs * state.proc3_CODs * state.proc4_CODs * state.proc5_CODs;
	 
	  
	 state.proc1_PO4 = parameters.PO4_av * interface.PO4_norm;
 
   
   state.proc2_PO4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_PO4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_PO4) == 1) && (state.proc4_PO4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_PO4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_PO4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_PO4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_PO4)
	 																   THEN previous(state.proc4_PO4) + parameters.proc4_slope1_PO4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_PO4) + parameters.proc4_slope2_PO4 * (independent.t - previous(independent.t));
	 
	 state.proc4_PO4 = IF (state.proc4_PO4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_PO4_h;
	 
	 state.proc5_PO4 = 1 + state.proc5_1_PO4 + state.proc5_2_PO4;
	 state.proc5_1_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_PO4 / 2))
	 												 THEN previous(state.proc5_1_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_PO4)
	 															THEN previous(state.proc5_1_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_PO4 / 2))
	 												 		 THEN previous(state.proc5_2_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_PO4)
	 																	 THEN previous(state.proc5_2_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_PO4) && (previous(state.proc5_2_PO4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.PO4 = state.proc1_PO4 * state.proc2_PO4 * state.proc3_PO4 * state.proc4_PO4 * state.proc5_PO4;
	 
	  
	 state.proc1_COD = parameters.COD_av * interface.COD_norm;
 
   
   state.proc2_COD = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_COD = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_COD = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_COD)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_COD)
	 											 		 ELSE IF (previous(state.proc4_COD) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_COD)
	 																 		 THEN previous(state.proc4_COD) + parameters.proc4_slope1_COD * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_COD) + parameters.proc4_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_COD)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_COD)
	 														  THEN parameters.peak_COD_low
	 														  ELSE parameters.peak_COD_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_COD_h) - parameters.proc6_slope1_COD * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_COD_h) - parameters.proc6_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD = IF (state.proc6_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc6_COD_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_COD_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_COD_h) + parameters.proc7_slope1_COD * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_COD_h) - parameters.proc7_slope2_COD * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_COD = IF (state.proc7_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc7_COD_h;
	 
	 state.COD = state.proc1_COD * state.proc2_COD * state.proc3_COD * state.proc4_COD + state.proc6_COD + state.proc7_COD;
	 
	  
	 state.proc1_TSS = parameters.TSS_av * interface.TSS_norm;
 
   
   state.proc2_TSS = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_TSS = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_TSS = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_TSS)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_TSS)
	 											 		 ELSE IF (previous(state.proc4_TSS) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_TSS)
	 																 		 THEN previous(state.proc4_TSS) + parameters.proc4_slope1_TSS * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_TSS) + parameters.proc4_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_TSS)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_TSS)
	 														  THEN parameters.peak_TSS_low
	 														  ELSE parameters.peak_TSS_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_TSS_h) - parameters.proc6_slope1_TSS * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_TSS_h) - parameters.proc6_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS = IF (state.proc6_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc6_TSS_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_TSS_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_TSS_h) + parameters.proc7_slope1_TSS * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_TSS_h) - parameters.proc7_slope2_TSS * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_TSS = IF (state.proc7_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc7_TSS_h;
	 
	 state.TSS = state.proc1_TSS * state.proc2_TSS * state.proc3_TSS * state.proc4_TSS + state.proc6_TSS + state.proc7_TSS;

   interface.Outflow[H2O_sew] = -interface.Q_Meas/parameters.SewSpecificVolume[H2O_sew];
   interface.Outflow[COD_part] = -(state.COD - state.CODs) * state.Q_in;
   interface.Outflow[COD_sol] = -state.CODs * state.Q_in;
   interface.Outflow[X_TSS_sew] = -state.TSS * state.Q_in;
   interface.Outflow[NH4_sew] = -state.NH4 * state.Q_in;
   interface.Outflow[PO4_sew] = -state.PO4 * state.Q_in;
   
 };

:};


# 46 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.base.influent.msl" 2

	


# 67 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\coupled_models.msl" 1
 



















# 70 "C:\\Users\\WEST\\Desktop\\github\\WESTforEINDHOVEN\\WEST\\data\\blocks\\WESTforKALLISTO - InfluentModel\\Models\\wwtp.msl" 2


