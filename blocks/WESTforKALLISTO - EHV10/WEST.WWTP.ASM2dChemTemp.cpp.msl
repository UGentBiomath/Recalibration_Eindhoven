# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl"
 














 



# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\generic.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\generic.base.msl" 1
 


















 
 
 
 
 
 
 
 
 
 
 

 TYPE Generic "builtin: type variable";
  
  
  

 TYPE Integer "builtin: positive and negative Natural Numbers";

 TYPE Real "builtin: Real numbers";

 TYPE Char "builtin: ASCII character";

 TYPE String 
  "builtin: Char* (implemented as atomic type for efficiency reasons)";

 TYPE Bottom "builtin: bottom type" = ENUM {null};
  
  
  
  

 TYPE Boolean "builtin: Logic type" = ENUM {True, False};

 
 
 

 TYPE TypeDeclarationType
 "builtin: type of TYPE declaration statement";
 TYPE ClassDeclarationType
 "builtin: type of CLASS declaration statement";

 TYPE ObjectDeclarationType
 "builtin: type of OBJ declaration statement";

 TYPE DeclarationType
 "type of a declaration (TYPE, CLASS, or OBJ) statement"
 = UNION {TypeDeclarationType, ClassDeclarationType, ObjectDeclarationType};

 TYPE ExpressionType
 "builtin: type of expressions";

 TYPE EquationType
 "builtin: type of equations";

 TYPE GenericIntervalType
 "Generic Interval"
 
 
 
 = RECORD 
   {
    lowerBound: Generic;   
    upperBound: Generic;   
    lowerIncluded: Boolean;
    upperIncluded: Boolean;
   };

 TYPE RealIntervalType "Interval of real numbers"
 SUBSUMES GenericIntervalType =
 RECORD 
 {
  lowerBound: Real;  
  upperBound: Real;  
  lowerIncluded: Boolean;
  upperIncluded: Boolean;
 };

 
 
 

 TYPE UnitType 
 "The type of physical units. For the time being, a string"
 = String;

 TYPE QuantityType
 "The different physical quantities. For the time being, string"
 = String;

 TYPE CausalityType
 " Causality of entities"
 
 
 
 
 = ENUM {CIN, COUT, CINOUT};

 TYPE PhysicalNatureType
 "The nature of physical variables FIELD is used (in the physicalDAE context) to denote parameters and constants"
 = ENUM {ACROSS, THROUGH, FIELD};

 TYPE PhysicalQuantityType 
 "The type of any physical quantity" 
 =
 RECORD
 {
  quantity   : QuantityType;
  unit       : UnitType;
  interval   : RealIntervalType;
  value      : Real;
  causality  : CausalityType;
  nature     : PhysicalNatureType;
 };

  
  
  

 TYPE InterfaceDeclarationType
 "declarations within an interface" = DeclarationType;

 TYPE ParameterDeclarationType
 "declarations within parameter section" = DeclarationType;

 TYPE ModelDeclarationType
 "declarations within sub_models section" = DeclarationType;

 TYPE CouplingStatementType
 "parameter coupling and connect() statements" = EquationType;

 TYPE GenericModelType 
 "The signature of the generic part of any (whatever the formalism) model"
 = 
 RECORD
 { 
  comments   : String;
  interface  : SET_OF (InterfaceDeclarationType); 
    
  parameters : SET_OF (ParameterDeclarationType); 
    
 };

 TYPE DAEModelType 
 "The signature of a Differential Algebraic Equation (DAE) model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };
 
 TYPE PhysicalDAEModelType 
 "The signature of a physicalDAEModelType model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };

 TYPE CoupledModelType "The signature of a coupled (network) model"
 EXTENDS GenericModelType WITH
 RECORD
 {
  sub_models : SET_OF (ModelDeclarationType);
  coupling   : SET_OF (CouplingStatementType);
 };
  

# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\generic.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\generic.quantity.si.msl" 1
 


















 
 
 
 
 

 

   CLASS Angle
   "A class for angle"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Angle";
    unit      <- "rad";
    displayunit <- "deg";
   :};

   CLASS SolidAngle
   "A class for SolidAngle"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SolidAngle";
    unit      <- "sr";
   :};

   TYPE StringType
   "The class for all kind of strings + some extra's"
   =
   RECORD
   {
    quantity   : QuantityType;
    value      : String;
    unit       : UnitType;
   };

   CLASS Date
   "A class for date"
   SPECIALISES StringType :=
   {:
    quantity  <- "Date";
   :};

   CLASS Time
   "A class for time"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Time";
    unit      <- "d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

   CLASS Length
   "A class for Length"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Length";
    unit      <- "m";
   :};

   CLASS Area
   "A class for Area"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Area";
    unit      <- "m2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS Volume
   "Volume"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Volume";
    unit      <- "m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS AngularVelocity
   "A class for AngularVelocity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AngularVelocity";
    unit      <- "rad/d";
   :};

   CLASS Velocity
   "A class for Velocity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Velocity";
    unit      <- "m/d";
   :};

 
 
 

   CLASS Rate
   "A class for rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Rate";
    unit      <- "dUnit/dt";
   :};

   CLASS FlowRate
   "Flow rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity <- "FlowRate";
    unit     <- "m3/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
 
 

   CLASS Ratio
   "A class for ratio"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Ratio";
    unit      <- "dUnit/dUnit";
   :};

   CLASS AngularAcceleration
   "A class for AngularAcceleration"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AngularAcceleration";
    unit      <- "rad/d2";
   :};

   CLASS Acceleration
   "A class for Acceleration"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Acceleration";
    unit      <- "m/d2";
   :};

 

   CLASS Frequency
   "The type of frequency"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Frequency";
    unit      <- "Hz";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 

   CLASS Mass
   "A class for Mass"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SludgeMass
   "Sludge production"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "SludgeMass";
   unit     <- "kg SS";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};

   CLASS SludgePerDay
   "Sludge production"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "SludgePerDay";
   unit     <- "kg SS/d";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};
 
   CLASS Density
   "A class for Density"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Density";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SurfaceDensity
   "A class for Areal Density"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Areal Density";
    unit      <- "g/m2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};
   
   CLASS SpecificVolume
   "Specific volume ((density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificVolume";
    unit      <- "m3/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS SpecificArea
   "Specific area ((surface density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificArea";
    unit      <- "m2/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

      CLASS SpecificLength
   "Specific length ((length density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificLength";
    unit      <- "m/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   
   CLASS LinearDensity
   "A class for LinearDensity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LinearDensity";
    unit      <- "g/m";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS MomentOfInertia
   "A class for MomentOfInertia"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MomentOfInertia";
    unit      <- "g*m2";
   :};

   CLASS Momentum
   "A class for Momentum"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g*m/d";
   :};

   CLASS Force
   "A class for Force"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Force";
    unit      <- "N";
   :};

   CLASS AngularMomentum
   "A class for AngularMomentum"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g*m2/d";
   :};

   CLASS MomentOfForce
   "A class for MomentOfForce"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MomentOfForce";
    unit      <- "N*m";
   :};

   CLASS PressureDifference
   "A class for Pressure"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "Pa";
    interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF; :};
   :};

   
   CLASS Pressure
   "A class for Pressure"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "Pa";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS NormalStress
   "A class for NormalStress"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "NormalStress";
    unit      <- "Pa";
   :};

   CLASS Diffusivity
   "A class for Diffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Diffusivity";
    unit      <- "m2/d";
   :};

   CLASS DynamicViscosity
   "A class for DynamicViscosity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "DynamicViscosity";
    unit      <- "Pa*d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS KinematicViscosity
   "A class for KinematicViscosity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "KinematicViscosity";
    unit      <- "m2/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SurfaceTension
   "A class for SurfaceTension"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SurfaceTension";
    unit      <- "N/m";
   :};
   
   CLASS Energy
   "A class for Energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Energy";
    unit      <- "J";
   :};

   CLASS Power
   "A class for Power"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Power";
    unit      <- "W";
   :};

   CLASS EnergyIndex
   "Aeration and Pumping energy"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "EnergyIndex";
   unit     <- "kWh/d";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};

   CLASS FiltrationResistance SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "filtration resistance";
    unit      <- "1/m";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

   CLASS SpecificAreaVolume
   "Mass per time unit"
   SPECIALISES PhysicalQuantityType :=
   {:
   quantity  <- "specific area per volume";
   unit      <- "1/m";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
   CLASS KelvinTemperature
   "A class for KelvinTemperature"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity    <- "KelvinTemperature";
    unit        <- "K";
    interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS CelsiusTemperature
   "A class for CelsiusTemperature"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CelsiusTemperature";
    unit      <- "degC";
    interval  <- {: lowerBound <- -273.15; upperBound <- PLUS_INF; :};
   :};

   CLASS LinearExpansionCoefficient
   "A class for LinearExpansionCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LinearExpansionCoefficient";
    unit      <- "1/K";
   :};

   CLASS CubicExpansionCoefficient
   "A class for CubicExpansionCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CubicExpansionCoefficient";
    unit      <- "1/K";
   :};

   CLASS RelativePressureCoefficient
   "A class for RelativePressureCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RelativePressureCoefficient";
    unit      <- "1/K";
   :};

   CLASS PressureCoefficient
   "A class for PressureCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PressureCoefficient";
    unit      <- "Pa/K";
   :};

   CLASS IsothermalCompressibility
   "A class for IsothermalCompressibility"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsothermalCompressibility";
    unit      <- "1/Pa";
   :};

   CLASS IsentropicCompressibility
   "A class for IsentropicCompressibility"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsentropicCompressibility";
    unit      <- "1/Pa";
   :};

   CLASS Heat = Energy;

   CLASS HeatFlowRate
   "A class for HeatFlowRate"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "HeatFlowRate";
    unit      <- "W";
   :};

   CLASS DensityOfHeatFlowRate
   "A class for DensityOfHeatFlowRate"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "DensityOfHeatFlowRate";
    unit      <- "W/m2";
   :};

   CLASS ThermalConductivity
   "A class for ThermalConductivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalConductivity";
    unit      <- "W/(m*K)";
   :};

   CLASS CoefficientOfHeatTransfer
   "A class for CoefficientOfHeatTransfer"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CoefficientOfHeatTransfer";
    unit      <- "W/(m2*K)";
   :};

   CLASS SurfaceCoefficientOfHeatTransfer
   "A class for SurfaceCoefficientOfHeatTransfer"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SurfaceCoefficientOfHeatTransfer";
    unit      <- "W/(m2*K)";
   :};

   CLASS ThermalInsulance
   "A class for ThermalInsulance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalInsulance";
    unit      <- "m2*K/W";
   :};

   CLASS ThermalResistance
   "A class for ThermalResistance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalResistance";
    unit      <- "K/W";
   :};

   CLASS ThermalConductance
   "A class for ThermalConductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalConductance";
    unit      <- "W/K";
   :};

   CLASS ThermalDiffusivity
   "A class for ThermalDiffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalDiffusivity";
    unit      <- "m2/d";
   :};

   CLASS HeatCapacity
   "A class for HeatCapacity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "HeatCapacity";
    unit      <- "J/K";
   :};

   CLASS SpecificHeatCapacity
   "A class for SpecificHeatCapacity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificHeatCapacity";
    unit      <- "J/(g*K)";
   :};

 
 
 

   CLASS RatioOfspecificHeatCapacities
   "A class for RatioOfSpecificHeatCapacities"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RatioOfSpecificHeatCapacities";
    unit      <- "-";
   :};

   CLASS IsentropicExponent
   "A class for IsentropicExponent"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsentropicExponent";
    unit      <- "-";
   :};

   CLASS Entropy
   "A class for Entropy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Entropy";
    unit      <- "J/K";
   :};

   CLASS SpecificEntropy
   "A class for SpecificEntropy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificEntropy";
    unit      <- "J/(g*K)";
   :};

   CLASS SpecificEnergy
   "A class for SpecificEnergy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificEnergy";
    unit      <- "J/g";
   :};

 
 
 
 

   CLASS ThermodynamicEnergy         = Energy;
   CLASS HelmholtzFreeEnergy         = Energy;
   CLASS GibbsFreeEnergy             = Energy;
   CLASS Enthalpy                    = Energy;

   CLASS SpecificThermodynamicEnergy = SpecificEnergy;
   CLASS SpecificHelmholtzFreeEnergy = SpecificEnergy;
   CLASS SpecificGibbsFreeEnergy     = SpecificEnergy;
   CLASS SpecificEnthalpy            = SpecificEnergy;

   CLASS PlanckFunction
   "A class for PlanckFunction"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PlanckFunction";
    unit      <- "J/g";
   :};

 
   CLASS ElectricCurrent
   "A class for ElectricCurrent"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricCurrent";
    unit      <- "A";
   :};

   CLASS ElectricCharge
   "A class for ElectricCharge"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricCharge";
    unit      <- "C";
   :};

   CLASS ElectricPotential
   "A class for ElectricPotential"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricPotential";
    unit      <- "V";
   :};

   CLASS Capacitance
   "A class for Capacitance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Capacitance";
    unit      <- "F";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Inductance
   "A class for Inductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Inductance";
    unit      <- "H";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Resistance
   "A class for Resistance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Resistance";
    unit      <- "Ohm";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Conductance
   "A class for Conductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Conductance";
    unit      <- "S";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

 

   CLASS LuminousIntensity
   "A class for LuminousIntensity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LuminousIntensity";
    unit      <- "cd";
   :};

 

   CLASS AmountOfSubstance
   "A class for AmountOfSubstance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AmountOfSubstance";
    unit      <- "mol";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

 

   CLASS pH
   "A class for pH"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "pH";
    interval  <- {: lowerBound <- 0; upperBound <- 14 :};
   :};

   CLASS Concentration
   "A class for concentration"
   SPECIALISES PhysicalQuantityType :=
   {:
    nature <- "ACROSS";
    quantity <- "Concentration";
    unit <- "g/m3";
    interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
 

   CLASS ReynoldsNumber
   "A class for ReynoldsNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ReynoldsNumber";
    unit      <- "-";
   :};

   CLASS EulerNumber
   "A class for EulerNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "EulerNumber";
    unit      <- "-";
   :};

   CLASS FroudeNumber
   "A class for FroudeNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "FroudeNumber";
    unit      <- "-";
   :};

   CLASS GrashofNumber
   "A class for GrashofNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "GrashofNumber";
    unit      <- "-";
   :};

   CLASS WeberNumber
   "A class for WeberNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "WeberNumber";
    unit      <- "-";
   :};

   CLASS MachNumber
   "A class for MachNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MachNumber";
    unit      <- "-";
   :};

   CLASS KnudsenNumber
   "A class for KnudsenNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "KnudsenNumber";
    unit      <- "-";
   :};

   CLASS StrouhalNumber
   "A class for StrouhalNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "StrouhalNumber";
    unit      <- "-";
   :};

 
   CLASS FourierNumber
   "A class for FourierNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "FourierNumber";
    unit      <- "-";
   :};

   CLASS PecletNumber
   "A class for PecletNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PecletNumber";
    unit      <- "-";
   :};

   CLASS RayleighNumber
   "A class for RayleighNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RayleighNumber";
    unit      <- "-";
   :};

   CLASS NusseltNumber
   "A class for NusseltNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "NusseltNumber";
    unit      <- "-";
   :};

   CLASS BiotNumber = NusseltNumber;
 
 
 

   CLASS StantonNumber
   "A class for StantonNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "StantonNumber";
    unit      <- "-";
   :};

 
   CLASS PrandtlNumber
   "A class for PrandtlNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PrandtlNumber";
    unit      <- "-";
   :};

   CLASS SchmidtNumber
   "A class for SchmidtNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SchmidtNumber";
    unit      <- "-";
   :};

   CLASS LewisNumber
   "A class for LewisNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LewisNumber";
    unit      <- "-";
   :};

 
 
 

 
 
 

 
 
 
 
 

 



































































 
 
 
   CLASS PartialPressureInAir
   "A class for Partial Pressure in air"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "atm";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS MolecularDiffusivity
   "A class for Diffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Diffusivity";
    unit      <- "m2/s";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};


# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\generic.msl" 2



# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.quantity.msl" 1
 














 



 
 
 
 
 
 

 CLASS MassFlux
 "Mass per time unit"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity  <- "MassFlux";
  unit      <- "g/d";
  interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF :};
  nature <- "THROUGH";
 :};

 CLASS ArealFlux
 "Mass per unit of surface and per unit of time"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "ArealFlux";
  unit     <- "g/(m2*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
 :};

 

 

  CLASS YieldForAutotrophicBiomass
  "A class for YieldForAutotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_A";
    unit      <- "gCOD/gN";
    interval  <- {: lowerBound <- 0; upperBound <- 4.57 :};
  :};

  CLASS YieldForHeterotrophicBiomass
  "A class for YieldForHeterotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_H";
    unit      <- "gCOD/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};    

  CLASS FractOfBiomassLeadingToPartProd
  "Fraction of biomass leading to particulate products"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "F_P";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};    

  CLASS MassOfNitrogenPerMassOfCODInBiomass
  "Mass of N per mass of COD in biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I_XB";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
  :};    

  CLASS MassOfNitrogenPerMassOfCODInProdFromBiomass
  "Mass of N per mass of COD in products from biomass" 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I_XP";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
  :};    

 

  CLASS MaxSpecifGrowthRateHetero
  "Maximum specific growth rate for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_H";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 20 :};
  :};    

  CLASS MaxSpecifGrowthRateAutotr
  "Maximum specific growth rate for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 5 :};
  :};    

  CLASS HalfSatCoeff
  "Half-saturation coefficient"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_";
    unit      <- "gCOD/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 1000000 :};
  :};    

  CLASS HalfSatCoeffForHetero
  "Half-saturation coefficient for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_S";
    unit      <- "gCOD/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 100 :};
  :};    

  CLASS OxygenHalfSatCoeffForHetero
  "Oxygen half-saturation coeff for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OH";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};    

  CLASS NitrateHalfSatCoeffForDenitrifHetero
  "Nitrate half-saturation coeff for denitrifying heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NO";
    unit      <- "gNO3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 2 :};
  :};    

  CLASS OxygenHalfSatCoeffForAutotr
  "Oxygen half-saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OA";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};    

  CLASS AmmonHalfSatCoeffForAutotr
  "Ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NH";
    unit      <- "gNH3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};

  CLASS HalfSatCoeffForHydrolSlowBioDegradeSubstr
  "Half saturation constant for hydrolysis of slowly biodegradable substrate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_X";
    unit      <- "gCOD/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS MaxSpecificHydrolysisRate
  "Maximum specific hydrolysis rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_h";
    unit      <- "gCOD/(gCOD*d)";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

  CLASS AmmonificationRate
  "Ammonification rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_a";
    unit      <- "m3/(gCOD*d)";
    interval  <- {: lowerBound <- 0; upperBound <- 0.25 :};
  :};    

  CLASS DecayCoeffHeterotr
  "Decay coefficient for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "B_H";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

  CLASS DecayCoeffAutotr
  "Decay coefficient for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "B_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

 

  CLASS DissolvedComponent
  "A class for dissolved components"
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "S";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
    nature <- "ACROSS";
  :};    

  CLASS ParticulateComponent
  "A class for particulate component"
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "X";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
    nature <- "ACROSS";
  :};    

  CLASS ConversionFactor
  "A class for typical conversion factors for continuity equations"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "g/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS NitrogenConversionFactor
  "A class for typical conversion factors of Nitrogen for continuity equations"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS PhosphorusConversionFactor
  "A class for typical conversion factors of Phosphorus for continuity equations"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "gP/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};
    
  CLASS MaxGrowthRate
  "Maximum growth rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 100 :};
  :};    

  CLASS RateConstant
  "Rate constant"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Q_or_B_or_K";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 20 :};
  :};    

 
 

  CLASS ChemOxDemand
  "Chemical oxygen demand"
 
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "COD";
    unit      <- "gO2/m3";
  :};    
  
  CLASS BiolOxDemand
  "Biological oxygen demand" 
 
 
 
 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "BOD_5_20";
    unit      <- "gO2/m3";
  :};    

  CLASS NitrifOxDemand
  "Nitrification oxygen demand"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "NOD";
    unit      <- "gO2/m3";
  :};    

  CLASS DissolvedOxygen
  "A class for the ammount of dissolved oxygen"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity    <- "DO";
    unit        <- "gO2/m3";
    displayunit <- "gO2/m3";
    interval    <- {: lowerBound <- 0; upperBound <- 15 :};
  :};

 
 

 CLASS Yield
 "A class for Yield"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Yield";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};

 CLASS GrowthRate
 "GrowthRate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "GrowthRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
 :};

  CLASS ProcessRate
 "GrowthRate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "ProcessRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :}; 
 
 CLASS Fraction
 "Fraction"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Fraction";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1:};
 :};

 CLASS SaturationCoefficient
 "Saturation coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "K";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 100:};
 :};

 CLASS DecayCoefficient
 "Decay coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "B";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
 :};

 CLASS CorrectionFactor
 "CorrectionFactor"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
 :};

 CLASS ReductionFactor
 "Reductionfactor"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
 :};

 CLASS MaxSpecAmmonRate
 "Maximum specific ammonification rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "MaxSpecAmmonRate";
  unit     <- "m3/(gCOD*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};

 CLASS OxygenTransferCoefficient
 "Oxygen Transfer Coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Kla";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 5000 :};
 :};

CLASS OxygenUptakeRate
 "Oxygen Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "OUR";
  unit     <- "g/(m3.d)";
 :};

CLASS NitrateUptakeRate
 "Nitrate Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "NUR";
  unit     <- "g/(m3.d)";
 :};

 CLASS NitrateProductionRate
 "Nitrate Production Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "NPR";
  unit     <- "g/(m3.d)";
 :};
 
CLASS AmmoniumUptakeRate
 "Ammonium Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "AUR";
  unit     <- "g/(m3.d)";
 :};
 
CLASS PhosphateUptakeRate
 "Phosphate Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "PUR";
  unit     <- "g/(m3.d)";
 :};  

CLASS PhosphateReleaseRate
 "Phosphate Release Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "PRR";
  unit     <- "g/(m3.d)";
 :};   
 
CLASS ElectricalEnergy
   "A class for electrical energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Electrical energy";
    unit      <- "kWh";
    :};

CLASS TransferRateEnergy
   "A class for transfer rate per unit of energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Transfer rate per energy";
    unit      <- "g/kWh";
    :};
  
CLASS Dollar
   "dollars"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "dollar";
    unit      <- "$";
    :};

CLASS Euro
   "Euro"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "euro";
    unit      <- "E";
    :};

 CLASS HenryCoefficient
 "A class for the Henry coefficient"
 SPECIALISES PhysicalQuantityType := 
 {:
  quantity    <- "HenryCoefficient";
  unit        <- "atm.m3.Mol-1";
  interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS MassOfNitrogenPerMassOfCOD
 "Mass of N per mass of COD"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "I_";
   unit      <- "gN/gCOD";
   interval  <- {: lowerBound <- 0; upperBound <- 0.2; :};
 :};    

 CLASS MolarHalfSatCoeff
 "Half-saturation coefficient for components expressed in mol.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_S_";
   unit      <- "Mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};    

 CLASS InhibitionCoeff
 "Inhibition coefficient for components expressed in g.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "g.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   

 CLASS MolarInhibitionCoeff
 "Inhibition coefficient for components expressed in mol.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "Mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};    

 CLASS TemperatureCoefficient
 "Temperature coefficient for reaction rate"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "TemperatureCoefficient";
   unit      <- "-";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS MolConcentration
 "Concentration in Mol per m3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "MolConcentration";
   unit      <- "Mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :}; 
 
 CLASS MolFlowRate
 "Gas flow rate in Mol per day"
 SPECIALISES PhysicalQuantityType :=
 {: 
   quantity  <- "MolFlowRate";
   unit      <- "Mol.d-1";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS GasFlowRate
 "Gas flow rate in m3 per day"
 SPECIALISES PhysicalQuantityType :=
 {: 
   quantity  <- "GasFlowRate";
   unit      <- "m3.d-1";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 




  CLASS MonodTerm
  "A class for Monod-like terms"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "S / ( K + S)";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1:};
  :};    

  CLASS InhibitionTerm
  "A class for inhibtion terms of the ASM-models"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K / ( K + S)";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1:};
  :};    


 
 
CLASS LengthFlux
 "Mass per unit of length and per unit of time"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "LengthFlux";
  unit     <- "g/(m*d)";
  interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
 :};

CLASS BurgerDispersion
 "Time per unit of surface"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "b_mix";
   unit      <- "d/m2";
   interval  <- {: lowerbound <- 0; upperbound <- PLUS_INF; :};
 :};

CLASS BurgerSolidsStress
"A class for the parameter of the solids stress function"
SPECIALISES PhysicalQuantityType :=
{:
   quantity  <- "Alpha";
   unit      <- "m2/s2";
   interval  <- {: lowerbound <- 0; upperbound <- PLUS_INF; :};
 :};
 
 
 
 
  CLASS YieldForAutotrophicBiomassForMampaeyA
  "A class for YieldForAutotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_A";
    unit      <- "gCOD/gN";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS MaxSpecifDenitrifyRateForMampaeyB
  "Maximum specific growth rate for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};    
  
  CLASS AmmonHalfSatCoeffForAutotrForMampaeyA
  "Ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NH";
    unit      <- "gNH3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS OxygenHalfSatCoeffForAutotrForMampaeyA
  "Oxygen half-saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OA";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};  
  
  CLASS NSaturationCoefficientForMampaey
  "Saturation coefficient"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "K";
    unit     <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
  :};
  
 
  CLASS FreeAmmoniaSatCoeffForAutotr
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};

  CLASS FreeNitrousAcidSatCoeffForAutotr
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FNA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};
  
  CLASS bCoeffForRatkowsky
  "b coefficient of Ratkowsky temperature correction"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "eta";
    unit     <- "1/[(d^0.5)*(deg C)]";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};
 
  CLASS cCoeffForRatkowsky
  "c coefficient of Ratkowsky temperature correction"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "eta";
    unit     <- "1/degC";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};
  
  CLASS FreeAmmoniaInhibitionCoeff
  "Inhibition coefficient for free Ammonia"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_I_";
    unit      <- "gN/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
  :};   
 
 CLASS FreeNitrousAcidInhibitionCoeff
 "Inhibition coefficient for free nitrous acid"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 CLASS NitricOxideInhibitionCoeffForDenitrification
 "Inhibition coefficient for nitric oxide substances during denitrification"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 CLASS NHalfSatCoeffForDenitrification
 "Half saturation coefficient for N substances during denitrification"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 
  
 
  CLASS FreeAmmoniaSatCoeffForAutotrModif
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS FreeNitrousAcidSatCoeffForAutotrModif
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FNA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS FreeAmmoniaInhibitionCoeffModif
  "Inhibition coefficient for free Ammonia in the modified competitive term"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_I_";
    unit      <- "gN/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
  :};  
  
   CLASS FreeNitrousAcidInhibitionCoeffModif
   "Inhibition coefficient for free nitrous acid"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};  
   
   CLASS NitricOxideInhibitionCoeffForDenitrificationModif
   "Inhibition coefficient for nitric oxide substances during denitrification"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};  

   CLASS NHalfSatCoeffForDenitrificationModif
   "Half saturation coefficient for N substances during denitrification"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :}; 



# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.general.msl" 1
 


















 
 
 

 
 
 

  
  

# 83 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.general.msl"


 
 
 

 

 OBJ NrOfComponents
  "The number of biological components considered in the WWTP models"
  : Integer := Cardinality(Components);

 OBJ NrOfReactions
  "The number of reactions between biological components considered in the WWTP models"
  : Integer := Cardinality(Reactions);

  

 OBJ NrOfLayers "The number of layers in the secondary clarifier"
  : Integer := 10 ;

 OBJ NrOfLayersButOne "The number of layers in the secondary clarifier minus one" 
  : Integer := 9 ;

 OBJ NrOfLayersPlusOne "The number of layers in the secondary clarifier plus one" 
  : Integer := 11 ;

  
 
 
  OBJ NrOfLayersBurger "Burger model: The number of layers in the secondary clarifier (N)" : Integer := 20 ;  
  OBJ NrOfLayersPlusOneBurger "Burger model: The number of layers in the clarifier plus one (N+1)" : Integer := 21 ;  
  OBJ NrOfLayersPlusTwoBurger "Burger model: The number of layers in the clarifier plus two extra layers in the underflow (N+2)" : Integer := 22 ; 
  OBJ NrOfLayersPlusThreeBurger "Burger model: The number of layers in the secondary clarifier plus 3 (N+3)" : Integer := 23 ;
  OBJ NrOfLayersPlusFourBurger "Burger model: The number of layers in the clarifier plus the extra layers in effluent and underflow (N+4)" : Integer := 24 ;
  OBJ NrOfConcentration "Burger model: The number of discretisations between min and max concentration" : Integer := 1000;
 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 

 CLASS WWTPTerminal
 "The variables which are passed between WWTP model building blocks"
 = MassFlux[NrOfComponents;]; 

 CLASS InWWTPTerminal SPECIALISES WWTPTerminal;  
 CLASS OutWWTPTerminal SPECIALISES WWTPTerminal;  

 

 CLASS WWTPConcTerminal 
  "The variables which are passed between WWTP model building blocks in concentrations"
  = Concentration[NrOfComponents;]; 

 CLASS InWWTPConcTerminal SPECIALISES WWTPConcTerminal;  
 CLASS OutWWTPConcTerminal SPECIALISES WWTPConcTerminal;  

  
  
  
  



 
 
 

  
  
  
  

 OBJ Comp_Index "Temporary iteration variable, index of the component" : Integer;
 OBJ Reaction_Index "Temporary iteration variable, index of the reaction" : Integer;
 OBJ In_Comp_Index "Temporary iteration variable, index of the incoming component" : Integer;
 OBJ Out_Comp_Index "Temporary iteration variable, index of the outgoing component" : Integer;
 OBJ Terminal "Temporary iteration variable" : WWTPTerminal;
 OBJ In_Terminal "Temporary iteration variable" : WWTPTerminal;
 OBJ Out_Terminal "Temporary iteration variable" : WWTPTerminal;

  

 OBJ Layer_Index "Temporary iteration variable, index of the layer" : Integer;
 OBJ IndexOfFeedLayer "The index of the layer where the influent is feeded to the clarifier" 
  : Integer := 5 ;

 
  

 
  OBJ IndexOfFeedLayerBurger "The index of the layer where the influent is feeded to the clarifier" : Integer := 12 ;
  OBJ Conc_Index "Temporary iteration variable, index of the concentration vector" : Integer;
 

 
 
 

 
 
 
 

CLASS MassVector = Mass[NrOfComponents;];
CLASS MassFluxVector = MassFlux[NrOfComponents;];
CLASS ConcentrationVector = Concentration[NrOfComponents;];
CLASS SpecificVolumeVector = SpecificVolume[NrOfComponents;];
CLASS VelocityVector = Velocity[NrOfComponents;];
CLASS ArealFluxVector = ArealFlux[NrOfComponents;];
CLASS LengthVector = Length[NrOfLayers;];
CLASS VolumeVector = Volume[NrOfLayers;];
CLASS L_and_B_ConcentrationVector = Concentration[5;];

 
CLASS TakacsMassVector = Mass[NrOfLayers;];
CLASS TakacsConcentrationVector = Concentration[NrOfLayers;];
CLASS TakacsVelocityVector = Velocity[NrOfLayers;];
CLASS TakacsArealFluxVector = ArealFlux[NrOfLayers;];
CLASS LayerConcentrationMatrix = Concentration[NrOfComponents;][NrOfLayers;];

 
CLASS LayerMassMatrix = Mass[NrOfComponents;][NrOfLayers;];
 
 
CLASS BurgerMassVector = Mass[NrOfLayersPlusFourBurger;];
CLASS BurgerLengthVector = Length[NrOfLayersPlusFourBurger;];
CLASS BurgerConcentrationVector = Concentration[NrOfLayersPlusFourBurger;];
CLASS BurgerConcentrationVector2 = Concentration[NrOfConcentration;];
CLASS BurgerVelocityVector = Velocity[NrOfLayersPlusFourBurger;];
CLASS BurgerArealFluxVector = ArealFlux[NrOfLayersPlusFourBurger;];
CLASS BurgerArealFluxVector2 = ArealFlux[NrOfConcentration;];
CLASS BurgerLayerConcentrationMatrix = Concentration[NrOfComponents;][NrOfLayersPlusFourBurger;];
CLASS BurgerDiffusivityVector = Diffusivity[NrOfLayersPlusFourBurger;];
CLASS BurgerLengthFluxVector = LengthFlux[NrOfLayersPlusFourBurger;];
 
 
CLASS PloszConcentrationVector = Concentration[60;];
CLASS PloszVelocityVector = Velocity[60;];
CLASS PloszArealFluxVector = ArealFlux[60;];
CLASS PloszDiffusivityVector = Diffusivity[60;]; 
 
 


# 24 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 1
 


















  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

  
 
 

  
  
  
  
  
  

  
  

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1Temp.msl" 1
 


















# 38 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1Temp.msl"


# 52 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1Temp.msl"


# 88 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1Temp.msl"



# 55 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM2dModTemp.msl" 1
 


















# 46 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM2dModTemp.msl"


# 75 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM2dModTemp.msl"



# 108 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM2dModTemp.msl"



# 56 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3Temp.msl" 1
 


















# 38 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3Temp.msl"


# 56 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3Temp.msl"


# 88 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3Temp.msl"



# 57 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3P_EAWAG.msl" 1
 


















# 43 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3P_EAWAG.msl"


# 74 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3P_EAWAG.msl"


# 107 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM3P_EAWAG.msl"



# 58 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1_AN.msl" 1
 



















# 41 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1_AN.msl"



# 59 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1_AN.msl"


# 78 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM1_AN.msl"



# 61 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASMG1.msl" 1
 



















# 44 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASMG1.msl"



# 69 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASMG1.msl"


# 90 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASMG1.msl"



# 62 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 2



# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsASM2dChemTemp.msl" 1



TYPE Components
"
The biological components considered in the WWTP models
"
	= ENUM {H2O, 
		S_I, 
		S_O, 
		S_N2, 
		S_F, 
		S_A, 
		S_Al, 
		S_NO, 
		S_PO, 
		S_NH, 
		S_ALK, 
		X_I, 
		X_S, 
		X_H, 
		X_PAO, 
		X_PP, 
		X_PHA, 
		X_AUT, 
		X_TSS, 
		X_MEOH, 
		X_MEP, 
		X_I_i, 
		};




TYPE Reactions
"
The reactions between biological components considered in the WWTP models
"
	= ENUM {AerHydrol, 
		AnHydrol, 
		AnaerHydrol, 
		AerGrowthOnSf, 
		AerGrowthOnSa, 
		AnGrowthOnSfDenitrif, 
		AnGrowthOnSaDenitrif, 
		Fermentation, 
		LysisOfHetero, 
		StorageOfXPHA, 
		AerStorageOfXPP, 
		AnStorageOfXPP, 
		AerGrowthOnXPHA, 
		AnGrowthOnXPHADenitrif, 
		LysisOfXPAO, 
		LysisOfXPP, 
		LysisOfXPHA, 
		GrowthOfAuto, 
		LysisOfAuto, 
		Precipitation, 
		Redissolution, 
		Aeration, };






	OBJ IndexOfSolvent
	"The index of the solvent in the components vector considered in the WWTP models"
	: Integer := 1;



	OBJ IndexOfFirstSolubleComponent
	"The index of the first soluble component in the components vector considered in the WWTP models"
	: Integer := 2;


	OBJ IndexOfLastSolubleComponent
	"The index of the last soluble component in the components vector considered in the WWTP models"
	: Integer := 11;



	OBJ IndexOfFirstParticulateComponent
	"The index of the first particulate component in the components vector considered in the WWTP models"
	: Integer := 12;


	OBJ IndexOfLastParticulateComponent
	"The index of the last particulate component in the components vector considered in the WWTP models"
	: Integer := 22;



	OBJ IndexOfTSSComponent
	"The index of the TSS component in the components vector considered in the WWTP models"
	: Integer := 19;











# 65 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions1.msl" 2



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitions2.msl" 1
 


















  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

 
 
 

TYPE AnaerobicComponents
  "The biological components considered in the Siegrist anaerobic digestion model"
  = ENUM {H2O_An, S_H2, S_CH4, S_CO2, S_HCO3, S_H, S_NH4, S_AC, S_PRO,
          S_AS, S_FA, S_IN, X_S_An, X_AS, X_FA, X_PRO, X_AC, X_H2, X_IN};

  
  
  
  
  
  
 
 TYPE AnaerobicReactions
  "The anaerobic reactions between biological components considered in the Siegrist anaerobic digestion model"
  = ENUM {
          H2Stripping,
          CH4Stripping,
          CO2Stripping,
          BiopolymHydrol,
          ASFermentation,
          AnOxOfS_FA,
          AnOxOfS_PRO,
          AcToCH4Conv,
          H2ToCH4Conv,
          DecayOfX_AS,
          DecayOfX_FA,
          DecayOfX_PRO,
          DecayOfX_AC,
          DecayOfX_H2,
          ProtolysisOfHCO3,
          DeprotolysisOfCO2,
         };

 
 
 

 OBJ NrOfAnaerobicComponents "The number of anaerobic components considered in the anaerobic digestion model"
  : Integer := Cardinality(AnaerobicComponents);

 OBJ NrOfAnaerobicReactions "The number of anaerobic reactions considered in the anaerobic digestion model"
  : Integer := Cardinality(AnaerobicReactions);

 
 
 
 

 
 CLASS AnaerobicConcentrationVector = Concentration[NrOfAnaerobicComponents;];
 CLASS AnaerobicSpecificVolumeVector = SpecificVolume[NrOfAnaerobicComponents;];
 CLASS AnaerobicMassVector = Mass[NrOfAnaerobicComponents;];
 CLASS AnaerobicMassFluxVector = MassFlux[NrOfAnaerobicComponents;];

 
 
 


# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 1
 


















 CLASS WWTPAtomicModel
 " A generic atomic WWTP model. Only specifies mass balances"
 
 
 
 
 
 
 
 
 SPECIALISES PhysicalDAEModelType :=
 {:
  
  
  parameters <-
   {

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

     
     
     
     
    OBJ WWTPSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SpecificVolumeVector;

     
     
     
     
     
     
     
     
     
     

   };

  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };

  state <-
   {
    OBJ M "Vector containing masses for all the components" : MassVector 
# 105 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl"








   := [{: value <- 1000000000 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
					{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 100 :},{: value <- 10 :},
					{: value <- 1 :},{: value <- 1 :},{: value <- 10 :},{: value <- 123.33 :},{: value <- 1 :},
					{: value <- 1 :},{: value <- 10 :};]





















# 147 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl"

;
    OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": MassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all the components": MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =

     
     
     
     
     

    (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
    In_Terminal[Comp_Index])+
    (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
    Out_Terminal[Comp_Index]);};

     
     
     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};

     
     
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
    };
    {state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);
    };

 
 
 

   }; 
 :};

 
 
 

 
 
 

 CLASS WWTPAtomicModelWithoutVolume 
 SPECIALISES PhysicalDAEModelType :=
 {:
  parameters <-
   {
    OBJ WWTPSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SpecificVolumeVector;
   };

  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };
   
  state <-
   {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
   };

   equations <-
   {
     { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
         (In_Terminal[Comp_Index]);
     };

     {state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);
     };

   };
 :};

 
 
 

 CLASS WWTPAtomicModelWithVolume EXTENDS WWTPAtomicModel WITH
 {:

   state <-
    {
      OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Dimension" :};
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
    };

   equations <-
    {
      
      
    };

 :};

 
 
 

 CLASS WWTPAtomicModelWithVariableVolume
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  parameters <-
   {
     OBJ N "Number of weirs on a tank" : PhysicalQuantityType := 
         {: value <- 100 ; 
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :};
      group <- "Hydraulic" 
         :} ;
     OBJ A (* is_favorite = "1" *) "Surface area of the tank" : Area := {: value <- 200; group <- "Dimension"  :} ;
     OBJ alfa "Parameter, function of the weir type or width" 
         : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic"  :};
     OBJ beta "Parameter, depends on the weir design" 
         : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
     OBJ V_Const (* is_favorite = "1" *) "Constant tank volume beneath the lowest point of the weir" 
         : Volume := {: value <- 1900; group <- "Dimension" :};
   };

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
     
     
     
     

    state.Q_Out = IF (state.V > parameters.V_Const)
                THEN
    parameters.N * parameters.alfa 
      * pow((state.V - parameters.V_Const)/parameters.A, parameters.beta)
        ELSE 0;

     
     
     
     

    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};

  
  
  
  
  

 CLASS VarVolumeConversionModel EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 354 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2

 :};
 
  

 CLASS VarVolumeASMConversionModel EXTENDS VarVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 








































# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 1


  interface <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.interface.msl" 1


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 



# 5 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.parameters.msl" 1


	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 
 
 



# 10 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  state <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.state.msl" 1


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;
	OBJ K_NH_AUT_Temp	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient := {: group <- "Kinetic" :}; 



# 15 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  initial <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.stoichiometry.msl" 1


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;



# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  equations <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.kinetics.msl" 1


 
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);
	state.K_NH_AUT_Temp = parameters.K_NH_AUT * pow(10,(0.051 * state.Temp_Actual - 1.158));

	state.Kinetics[AerHydrol] := state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] := state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] := state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] := state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] := state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] := state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] := state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] := state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] := state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] := state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] := state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] := state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] := state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] := state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] := state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] := parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] := parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.sensors.msl" 1


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR = 
          IF(state.V==0) 
          THEN 0 
          ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;



# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };



# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



# 361 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2

 :};

 
 
 

CLASS WWTPAtomicModelWithPumpedVolume
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Q_Pump (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired effluent flow rate" : FlowRate := {: causality <- "CIN" ; value <- 100; group <- "Operational" :} ;
   };

  parameters <-
   {
     OBJ V_Max (* is_favorite = "1" *) "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min (* is_favorite = "1" *) "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
   };

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min && 
                    interface.Q_Pump > state.Q_In) 
                THEN state.Q_In
                ELSE  
                  IF (state.V < parameters.V_Max)
                  THEN interface.Q_Pump
                  ELSE
                    IF (state.Q_In < interface.Q_Pump)
                    THEN interface.Q_Pump
                    ELSE state.Q_In ;    

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};

CLASS PumpedVolumeConversionModel EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 424 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2

 :};

 CLASS PumpedVolumeASMConversionModel EXTENDS PumpedVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 








































# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 1


  interface <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.interface.msl" 1


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 



# 5 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.parameters.msl" 1


	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 
 
 



# 10 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  state <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.state.msl" 1


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;
	OBJ K_NH_AUT_Temp	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient := {: group <- "Kinetic" :}; 



# 15 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  initial <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.stoichiometry.msl" 1


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;



# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  equations <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.kinetics.msl" 1


 
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);
	state.K_NH_AUT_Temp = parameters.K_NH_AUT * pow(10,(0.051 * state.Temp_Actual - 1.158));

	state.Kinetics[AerHydrol] := state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] := state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] := state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] := state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] := state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] := state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] := state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] := state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] := state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] := state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] := state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] := state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] := state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] := state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] := state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] := parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] := parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.sensors.msl" 1


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR = 
          IF(state.V==0) 
          THEN 0 
          ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;



# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };



# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



# 429 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2


 :};

 
 
 

 CLASS WWTPAtomicModelWithFixedVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
      
      
   };

  parameters <-  
   {
     OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
   };   
   
  state <-
   {
 
   };

  initial <-  
  {
  state.M[IndexOfSolvent] = parameters.Vol / parameters.WWTPSpecificVolume[IndexOfSolvent];
  };   
  equations <-
   {
     
     
     
 
      
     
     
     

    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_In ;};
   };
 :};

 
CLASS WWTPAtomicModelWithFixedVolumeCM EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Vol (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Volume of the tank" : 
       Volume := {: causality <- "CIN"; group <- "Dimension" :};
   };

  parameters <-  
   {
      
   };   
   
  state <-
   {
 
   };

  initial <-  
  {
  state.M[IndexOfSolvent] = interface.Vol / parameters.WWTPSpecificVolume[IndexOfSolvent];
  };   
  equations <-
   {
     
     
     
 
      
     
     
     

    state.V = interface.Vol;
     
     

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_In ;};
   };
 :};

 CLASS FixVolumeConversionModel EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 551 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2

 :};
 
CLASS FixVolumeConversionModelCM EXTENDS WWTPAtomicModelWithFixedVolumeCM WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 556 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2

 :};

CLASS FixVolumeASMConversionModel EXTENDS FixVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 








































# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 1


  interface <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.interface.msl" 1


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 



# 5 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.parameters.msl" 1


	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 
 
 



# 10 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  state <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.state.msl" 1


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;
	OBJ K_NH_AUT_Temp	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient := {: group <- "Kinetic" :}; 



# 15 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  initial <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.stoichiometry.msl" 1


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;



# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  equations <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.kinetics.msl" 1


 
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);
	state.K_NH_AUT_Temp = parameters.K_NH_AUT * pow(10,(0.051 * state.Temp_Actual - 1.158));

	state.Kinetics[AerHydrol] := state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] := state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] := state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] := state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] := state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] := state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] := state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] := state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] := state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] := state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] := state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] := state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] := state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] := state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] := state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] := parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] := parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.sensors.msl" 1


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR = 
          IF(state.V==0) 
          THEN 0 
          ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;



# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };



# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



# 561 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2

 :};

 CLASS FixVolumeASMConversionModelCM EXTENDS FixVolumeConversionModelCM WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 








































# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 1


  interface <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.interface.msl" 1


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 



# 5 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.parameters.msl" 1


	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 
 
 



# 10 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  state <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.state.msl" 1


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;
	OBJ K_NH_AUT_Temp	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient := {: group <- "Kinetic" :}; 



# 15 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  initial <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.stoichiometry.msl" 1


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;



# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  equations <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.kinetics.msl" 1


 
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);
	state.K_NH_AUT_Temp = parameters.K_NH_AUT * pow(10,(0.051 * state.Temp_Actual - 1.158));

	state.Kinetics[AerHydrol] := state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] := state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] := state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] := state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] := state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] := state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] := state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] := state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] := state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] := state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] := state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] := state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] := state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] := state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] := state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] := parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] := parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.sensors.msl" 1


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR = 
          IF(state.V==0) 
          THEN 0 
          ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;



# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };



# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



# 566 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.msl" 2

 :};

 
 
 

 
 
 

 
 
 
 
 



# 28 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2


 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 1
 


















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.twocombiner.msl" 1
 


















 CLASS TwoCombiner
 (* icon = "two_combiner" ; is_default = "true" *)  
 "two combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of two flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1" :};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.threecombiner.msl" 1
 


















 CLASS ThreeCombiner
 (* icon = "three_combiner" ; is_default = "true" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of three flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.fourcombiner.msl" 1
 


















 CLASS FourCombiner
 (* icon = "four_combiner" ; is_default = "true" *)  
 "Four combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of four flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 23 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.fivecombiner.msl" 1
 














 



 CLASS FiveCombiner
 (* icon = "five_combiner" ; is_default = "true" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of five flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Inflow5 (* terminal = "in_5" *) "Inflow5" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 5":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In5 (* is_favorite = "1" *) "Influent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_In5 = interface.Inflow5[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];

     {state.Q_Out = (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 24 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2


 
 

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.reltwosplitter.msl" 1
 














 



CLASS RelTwoSplitter
 (* icon = "two_fraction_splitter" ; is_default = "true" *)
 "relative splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.9; group <- "Operational" :};
   };
  parameters <-
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 
 
 :};


# 29 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relthreesplitter.msl" 1
 














 



 CLASS RelThreeSplitter
 (* icon = "three_fraction_splitter" ; is_default = "true" *)
 "relative three splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.8 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};


# 30 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relfoursplitter.msl" 1
 


















 CLASS RelFourSplitter
 (* icon = "four_fraction_splitter" ; is_default = "true" *)
 "relative four splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into four flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};
 


# 31 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relfivesplitter.msl" 1
 


















 CLASS RelFiveSplitter
 (* icon = "five_fraction_splitter" ; is_default = "true" *)
 "relative five splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into five flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow5" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out5 (* is_favorite = "1" *) "Effluent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4 + interface.f_Out5) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out5)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
      };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index] - interface.Outflow5[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    state.Q_Out5 = - interface.Outflow5[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
   }; 

 :};


# 32 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2


 

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.abstwosplitter.msl" 1
 


















 CLASS AbsTwoSplitter
 (* icon = "two_flow_splitter" ; is_default = "true" *)
 "absolute two way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };
  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   
  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
    state.Q_Out1 = IF(interface.Q_Out2 > state.Q_In)
                   THEN 0
                   ELSE state.Q_In - state.Q_Out2_Actual ;

    state.Q_Out2_Actual = IF(interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out2) ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    
   }; 
 :};


# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absthreesplitter.msl" 1
 


















 CLASS AbsThreeSplitter
 (* icon = "three_flow_splitter" ; is_default = "true" *)
 "absolute three way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_4" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
    OBJ Pumping_Energy_1 "Take into account pumping energy out_1" : Integer := {: value <- 0 ; group <- "Cost":};
    OBJ Pumping_Energy_2 "Take into account pumping energy out_2" : Integer := {: value <- 1 ; group <- "Cost":};
    OBJ Pumping_Energy_3 "Take into account pumping energy out_3" : Integer := {: value <- 1 ; group <- "Cost":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
 
    OBJ Integral_PE (* hidden = "0" *)"Total flow to calculate Pumping Energy" : ElectricalEnergy ;
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = IF ((state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual)) < 0.0)
	 								THEN 0.0
	 								ELSE state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual);

    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        	THEN state.Q_In - state.Q_Out2_Actual
                        	ELSE interface.Q_Out3;

    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

 
    state.Integral_PE = IF (parameters.Pumping_Energy_1 == 1)
                        THEN 
                            IF (parameters.Pumping_Energy_2 == 1)
                            THEN 
                                IF (parameters.Pumping_Energy_3 == 1)
                                THEN state.Q_Out1 + state.Q_Out2_Actual + state.Q_Out3_Actual
                                ELSE state.Q_Out1 + state.Q_Out2_Actual 
                            ELSE 
                                IF (parameters.Pumping_Energy_3 == 1) 
                                THEN state.Q_Out1 + state.Q_Out3_Actual
                                ELSE state.Q_Out1
                        ELSE 
                            IF (parameters.Pumping_Energy_2 == 1)
                            THEN 
                                IF (parameters.Pumping_Energy_3 == 1)
                                THEN state.Q_Out2_Actual + state.Q_Out3_Actual
                                ELSE state.Q_Out1 
                            ELSE 
                                IF (parameters.Pumping_Energy_3 == 1) 
                                THEN state.Q_Out3_Actual
                                ELSE 0 ;
              
  DERIV(state.Integ_PE,[independent.t]) =  state.Integral_PE ;
   
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   }; 
 :};


# 37 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absfoursplitter.msl" 1
 


















 CLASS AbsFourSplitter
 (* icon = "four_flow_splitter" ; is_default = "true" *)
 "absolute four way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into four flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_5" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual);
 
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual
                        ELSE interface.Q_Out3;

    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
                        ELSE interface.Q_Out4;

    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;
    state.f_Out4 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out4_Actual /state.Q_In ; 
           
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    
   }; 
 :};


# 38 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absfivesplitter.msl" 1
 


















 CLASS AbsFiveSplitter
 (* icon = "five_flow_splitter" ; is_default = "true" *)
 "absolute five way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into five flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow5 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_6" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ f_Out5 (* hidden = "1" *) "Fraction of the influent flux going to outflow5" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate ;
    OBJ Q_Out5_Actual (* is_favorite = "1" *) "Help variable for outflow5 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual);
 
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual
                        ELSE interface.Q_Out3;

    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
                        ELSE interface.Q_Out4;

    state.Q_Out5_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4+interface.Q_Out5) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual - state.Q_Out4_Actual
                        ELSE interface.Q_Out5;
            
    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;
    state.f_Out4 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out4_Actual /state.Q_In ; 
    state.f_Out5 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out5_Actual / state.Q_In ;
           
           
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out5 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   }; 
 :};


# 39 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2


 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\splitter_combiner/wwtp.base.splitters_combiners.modeldatacombiner.msl" 1
 









 CLASS ModelDataCombiner
 (* icon = "two_combiner" ; is_default = "false" *)  
 "two combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model to combine modeled data and measured data";
  interface <-
   { 
    OBJ InflowModel (* terminal = "in_1" *) "InflowModel" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1" :};
    OBJ InflowData (* terminal = "in_2" *) "InflowData" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };
  state <-  
  {
    OBJ Q_InModel (* is_favorite = "1" *) "Influent flow rate from Model" : FlowRate := {: group <- "Operational" :};
    OBJ Q_InData (* is_favorite = "1" *) "Influent flow rate from Data" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };

  parameters <-
  {
   
     OBJ Flow_data "Whether flow data is available at this location" : Boolean := {: value <- False; group <- "To replace"; interval <- {: lowerBound <- 0; upperBound <- 1:}; :}; 
     
  };
  
  equations <-
    {
    state.Q_InModel = IF (parameters.Flow_data == 0)
    THEN interface.InflowModel[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent]
    ELSE 0;
    
    state.Q_InData = IF (parameters.Flow_data == 0)
    THEN 0
    ELSE interface.InflowData[IndexOfSolvent] * parameters.WWTPSpecificVolume[IndexOfSolvent];
    
    state.Q_Out = IF (parameters.Flow_data == 0)
    THEN interface.InflowModel[IndexOfSolvent]
    ELSE interface.InflowData[IndexOfSolvent];
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:  
      interface.Outflow[Comp_Index] = IF (interface.InflowData[Comp_Index] == 0)
      THEN - interface.InflowModel[Comp_Index]
      ELSE - interface.InflowData[Comp_Index] / interface.InflowData[IndexOfSolvent] * interface.InflowModel[IndexOfSolvent];};
    
    interface.Outflow[IndexOfSolvent] = IF (parameters.Flow_data == 0)
    THEN - interface.InflowModel[IndexOfSolvent]
    ELSE - interface.InflowData[IndexOfSolvent];
  
     
     
     
     
     

    
     
     
   }; 
 :};


# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.splitters_combiners.msl" 2



# 31 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.buffertanks.msl" 1
 


















CLASS PumpedVolumeBuffer
 "A class for buffertanks with a pumped variable volume"
 EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
  comments <- "A model for a tank with a variable volume caused by a pump";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

  equations <-
   {
     interface.V_Buffer = state.V;
   };
  initial <-
   {
   };
 :};

CLASS FixVolumeBuffer
 "A class for buffertanks with a fixed volume"
 EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
   comments <- "A model for a tank with a fixed volume";

   interface <-
   {
     OBJ V_Buffer  (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

   equations <-
   {
     interface.V_Buffer = state.V;
   };

   initial <-
   {
   };
 :};

CLASS VarVolumeBuffer
 "A class for buffertanks with variable volume"
 EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
  comments <- "A model for a  tank with a variable volume caused by a weir";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

  equations <-
   {
    interface.V_Buffer = state.V;
   };

  initial <-
   {
   }; :};
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumestormtank.msl" 1
 














 



CLASS PumpedVolumeStormTank
  (* icon = "storm_tank" ; is_default = "true" *)
  "Model for a storm tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a storm tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *) "Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :}; 



 
# 84 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumebuffertank.msl" 1
 


















CLASS PumpedVolumeBufferTank
  (* icon = "buffer_tank" ; is_default = "true" *)
  "Model for a buffer tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a buffer tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :};  
 



 
# 85 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\buffertank/wwtp.base.buffertanks.fixvolumeequalisationtank.msl" 1
 


















  CLASS FixVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES FixVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  



 
# 86 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\buffertank/wwtp.base.buffertanks.varvolumeequalisationtank.msl" 1
 


















  CLASS VarVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES VarVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  



 
# 87 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumebuffertankEindhoven.msl" 1
 








 CLASS PumpedVolumeBuffer_Eindhoven
 (* icon = "buffer_tank" ; is_default = "true" *)
 "A class for buffertanks with a pumped variable volume"
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Q_Pump (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired effluent flow rate" : 
	 	  FlowRate := {: causality <- "CIN" ; value <- 100; group <- "Operational" :} ;   
		};

  parameters <-
   {
     OBJ V_Max "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
   };

  state <-
   {
     OBJ Q_Out "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (parameters.WWTPSpecificVolume[Comp_Index]*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
				   THEN 0
				   ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min)
                  THEN 0
                  ELSE IF ((state.V < parameters.V_Max) && (state.Q_In == 0))
                       THEN interface.Q_Pump
                       ELSE IF ((state.V < parameters.V_Max) && (state.Q_In > 0))
                            THEN 0
                            ELSE IF ((state.V >= parameters.V_Max) && (state.Q_In > 0))
							     THEN state.Q_In
								 ELSE interface.Q_Pump;    

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};



 
# 88 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.buffertanks.msl" 2




 
# 32 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.activated_sludge_units.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl" 1
 


















 CLASS FixVolumeASU 
 (* icon = "activated_sludge_unit" ; is_default = "true" *)
 SPECIALISES FixVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a fixed volume";
   interface <-  
   {
    OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	 	OBJ DOsat	(* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen saturation" : Concentration	
	 	:= {: causality <- "CIN" ; value <- 12 ; group <- "Conversion factors" :}; 
	 	 
	   


    OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "0" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
    OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
   initial <-
   {
    
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;
  	state.S_O_Saturation = interface.DOsat;
  	 


    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ; 
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
               THEN parameters.ME_unit * state.V
             ELSE 
               IF (parameters.Mixing_When_Aerated)
               THEN parameters.ME_unit * state.V
               ELSE 0;    

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
   };   
 :};
	 
 
	 
CLASS FixVolumeASUCM
 (* icon = "activated_sludge_unit" ; is_default = "true" *)
 SPECIALISES FixVolumeASMConversionModelCM :=
 {:
   comments <- "Model for an activated sludge unit with a fixed volume";
   interface <-  
   {
    OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
	 	OBJ DOsat	(* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen saturation" : Concentration	
	 	:= {: causality <- "CIN" ; value <- 12 ; group <- "Conversion factors" :}; 
	 	 
	   


    OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

    OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "0" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
    OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
   initial <-
   {
    
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;
  	state.S_O_Saturation = interface.DOsat;
  	 


    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ; 
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
               THEN parameters.ME_unit * state.V
             ELSE 
               IF (parameters.Mixing_When_Aerated)
               THEN parameters.ME_unit * state.V
               ELSE 0;    

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
   };   
 :};	 
	 
	 
 CLASS reaeration_tank 
 (* icon = "activated_sludge_unit" ; is_default = "" *)
 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "Model for an effluent reaeration unit with a fixed volume";
		 
		   independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };

   interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
		 OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   




		 OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
		 OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
		 OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
   };
		 
   parameters <- 
   {
		 OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
   };
   
   state <-
   {
		 OBJ M "Vector containing masses for all the components" : MassVector 
# 206 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl"



























# 241 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl"

;
    OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": MassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all the components": MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
		 
		 OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :};
		 OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
		 		 
		  OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Dimension" :};
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
		 
		   };

   initial <-  
   {
  state.M[IndexOfSolvent] = parameters.Vol / 0.000001;
  };   
		 
   equations <- 
   {
		  {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
		 
		 (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
    In_Terminal[Comp_Index])+
    (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
    Out_Terminal[Comp_Index]);};
		 
		 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};
		 
		 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
    };

    {state.Q_In = (0.000001 
                  * state.InFluxPerComponent[IndexOfSolvent]);
    };
		 
		 state.V = state.M[IndexOfSolvent] * 0.000001;
		 
		 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;};

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_In ;};
		 
		 state.Kla_Actual = interface.Kla;



		 state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
     state.ConversionTermPerComponent[S_O] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]) * state.V;
		 
		 interface.DO = state.C[S_O];
		 interface.TSS = state.C[X_TSS];
		 interface.V_ASU = state.V;
   };   
 :};


# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.pumpedvolumeasu.msl" 1
 


















 CLASS PumpedVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES PumpedVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable pumped volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };   
 :};



# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.varvolumeasu.msl" 1
 


















 CLASS VarVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES VarVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
   };   
 :};



# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.activated_sludge_units.msl" 2




# 33 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 1
 


















 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 1
 


















CLASS  FixVolumeTwoTank
SPECIALISES CoupledModelType :=
{:
 interface <-
 {
  OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :},
  OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent" :},



  OBJ Kla1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU1" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ Kla2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU2" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy1 (* terminal = "out_2" *)"Aeration energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy1 (* terminal = "out_2" *)"Mixing energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ AerationEnergy2 (* terminal = "out_2" *)"Aeration energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy2 (* terminal = "out_2" *)"Mixing energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 37 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2


 };

 parameters <-
 {
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeConversionModel.parameters.msl" 1
 






























# 43 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

  OBJ Vol1 (* is_favorite = "1" *) "Volume of ASU1" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  OBJ Vol2 (* is_favorite = "1" *) "Volume of ASU2" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
 };

 sub_models <-
 {
  OBJ ASU1 : FixVolumeASU,
  OBJ ASU2 : FixVolumeASU,
 };

 coupling <-
 {
   
  sub_models.ASU1.parameters.Vol.value := parameters.Vol1.value,
  sub_models.ASU2.parameters.Vol.value := parameters.Vol2.value,


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 61 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 62 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2








   
  connect(interface.Inflow, sub_models.ASU1.interface.Inflow),
  connect(sub_models.ASU1.interface.Outflow, sub_models.ASU2.interface.Inflow),
  connect(interface.Kla1, sub_models.ASU1.interface.Kla),
  connect(interface.Kla2, sub_models.ASU2.interface.Kla),
  connect(sub_models.ASU1.interface.AerationEnergy, interface.AerationEnergy1),
  connect(sub_models.ASU2.interface.AerationEnergy, interface.AerationEnergy2),
  connect(sub_models.ASU1.interface.MixingEnergy, interface.MixingEnergy1),
  connect(sub_models.ASU2.interface.MixingEnergy, interface.MixingEnergy2),




 };
:};



# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasutwotank.msl" 1
 


















CLASS  FixVolumeASUTwoTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTwoTank:=
{:
 comments <- "A coupled model for two activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU2.interface.Outflow, interface.Outflow),
 };
:};



# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 1
 


















CLASS  FixVolumeThreeTank
EXTENDS FixVolumeTwoTank WITH
{:

 sub_models <-
 {

  OBJ ASU3 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU3" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy3 (* terminal = "out_2" *)"Aeration energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy3 (* terminal = "out_2" *)"Mixing energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol3 (* is_favorite = "1" *) "Volume of ASU3" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU3.parameters.Vol.value := parameters.Vol3.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

 





   

  connect(sub_models.ASU2.interface.Outflow, sub_models.ASU3.interface.Inflow),
  connect(interface.Kla3, sub_models.ASU3.interface.Kla),
  connect(sub_models.ASU3.interface.AerationEnergy, interface.AerationEnergy3),
  connect(sub_models.ASU3.interface.MixingEnergy, interface.MixingEnergy3),




 };
:};



# 24 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuthreetank.msl" 1
 


















CLASS  FixVolumeASUThreeTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeThreeTank:=
{:
 comments <- "A coupled model for three activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU3.interface.Outflow, interface.Outflow),
 };
:};



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 1
 


















CLASS  FixVolumeFourTank
EXTENDS FixVolumeThreeTank WITH
{:

 sub_models <-
 {

  OBJ ASU4 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU4" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy4 (* terminal = "out_2" *)"Aeration energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy4 (* terminal = "out_2" *)"Mixing energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol4 (* is_favorite = "1" *) "Volume of ASU4" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU4.parameters.Vol.value := parameters.Vol4.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

 





   

  connect(sub_models.ASU3.interface.Outflow, sub_models.ASU4.interface.Inflow),
  connect(interface.Kla4, sub_models.ASU4.interface.Kla),
  connect(sub_models.ASU4.interface.AerationEnergy, interface.AerationEnergy4),
  connect(sub_models.ASU4.interface.MixingEnergy, interface.MixingEnergy4),




 };
:};



# 27 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasufourtank.msl" 1
 


















CLASS  FixVolumeASUFourTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFourTank:=
{:
 comments <- "A coupled model for four activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU4.interface.Outflow, interface.Outflow),
 };
:};



# 28 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 1
 


















CLASS  FixVolumeFiveTank
EXTENDS FixVolumeFourTank WITH
{:

 sub_models <-
 {

  OBJ ASU5 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU5" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy5 (* terminal = "out_2" *)"Aeration energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy5 (* terminal = "out_2" *)"Mixing energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol5 (* is_favorite = "1" *) "Volume of ASU5" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU5.parameters.Vol.value := parameters.Vol5.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

 





   

  connect(sub_models.ASU4.interface.Outflow, sub_models.ASU5.interface.Inflow),
  connect(interface.Kla5, sub_models.ASU5.interface.Kla),
  connect(sub_models.ASU5.interface.AerationEnergy, interface.AerationEnergy5),
  connect(sub_models.ASU5.interface.MixingEnergy, interface.MixingEnergy5),




 };
:};



# 30 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasufivetank.msl" 1
 


















CLASS  FixVolumeASUFiveTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFiveTank:=
{:
 comments <- "A coupled model for five activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU5.interface.Outflow, interface.Outflow),
 };
:};



# 31 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 1
 


















CLASS  FixVolumeSixTank
EXTENDS FixVolumeFiveTank WITH
{:

 sub_models <-
 {

  OBJ ASU6 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU6" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy6 (* terminal = "out_2" *)"Aeration energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy6 (* terminal = "out_2" *)"Mixing energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol6 (* is_favorite = "1" *) "Volume of ASU6" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU6.parameters.Vol.value := parameters.Vol6.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

 





   

  connect(sub_models.ASU5.interface.Outflow, sub_models.ASU6.interface.Inflow),
  connect(interface.Kla6, sub_models.ASU6.interface.Kla),
  connect(sub_models.ASU6.interface.AerationEnergy, interface.AerationEnergy6),
  connect(sub_models.ASU6.interface.MixingEnergy, interface.MixingEnergy6),




 };
:};



# 33 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasusixtank.msl" 1
 


















CLASS  FixVolumeASUSixTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSixTank:=
{:
 comments <- "A coupled model for six activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU6.interface.Outflow, interface.Outflow),
 };
:};



# 34 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 1
 


















CLASS  FixVolumeSevenTank
EXTENDS FixVolumeSixTank WITH
{:

 sub_models <-
 {

  OBJ ASU7 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU7" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy7 (* terminal = "out_2" *)"Aeration energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy7 (* terminal = "out_2" *)"Mixing energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol7 (* is_favorite = "1" *) "Volume of ASU7" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU7.parameters.Vol.value := parameters.Vol7.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

 





   

  connect(sub_models.ASU6.interface.Outflow, sub_models.ASU7.interface.Inflow),
  connect(interface.Kla7, sub_models.ASU7.interface.Kla),
  connect(sub_models.ASU7.interface.AerationEnergy, interface.AerationEnergy7),
  connect(sub_models.ASU7.interface.MixingEnergy, interface.MixingEnergy7),




 };
:};



# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuseventank.msl" 1
 


















CLASS  FixVolumeASUSevenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSevenTank:=
{:
 comments <- "A coupled model for seven activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU7.interface.Outflow, interface.Outflow),
 };
:};



# 37 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 1
 


















CLASS  FixVolumeEightTank
EXTENDS FixVolumeSevenTank WITH
{:

 sub_models <-
 {

  OBJ ASU8 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU8" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy8 (* terminal = "out_2" *)"Aeration energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy8 (* terminal = "out_2" *)"Mixing energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol8 (* is_favorite = "1" *) "Volume of ASU8" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU8.parameters.Vol.value := parameters.Vol8.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

 





   

  connect(sub_models.ASU7.interface.Outflow, sub_models.ASU8.interface.Inflow),
  connect(interface.Kla8, sub_models.ASU8.interface.Kla),
  connect(sub_models.ASU8.interface.AerationEnergy, interface.AerationEnergy8),
  connect(sub_models.ASU8.interface.MixingEnergy, interface.MixingEnergy8),




 };
:};



# 39 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasueighttank.msl" 1
 


















CLASS  FixVolumeASUEightTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeEightTank:=
{:
 comments <- "A coupled model for eight activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU8.interface.Outflow, interface.Outflow),
 };
:};



# 40 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 1
 


















CLASS  FixVolumeNineTank
EXTENDS FixVolumeEightTank WITH
{:

 sub_models <-
 {

  OBJ ASU9 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla9 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU9" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy9 (* terminal = "out_2" *)"Aeration energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy9 (* terminal = "out_2" *)"Mixing energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol9 (* is_favorite = "1" *) "Volume of ASU9" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU9.parameters.Vol.value := parameters.Vol9.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

 





   

  connect(sub_models.ASU8.interface.Outflow, sub_models.ASU9.interface.Inflow),
  connect(interface.Kla9, sub_models.ASU9.interface.Kla),
  connect(sub_models.ASU9.interface.AerationEnergy, interface.AerationEnergy9),
  connect(sub_models.ASU9.interface.MixingEnergy, interface.MixingEnergy9),




 };
:};



# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuninetank.msl" 1
 


















CLASS  FixVolumeASUNineTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeNineTank:=
{:
 comments <- "A coupled model for nine activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU9.interface.Outflow, interface.Outflow),
 };
:};



# 43 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 1
 


















CLASS  FixVolumeTenTank
EXTENDS FixVolumeNineTank WITH
{:

 sub_models <-
 {

  OBJ ASU10 : FixVolumeASU,
 };

 parameters <-  
 {
  OBJ Vol10 (* is_favorite = "1" *) "Volume of ASU10" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 interface <-
 {
  OBJ Kla10 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU10" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy10 (* terminal = "out_2" *)"Aeration energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy10 (* terminal = "out_2" *)"Mixing energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 






























# 41 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2


 };

 coupling <-
 {
   
  sub_models.ASU10.parameters.Vol.value := parameters.Vol10.value,
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 















# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 






























# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

 





   

  connect(sub_models.ASU9.interface.Outflow, sub_models.ASU10.interface.Inflow),
  connect(interface.Kla10, sub_models.ASU10.interface.Kla),
  connect(sub_models.ASU10.interface.AerationEnergy, interface.AerationEnergy10),
  connect(sub_models.ASU10.interface.MixingEnergy, interface.MixingEnergy10),




 };
:};



# 45 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasutentank.msl" 1
 


















CLASS  FixVolumeASUTenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTenTank:=
{:
 comments <- "A coupled model for ten activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU10.interface.Outflow, interface.Outflow),
 };
:};



# 46 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.n_tanks.msl" 2




# 34 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.SBR.msl" 1
 


















CLASS SBRAtomicModel
SPECIALISES PhysicalDAEModelType :=
  {:
  
  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "influent" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :};
  OBJ Outflow1 (* terminal = "out_1" *) "effluent" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 1" :};
  };
  
  parameters <- 
  {
   
    OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components": SpecificVolumeVector;
  
   
    OBJ Q_Waste (* is_favorite = "1" *) "Desired waste flow rate during the idle phase" : FlowRate := {: value <- 240; group <- "Operational" :};
  };

  independent <- 
  { 
    OBJ t "Time": Time := {: group <- "Time" :};
  };
    
  state <-
  
  {
    OBJ ConversionTermPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ V (* is_favorite = "1" *) "Volume in the tank" : Volume := {: group <- "Dimension" :};
    OBJ C "Concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
 
    OBJ FluxPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Incoming massflux per component" : MassFluxVector;
 
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
 
    OBJ M "Vector containing masses for all the components" : MassVector 
# 67 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.SBR.msl"



















;
    };
  
  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    };  

  equations <- 
   {
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
       (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
         In_Terminal[Comp_Index])+
       (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
         Out_Terminal[Comp_Index]);
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
     };
   
 
    state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]);

 
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     (parameters.WWTPSpecificVolume[Comp_Index] * state.M[Comp_Index]);

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.C[Comp_Index] = IF (state.V == 0)
                   THEN 0
                 ELSE state.M[Comp_Index]/state.V;
     };  
    };  
    :};

CLASS SBRConversionModel
EXTENDS SBRAtomicModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 129 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.SBR.msl" 2

 :};

CLASS SBRASMConversionModel
EXTENDS SBRConversionModel WITH
 {:
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 








































# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 1


  interface <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.interface.msl" 1


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 



# 5 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.parameters.msl" 1


	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 
 
 



# 10 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  state <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.state.msl" 1


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;
	OBJ K_NH_AUT_Temp	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient := {: group <- "Kinetic" :}; 



# 15 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  initial <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.stoichiometry.msl" 1


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;



# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };

  equations <-
  {
  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.kinetics.msl" 1


 
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);
	state.K_NH_AUT_Temp = parameters.K_NH_AUT * pow(10,(0.051 * state.Temp_Actual - 1.158));

	state.Kinetics[AerHydrol] := state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] := state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] := state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] := state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] := state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] := state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] := state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] := state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] := state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] := state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] := state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] := state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] := state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] := state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] := state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] := state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] := state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] := parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] := parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration] := state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  	
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempModel.sensors.msl" 1


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR = 
          IF(state.V==0) 
          THEN 0 
          ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR = 
          IF(state.V==0) 
          THEN 0 
          ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;



# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASM2dChemTempConversionModel.body.msl" 2

  };



# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2



# 135 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.SBR.msl" 2

 :};
 

    

# 35 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 1
 


















CLASS SBRModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
   OBJ Outflow2 (* terminal = "out_3" *) "bypass" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 2" :};
   OBJ Underflow (* terminal = "out_4" *) "effluent waste" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Underflow" :};
   OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one SBR in a multi-sbr system configuration " : Time 
     := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
   OBJ T1 (* terminal = "in_2"; manip = "1" *) "Period for the fill phase" : Time 
     := {: causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
   OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time 
     := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
   OBJ T4 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ T5 (* terminal = "in_2"; manip = "1" *) "Period for the idle phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate 
       := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};




  };
  
  parameters <- 
  {
  };
  
  state <-
  {
   
    OBJ T "Length of total cycle" : Time := {: group <- "Operational" :};
    OBJ T2 "Period for the reaction phase" : Time := {: value <- 0.125 ; group <- "Operational" :};
    OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
   
    OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    OBJ Q_Bypass "Bypass flow rate" : FlowRate := {: group <- "Operational" :};
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = interface.T1 + state.T2 + interface.T3 + interface.T4 + interface.T5 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;




  };  
    :};


CLASS SBRPointsettler
EXTENDS SBRModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000 ; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0 ; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 10000 ; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1 ; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400 ; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005 ; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2 ; group <- "Settling":};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    };

  equations <-
   {
 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                        THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN 0
        ELSE
          IF (independent.t - state.t_Begin < (interface.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
          THEN 0
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3) )
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
              THEN state.Q_Out_Help_Draw
            ELSE 0;

   state.Q_Bypass =
       
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
     THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN state.Q_In
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN state.Q_In
         ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN state.Q_In
             ELSE state.Q_In;

    state.Q_Under =
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN 0
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN 0
             ELSE state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < interface.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE
       IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
       THEN state.ConversionTermPerComponent[Comp_Index]
       ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
           THEN state.FluxPerComponent[Comp_Index]
           ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:

       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN 0 
        ELSE
          IF (independent.t - state.t_Begin < interface.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
              THEN 0
              ELSE
                IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
                THEN - state.C[Comp_Index] * interface.Q_Draw * parameters.f_ns
                ELSE 0;
     };

    interface.Outflow2[IndexOfSolvent] = - state.Q_Bypass / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      
      interface.Outflow2[Comp_Index] =
       IF (independent.t < interface.T_Launch)
       THEN 0
       ELSE
         IF (independent.t - state.t_Begin < interface.T1)
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
           THEN - state.InFluxPerComponent[Comp_Index]
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
             THEN - state.InFluxPerComponent[Comp_Index]
             ELSE
               IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
               THEN - state.InFluxPerComponent[Comp_Index]
               ELSE - state.InFluxPerComponent[Comp_Index];
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns) ;
     };

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
 
   };
 :};


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler1phasereact.msl" 1
 



















CLASS SBRPointsettler1PhaseReact
(* icon = "sbr"; is_default = "true" *)
EXTENDS SBRPointsettler WITH
 {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFCD" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

state <-
   {
    };
 
 equations <- 
   {
      state.T2 = interface.T2R1 ;
   
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < interface.T1 )
            THEN interface.Kla_Fill 
              ELSE
              IF ((independent.t - state.t_Begin) < (state.T2 +interface.T1))
            THEN interface.Kla_React1 
              ELSE 0; 
   };
   
    :};



# 325 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler2phasereact.msl" 1
 



















 CLASS SBRPointsettler2PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1 )
         THEN interface.Kla_Fill 
           ELSE 
             IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
             THEN interface.Kla_React1 
           ELSE 
               IF ( (independent.t - state.t_Begin)<(state.T2 + interface.T1) )
               THEN interface.Kla_React2
               ELSE 0; 
    };
    
    :};



# 326 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler3phasereact.msl" 1
 



















CLASS SBRPointsettler3PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
  interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
              THEN interface.Kla_React3
                  ELSE 0; 
            
    };
    
    :};



# 327 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler4phasereact.msl" 1
 



















CLASS SBRPointsettler4PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                THEN interface.Kla_React4
                    ELSE 0; 
            
    };
    
    :};



# 328 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler5phasereact.msl" 1
 



















CLASS SBRPointsettler5PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5;
      
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                  THEN interface.Kla_React5
                      ELSE 0; 
            
    };
    
    :};



# 329 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler6phasereact.msl" 1
 














 




CLASS SBRPointsettler6PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                    THEN interface.Kla_React6
                        ELSE 0; 
            
    };
    
    :};



# 330 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler7phasereact.msl" 1
 



















CLASS SBRPointsettler7PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                      THEN interface.Kla_React7
                          ELSE 0; 
            
    };
    
    :};



# 331 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\SBR/wwtp.base.SBR.sbrpointsettler8phasereact.msl" 1
 



















CLASS SBRPointsettler8PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T2R8;
   
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T1))
                        THEN interface.Kla_React7
                        ELSE  
                            IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                        THEN interface.Kla_React8
                            ELSE 0; 
            
    };
    
    :};



# 332 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.SBR.msl" 2




# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 1
 


















CLASS CFCDModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFCD in a multi-CFCD system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};




  };
    
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {: group <- "Operational" :};  
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = state.T1 + interface.T2 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;




  };  
    :};


CLASS CFCDPointsettler
EXTENDS CFCDModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {

 

 

 

 
  
 

 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    };

  equations <-
   {
 
    

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out = state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       DERIV(state.M[Comp_Index],[independent.t]) =
      IF (independent.t < interface.T_Launch)
    THEN state.FluxPerComponent[Comp_Index]
    ELSE
        IF (independent.t - state.t_Begin < state.T1)
        THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
        ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out * parameters.f_ns
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns)
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler1phasereact.msl" 1
 



















CLASS CFCDPointsettler1PhaseReact
(* icon = "cfcd"; is_default = "true" *)
EXTENDS CFCDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed continuous discharge tank with 1 reaction phase";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFCD" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

  state <-

   {
     
    };
 
 equations <- 
   {
      state.T1 = interface.T1R1 ;
  
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN 0
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1 
              ELSE  0; 
   };
   
    :};
 


# 234 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler2phasereact.msl" 1
 



















 CLASS CFCDPointsettler2PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge with 2 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN 0 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 235 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler3phasereact.msl" 1
 



















CLASS CFCDPointsettler3PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 3 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 236 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler4phasereact.msl" 1
 



















CLASS CFCDPointsettler4PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 4 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
      state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
              THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 237 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler5phasereact.msl" 1
 














 




CLASS CFCDPointsettler5PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 5 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 238 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler6phasereact.msl" 1
 



















CLASS CFCDPointsettler6PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 6 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                  THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 239 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler7phasereact.msl" 1
 



















CLASS CFCDPointsettler7PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 7 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;

       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React7
                      ELSE 0; 
            
    };
    
    :};



# 240 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler8phasereact.msl" 1
 



















CLASS CFCDPointsettler8PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 8 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
     
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 241 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFCD.msl" 2





# 37 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 1
 


















CLASS CFIDModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFID in a multi-CFID system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time := {: causality <- "CIN" ; value <- 0.025; group <- "Operational":};
    OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};




  };  
  
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {:value <- 0.25; group <- "Operational" :};
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
    state.T = state.T1 + interface.T2 + interface.T3 ;

 
   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;




  };  
    :};
  

CLASS CFIDPointsettler
EXTENDS CFIDModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 

 

 

 
  
 
 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
 

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                            THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN state.Q_Out_Help
        ELSE
          IF (independent.t - state.t_Begin < (state.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (state.T1 + interface.T2))
          THEN state.Q_Out_Help
          ELSE state.Q_Out_Help_Draw + state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < state.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE state.FluxPerComponent[Comp_Index];
     };

       

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent];

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };
 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler1phasereact.msl" 1
 














 




CLASS CFIDPointsettler1PhaseReact
(* icon = "cfid"; is_default = "true" *)
EXTENDS CFIDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed SBR with 1 reaction phase";
 
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

 parameters <-
   { 
    };

  state <-
   {
    };
 
 equations <- 
   {

    state.T1 = interface.T1R1;
    
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1
              ELSE  0; 
   };
   
    :};



# 248 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler2phasereact.msl" 1
 



















 CLASS CFIDPointsettler2PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 2 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 249 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler3phasereact.msl" 1
 



















CLASS CFIDPointsettler3PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 3 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 250 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler4phasereact.msl" 1
 



















CLASS CFIDPointsettler4PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 4 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 251 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler5phasereact.msl" 1
 



















CLASS CFIDPointsettler5PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 5 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 252 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler6phasereact.msl" 1
 



















CLASS CFIDPointsettler6PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 6 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 253 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler7phasereact.msl" 1
 



















CLASS CFIDPointsettler7PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 7 reaction phases";
  
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React7
                        ELSE 0; 
            
    };
    
    :};



# 254 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\CFID/wwtp.base.CFID.cfidpointsettler8phasereact.msl" 1
 



















CLASS CFIDPointsettler8PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 8 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                        THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 255 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.CFID.msl" 2



# 38 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.clarifier.msl" 1
 



















 CLASS PointSettler
 "Pointsettler"

 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 



    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
    OBJ f_ns_help (* hidden = "1" *) "Non-settleable fraction of suspended solids" : Fraction ;
   };

  equations <-
   {
      
      
  
      
      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
                 THEN state.Q_In
                 ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.f_Out = IF  (state.Q_In <= interface.Q_Under)
              THEN 0
              ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;
    state.f_Under = IF (state.Q_In <= interface.Q_Under)
                THEN 1
              ELSE interface.Q_Under/state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    interface.Underflow[IndexOfSolvent] = IF  (state.Q_In <= interface.Q_Under)
                   THEN - state.Q_In / parameters.WWTPSpecificVolume[IndexOfSolvent]
                   ELSE - interface.Q_Under / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = 
     - state.InFluxPerComponent[Comp_Index]* state.f_Under ;};

      
      
      
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * 
        state.f_ns_help ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

     
# 163 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.clarifier.msl"



    state.X_In =  IF (state.Q_In == 0)
            THEN 0
          ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out =  IF (state.Q_In <= interface.Q_Under)
           THEN 0
           ELSE (- interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under) );

    state.X_Under = IF (state.Q_In <= interface.Q_Under) 
              THEN
                IF (state.Q_In == 0)
                  THEN 0
                ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
            ELSE 
                IF (interface.Q_Under == 0)
                  THEN 0
                ELSE - interface.Underflow[IndexOfTSSComponent] / (interface.Q_Under);


 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };
 :};





# 39 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarypointsettler.msl" 1
 



















 CLASS PrimaryPointSettler  (* icon = "primary_clarifier" ; is_default = "true" *)
 "Point-settler model for primary clarifier"
  EXTENDS PointSettler WITH
  {:
    comments <- "A model for a primary point settler only using mass balances";
    parameters <-
    {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.6 ; group <- "Settling" :};
    };
    equations <-
    {
    state.f_ns_help = parameters.f_ns ;
    };
  :};




# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl" 1
 


















# 261 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl"



# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay.msl" 1
 



















 CLASS Tay
 (* icon = "primary_clarifier" *)
 "The model of Tay for primary clarifiers"

 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Tay";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ T_A "Half removal time" : Time := {: value <- 0.125 ; group <- "Settling" :};
    OBJ Delta_t "Time period defining the interval over which the average flow rate is calculated" : Time := {: value <- 0.1 ; group <- "Settling" :};
    OBJ t_Start "Time where the calculation of the average flow rate starts" : Time := {: value <- 0.1 ; group <- "Settling":};
    
    
    OBJ V_Clar (* is_favorite = "1" *) "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ thelp (* hidden = "1" *) "Previous time help variable" : Time;
    OBJ Qmean (* hidden = "1" *) "Averaged influent flow rate" : FlowRate;
    OBJ Qprev1 (* hidden = "1" *) "Influent flow rate over a period Delta_t back in time" : FlowRate;
    OBJ Qprev2 (* hidden = "1" *) "Influent flow rate over a period Delta_t, two times Delta_t back in time" : FlowRate;
    OBJ Qprev3 (* hidden = "1" *) " Influent flow rate over a period Delta_t, three times Delta_t back in time " : FlowRate;
    OBJ Qprev4 (* hidden = "1" *) " Influent flow rate over a period Delta_t, four times Delta_t back in time " : FlowRate;
    OBJ Qprev5 (* hidden = "1" *) " Influent flow rate over a period Delta_t, five times Delta_t back in time " : FlowRate;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.f_Out := IF (state.Q_In <= interface.Q_Under)
                   THEN 0
       ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;

    state.Qprev1 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN state.Q_In
                     ELSE previous(state.Qprev1);

    state.Qprev2 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev1)
                     ELSE previous(state.Qprev2);

    state.Qprev3 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev2)
                     ELSE previous(state.Qprev3);

    state.Qprev4 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev3)
                     ELSE previous(state.Qprev4);

    state.Qprev5 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev4)
                     ELSE previous(state.Qprev5);

    state.thelp = IF (independent.t < parameters.t_Start)
                   THEN independent.t
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN independent.t
                     ELSE previous(state.thelp);

    state.Qmean = (state.Qprev1 + state.Qprev2 + state.Qprev3 + state.Qprev4 + state.Qprev5) / 5;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] = 
      IF (state.Q_In == 0 || state.Qmean == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                       (state.Q_In * (1 + parameters.V_Clar / (state.Qmean * parameters.T_A)));
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

      
      
# 205 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay.msl"




    state.X_In =  IF (state.Q_In == 0)
      THEN 0
      ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out = IF (state.Q_In <= interface.Q_Under)
      THEN 0
      ELSE - interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under);

    state.X_Under = IF (state.Q_In <= interface.Q_Under) 
        THEN
           IF (state.Q_In == 0)
               THEN 0
           ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
        ELSE 
           IF (interface.Q_Under == 0)
               THEN 0
           ELSE - interface.Underflow[IndexOfTSSComponent] / (interface.Q_Under);

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    }; 
  :};



# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay4.msl" 1
 










 CLASS Tay4
 (* icon = "primary_clarifier" *)
 "Modification of the model of Tay for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Tay";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    		 FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};  
    OBJ E_R_XCOD_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for particulate COD at dry weather flows" : 
	 		Fraction := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XII_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for inert inorganic particulates at dry weather flows" : 
	 		Fraction := {: causality <- "CIN" ; value <- 0.90; group <- "Settling" :};
};

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ Delta_t "Time period defining the interval over which the average flow rate is calculated" : Time := {: value <- 0.1 ; group <- "Settling" :};
    OBJ t_Start "Time where the calculation of the average flow rate starts" : Time := {: value <- 0.1 ; group <- "Settling":};
    
    
    OBJ V_Clar "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
  	OBJ Q_In_DW "Dry weather flow rate" : FlowRate := {: value <- 92000; group <- "Dimension" :};
 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
 
	OBJ T_Average "averaging time used for the calculation of the average retention time"
	: Time := {: value <- 0.04167; group <- "Numeric" :};
	OBJ ID_Q (* hidden = "1" *) "ID for a buffer for the calculation of the average retention time"
	: Time := {: value <- 0.04167; group <- "Numeric" :};
	OBJ Buffer_Fill_Time "Time interval for filling up the buffer" 
	 : Time := {: value <- 0.000001; group <- "Numeric" :};
   };

  state <-
   {
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out_DW (* hidden = "1" *) "Fraction of the influent flux going to the overflow during dry weather" : Fraction;
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
 
    OBJ Qmean (* hidden = "0" *) "Averaged influent flow rate" : FlowRate;
 
 
 
 
 
    OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_In_Calc "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "0" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ E_Removal "Calculated Removal efficiency for each component" : Fraction[NrOfComponents;] := {: group <- "Settling" :};
    OBJ COD_In (* hidden = "1" *) "Incoming flux of COD" : MassFlux;
    OBJ COD_Out (* hidden = "1" *) "Outgoing flux of COD" : MassFlux;
    OBJ XCOD_In (* hidden = "1" *) "Incoming flux of XCOD" : MassFlux;
    OBJ XCOD_Out (* hidden = "1" *) "Outgoing flux of XCOD" : MassFlux;
    OBJ f_ns_XCOD_DW "Non-settlable fraction for particulate COD at dry weather flows" : Fraction := {: group <- "Settling" :};
    OBJ f_ns_XII_DW "Non-settlable fraction for inert inorganic particulates at dry weather flows" : Fraction := {: group <- "Settling" :};
    OBJ E_R_COD "Removal efficiency for COD" : Fraction := {: group <- "Settling" :};
    OBJ E_R_XCOD "Removal efficiency for XCOD" : Fraction := {: group <- "Settling" :};
    OBJ E_R_TSS "Removal efficiency for TSS" : Fraction := {: group <- "Settling" :};
    OBJ E_R_TSS2 "Removal efficiency for TSS" : Fraction := {: group <- "Settling" :};
    OBJ T_A_XCOD "Half removal time for X_COD" : Time := {: group <- "Settling" :};
    OBJ T_A_XII "Half removal time for inert inorganic particulates" : Time := {: group <- "Settling" :};
 
    OBJ Buffer_Q (* hidden = "1" *) "buffer for the calculation of the average retention time" : MassFlux;
 
   };

    initial <-  
    {
 
 
 
	parameters.ID_Q = MSLUBufferCreate(parameters.T_Average,parameters.Buffer_Fill_Time);
   };
   
  equations <-
   {
    state.f_Out_DW = (parameters.Q_In_DW - interface.Q_Under)/parameters.Q_In_DW;
 	  state.f_ns_XCOD_DW = (1.0 - interface.E_R_XCOD_DW) / state.f_Out_DW;
	  state.f_ns_XII_DW = (1.0 - interface.E_R_XII_DW) / state.f_Out_DW;

      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
				   		   THEN 0
 
				   		   ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

	 

    state.Buffer_Q = MSLUBufferPut(parameters.ID_Q, independent.t, state.Q_In);
    state.Qmean = MSLUBufferGetMean(parameters.ID_Q);	
 
	
 
    state.f_Out := IF (state.Q_In <= 0)
                   THEN 0
 			 	   ELSE (state.Q_In - state.Q_Under_Actual) / state.Q_In ;

 









































 

 
 

	state.T_A_XCOD = (parameters.V_Clar/parameters.Q_In_DW) * (state.f_ns_XCOD_DW/(1-state.f_ns_XCOD_DW));
	state.T_A_XII = (parameters.V_Clar/parameters.Q_In_DW) * (state.f_ns_XII_DW/(1-state.f_ns_XII_DW));
	
    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      

 
 
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. X_AUT}:
      interface.Outflow[Comp_Index] = 
			IF (state.Q_In == 0 || state.Qmean == 0)
			THEN 0
			ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                       (1 + parameters.V_Clar / (state.Qmean * state.T_A_XCOD));
     };

 
 
 
    {FOREACH Comp_Index IN {X_MEOH .. X_I_i}:
      interface.Outflow[Comp_Index] = 
			IF (state.Q_In == 0 || state.Qmean == 0)
			THEN 0
			ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                       (1 + parameters.V_Clar / (state.Qmean * state.T_A_XII));
     };

	interface.Outflow[X_TSS] = interface.Outflow[X_I] * parameters.i_TSS_X_I
							  + interface.Outflow[X_S] * parameters.i_TSS_X_S
							  + interface.Outflow[X_H] * parameters.i_TSS_BM
							  + interface.Outflow[X_PAO] * parameters.i_TSS_BM
							  + interface.Outflow[X_PP] * 3.23
							  + interface.Outflow[X_PHA] * 0.6
							  + interface.Outflow[X_AUT] * parameters.i_TSS_BM
							  + interface.Outflow[X_MEOH] * 1.0
							  + interface.Outflow[X_MEP] * 1.0
							  + interface.Outflow[X_I_i] * 1.0;
	 
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

      
      
# 288 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay4.msl"




    state.X_In = IF (state.Q_In == 0)
			   	 THEN 0
				 ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_In_Calc = (interface.Inflow[X_I] * parameters.i_TSS_X_I
							  + interface.Inflow[X_S] * parameters.i_TSS_X_S
							  + interface.Inflow[X_H] * parameters.i_TSS_BM
							  + interface.Inflow[X_PAO] * parameters.i_TSS_BM
							  + interface.Inflow[X_PP] * 3.23
							  + interface.Inflow[X_PHA] * 0.6
							  + interface.Inflow[X_AUT] * parameters.i_TSS_BM
							  + interface.Inflow[X_MEOH] * 1.0
							  + interface.Inflow[X_MEP] * 1.0
							  + interface.Inflow[X_I_i] * 1.0) / state.Q_In;
				 
    state.X_Out = IF (state.Q_In <= interface.Q_Under)
				  THEN - interface.Outflow[IndexOfTSSComponent] / (state.Q_In)
 
				  ELSE - interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under);

     state.X_Under = 
    		IF (state.Q_Under_Actual <= 0)
			THEN 0
			ELSE - interface.Underflow[IndexOfTSSComponent] / state.Q_Under_Actual;
     
 












 
	   state.E_R_TSS = (1 - state.X_Out / state.X_In);
	   state.E_R_TSS2 = (1 - state.X_Out / state.X_In_Calc);
	   
       state.COD_Out = - interface.Outflow[S_I] - interface.Outflow[S_A] - interface.Outflow[S_F]
	   				   - interface.Outflow[X_I] - interface.Outflow[X_S] - interface.Outflow[X_H]
	   				   - interface.Outflow[X_PAO] - interface.Outflow[X_PAO] - interface.Outflow[X_AUT];
       state.COD_In = interface.Inflow[S_I] + interface.Inflow[S_A] + interface.Inflow[S_F]
	   				   + interface.Inflow[X_I] + interface.Inflow[X_S] + interface.Inflow[X_H]
	   				   + interface.Inflow[X_PAO] + interface.Inflow[X_PAO] + interface.Inflow[X_AUT];
	  
	   state.E_R_COD = (1 - state.COD_Out / state.COD_In);

       state.XCOD_Out = - interface.Outflow[X_I] - interface.Outflow[X_S] - interface.Outflow[X_H]
	   				   - interface.Outflow[X_PAO] - interface.Outflow[X_PAO] - interface.Outflow[X_AUT];
       state.XCOD_In = interface.Inflow[X_I] + interface.Inflow[X_S] + interface.Inflow[X_H]
	   				   + interface.Inflow[X_PAO] + interface.Inflow[X_PAO] + interface.Inflow[X_AUT];
	  
	   state.E_R_XCOD = (1 - state.XCOD_Out / state.XCOD_In);

    }; 
  :};






# 23 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.lessardbeck.msl" 1
 


















# 623 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.lessardbeck.msl"



# 24 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacs.msl" 1
 



















 CLASS PrimaryTakacs
 (* icon = "primary_clarifier" *)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1"*) "Height of the sludge blanket" : 
         Length := {: causality <- "COUT" ; group <- "Measurement data":};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length  := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration  := {: group <- "Settling" :};  
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration  := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration  := {: group <- "Concentration" :}; 
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration  := {: group <- "Concentration" :};   
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE 
      - state.InFluxPerComponent[Comp_Index] * 
      (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE
      - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) *
      state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual /
                  parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] -
      interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
    ELSE
      - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) *
      state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;
 
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacssolublespropagator.msl" 1
 


















# 471 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacssolublespropagator.msl"



# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsallfractionpropagator.msl" 1
 



















 CLASS PrimaryTakacsAllFractionPropagator
 (* icon = "primary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 









{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
state.X_Layer[Layer_Index] = state.C[IndexOfTSSComponent][Layer_Index];
};


 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};



# 27 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsreactive1.msl" 1
 


















# 625 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsreactive1.msl"




# 28 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

 
 
 
 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.removalfractions.msl" 1
 









 
 CLASS SimpleRemovalFractions
 (* icon = "primary_clarifier" *)
 "Simple model for primary clarifiers with different removal efficiencies for different fractions"

 
 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Tay";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    		 FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};  
    OBJ E_R_SI_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for S_I at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.0; group <- "Settling" :};
    OBJ E_R_SA_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for S_A at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.0; group <- "Settling" :};
    OBJ E_R_SF_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for S_F at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.0; group <- "Settling" :};
    OBJ E_R_SNO_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for S_NO at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.0; group <- "Settling" :};
    OBJ E_R_SNH_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for S_NH at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.0; group <- "Settling" :};
    OBJ E_R_SPO_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for S_PO at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XS_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for X_S at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XI_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for X_I at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XH_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for X_H at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XAUT_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for X_AUT at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XPAO_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for X_PAO at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XPP_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for X_PP at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XPHA_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for X_PHA at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.50; group <- "Settling" :};
    OBJ E_R_XII_DW (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Removal efficiency for inert inorganic particulates at dry weather flows" : 
	 		Real := {: causality <- "CIN" ; value <- 0.90; group <- "Settling" :};
};

  parameters <- 
   { 
 
    
    
    OBJ V_Clar "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	 
 
   };

  state <-
   {
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out_DW (* hidden = "1" *) "Fraction of the influent flux going to the overflow during dry weather" : Fraction;
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
 
    OBJ E_R_COD "Removal efficiency for COD" : Fraction := {: group <- "Settling" :};
    OBJ E_R_XCOD "Removal efficiency for XCOD" : Fraction := {: group <- "Settling" :};
    OBJ E_R_TSS "Removal efficiency for TSS" : Fraction := {: group <- "Settling" :};

    OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_In_Calc "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "0" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ COD_In (* hidden = "1" *) "Incoming flux of COD" : MassFlux;
    OBJ COD_Out (* hidden = "1" *) "Outgoing flux of COD" : MassFlux;
    OBJ XCOD_In (* hidden = "1" *) "Incoming flux of XCOD" : MassFlux;
    OBJ XCOD_Out (* hidden = "1" *) "Outgoing flux of XCOD" : MassFlux;
 
 
   };

    initial <-  
    {
   };
   
  equations <-
   {


      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
				   		   THEN 0
 
				   		   ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

	
 
    state.f_Out := IF (state.Q_In <= 0)
                   THEN 0
 			 	   ELSE (state.Q_In - state.Q_Under_Actual) / state.Q_In ;



   		

      interface.Outflow[H2O] = - state.InFluxPerComponent[H2O] * state.f_Out ;
      interface.Outflow[S_I] = - state.InFluxPerComponent[S_I] * state.f_Out *(1.0 - interface.E_R_SI_DW);
	      interface.Outflow[S_O] = - state.InFluxPerComponent[S_O] * state.f_Out ;
      interface.Outflow[S_N2] = - state.InFluxPerComponent[S_N2] * state.f_Out ;
      interface.Outflow[S_F] = - state.InFluxPerComponent[S_F] * state.f_Out *(1.0 - interface.E_R_SF_DW);
      interface.Outflow[S_A] = - state.InFluxPerComponent[S_A] * state.f_Out *(1.0 - interface.E_R_SA_DW);
      interface.Outflow[S_Al] = - state.InFluxPerComponent[S_Al] * state.f_Out ;
      interface.Outflow[S_NO] = - state.InFluxPerComponent[S_NO] * state.f_Out *(1.0 - interface.E_R_SNO_DW);
      interface.Outflow[S_PO] = - state.InFluxPerComponent[S_PO] * state.f_Out *(1.0 - interface.E_R_SPO_DW);
      interface.Outflow[S_NH] = - state.InFluxPerComponent[S_NH] * state.f_Out *(1.0 - interface.E_R_SNH_DW);
      interface.Outflow[S_ALK] = - state.InFluxPerComponent[S_ALK] * state.f_Out ;
	 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      

 
 
	 
	
      interface.Outflow[X_I] = IF (state.Q_In == 0)
															 THEN 0
															 ELSE - state.InFluxPerComponent[X_I] * state.f_Out *(1.0 - interface.E_R_XI_DW);
      interface.Outflow[X_S] = IF (state.Q_In == 0)
															 THEN 0
															 ELSE - state.InFluxPerComponent[X_S] * state.f_Out *(1.0 - interface.E_R_XS_DW);
      interface.Outflow[X_H] = IF (state.Q_In == 0)
															 THEN 0
															 ELSE - state.InFluxPerComponent[X_H] * state.f_Out *(1.0 - interface.E_R_XH_DW);
      interface.Outflow[X_PAO] = IF (state.Q_In == 0)
															 THEN 0
															 ELSE - state.InFluxPerComponent[X_PAO] * state.f_Out *(1.0 - interface.E_R_XPAO_DW);
      interface.Outflow[X_PP] = IF (state.Q_In == 0)
															 THEN 0
															 ELSE - state.InFluxPerComponent[X_PP] * state.f_Out *(1.0 - interface.E_R_XPP_DW);
      interface.Outflow[X_PHA] = IF (state.Q_In == 0)
															 THEN 0
															 ELSE - state.InFluxPerComponent[X_PHA] * state.f_Out *(1.0 - interface.E_R_XPHA_DW);
      interface.Outflow[X_AUT] = IF (state.Q_In == 0)
															 THEN 0
															 ELSE - state.InFluxPerComponent[X_AUT] * state.f_Out *(1.0 - interface.E_R_XAUT_DW);
	 


 
 
 
    {FOREACH Comp_Index IN {X_MEOH .. X_I_i}:
      interface.Outflow[Comp_Index] = 
			IF (state.Q_In == 0)
			THEN 0
			ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out *(1.0 - interface.E_R_XII_DW);
     };

	interface.Outflow[X_TSS] = interface.Outflow[X_I] * parameters.i_TSS_X_I
							  + interface.Outflow[X_S] * parameters.i_TSS_X_S
							  + interface.Outflow[X_H] * parameters.i_TSS_BM
							  + interface.Outflow[X_PAO] * parameters.i_TSS_BM
							  + interface.Outflow[X_PP] * 3.23
							  + interface.Outflow[X_PHA] * 0.6
							  + interface.Outflow[X_AUT] * parameters.i_TSS_BM
							  + interface.Outflow[X_MEOH] * 1.0
							  + interface.Outflow[X_MEP] * 1.0
							  + interface.Outflow[X_I_i] * 1.0;
	 
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

      
      
# 260 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.removalfractions.msl"




    state.X_In = IF (state.Q_In == 0)
			   	 THEN 0
				 ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_In_Calc = (interface.Inflow[X_I] * parameters.i_TSS_X_I
							  + interface.Inflow[X_S] * parameters.i_TSS_X_S
							  + interface.Inflow[X_H] * parameters.i_TSS_BM
							  + interface.Inflow[X_PAO] * parameters.i_TSS_BM
							  + interface.Inflow[X_PP] * 3.23
							  + interface.Inflow[X_PHA] * 0.6
							  + interface.Inflow[X_AUT] * parameters.i_TSS_BM
							  + interface.Inflow[X_MEOH] * 1.0
							  + interface.Inflow[X_MEP] * 1.0
							  + interface.Inflow[X_I_i] * 1.0) / state.Q_In;
				 
    state.X_Out = IF (state.Q_In <= interface.Q_Under)
				  THEN - interface.Outflow[IndexOfTSSComponent] / (state.Q_In)
 
				  ELSE - interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under);

     state.X_Under = 
    		IF (state.Q_Under_Actual <= 0)
			THEN 0
			ELSE - interface.Underflow[IndexOfTSSComponent] / state.Q_Under_Actual;
     
 












 
	    
	   state.E_R_TSS = (1 - state.X_Out / state.X_In_Calc);
	   
       state.COD_Out = - interface.Outflow[S_I] - interface.Outflow[S_A] - interface.Outflow[S_F]
	   				   - interface.Outflow[X_I] - interface.Outflow[X_S] - interface.Outflow[X_H]
	   				   - interface.Outflow[X_PAO] - interface.Outflow[X_PAO] - interface.Outflow[X_AUT];
       state.COD_In = interface.Inflow[S_I] + interface.Inflow[S_A] + interface.Inflow[S_F]
	   				   + interface.Inflow[X_I] + interface.Inflow[X_S] + interface.Inflow[X_H]
	   				   + interface.Inflow[X_PAO] + interface.Inflow[X_PAO] + interface.Inflow[X_AUT];
	  
	   state.E_R_COD = (1 - state.COD_Out / state.COD_In);

       state.XCOD_Out = - interface.Outflow[X_I] - interface.Outflow[X_S] - interface.Outflow[X_H]
	   				   - interface.Outflow[X_PAO] - interface.Outflow[X_PAO] - interface.Outflow[X_AUT];
       state.XCOD_In = interface.Inflow[X_I] + interface.Inflow[X_S] + interface.Inflow[X_H]
	   				   + interface.Inflow[X_PAO] + interface.Inflow[X_PAO] + interface.Inflow[X_AUT];
	  
	   state.E_R_XCOD = (1 - state.XCOD_Out / state.XCOD_In);

    }; 
  :};



 


# 34 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\primary_clarifier/wwtp.base.primary_clarifier.removalrates.msl" 1
 











 CLASS removal_rates
  
 (* icon = "primary_clarifier" *)
 "Model of settling with removal rates and fixed DO, for DAF, CEPT etc."				

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
	  OBJ val (* terminal = "in_2" *) "Inflow" : 
         Real := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
   };

  parameters <- 
   { 
    OBJ threshold "value > threshold = removals a, value <= threshold = removals b" : 
         Real := {: value <- 1 ; group <- "Settling" :};
	  OBJ f_NH4a "Non-settleable fraction of NH4 above threshold" : 
         Fraction := {: value <- 1 ; group <- "Settling" :};
    OBJ f_PO4a "Non-settleable fraction of PO4 above threshold" : 
         Fraction := {: value <- 0.12 ; group <- "Settling" :};
	  OBJ f_sCODa "Non-settleable fraction of sCOD above threshold" : 
         Fraction := {: value <- 0.75 ; group <- "Settling" :};
	  OBJ f_TSSa "Non-settleable fraction of TSS above threshold" : 
         Fraction := {: value <- 0.11 ; group <- "Settling" :};
	  OBJ f_NH4b "Non-settleable fraction of NH4 below threshold" : 
         Fraction := {: value <- 1 ; group <- "Settling" :};
    OBJ f_PO4b "Non-settleable fraction of PO4 below threshold" : 
         Fraction := {: value <- 0.94 ; group <- "Settling" :};
	  OBJ f_sCODb "Non-settleable fraction of sCOD below threshold" : 
         Fraction := {: value <- 0.9 ; group <- "Settling" :};
	  OBJ f_TSSb "Non-settleable fraction of TSS below threshold" : 
         Fraction := {: value <- 0.45 ; group <- "Settling" :};
    OBJ Q_Under "Underflow rate" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	  OBJ DO_out "Effluent DO" : Concentration := {: value <- 0.1 ; group <- "Operational" :};
   };

  state <-
   {
    OBJ f_NH4 "Non-settleable fraction of NH4" : Fraction := {: group <- "Settling" :};
    OBJ f_PO4 "Non-settleable fraction of PO4" : Fraction := {: group <- "Settling" :};
	  OBJ f_sCOD "Non-settleable fraction of sCOD" : Fraction := {: group <- "Settling" :};
	  OBJ f_TSS "Non-settleable fraction of TSS" : Fraction := {: group <- "Settling" :};
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
	  OBJ P_removed "P removed" : MassFlux := {: group <- "Operational" :};
   };

  equations <-
   {
      
      
  
      
      
      
	 
	 state.f_NH4 = IF (interface.val <= parameters.threshold)
	 			   		 THEN parameters.f_NH4b
				  			 ELSE parameters.f_NH4a;
	 state.f_PO4 = IF (interface.val <= parameters.threshold)
	 			  		  THEN parameters.f_PO4b
				   			ELSE parameters.f_PO4a;
	 state.f_sCOD = IF (interface.val <= parameters.threshold)
	 			  			 THEN parameters.f_sCODb
				  			  ELSE parameters.f_sCODa;
	 state.f_TSS = IF (interface.val <= parameters.threshold)
	 			  		  THEN parameters.f_TSSb
				   			ELSE parameters.f_TSSa;

   state.Q_Under_Actual = IF (state.Q_In <= parameters.Q_Under)
				   		  			   THEN state.Q_In * 0.9
				   		 			    ELSE parameters.Q_Under; 

   state.Q_Out = state.Q_In - state.Q_Under_Actual;


   state.f_Out = IF	(state.Q_In <= state.Q_Under_Actual)
		      	 		THEN 0
		      	 	  ELSE (state.Q_In - state.Q_Under_Actual) / state.Q_In ;
   state.f_Under = IF (state.Q_In <= state.Q_Under_Actual)
		          	 	THEN 1
		        			 ELSE state.Q_Under_Actual/state.Q_In ;

	  interface.Outflow[IndexOfSolvent] = - state.InFluxPerComponent[IndexOfSolvent] * state.f_Out ;
	  interface.Outflow[S_I] = - state.InFluxPerComponent[S_I] * state.f_sCOD ;
	  interface.Outflow[S_O] = - state.Q_Out * parameters.DO_out ;
	  interface.Outflow[S_N2] = - state.InFluxPerComponent[S_N2] * state.f_Out ;
	  interface.Outflow[S_F] = - state.InFluxPerComponent[S_F] * state.f_sCOD ;
	  interface.Outflow[S_A] = - state.InFluxPerComponent[S_A] * state.f_sCOD ;
	  interface.Outflow[S_Al] = - state.InFluxPerComponent[S_Al] * state.f_Out ;
	  interface.Outflow[S_NO] = - state.InFluxPerComponent[S_NO] * state.f_Out ;
	  interface.Outflow[S_NH] = - state.InFluxPerComponent[S_NH] * state.f_NH4 ;
	  interface.Outflow[S_PO] = - state.InFluxPerComponent[S_PO] * state.f_PO4 ;
	  interface.Outflow[S_ALK] = - state.InFluxPerComponent[S_ALK] * state.f_Out ;

    interface.Underflow[IndexOfSolvent] = IF	(state.Q_In <= state.Q_Under_Actual)
		  			 		   										  THEN - state.Q_In / 0.000001
		  			 		  										   ELSE - state.Q_Under_Actual / 0.000001 ;

    interface.Underflow[S_I] = - (state.InFluxPerComponent[S_I] + interface.Outflow[S_I]) ;
	  interface.Underflow[S_O] = 0;
	
	  {FOREACH Comp_Index IN {S_N2 .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = 
     - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      
      
      


    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * state.f_TSS ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = 
	   - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]);};

    state.X_In = 	IF (state.Q_In == 0)
			   			  	THEN 0
									 ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out =  IF (state.Q_In <= state.Q_Under_Actual)
			 	  			  THEN 0
			 	  			  ELSE (- interface.Outflow[IndexOfTSSComponent] / (state.Q_In - state.Q_Under_Actual) );

    state.X_Under = IF (state.Q_In <= state.Q_Under_Actual) 
			  	  				THEN IF (state.Q_In == 0)
  		         	  		  THEN 0
		   	   		  			 ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
			  						ELSE IF (state.Q_Under_Actual == 0)
  		         	 		   THEN 0
		   	   		 			  ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_Under_Actual);
	  state.P_removed = interface.Inflow[S_PO] + interface.Outflow[S_PO];
   };
 :};
 
 
# 35 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.primary_clarifier.msl" 2




# 40 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarypointsettler.msl" 1
 



















 CLASS SecondaryPointSettler
 (* icon = "secondary_clarifier" *)
 "Point-settler model for secondary clarifiers"
  EXTENDS PointSettler WITH
  {:
    comments <- "A model for a secondary point settler only using mass balances";
    parameters <-
    {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.005 ; group <- "Settling" :};
    };
    equations <-
    {
    state.f_ns_help = parameters.f_ns ;
    };
  :};




# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.marsililibelli.msl" 1
 



















 CLASS MarsiliLibelli
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
 
 
 
 
 
 
 
 
 
 
 
 
 
   Comments <- "A model for a secondary settler by Marsili Libelli";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ A (* is_favorite = "1" *) "Surface of secondary clarifier" : Area := {: value <- 400 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of secondary clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Limit sedimentation velocity for diluted suspensions" : Velocity := {: value <- 4 ; group <- "Settling" :};
    OBJ N "Cole sludge concentration dependency parameter" : Real := {: value <- 2.75 ; group <- "Settling" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ J_T "Total sludge flux" : ArealFlux := {: group <- "Settling" :};
    OBJ help (* hidden = "1" *) "Help variable" : Real;
    OBJ AA (* hidden = "1" *) "Help variable" : Real;
    OBJ U "Underflow velocity" : Velocity := {: group <- "Settling" :};
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ M "Mass of sludge in secondary clarifier" : Mass := {: group <- "Mass" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_L "Limiting sludge biomass concentration" : Concentration := {: group <- "Settling" :};
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {           
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 
    
    state.U = state.Q_Under_Actual / parameters.A;

    state.AA = 1 - parameters.N;
    state.help = IF (state.U == 0)
         THEN 0
         ELSE log(-state.U / (state.AA * parameters.v0)) ;

    state.J_T = 1000 * (parameters.v0 * exp(state.AA / (state.AA - 1) * state.help) + state.U *
               exp(1 / (state.AA - 1) * state.help));
    state.X_L = 1000 * exp(1 / (state.AA - 1) * state.help);

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.H_S = state.M / state.X_L / parameters.A;

    state.X_Out = IF (state.H_S <= parameters.H)
                THEN 0
                ELSE state.X_L;

 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

    state.X_Under = IF (( state.SolidFlux_In) >= (parameters.A *state.J_T))   
          THEN
              IF (state.Q_Under_Actual == 0)
          THEN 0 
          ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                    ELSE
                      IF (state.H_S > 0)
                      THEN
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                      ELSE
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE state.SolidFlux_In / state.Q_Under_Actual;

    {DERIV(state.M,[independent.t]) =
             IF (state.SolidFlux_In >= (parameters.A * state.J_T))
             THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
             ELSE
               IF (state.H_S > 0)
               THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
               ELSE 0;
    };

 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
interface.Overflow[Comp_Index] = 
IF (state.Q_In == 0)
    THEN 0 
    ELSE
- state.InFluxPerComponent[Comp_Index] * state.Q_Out / state.Q_In;
      };

       interface.Underflow[IndexOfSolvent] = 
              - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent];

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] = 
 - (state.InFluxPerComponent[Comp_Index]
        + interface.Overflow[Comp_Index]) ;
     };

    interface.TSS = state.M /(parameters.A * parameters.H);

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };
 :};




# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondaryotterpohlfreund.msl" 1
 



















 CLASS SecondaryOtterpohlFreund
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
 
 
 
 
 
 
 
 
 
 
 
 
 
 

   Comments <- "A model for a secondary settler by Otterpohl and Freund";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge volume index" : Real := 
        {: 
          causality <- "CIN" ; 
      value <- 100;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; upperBound <- 1000; :};
        :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {
    
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v_FS "Settling velocity for small fraction of solids" : Velocity := {: value <- 0.24 ; group <- "Settling" :};
    OBJ f0 "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.04;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ A_FS "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.00078;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ J_Up_FS (* hidden = "1" *) "Upward sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_Up_FM (* hidden = "1" *) "Upward sludge flux of the macroflocs" : TakacsArealFluxVector;
    OBJ J_Dn_FS (* hidden = "1" *) "Downward sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_Dn_FM (* hidden = "1" *) "Downward sludge flux macroflocs" : TakacsArealFluxVector;
    OBJ J_G_FS (* hidden = "1" *) "Static sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_G_FM (* hidden = "1" *) "Static sludge flux of the macroflocs" : TakacsArealFluxVector;
    OBJ J_G_FM_Help (* hidden = "1" *) "Static sludge flux of the macroflocs": TakacsArealFluxVector;
    OBJ J_G_FS_Help (* hidden = "1" *) "Static sludge flux of the small solids fraction": TakacsArealFluxVector;
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;

    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};

    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    
    OBJ X_FM_Layer "Vector containing concentration of macroflocs for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ X_FS_Layer "Vector containing concentration of small solids  for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
    OBJ v_FM "Settling velocity for macroflocs" : TakacsVelocityVector := {: group <- "Settling" :};
    OBJ f1 "Fraction of small solids" : Fraction := {: group <- "Influent characterization" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  

     
    OBJ B (* hidden = "1" *) "variable B of the omega function" : Real ;
    OBJ help_var_omega (* hidden = "1" *) "help state" : Real ;
    
    OBJ H_T "Height of transition point" : Length := {: group <- "Settling" :};
    OBJ H_C "Height of compressing point" : Length := {: group <- "Settling" :};
    OBJ H0 "Height of influent" : Length := {: group <- "Dimension" :};
    OBJ omega (* hidden = "1" *) "Hartels omega function" : Real[NrOfLayers;] ;
    OBJ z (* hidden = "1" *) "Vertical coordinate, bottom z=0" : LengthVector ;
    OBJ X_C "Solids concentration at compression point" : Concentration := {: group <- "Settling" :};
    OBJ X_AT "Solids concentration of the aeration tank" : Concentration := {: group <- "Concentration" :};
    OBJ X_FM_AT "Solids concentration of the aeration tank, macroflocs" : Concentration := {: group <- "Concentration" :};
    OBJ X_FS_AT "Solids concentration of the aeration tank, small solids" : Concentration := {: group <- "Concentration" :};
    OBJ k (* hidden = "1" *) "Part of the Vesilind equation, here results of Hartel" : Real ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of small solids and macroflocs" : Concentration ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
    state.H0 = ((NrOfLayers - IndexOfFeedLayer) + 0.5) * state.H_Layer;
    state.X_C = 480 / interface.SVI ;
    state.k = 1.043 - 0.9834 * exp( -0.00581 * interface.SVI) ;
    state.help_var_omega = -(1 + 2 * interface.SVI / (100 + interface.SVI));

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
     state.z[Layer_Index] =
        ((NrOfLayers - Layer_Index) + 0.5) * state.H_Layer ;
    };

   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


     
     
     
    state.B = - (( 100 + interface.SVI) / interface.SVI + 1)
                * pow(state.H_C, (1 + 2 * interface.SVI / (100 + interface.SVI)));

    

    state.H_T = IF(2 * state.H_C > state.H0)
                THEN state.H0
                ELSE 2 * state.H_C ;

    state.H_C = (state.X_AT * state.H0 / state.X_C) * (1 - 1 / (state.X_C * state.k)) ;
    state.X_AT = IF (state.Q_In == 0 )
             THEN 0
         ELSE state.SolidFlux_In / state.Q_In;

 
 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.omega[Layer_Index] = IF (state.H_T == 0)
             THEN 1 / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega))
             ELSE (1 - state.B * pow(state.H_T,state.help_var_omega))
              / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega));
    };

    state.f1 = parameters.f0 * exp( - parameters.A_FS * state.X_AT) ;

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.v_FM[Layer_Index] = 
             (17.4 * exp(-0.00581 * interface.SVI) + 3.931)
             * (exp(-(-0.9834e-3 * exp(-0.00581 * interface.SVI) + 1.043e-3)
                       * (state.X_FM_Layer[Layer_Index] + state.X_FS_Layer[Layer_Index])))
             * 24 ;
    };

     
     
     

    state.X_FM_AT = state.X_AT * (1 - state.f1) ;
    state.X_FS_AT = state.X_AT * state.f1 ;

    state.v_Up = state.Q_Out / parameters.A; 
    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FM_Help[Layer_Index] =
        state.v_FM[Layer_Index] * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FS_Help[Layer_Index] =
        parameters.v_FS * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FS[Layer_Index] =
        state.v_Up * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FM[Layer_Index] =
        state.v_Up * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FS[Layer_Index] =
        state.v_Dn * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FM[Layer_Index] =
        state.v_Dn * state.X_FM_Layer[Layer_Index];
    };

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FS[Layer_Index] =
        IF (state.J_G_FS_Help[Layer_Index] > state.J_G_FS_Help[Layer_Index+1])
        THEN state.J_G_FS_Help[Layer_Index+1]
        ELSE state.J_G_FS_Help[Layer_Index] ;
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FM[Layer_Index] =
        IF (state.J_G_FM_Help[Layer_Index] > state.J_G_FM_Help[Layer_Index+1])
        THEN state.J_G_FM_Help[Layer_Index+1]
        ELSE state.J_G_FM_Help[Layer_Index] ;
    };

     
     
     

    { DERIV(state.X_FS_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FS[2] - state.J_G_FS[1] - ( state.Q_Out / parameters.A * state.X_FS_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FS_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FS[Layer_Index] - state.J_Up_FS[Layer_Index]
             + state.J_G_FS[Layer_Index-1]
             - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * state.f1
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FS[Layer_Index+1] - ( state.J_Up_FS[Layer_Index])
                - state.J_G_FS[Layer_Index] + state.J_G_FS[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FS[Layer_Index-1] - ( state.J_Dn_FS[Layer_Index])
                + (state.J_G_FS[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FS_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FS[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FS_Layer[NrOfLayers])
       + (state.J_G_FS[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    { DERIV(state.X_FM_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FM[2] - state.J_G_FM[1] - ( state.Q_Out / parameters.A * state.X_FM_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FM_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FM[Layer_Index] - state.J_Up_FM[Layer_Index]
             + state.J_G_FM[Layer_Index-1]
             - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * (1 - state.f1)
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FM[Layer_Index+1] - ( state.J_Up_FM[Layer_Index])
                - state.J_G_FM[Layer_Index] + state.J_G_FM[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FM[Layer_Index-1] - ( state.J_Dn_FM[Layer_Index])
                + (state.J_G_FM[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FM_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FM[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FM_Layer[NrOfLayers])
       + (state.J_G_FM[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_FS_Layer[1] + state.X_FM_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_FS_Layer[NrOfLayers] + state.X_FM_Layer[NrOfLayers];

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    }; 

    { state.SolidConcentration = (SUMOVER Layer_Index IN {1 .. NrOfLayers}:
       state.X_FS_Layer[Layer_Index] + state.X_FM_Layer[Layer_Index]) ;
    };

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.takacs.msl" 1
 



















 
 
 

 CLASS Takacs
 (* icon = "secondary_clarifier"*)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
         THEN parameters.v00
         ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};




# 23 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.takacssvi.msl" 1
 




















 CLASS Takacs_SVI
 (* icon = "secondary_clarifier"; is_default = "true" *)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge Volume Index in mL/g" : 
      Real := {: causality <- "CIN" ; value <- 100 ; group <- "Settling" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.r_H = (0.148 + 0.00210 * interface.SVI) / 1000;

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

 
    state.v0_H = parameters.v0 * exp(state.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

 








    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - state.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
         THEN parameters.v00
         ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};





# 24 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl" 1
 


















# 475 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"



# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacsallfractionpropagator.msl" 1
 



















 CLASS SecondaryTakacsAllFractionPropagator
 (* icon = "secondary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Specific volume of the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
                        THEN 0
                        ELSE state.SolidFlux_In / state.Q_In;
     };

 









{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
state.X_Layer[Layer_Index] = state.C[IndexOfTSSComponent][Layer_Index];
};


 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

    interface.Sludge_Blanket_Height = state.H_S;
 
    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

   
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.secondary_clarifier.burger.msl" 1
 














 
 






CLASS Burger
  (* icon = "secondary_clarifier" *)
  "Layered clarifier model by Burger with Vesilind settling function" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A model for a secondary settler by Burger with Vesilind settling";
    interface <-
    {
		OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
		OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
		OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
		OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
		 
		OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    };
    parameters <-
    {
		OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/d2)": Acceleration := {: value <- 7.32312576e10 :};
		OBJ PI (* hidden = "1" *) "PI": Real := {: value <- 3.141592653 :};
		OBJ A "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
		OBJ H "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
		OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
		OBJ X_Lim "Minimum concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
		OBJ Vs_Switch "1=Vsilind, 2=Takacs, 3=Cho" : Integer :={: value <-2 ; group <- "Settling" :};
		 
		OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
		OBJ r_V "Settling parameter" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :};
		 
		OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
		OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
		OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
		OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
		 
		OBJ k "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
		OBJ n "Settling parameter" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :};
		 
		OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
		 
		 
		OBJ Comp_ON "Switch on/off compression": Integer :={: value <- 0 ; group <- "Compression" :};
		OBJ Alpha "Effective solids stress parameter" : BurgerSolidsStress := {: value <- 0.8 ; group <- "Compression" :};

		OBJ Rhos "Solid density": Density := {: value <- 1050000 ; group <- "Compression" :};
		OBJ Rhof "Fluid density": Density := {: value <- 998000 ; group <- "Compression" :};
		OBJ C_crit "Gel point" : Concentration := {: value <- 6000 ; group <- "Compression" :};
		 
		OBJ C_min "Minimum packing concentration" : Concentration := {: value <- 0 ; group <- "Settling" :};
		OBJ C_max "Maximum packing concentration" : Concentration := {: value <- 20000 ; group <- "Settling" :};
		OBJ TOL "Tolerance level to calculate concentration with maximum settling flux" : Fraction := {: value <- 1e-10 ; group <- "Settling" :};
		 
		OBJ Disp_ON "Switch on/off dispersion": Integer :={: value <- 0 ; group <- "Dispersion" :};
		OBJ a_mix "Dispersion parameter" : Length := {: value <- 0.4 ; group <- "Dispersion" :};
		OBJ b_mix "Dispersion parameter" : BurgerDispersion := {: value <- 0.00001 ; group <- "Dispersion" :}; 
		OBJ batch "Switch ON/OFF batch mode" : Integer :={: value <- 1 ; group <- "Settling" :};
    };
    state <-
    {
		 
		OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
		OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;
		OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
		OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :};
		OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
        OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
		OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": BurgerVelocityVector;
		OBJ v_S_Help2 (* hidden = "1" *) "Static settling velocity help variable": BurgerVelocityVector;
		OBJ v_S (* hidden = "1" *) "Static settling velocity" : BurgerVelocityVector;
		OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : BurgerArealFluxVector;
		OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : BurgerArealFluxVector;
		OBJ J_G (* hidden = "1" *) "Static sludge flux" : BurgerArealFluxVector;
		OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": BurgerArealFluxVector;
		OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
		OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
		OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
		OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;
		OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
		OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
		OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
		
		 
		OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Under_Actual "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
		OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :};
		OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Layer "Vector containing concentration of particulates for all the layers" : BurgerConcentrationVector := {: group <- "Concentration" :};
		 
		OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
		 
		 
	    	OBJ D_comp (* hidden = "0" *) "Primitive of compression function" : BurgerLengthFluxVector;
		
		 
		OBJ Fbk_max "Maximum flux" : ArealFlux := {: group <- "Settling" :};
		OBJ C_fbk_max "Concentration corresponding to maximal settling flux" : Concentration := {: group <- "Settling" :};
		
		 
	    	OBJ d_mix (* hidden = "0" *) "Dispersion function" : BurgerDiffusivityVector;
		OBJ z (* hidden = "0" *) "Height in clarifier" : BurgerLengthVector;

		 
        OBJ FbkPrimeVector (* hidden = "1" *) "Vector containing derivative of flux function for all the layers" : BurgerArealFluxVector2;
		OBJ ConcVector (* hidden = "1" *) "Vector containing concentrations between Cmin and Cmax" : BurgerConcentrationVector2;
		OBJ FbkPrimeMax (* hidden = "1" *) "Maximum of flux derivative" : ArealFlux;
		OBJ QfMax (* hidden = "1" *) "maximum incoming velocity" : Velocity;
		OBJ DcompMax (* hidden = "1" *) "maximum value of compression" : LengthFlux;
		OBJ d_mixMax (* hidden = "1" *) "maximal value of disperion" : Diffusivity; 
		OBJ d_mixMaxHelp (* hidden = "1" *) "maximal value of disperion" : Diffusivity; 
		OBJ CFL (* hidden = "0" *) "maximum allowed time-step" : Time;
		};
    initial <-
    {
		parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
		state.V_Layer = parameters.A * (parameters.H / NrOfLayersBurger);
		state.H_Layer = parameters.H / (NrOfLayersBurger);

		 
		 
		
		state.C_fbk_max = IF (parameters.Vs_Switch == 1) 
			THEN MSLUBurgerCHat(parameters.v0, parameters.r_V, parameters.C_min, parameters.C_max, parameters.TOL)
			ELSE MSLUBurgerCHat(parameters.v0, parameters.r_H, parameters.C_min, parameters.C_max, parameters.TOL);
		state.Fbk_max = IF (parameters.Vs_Switch == 1) THEN parameters.v0 * exp(-parameters.r_V * state.C_fbk_max) * state.C_fbk_max 
			ELSE parameters.v0 * exp(-parameters.r_H * state.C_fbk_max) * state.C_fbk_max;
		
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.z[Layer_Index] =
		  	fabs(state.H_Layer * (Layer_Index - IndexOfFeedLayerBurger)) ; };
			
		 
		{ FOREACH Conc_Index IN {1 .. NrOfConcentration}: state.ConcVector[Conc_Index] =(Conc_Index-1)*(parameters.C_max-parameters.C_min)/(NrOfConcentration-1);};
	
		{ FOREACH Conc_Index IN {1 .. NrOfConcentration}: state.FbkPrimeVector[Conc_Index] =
		  	IF (parameters.Vs_Switch == 1)
			THEN parameters.v0 * exp(-parameters.r_V * state.ConcVector[Conc_Index])*(1-parameters.r_V*state.ConcVector[Conc_Index])
			ELSE 
				IF (parameters.Vs_Switch == 2)
				THEN parameters.v0 * (
				     (exp(-parameters.r_H * state.ConcVector[Conc_Index])-exp(-parameters.r_P*state.ConcVector[Conc_Index]))
				     +(exp(-parameters.r_H*state.ConcVector[Conc_Index])*(-parameters.r_H)-exp(-parameters.r_P*state.ConcVector[Conc_Index])*(-parameters.r_P))
				     *state.ConcVector[Conc_Index])
				ELSE 0;
		};
		
		state.FbkPrimeMax=MSLUGetMax(ref(state.FbkPrimeVector[1]),NrOfConcentration);
		
		state.DcompMax=parameters.Comp_ON*parameters.Alpha*pow(24*3600,2)* parameters.Rhos * parameters.v0 *
			exp(-parameters.r_V * parameters.C_crit)/(parameters.g*(parameters.Rhos-parameters.Rhof));
    };
    independent <-
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    equations <-
    {
		state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under) THEN state.Q_In
			ELSE interface.Q_Under ;
		state.v_Dn = state.Q_Under_Actual / parameters.A ;
		
		{ FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
		  	SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

		state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]);
		state.Q_Out = state.Q_In - state.Q_Under_Actual ;

		




		
		state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];
		

		state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;
		{state.SolidConcentration = ( SUMOVER Layer_Index IN {3 .. NrOfLayersPlusTwoBurger}:
			state.X_Layer[Layer_Index]) / NrOfLayersBurger; };
		
		state.X_Min = IF (state.Q_In == 0)
		THEN parameters.f_ns * state.SolidConcentration
		ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

		state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

		state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 
			
		state.v_Up = state.Q_Out / parameters.A ;

		 
		
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
			state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) 
			THEN 0 
			ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
		};
		
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
			state.v_S_Help2[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > parameters.v00)
			THEN parameters.v00
			ELSE state.v_S_Help[Layer_Index]);
		};


		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.v_S[Layer_Index] =
		  	IF (parameters.Vs_Switch == 1)
			THEN parameters.v0 * exp(-parameters.r_V * state.X_Layer[Layer_Index])
			ELSE 
				IF (parameters.Vs_Switch == 2)
				THEN state.v_S_Help2[Layer_Index]
				ELSE 
					IF (state.X_Layer[Layer_Index]==0)
					THEN 0
					ELSE parameters.k*exp(-parameters.n*state.X_Layer[Layer_Index])/state.X_Layer[Layer_Index];
		};		

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.J_G_Help[Layer_Index] =
		  	state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };
	
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}: state.J_G[Layer_Index] =
		  	IF (state.X_Layer[Layer_Index]<state.X_Layer[Layer_Index+1]) THEN MSLUGetMin2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1])
			   ELSE IF (((state.C_fbk_max-state.X_Layer[Layer_Index])*(state.C_fbk_max-state.X_Layer[Layer_Index+1]))<0) THEN state.Fbk_max
			   ELSE MSLUGetMax2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1]) ; };
	
		 
		{ FOREACH Layer_Index IN {2 .. IndexOfFeedLayerBurger}: state.J_Up[Layer_Index] =
		  	state.v_Up * state.X_Layer[Layer_Index] ; };
		{ FOREACH Layer_Index IN {IndexOfFeedLayerBurger .. NrOfLayersPlusFourBurger}: state.J_Dn[Layer_Index] =
		  	state.v_Dn * state.X_Layer[Layer_Index] ; };

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.D_comp[Layer_Index] =
		       (IF (state.X_Layer[Layer_Index] < parameters.C_crit) THEN 0
		 	   ELSE
				(IF (parameters.Vs_Switch == 1) 
				THEN parameters.Comp_ON * parameters.Alpha *pow(24*3600,2) * parameters.Rhos * parameters.v0 *
				(exp(-parameters.r_V * state.X_Layer[Layer_Index])-exp(-parameters.r_V * parameters.C_crit)) /
				(-parameters.r_V * parameters.g * (parameters.Rhos-parameters.Rhof))
				ELSE parameters.Comp_ON * parameters.Alpha *pow(24*3600,2) * parameters.Rhos * parameters.v0 *
				(exp(-parameters.r_H * state.X_Layer[Layer_Index])-exp(-parameters.r_H * parameters.C_crit)) /
				(-parameters.r_H * parameters.g * (parameters.Rhos-parameters.Rhof)))
			   ) ;
   	    	};

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.d_mix[Layer_Index] =
		  	IF (state.z[Layer_Index] < (parameters.b_mix*state.Q_In))
			THEN parameters.Disp_ON * parameters.a_mix/parameters.A * state.Q_In *
			  pow(cos(parameters.PI*state.z[Layer_Index]/(2*parameters.b_mix*state.Q_In)),2)
			ELSE 0 ; };

		
		 
				
		state.QfMax = MSLUGetMax2(state.Q_In/parameters.A, state.QfMax);
				
		state.d_mixMaxHelp=parameters.Disp_ON*parameters.a_mix/parameters.A * state.Q_In;
		state.d_mixMax =MSLUGetMax2(state.d_mixMaxHelp,state.d_mixMax);
		
		state.CFL=1/(1/state.H_Layer*(state.QfMax+state.FbkPrimeMax)+(2/pow(state.H_Layer,2))*(state.DcompMax+state.d_mixMax));	
				

		 
		 
		{ DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * parameters.batch * (state.J_Up[2]) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };
		{ DERIV(state.X_Layer[2],[independent.t]) = (1 / state.H_Layer) * parameters.batch * (state.J_Up[3] - state.J_Up[2] - state.J_G[2] + (1 / state.H_Layer) *(state.D_comp[3]- state.D_comp[2])); };
		
		 
		{ DERIV(state.X_Layer[3],[independent.t]) = IF (3 == IndexOfFeedLayerBurger)
		  	THEN (1 / state.H_Layer) * (- state.J_Up[3] - state.J_Dn[3] + state.J_G[2] - state.J_G[3] +
			(1 / state.H_Layer) *(state.d_mix[3]*(state.X_Layer[4]-state.X_Layer[3]) + state.D_comp[4]+state.D_comp[2]-2*state.D_comp[3])) + 
			(1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[4] - state.J_Up[3] + state.J_Dn[2] - state.J_Dn[3] + state.J_G[2] -
			state.J_G[3] + (1 / state.H_Layer) *(state.d_mix[3]*((state.X_Layer[4]-state.X_Layer[3])) + state.D_comp[4]+state.D_comp[2] -
			2*state.D_comp[3])); };
		
		 
		{ FOREACH Layer_Index IN {4 .. NrOfLayersPlusOneBurger}: DERIV(state.X_Layer[Layer_Index],[independent.t]) =
		  	IF (Layer_Index == IndexOfFeedLayerBurger) THEN (1 / state.H_Layer) * (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
			   state.d_mix[Layer_Index] *(state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) 
			   - state.d_mix[Layer_Index-1] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) + 
			   state.D_comp[Layer_Index+1] + state.D_comp[Layer_Index-1] - 2*state.D_comp[Layer_Index])) +
			   (1 / state.V_Layer) * state.SolidFlux_In
			   ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index] + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
				state.d_mix[Layer_Index]*(state.X_Layer[Layer_Index+1] - 
			   state.X_Layer[Layer_Index]) - state.d_mix[Layer_Index-1] *(state.X_Layer[Layer_Index]-state.X_Layer[Layer_Index-1]) +
			   state.D_comp[Layer_Index+1]+state.D_comp[Layer_Index-1]-2*state.D_comp[Layer_Index])) ; };

		 
		{ DERIV(state.X_Layer[NrOfLayersPlusTwoBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusOneBurger] 
				- parameters.batch*state.J_Dn[NrOfLayersPlusTwoBurger] +
		  		state.J_G[NrOfLayersPlusOneBurger] - parameters.batch*state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) * (
				-state.d_mix[NrOfLayersPlusOneBurger] * (parameters.batch*state.X_Layer[NrOfLayersPlusTwoBurger] - state.X_Layer[NrOfLayersPlusOneBurger]) + 
				parameters.batch*state.D_comp[NrOfLayersPlusThreeBurger] + state.D_comp[NrOfLayersPlusOneBurger] - state.D_comp[NrOfLayersPlusTwoBurger]
				- parameters.batch*state.D_comp[NrOfLayersPlusTwoBurger])) ; };
		
		 
		{ DERIV(state.X_Layer[NrOfLayersPlusThreeBurger],[independent.t]) = parameters.batch*((1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusTwoBurger] - state.J_Dn[NrOfLayersPlusThreeBurger] +
		  		state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) *(state.D_comp[NrOfLayersPlusTwoBurger]-state.D_comp[NrOfLayersPlusThreeBurger]))) ; };
		{ DERIV(state.X_Layer[NrOfLayersPlusFourBurger],[independent.t]) = parameters.batch*((1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusThreeBurger] - state.J_Dn[NrOfLayersPlusFourBurger])); };

		state.X_Out = IF (state.Q_Out == 0)	THEN 0 ELSE state.X_Layer[1] ;
		state.X_Under = IF (state.Q_Under_Actual == 0) THEN 0 ELSE state.X_Layer[NrOfLayersPlusFourBurger] ;
		
		 
		state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayersPlusTwoBurger,parameters.X_Lim) ;
		state.H_S = (NrOfLayersPlusTwoBurger - state.IndexOfSludgeBlanket) * state.H_Layer ;

		 
		state.SolidFlux_Out = state.X_Out * state.Q_Out ;
		{ FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent} : interface.Overflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0	ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
		  		IF (state.SolidFlux_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

		 
		state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
		interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
		{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}: interface.Underflow[Comp_Index] =
		  		- state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

		 
		 
		interface.Sludge_Blanket_Height = state.H_S ;
		interface.TSS = state.SolidConcentration ;
		interface.V_Clarifier = parameters.A * parameters.H ;  
		 
		 
		DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
		interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    };

 :};




# 29 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.secondary_clarifier.plosz.msl" 1
 




















CLASS BasePlosz
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   interface <-
   {
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" :};
   OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" :};
   OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" :};
   OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    
   OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 754 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 3 ; group <- "Dimension" :};
 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.001375 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ L_60 "Fraction of  underflow withdrawn from layer 60" : Real := {: value <- 0.25 :};
    OBJ L_59 "Fraction of  underflow withdrawn from layer 59" : Real := {: value <- 0.25 :};
    OBJ L_58 "Fraction of  underflow withdrawn from layer 58" : Real := {: value <- 0.25 :};
    OBJ L_57 "Fraction of  underflow withdrawn from layer 57" : Real := {: value <- 0.075 :};
    OBJ L_56 "Fraction of  underflow withdrawn from layer 56" : Real := {: value <- 0.075 :};
    OBJ L_55 "Fraction of  underflow withdrawn from layer 55" : Real := {: value <- 0.05 :};
    OBJ L_54 "Fraction of  underflow withdrawn from layer 54" : Real := {: value <- 0.05 :};
 
    OBJ Eta_Con "Downwards convection control" : Velocity := {: value <- 0.504 :};
    OBJ D_01 "Over flow dependent dispersion model parameter" : Diffusivity := {: value <- 3.95 :}; 
    OBJ V_OV_DIS "Boundary overflow velocity for dispersion" : Velocity := {: value <- 15 :}; 
    OBJ V_F_CON "Boundary feedflow velocity for convection" : Length := {: value <- 30.5 :};
    OBJ g_Dis "Dispersion function coefficient" : Time := {: value <- 0.022 :}; 
 
    OBJ D_C_max "Maximum value of the dispersion coefficient" : Real := {: value <- 15 :};
 
 
    OBJ L_F_max "Maximum height of the feed layer" : Real := {: value <- 32 :};
 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : PloszConcentrationVector := {: group <- "Concentration" :};
 
    OBJ D_Con_Help (* hidden = "1" *) "Help for the over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ D_Con "Over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ V_Ff "Clarifier feed velocity" : Velocity;
    OBJ V_Fo "Clarifier overflow velocity" : Velocity;
    OBJ Eta_CC "Feed velocity dependent convection reduction factor" : Real;
    OBJ Eta_Con_Help (* hidden = "1" *) "Help for convection reduction factor" : Real;
 
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;	
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : PloszVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": PloszVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : PloszArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : PloszArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : PloszArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": PloszArealFluxVector;
 
    OBJ DynamicIndexOfFeedLayer_Help (* hidden = "1" *) "Dynamic Index of Feed Layer - HELP" : Real;
    OBJ DynamicIndexOfFeedLayer "Dynamic Index of Feed Layer" : Real := {: group <- "Operational" :};
 
    OBJ J_Dis (* hidden = "1" *) "Dispersion flux": PloszArealFluxVector;
    OBJ D_1 (* hidden = "1" *) "Dispersion with the following layer ": PloszDiffusivityVector; 
    OBJ D_2 (* hidden = "1" *) " Dispersion with the precedent layer ": PloszDiffusivityVector; 
    OBJ J_GUp_Help (* hidden = "1" *) "Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective help fluxes": PloszArealFluxVector; 
    OBJ J_GUp (* hidden = "1" *) " Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective fluxes": PloszArealFluxVector; 
 
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;	
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    parameters.WWTPSpecificVolume[H2O] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / 60); 
    state.H_Layer = parameters.H / 60;
   };

  independent <- { OBJ t "Time": Time; };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

 
    state.v_Dn = (state.Q_Under_Actual / parameters.A) * state.Eta_CC; 

 
 
    state.DynamicIndexOfFeedLayer_Help = MSLUFindThreshold(ref(state.X_Layer[1]),60,state.X_In);
    state.DynamicIndexOfFeedLayer = MSLUGetMax2(state.DynamicIndexOfFeedLayer_Help,parameters.L_F_max);
 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
			SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

    state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]) ;

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 







    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;

	{ state.SolidConcentration =
			(SUMOVER Layer_Index IN {1 .. 60}: state.X_Layer[Layer_Index]) / 60 ; };

    state.X_Min = IF (state.Q_In == 0) THEN parameters.f_ns * state.SolidConcentration
			ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

 




    state.v_Up = state.Q_Out / parameters.A; 

 
    state.V_Ff = state.Q_In / parameters.A;
    state.V_Fo = state.Q_Out / parameters.A;

    state.D_Con_Help = IF (state.V_Fo < parameters.V_OV_DIS) THEN parameters.D_01
			ELSE parameters.D_01 + parameters.g_Dis * (state.V_Fo - parameters.V_OV_DIS) * (state.V_Fo - parameters.V_OV_DIS) ;

    state.D_Con = MSLUGetMin2(state.D_Con_Help, parameters.D_C_max);
	 
    state.Eta_Con_Help = IF (state.V_Ff < parameters.V_F_CON) THEN parameters.Eta_Con
			ELSE parameters.Eta_Con + (state.V_Ff - parameters.V_F_CON) /  parameters.V_F_CON * (state.V_Ff - parameters.V_F_CON) / parameters.V_F_CON;

    state.Eta_CC = MSLUGetMin2(state.Eta_Con_Help, 1.0);
 
    
 
    { FOREACH Layer_Index IN {1 .. 59}: state.D_1[Layer_Index] = state.D_Con ; };
    { FOREACH Layer_Index IN {1 .. 60}: state.D_2[Layer_Index] = state.D_Con ; };
 

 







        
    { FOREACH Layer_Index IN {1 .. 60}: state.J_G_Help[Layer_Index] =
			state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };

 
    { FOREACH Layer_Index IN {2 .. 60}: state.J_Up[Layer_Index] = 
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 0		   
					ELSE state.v_Up * state.X_Layer[Layer_Index]; };	 

 
    { FOREACH Layer_Index IN {1 .. 59}: state.J_Dn[Layer_Index] =
			IF (Layer_Index >= state.DynamicIndexOfFeedLayer) THEN state.v_Dn * state.X_Layer[Layer_Index]	 
					ELSE 0; }; 								  	   		 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_Dis[Layer_Index] =
			- state.D_2[Layer_Index] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) / state.H_Layer
			+ state.D_1[Layer_Index] * (state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) / state.H_Layer ; };
 

 

 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_G[Layer_Index-1] =
			IF (Layer_Index <= state.DynamicIndexOfFeedLayer) THEN
					IF (state.J_G_Help[Layer_Index-1] <= state.J_G_Help[Layer_Index]) THEN state.J_G_Help[Layer_Index-1]
					   		ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index-1] ; };

    { FOREACH Layer_Index IN {1 .. 59}: state.J_G[Layer_Index] =
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 
					IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1]) THEN state.J_G_Help[Layer_Index+1]
							ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index] ; };
 


 
    { DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1] + state.D_1[1] * (state.X_Layer[2]
			- state.X_Layer[1]) / state.H_Layer) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };

    { FOREACH Layer_Index IN {2 .. 53}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == state.DynamicIndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]);
    };

 
    { DERIV(state.X_Layer[54],[independent.t]) = IF (54 == state.DynamicIndexOfFeedLayer)
	  		THEN (1 / state.H_Layer) * (state.J_Up[55] - state.J_Up[54] + state.J_Dn[53] - state.J_Dn[54]
			+ state.J_G[53] - state.J_G[54] + state.J_Dis[54]) - ((state.Q_Under_Actual * parameters.L_54)
			/ state.V_Layer) * state.X_Layer[54] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[55] - state.J_Up[54] + state.J_Dn[53] - state.J_Dn[54]
			+ state.J_G[53] - state.J_G[54] + state.J_Dis[54]) - ((state.Q_Under_Actual * parameters.L_54)
			/ state.V_Layer) * state.X_Layer[54] ; };

    { DERIV(state.X_Layer[55],[independent.t]) = IF (55 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[56] - state.J_Up[55] + state.J_Dn[54] - state.J_Dn[55]
			+ state.J_G[54] - state.J_G[55] + state.J_Dis[55]) - ((state.Q_Under_Actual * parameters.L_55)
			/ state.V_Layer) * state.X_Layer[55] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[56] - state.J_Up[55] + state.J_Dn[54] - state.J_Dn[55]
			+ state.J_G[54] - state.J_G[55] + state.J_Dis[55]) - ((state.Q_Under_Actual * parameters.L_55)
			/ state.V_Layer) * state.X_Layer[55] ; };

    { DERIV(state.X_Layer[56],[independent.t]) = IF (56 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[57] - state.J_Up[56] + state.J_Dn[55] - state.J_Dn[56]
			+ state.J_G[55] - state.J_G[56] + state.J_Dis[56]) - ((state.Q_Under_Actual * parameters.L_56)
			/ state.V_Layer) * state.X_Layer[56] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[57] - state.J_Up[56] + state.J_Dn[55] - state.J_Dn[56]
			+ state.J_G[55] - state.J_G[56] + state.J_Dis[56]) - ((state.Q_Under_Actual * parameters.L_56)
			/ state.V_Layer) * state.X_Layer[56] ; };

    { DERIV(state.X_Layer[57],[independent.t]) =  IF (57 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[58] - state.J_Up[57] + state.J_Dn[56] - state.J_Dn[57]
			+ state.J_G[56] - state.J_G[57] + state.J_Dis[57]) - ((state.Q_Under_Actual * parameters.L_57)
			/ state.V_Layer) * state.X_Layer[57] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[58] - state.J_Up[57] + state.J_Dn[56] - state.J_Dn[57]
			+ state.J_G[56] - state.J_G[57] + state.J_Dis[57]) - ((state.Q_Under_Actual * parameters.L_57)
			/ state.V_Layer) * state.X_Layer[57] ; };

    { DERIV(state.X_Layer[58],[independent.t]) = IF (58 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[59] - state.J_Up[58] + state.J_Dn[57] - state.J_Dn[58]
			+ state.J_G[57] - state.J_G[58] + state.J_Dis[58]) - ((state.Q_Under_Actual * parameters.L_58)
			/ state.V_Layer) * state.X_Layer[58] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[59] - state.J_Up[58] + state.J_Dn[57] - state.J_Dn[58]
			+ state.J_G[57] - state.J_G[58] + state.J_Dis[58]) - ((state.Q_Under_Actual * parameters.L_58)
			/ state.V_Layer) * state.X_Layer[58] ; };

    { DERIV(state.X_Layer[59],[independent.t]) = IF (59 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Up[60] - state.J_Up[59] + state.J_Dn[58] - state.J_Dn[59]
			+ state.J_G[58] - state.J_G[59] + state.J_Dis[59]) - ((state.Q_Under_Actual * parameters.L_59)
			/ state.V_Layer) * state.X_Layer[59] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[60] - state.J_Up[59] + state.J_Dn[58] - state.J_Dn[59]
			+ state.J_G[58] - state.J_G[59] + state.J_Dis[59]) - ((state.Q_Under_Actual * parameters.L_59)
			/ state.V_Layer) * state.X_Layer[59] ; };

    { DERIV(state.X_Layer[60],[independent.t]) =  IF (60 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] ; };

    state.X_Out = IF (state.Q_Out == 0) THEN 0
			ELSE state.X_Layer[1]; 
 

 

    state.X_Under = IF (state.Q_Under_Actual == 0)
			  THEN 0
			  ELSE state.X_Layer[60] * parameters.L_60 + state.X_Layer[59] * parameters.L_59 + 
			  state.X_Layer[58] * parameters.L_58 + state.X_Layer[57] * parameters.L_57 + state.X_Layer[56] * parameters.L_56 + state.X_Layer[55] * parameters.L_55 + state.X_Layer[54] * parameters.L_54; 

 

 
    state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),60,parameters.X_Lim) ;
    state.H_S = (60 - state.IndexOfSludgeBlanket + 1) * state.H_Layer ;

 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}: interface.Overflow[Comp_Index] =
	  		IF (state.Q_In == 0) THEN 0
			ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
			IF (state.SolidFlux_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

 
    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
			interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
			IF (state.Q_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

 
 
    interface.Sludge_Blanket_Height = state.H_S;
    interface.TSS = state.SolidConcentration;
    interface.V_Clarifier = parameters.A * parameters.H;  

	 
	DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual ;
	interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};




CLASS Plosz
 (* icon = "secondary_clarifier" *)
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 103.012 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.0002526 ; group <- "Settling" :}; 
   };

  equations <-
   {
    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > parameters.v0) THEN parameters.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 30 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.secondary_clarifier.ploszsvi.msl" 1
 




















CLASS PloszSVI
 (* icon = "secondary_clarifier" *)
 "Layered convection-dispersion model of the secondary settling tank - Benedek Gy. Plosz"

 
 
 
 
 

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    
    OBJ V_alpha "SSVI3.5(ml/g) - V0(m/d) exponential regression - alpha value" : Real := {: value <- 133.7472 :};
    OBJ V_beta "SSVI3.5(ml/g) - V0(m/d) exponential regression - exponent" : Real := {: value <- -0.0034467 :};
    OBJ r_H_lambda "SSVI3.5(ml/g) - r_H(m3/g) linear regression - slope" : Real := {: value <- 0.0000026 :};
    OBJ r_H_kappa "SSVI3.5(ml/g) - r_H(m3/g) linear regression - y-intercept" : Real := {: value <- 0.0000628 :};
    OBJ DSVI "Diluted sludge volume index, DSVI (ml/g)" : SpecificVolume := {: value <- 85 :};
    OBJ p_SVI "SSVI3.5/DSVI ratio" : Real := {: value <- 0.658 :};
    
   };

   state <-
   {
 
    OBJ v0 "Maximum theoretical settling velocity" : Velocity ;
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume ;
 
   };

  equations <-
   {
 
    state.v0 = parameters.V_alpha * exp(parameters.V_beta * parameters.DSVI * parameters.p_SVI);
    state.r_H = parameters.r_H_lambda * parameters.DSVI * parameters.p_SVI + parameters.r_H_kappa;
	
    state.v0_P = state.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = state.v0 * exp(state.r_H * state.X_Min);

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - state.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > state.v0) THEN state.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 31 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.secondary_clarifier.burgerdoubleexponential.msl" 1
 





 
 






  OBJ Legendre_Index "Temporary iteration variable, index of Gaussian quadrature" : Integer;
  OBJ NrOfNodes "The number of nodes and weights used in the Gaussian Quadrature for compression calculation" : Integer := 16; 

CLASS BurgerDoubleExponential
 (* icon = "secondary_clarifier" ; is_default = "" *)
 "Layered clarifier model by Burger with double exponential settling function"

 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
	 		 FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

   parameters <- 
   {     
    OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
    OBJ A "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  	OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
	  OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};


    
      
 
 
	 
    
      
       OBJ Comp "Parameter to switch off compression; 1: on 0: off": Integer :={: value <- 1 ; group <- "Compression" :};
	   OBJ alpha "Effective solids stress parameter" : NormalStress := {: value <- 5 ; group <- "Compression" :};
       OBJ beta "Effective solids stress parameter" : Concentration := {: value <- 4 ; group <- "Compression" :};
	   OBJ rhos "Solid density": Density := {: value <- 1050 ; group <- "Compression" :};
	   OBJ rhof "Fluid density": Density := {: value <- 998 ; group <- "Compression" :};
	   OBJ C_crit "Gel point" : Concentration := {: value <- 600 ; group <- "Compression" :};
	   OBJ gr "Acceleration of gravity": Acceleration := {: value <- 9.81 ; group <- "Compression" :};
	   OBJ wl (* hidden = "1" *) "Vector of Legendre weights used in the Gaussian quadrature for the calculation of compression": 
	   	   Real[NrOfNodes;] := [{: value <- 2.715245941175406e-2 :},{: value <- 6.225352393864778e-2 :},{: value <- 9.515851168249290e-2 :},
		   {: value <- 1.246289712555339e-1 :},{: value <- 1.495959888165768e-1 :},{: value <- 1.691565193950026e-1 :},{: value <- 1.826034150449236e-1 :},
		   {: value <- 1.894506104550684e-1 :},{: value <- 1.894506104550684e-1 :},{: value <- 1.826034150449236e-1 :},
		   {: value <- 1.691565193950026e-1 :},{: value <- 1.495959888165768e-1 :},{: value <- 1.246289712555339e-1 :},
		   {: value <- 9.515851168249290e-2 :},{: value <- 6.225352393864778e-2 :},{: value <- 2.715245941175406e-2 :}]; 
	   OBJ nl (* hidden = "1" *) "Vector of Legendre nodes used in the Gaussian quadrature for the calculation of compression": 
	   	   Real[NrOfNodes;] := [{: value <- 9.894009349916499e-1 :},{: value <- 9.445750230732326e-1 :},{: value <- 8.656312023878319e-1 :},
		   {: value <- 7.554044083550031e-1 :},{: value <- 6.178762444026438e-1 :},{: value <- 4.580167776572273e-1 :},{: value <- 2.816035507792589e-1 :},
		   {: value <- 9.501250983763748e-2 :},{: value <- -9.501250983763748e-2 :},{: value <- -2.816035507792589e-1 :},
		   {: value <- -4.580167776572273e-1 :},{: value <- -6.178762444026438e-1 :},{: value <- -7.554044083550031e-1 :},
		   {: value <- -8.656312023878319e-1 :},{: value <- -9.445750230732326e-1 :},{: value <- -9.894009349916499e-1 :}];
	    
	   OBJ C_min "Minimal packing concentration" : Concentration := {: value <- 0 ; group <- "Settling" :};
	   OBJ C_max "Maximal packing concentration" : Concentration := {: value <- 2000 ; group <- "Settling" :};
	   OBJ TOL "Tolerance level to calculate CHat" : Fraction := {: value <- 1e-15 ; group <- "Settling" :};     
   };

   state <-
   {
    
    
	OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
	OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};	
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};	 
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : BurgerConcentrationVector := {: group <- "Concentration" :};
	OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;	
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v_S (* hidden = "0" *) "Static settling velocity" : BurgerVelocityVector;
    OBJ J_Up "Upward sludge flux" : BurgerArealFluxVector;
    OBJ J_Dn "Downward sludge flux" : BurgerArealFluxVector;
    OBJ J_G "Static sludge flux" : BurgerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": BurgerArealFluxVector;
	OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;	
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
	OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;

	
	 
	   
       
 
 

    
	 
	   
	    OBJ X_comp (* hidden = "1" *) "Vector with max(Cj,Ccrit)" : BurgerConcentrationVector := {: group <- "Concentration" :};
	    OBJ J_comp_help (* hidden = "1" *) "Compression sludge flux" : BurgerArealFluxVector;
		OBJ J_comp (* hidden = "1" *) "Compression sludge flux" : BurgerArealFluxVector;
		OBJ HelpPar1 (* hidden = "1" *) "rhos*v0*alpha/(g*(rhos-rhof))" : Real;
		OBJ HelpPar2 (* hidden = "1" *) "-Ccrit+beta" : Concentration; 
 
 
		OBJ HelpVar1 (* hidden = "1" *) "Help variable for Gaussian quadrature: (b-a)/2" : Real[NrOfLayersPlusFourBurger;];
		OBJ HelpVar2 (* hidden = "1" *) "Help variable for Gaussian quadrature: (b+a)/2" : BurgerConcentrationVector;
	   
  	    OBJ Fbk_max "Maximum flux" : ArealFlux;
	    OBJ C_fbk_max "Concentration corresponding to maximal settling flux" : Concentration ;
 };

   initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
    state.V_Layer = parameters.A * (parameters.H / NrOfLayersBurger); 
    state.H_Layer = parameters.H / NrOfLayersBurger;

	 
	state.C_fbk_max=CHat_DExp(parameters.v0,parameters.r_H,parameters.r_P,parameters.C_min,parameters.C_max,parameters.TOL);
	state.Fbk_max= parameters.v0*(exp(-parameters.r_H* state.C_fbk_max) - exp(- parameters.r_P*state.C_fbk_max));
    
	
	 
	state.HelpPar1 = parameters.Comp * parameters.rhos * parameters.v0 * parameters.alpha / (parameters.gr * (parameters.rhos - parameters.rhof));
	state.HelpPar2 = -parameters.C_crit + parameters.beta;
    
	};
  
  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
				 THEN state.Q_In
				 ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 
	
	{ FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (parameters.WWTPSpecificVolume[IndexOfSolvent] 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
			THEN 0
			ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {3 .. NrOfLayersPlusTwoBurger}:
                                         state.X_Layer[Layer_Index]) / NrOfLayersBurger;
    };

	 
		 
		 

    	 

		 

    	state.v_Up = state.Q_Out / parameters.A; 

    	 
    	 
    	 
    	 
    	 
    	 
    	 

   		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
         state.v_S[Layer_Index] = 
parameters.v0*(exp(-parameters.r_H* state.X_Layer[Layer_Index]) -exp(- parameters.r_P * state.X_Layer[Layer_Index]));

 
           
          	  
          	  
    	}; 
	
    
	 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
       	   state.J_G_Help[Layer_Index] =
           state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    	};

		 
       		 
        	 
        	 
        	 
        	 
        	 
        	 
    		 
	
			 
			 
			 
			 
			 
			 
			
		 
			{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
    		  state.J_G[Layer_Index] = 
			   IF (state.X_Layer[Layer_Index]<state.X_Layer[Layer_Index+1])
			   THEN MSLUGetMin2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1])
			   ELSE
			     IF (((state.C_fbk_max-state.X_Layer[Layer_Index])*(state.C_fbk_max-state.X_Layer[Layer_Index+1]))<0)
				 THEN state.Fbk_max
				 ELSE MSLUGetMax2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1]);
    		};
	

	{ FOREACH Layer_Index IN {2 .. IndexOfFeedLayerBurger}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayerBurger .. NrOfLayersPlusFourBurger}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

	
	 
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
        state.X_comp[Layer_Index] = MSLUGetMax2(parameters.C_crit,state.X_Layer[Layer_Index]);
      };
	  
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.HelpVar1[Layer_Index] = (state.X_comp[Layer_Index+1]-state.X_comp[Layer_Index])/2;
	  };
	  
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.HelpVar2[Layer_Index] = (state.X_comp[Layer_Index+1]+state.X_comp[Layer_Index])/2;
	  };
	
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
        state.J_comp_help[Layer_Index] = 
 
	    IF (state.X_comp[Layer_Index]>=state.X_comp[Layer_Index+1])
	    THEN 0
	    ELSE SUMOVER Legendre_Index IN {1 .. NrOfNodes}:
	  	  	   (state.HelpPar1*(exp(-parameters.r_H*(state.HelpVar1[Layer_Index] * parameters.nl[Legendre_Index] 
			   + state.HelpVar2[Layer_Index]))-exp(-parameters.r_P*(state.HelpVar1[Layer_Index] 
			   * parameters.nl[Legendre_Index]+ state.HelpVar2[Layer_Index])))/((state.HelpVar1[Layer_Index] 
			   * parameters.nl[Legendre_Index]+ state.HelpVar2[Layer_Index]) + state.HelpPar2)) * parameters.wl[Legendre_Index]; 
      };
	  
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.J_comp[Layer_Index] = state.J_comp_help[Layer_Index] * state.HelpVar1[Layer_Index];
	  };

	
	 
	
		 
		{ DERIV(state.X_Layer[1],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Up[2])
	   	  - (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    	};

		{ DERIV(state.X_Layer[2],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Up[3] - state.J_Up[2] 
		  - state.J_G[2]
	   	   
	   	  );
    	};
	
		 
		{ FOREACH Layer_Index IN {3 .. NrOfLayersPlusOneBurger}:
       	  DERIV(state.X_Layer[Layer_Index],[independent.t]) =
          IF (Layer_Index == IndexOfFeedLayerBurger)
          THEN (1 / state.H_Layer) *
          	  (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]
			   
			 ) + (1 / state.V_Layer) * state.SolidFlux_In 
          ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]
			  
			  );
    	};

    	 
		{ DERIV(state.X_Layer[NrOfLayersPlusTwoBurger],[independent.t]) =
       	  (1 / state.H_Layer) *
       	  (state.J_Dn[NrOfLayersPlusOneBurger] - state.J_Dn[NrOfLayersPlusTwoBurger] 
	   	  + state.J_G[NrOfLayersPlusOneBurger] - state.J_G[NrOfLayersPlusTwoBurger] 
	   	   
	   	  ) ;
    	};

		 
		{ DERIV(state.X_Layer[NrOfLayersPlusThreeBurger],[independent.t]) =
       	  (1 / state.H_Layer) *
       	  (state.J_Dn[NrOfLayersPlusTwoBurger] - state.J_Dn[NrOfLayersPlusThreeBurger] 
	   	  + state.J_G[NrOfLayersPlusTwoBurger] 
	   	   
	   	  ) ;
    	};
	
		{ DERIV(state.X_Layer[NrOfLayersPlusFourBurger],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusThreeBurger]
	   	  -state.J_Dn[NrOfLayersPlusFourBurger]);
    	};

	
    state.X_Out = IF (state.Q_Out == 0)
			THEN 0
			ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
			  THEN 0
			  ELSE state.X_Layer[NrOfLayersPlusFourBurger];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayersPlusFourBurger,parameters.X_Lim);

    state.H_S = (NrOfLayersPlusFourBurger - state.IndexOfSludgeBlanket - 2) *
                state.H_Layer;


 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
		IF (state.Q_In == 0)
	      THEN 0
		ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
		IF (state.SolidFlux_In == 0)
		THEN 0
		ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
		IF (state.Q_In == 0)
		THEN 0
		ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};





# 33 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\secondary_clarifier/wwtp.secondary_clarifier.empirical.msl" 1
 















   CLASS Empirical
    (* icon = "secondary_clarifier" *)
   "Empirical"				
  
   SPECIALISES PhysicalDAEModelType :=
   {:
    interface <-
     { 
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
           InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
      OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
           OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
      OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
           OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
		  OBJ X_out (* terminal = "out_3" *) "TSS out" : 
           Concentration := {: causality <- "COUT" ; group <- "Effluent" :};
  	  OBJ Q_Under (* terminal = "in_2" *) "Q_Under" : 
           FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
  	  OBJ Inflow1 (* terminal = "in_2" *) "Measured plant inflow" : 
           FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
     };
  
    parameters <- 
     { 
  	   
  	  OBJ Q_exp "f_ns=(Q^Q_exp)/Q" : Real := {: value <- 0.8 ; group <- "Clarification" :};
  	  OBJ f_ns_DW "Non-settleable fraction of suspended solids in DWF" : Fraction := {: value <- 0.0005 ; group <- "Clarification" :};
  	  OBJ A "Surface of secondary clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
      OBJ H "Height of secondary clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
  	  OBJ t_tol "Minimum time for start and stop of clarification problems" : Time := {: value <- 0.01 ; group <- "Clarification" :};
  	  OBJ Q_ON "Flow rate for start of clarification problems" : FlowRate := {: value <- 40000 ; group <- "Clarification" :};	
  	  OBJ Q_OFF "Flow rate for stop of clarification problems" : FlowRate := {: value <- 40000 ; group <- "Clarification" :};
  	  OBJ t_delay "f_ns = (t_start/t_delay)^t_delay_exp" : Time := {: value <- 0.25 ; group <- "Clarification" :};
  	   
  	  OBJ t_after "f_ns = max_after - ((t-t_stop)/t_after)^t_after_exp" : Time := {: value <- 1 ; group <- "Clarification" :};
  	   
  	  OBJ max_after "f_ns = max_after - ((t-t_stop)/t_after)^t_after_exp" : Real := {: value <- 2 ; group <- "Clarification" :};
  	   
  	  OBJ C_c "Average TSS concentration entering the SST" : Concentration := {: value <- 4500 ; group <- "Clarification" :};
  	  	
  	  OBJ Q_ONs "Flow rate for start of settling problems" : FlowRate := {: value <- 40000 ; group <- "Settling" :};
  	  OBJ f_s_DW "fs1=f_s_DW*1000*f_ns" : Real := {: value <- 4; group <- "Settling" :};  	
  	  OBJ Q_as "fs2=Q_as*Q_ONs/Q" : Real := {: value <- 0.5 ; group <- "Settling" :};
  	  OBJ C_s "fs3=C_s*TSS" : Real := {: value <- 0.001 ; group <- "Settling" :};
  	  
  	  OBJ T_Average "Averaging time used for the inflow" : Time := {: value <- 0.1; group <- "" :};
     };
  	 
  	independent <- 
     { 
      OBJ t "Time"  : Time := {: group <- "Time" :}; 
     };
  
    state <-
     {
  	  OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Operational" :};
  	  OBJ M "Vector containing masses for all the components" : MassVector := {: group <- "Operational" :};
  	  OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};	
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Operational" :}; 
  	  OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
      OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
      OBJ Q_Under_Actual_h "Underflow rate" : FlowRate := {: group <- "Operational" :};
      OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
      OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
      OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
      OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Operational" :};
      OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Operational" :};
      OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Operational" :};
  	  OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: group <- "Clarification" :};
  	  OBJ thelp (* hidden = "1" *) "Help variable to calculate the time from start of event" : Real := {: group <- "Clarification" :};
  	  OBJ tstart (* hidden = "0" *) "Help variable to calculate the time from start of event" : Real := {: group <- "Clarification" :};
  	  OBJ tstop (* hidden = "0" *) "Help variable to calculate the time from stop of event" : Real := {: group <- "Clarification" :};
  	  OBJ ON (* hidden = "0" *) "True if 1, False if 0" : Integer := {: group <- "Clarification" :};  
  	  OBJ counter (* hidden = "1" *) "Counts the number of starts" : Integer := {: group <- "Clarification" :};
  	  OBJ t_fromstart (* hidden = "1" *) "Help variable to calculate the time from start of event" : Real := {: group <- "Clarification" :};
  	  OBJ Inflow11 (* hidden = "0" *) "Effluent flow rate" : FlowRate := {: group <- "Clarification" :};
  	  OBJ fns1 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns2 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns3 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns4 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns4_h (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ tstart1 (* hidden = "1" *) "Help variable" : Boolean := {: group <- "Clarification" :};
  	  OBJ tstart2 (* hidden = "1" *) "Help variable" : Boolean := {: group <- "Clarification" :};
  	  OBJ tstart3 (* hidden = "1" *) "Help variable" : Boolean := {: group <- "Clarification" :};
  	  
  	  OBJ Underflow_help (* hidden = "1" *) "Underflow suspended solids concentration" : MassFluxVector := {: group <- "Settling" :};
  	  OBJ f_s "Settleable fraction of suspended solids" : Real := {: group <- "Settling" :};
  	  OBJ fs1 (* hidden = "0" *) "Help variable" : Real := {: group <- "Settling" :};
  	  OBJ fs2 (* hidden = "0" *) "Help variable" : Real := {: group <- "Settling" :};
  	  OBJ fs3 (* hidden = "0" *) "Help variable" : Real := {: group <- "Settling" :};
      
  	 
     };
     
    initial <-  
     {
  	  state.M[IndexOfSolvent] = parameters.A * parameters.H / 0.000001;
      state.ON = 0;
  	  state.tstart = 0;
  	  state.thelp = 0;
  	  state.tstop = 0;
  	  state.counter = 0;				
     };
  
    equations <-
     {
  		state.Q_In = (0.000001 * interface.Inflow[IndexOfSolvent]);
      
  		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       DERIV(state.M[Comp_Index],[independent.t]) = interface.Inflow[Comp_Index] + interface.Outflow[Comp_Index] + interface.Underflow[Comp_Index] ;};
  						
       DERIV(state.Inflow11,[independent.t]) = (interface.Inflow1 - state.Inflow11) / parameters.T_Average;
  	 
  	   state.tstart1 = previous(state.ON) == 0;
  	   state.tstart2 = state.Inflow11 > parameters.Q_ON;
  	   state.tstart3 =  previous(state.Inflow11) <= parameters.Q_ON;
  	 
  	   state.tstart = IF ((previous(state.ON) == 0) && (state.Inflow11 > parameters.Q_ON) && (previous(state.Inflow11) <= parameters.Q_ON))
  	 		  	  	      THEN independent.t
  					          ELSE previous(state.tstart);
  	   state.counter = IF ((previous(state.ON) == 0) && (state.Inflow11 > parameters.Q_ON) && (previous(state.Inflow11) <= parameters.Q_ON))
  	 		  	  	       THEN previous(state.counter) + 1
  					           ELSE previous(state.counter);
  	   state.thelp = IF (state.counter > 0)  
  	 		  	         THEN independent.t - state.tstart
  				           ELSE 0;
  	   state.tstop = IF ((previous(state.ON) == 1) && (state.Inflow11 < parameters.Q_OFF) && (previous(state.Inflow11) >= parameters.Q_OFF))
  	 		  	         THEN independent.t
  				           ELSE previous(state.tstop);
  	   state.ON = IF ((state.thelp > parameters.t_tol) && (state.tstop < state.tstart))
  	               
  	 		  	      THEN 1
  				        ELSE 0;	
  	
  	   state.t_fromstart = IF ((state.ON == 0) && (state.Inflow11 <= parameters.Q_OFF))
  				  	             THEN 0 
  					               ELSE IF (state.thelp < parameters.t_delay)
  						                  THEN state.thelp
  						                  ELSE parameters.t_delay;
  	
  	   state.fns1 = IF (state.X_In < 100)
  	                 
  	                THEN parameters.f_ns_DW * (state.Inflow11 / parameters.Q_ON)
  	                 
  	                ELSE parameters.f_ns_DW * (state.Inflow11 / parameters.Q_ON) * parameters.C_c / state.X_In;
  	   
  	   state.fns2 = IF (state.Inflow11 > parameters.Q_OFF)
								     
								    THEN pow((state.Inflow11-parameters.Q_OFF),parameters.Q_exp) / state.Inflow11
								    ELSE 0;
								    
  	    
  	   state.fns3 = state.t_fromstart/parameters.t_delay;
  	   
  	    
  	   state.fns4_h = parameters.max_after - (independent.t - state.tstop)/parameters.t_after;
  	   
  	   state.fns4 = IF (state.fns4_h <= 0)
  							    THEN 0
  							    ELSE state.fns4_h;
  	
  	   state.f_ns = IF ((state.ON == 0) || (state.Inflow11 <= parameters.Q_ON))
  				          THEN state.fns1 * (1 + state.fns4)
  				          ELSE state.fns1 * (1 + state.fns4) + state.fns2 * state.fns3; 
  				          
  		 state.fs1 = IF (state.Inflow11 < parameters.Q_ONs)
  		              
								   THEN parameters.f_s_DW * state.f_ns * 1000
								   ELSE 1;
  		 
  		 state.fs2 = IF (state.Inflow11 > parameters.Q_ONs)
								   THEN parameters.Q_as * parameters.Q_ONs / state.Inflow11
								   ELSE 1;
								   
			 state.fs3 =parameters.C_s * state.C[X_TSS];
								   
			 state.f_s = state.fs1 * state.fs2 * state.fs3;
  	
  	   DERIV(state.Q_Under_Actual,[independent.t]) = (interface.Q_Under - state.Q_Under_Actual) / parameters.T_Average;
  	   state.Q_Under_Actual_h = IF (state.Q_In <= state.Q_Under_Actual)
  				   		                THEN 0.5 * state.Q_In
  				   		                ELSE state.Q_Under_Actual; 
  
       state.Q_Out = state.Q_In - state.Q_Under_Actual_h;
  					
  	   state.V = 0.000001*state.M[IndexOfSolvent];
  	
  	   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.C[Comp_Index] = IF (state.V == 0)
  				                    THEN 0
  				                    ELSE state.M[Comp_Index]/state.V;};
  
       {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
        interface.Outflow[Comp_Index] = IF (state.Q_In == 0)
  				                              THEN 0
  				                              ELSE - interface.Inflow[Comp_Index] * (state.Q_Out / state.Q_In);};
  
       {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
        interface.Underflow[Comp_Index] = IF (state.Q_In == 0)
  				                                THEN 0
  				                                ELSE - interface.Inflow[Comp_Index] - interface.Outflow[Comp_Index] ;};
  
       {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
        interface.Outflow[Comp_Index] = IF (state.Q_In == 0)
  				   		                        THEN 0
  							                        ELSE - interface.Inflow[Comp_Index] * state.f_ns ;};   
  
       {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
        state.Underflow_help[Comp_Index] = IF (state.Q_In == 0)
  				   		   			                   THEN 0
  										                     ELSE - interface.Inflow[Comp_Index] * state.f_s * state.M[Comp_Index] / (state.M[Comp_Index] + 100000) ;};
  										                      
    
    
  	   {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
        
        interface.Underflow[Comp_Index] = state.Underflow_help[Comp_Index];};
  
        state.X_In = 	IF (state.Q_In == 0)
  			   		        THEN 0
  					          ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;
  
        state.X_Out =  IF (state.Q_In == 0)
    		         	     THEN 0
  		   	   		       ELSE IF (state.Q_Out <= (0.5 * state.Q_In))
  		   	   		            THEN (- interface.Outflow[IndexOfTSSComponent] / (0.5 * state.Q_In))
  		   	   		            ELSE (- interface.Outflow[IndexOfTSSComponent] / state.Q_Out);
  
        state.X_Under = IF ((0.5 * state.Q_In) <= interface.Q_Under)  
  			  	  	        THEN IF (state.Q_In == 0)
    		         	           THEN 0
  		   	   		             ELSE - interface.Underflow[IndexOfTSSComponent] / (0.5 * state.Q_In)  
  			  		          ELSE IF (interface.Q_Under == 0)
    		         	           THEN 0
  		   	   		             ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_Under_Actual);  

        interface.X_out = state.X_Out;
     };
 :};



# 34 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.secondary_clarifier.msl" 2




# 41 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sand_filter.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sandfilter/wwtp.base.sand_filter.simpledownflow.msl" 1
 



















 CLASS SimpleDownFlow
  (* icon = "sand_filter" ; is_default = "true" *)
  "Semicontinuous Downflow granular medium filter"
 SPECIALISES PhysicalDAEModelType :=
 {:
  comments <- "A model for sand filtration";

  interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Inflow_Backwash (* terminal = "in_3" *) "Inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent backwash" :};
    OBJ Outflow_Filtered (* terminal = "out_1" *) "Outflow filtered" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent Filtered" :};
    OBJ Outflow_Unfiltered (* terminal = "out_3" *) "Outflow unfiltered" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent Unfiltered" :};
    OBJ Backwash  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Backwashing state" : Integer := 
         {:
       causality <- "CIN" ; 
       group <- "Operational" ;
           interval <- {: lowerBound <- 0; upperBound <- 1; :};  
         :};
   };

  parameters <-
   {
    OBJ WWTPSpecificVolume (* hidden = "1" *)
    "Vector containing the specific volume (= 1/density) for all the components"
    : SpecificVolumeVector;

    OBJ A (* is_favorite = "1" *) "Surface" : Area:= {: value <- 10 ; group <- "Dimension" :};
    OBJ k "Sludge resistance coefficient" : Real := {: value <- 0.001 ; group <- "Hydraulic" :};
    OBJ f_nf "Non-filterable fraction" : Fraction := {: value <- 0.005 ; group <- "Filtration" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ alfa "Outflow parameter" : PhysicalQuantityType := {: value <- 2500 ; group <- "Hydraulic" :};
    OBJ beta "Outflow parameter" : PhysicalQuantityType := {: value <- 1 ; group <- "Hydraulic" :};
    OBJ f0 "Clean filter bed resistance factor": Fraction := {: value <- 0.025 ; group <- "Hydraulic" :};
    OBJ H_Max (* is_favorite = "1" *) "Maximum height of the water in the sand filter" : Length := {: value <- 1 ; group <- "Dimension" :};
    OBJ Backwash_Intensity "Backwash Intensity" : Real := 
         {:
           unit <- "m-3";
           value <- 0.02 ;
       group <- "Filtration";
           interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};  
         :};
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Backwash  (* is_favorite = "1" *) "Backwash flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Filtered (* is_favorite = "1" *) "Filtered effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Unfiltered (* is_favorite = "1" *) "Unfiltered effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Unfiltered_Help (* hidden = "1" *) "Unfiltered effluent flow rate" : Real := {: group <- "Operational" :};
    OBJ H (* is_favorite = "1" *) "Height of the water on the sand filter" : Length := {: group <- "Operational" :};
    OBJ V "Volume" : Volume := {: group <- "Dimension" :};
    OBJ s_X "Mass of Sludge on the sand filter" : SurfaceDensity := {: group <- "Operational" :};
    OBJ M_X "Mass of sludge on the sand filter" : MassVector := {: group <- "Operational" :};
    OBJ f_Out_Filtered (* hidden = "1" *) "Fraction of the influent flux going to the filtered outflow" : Fraction ;
    OBJ f_Out_Unfiltered (* hidden = "1" *) "Fraction of the influent flux going to the unfiltered outflow" : Fraction ;






    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Backwash (* is_favorite = "1" *) "Backwash suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out_Filtered (* is_favorite = "1" *) "Filtered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out_Unfiltered (* is_favorite = "1" *) "Unfiltered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ b_Backwash "Backwash rate" : Frequency := {: group <- "Operational" :};
   };

  initial <-
   {
    parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   };

  equations <-
   {
 

    state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow[IndexOfSolvent];
    state.Q_Backwash = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow_Backwash[IndexOfSolvent];

 
 

    state.Q_Out_Filtered = IF (interface.Backwash <= 0)
                           THEN
      state.Q_Backwash +
                  parameters.alfa * pow(state.H, parameters.beta) * (1 - (parameters.f0 * exp(parameters.k * state.s_X)))
                           ELSE 0;

 
 
 
 

    state.Q_Out_Unfiltered_Help = state.Q_In
                           - parameters.alfa * pow(state.H, parameters.beta)
                             * (1 - (parameters.f0 * exp(parameters.k * state.s_X)));

    state.Q_Out_Unfiltered = IF (state.H > parameters.H_Max)
                   THEN 
                 IF (interface.Backwash <= 0)
                 THEN
                     IF (state.Q_Out_Unfiltered_Help < 0)
                   THEN 0
                   ELSE state.Q_Out_Unfiltered_Help
                 ELSE state.Q_In + state.Q_Backwash
                   ELSE 0;

 

    DERIV(state.H,[independent.t]) = 1/parameters.A * (state.Q_In + state.Q_Backwash - state.Q_Out_Filtered - state.Q_Out_Unfiltered);

    state.V = state.H * parameters.A;

 

    state.f_Out_Filtered = IF (interface.Backwash <= 0)
                 THEN
                 IF ((state.Q_Out_Filtered + state.Q_Out_Unfiltered) == 0)
                     THEN 0
                             ELSE state.Q_Out_Filtered / (state.Q_Out_Filtered + state.Q_Out_Unfiltered)
                 ELSE 0;

    state.f_Out_Unfiltered = 1 - state.f_Out_Filtered;

 
 
    DERIV(state.s_X,[independent.t]) =
  ((state.X_In * state.Q_In + state.X_Backwash * state.Q_Backwash - state.Q_Out_Filtered * state.X_Out_Filtered - state.Q_Out_Unfiltered * state.X_Out_Unfiltered)
    / parameters.A);

 
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       DERIV(state.M_X[Comp_Index],[independent.t]) =
      ( interface.Inflow[Comp_Index] + interface.Inflow_Backwash[Comp_Index]
    + interface.Outflow_Filtered[Comp_Index] + interface.Outflow_Unfiltered[Comp_Index]);
     };

 

# 204 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sandfilter/wwtp.base.sand_filter.simpledownflow.msl"




    state.X_In =  IF (state.Q_In == 0)
            THEN 0
          ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Backwash =  IF (state.Q_Backwash == 0)
            THEN 0
            ELSE interface.Inflow_Backwash[IndexOfTSSComponent] / state.Q_Backwash;

    state.X_Out_Filtered =  IF (state.Q_Out_Filtered == 0)
                THEN 0
                ELSE (- interface.Outflow_Filtered[IndexOfTSSComponent] / state.Q_Out_Filtered );

    state.X_Out_Unfiltered = IF (state.Q_Out_Unfiltered == 0)
                         THEN 0
                             ELSE - interface.Outflow_Unfiltered[IndexOfTSSComponent] / (state.Q_Out_Unfiltered );



 
 

    state.b_Backwash =  IF (state.H > parameters.H_Max)
            THEN interface.Backwash * state.Q_Backwash * parameters.Backwash_Intensity
            ELSE 0;

 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Filtered
                   - (1 - interface.Backwash) * interface.Inflow_Backwash[Comp_Index];
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * parameters.f_nf * state.f_Out_Filtered
                   - (1 - interface.Backwash) * interface.Inflow_Backwash[Comp_Index] ;
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Unfiltered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Unfiltered 
                 - interface.Backwash * interface.Inflow_Backwash[Comp_Index];
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Unfiltered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Unfiltered 
                 - interface.Backwash * interface.Inflow_Backwash[Comp_Index] 
                 - state.M_X[Comp_Index] * state.b_Backwash;
     };

   };
 :};




# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sand_filter.msl" 2




# 42 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.anaerobic_digestion.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.lessarddesjardins.msl" 1
 


















# 253 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.lessarddesjardins.msl"



# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.anaerobic_digestion.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.siegrist.msl" 1
 


















# 804 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.siegrist.msl"



# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.anaerobic_digestion.msl" 2



# 43 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 1
 


















CLASS Sensor
  "sensor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    interface <-
    {
		OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent":};
		OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
    };
    parameters <- 
    {
		OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components" : SpecificVolumeVector ;
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    state <- 
    {
		OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector ;
		OBJ Q_In "Influent flow rate" : PhysicalQuantityType := {: group <- "Operational" :};
    };
    initial <- 
    {
		parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
    };
    equations <- 
    {
		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
			state.InFluxPerComponent[Comp_Index] =
				SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };

		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
			interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] ; }; 

		state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent] ;
    };
  :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_flow.msl" 1
 














 




CLASS Sensor_Flow
  (* icon = "sensor_flow" ; is_default = "true" *)
  "Flow sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the flow rate";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    };

    equations <-
    {
      {interface.y_M = state.Q_In ;};
    };
 :};





# 59 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_do.msl" 1
 



















CLASS Sensor_DO
  (* icon = "sensor_do" ; is_default = "true" *)
  "Oxygen sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a sensor measuring the dissolved oxygen";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
       {interface.y_M = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[S_O] / state.Q_In ; };
     };
  :};




# 60 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_nh4.msl" 1
 



















CLASS Sensor_NH4
  (* icon = "sensor_nh4" ; is_default = "true" *)
  "Ammonia sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a sensor measuring the ammonia concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
   
    equations <-
    {
       {interface.y_M = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[S_NH] / state.Q_In ; };
    };
 :};   
    
 CLASS NH4_load
  (* icon = "sensor_nh4" *)
  "Ammonia load sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a (soft) sensor measuring the ammonia load";

    interface <-
    {
      OBJ y_M (* terminal = "out_2" *) "Sensor measured output" :
         Real := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
   
    equations <-
    {
       interface.y_M = interface.Inflow[S_NH];
    };
  :};
  




# 61 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_no3.msl" 1
 



















CLASS Sensor_NO3
  (* icon = "sensor_no3" ; is_default = "true" *)
  "Nitrate sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the nitrate concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE interface.Inflow[S_NO] / state.Q_In ; };
    };
  :};




# 62 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tss.msl" 1
 


















# 59 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tss.msl"




# 63 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl" 1
 



















CLASS Sensor_COD
  (* icon = "sensor_cod" ; is_default = "true" *)
  "COD sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the Chemical Oxygen Demand";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
# 44 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"



    interface.y_M = IF (state.Q_In == 0)
            THEN 0
            ELSE (interface.Inflow[S_A] + interface.Inflow[S_F] + interface.Inflow[X_S]
          + interface.Inflow[S_I] + interface.Inflow[X_I]
          + interface.Inflow[X_AUT] + interface.Inflow[X_H] 
          + interface.Inflow[X_PAO] + interface.Inflow[X_PHA])
             / state.Q_In ; 
  


# 66 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"


# 77 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"

  };
    :};




# 64 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl" 1
 


















# 94 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl"




# 65 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl" 1
 














 



# 135 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"




# 66 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl" 1
 














 



# 135 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"




# 67 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tp.msl" 1
 


















# 94 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_tp.msl"




# 68 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_po4.msl" 1
 



















CLASS Sensor_PO4
  (* icon = "sensor_po4" ; is_default = "true" *)
  "Phosphate sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the phosphate concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE interface.Inflow[S_PO] / state.Q_In ; };
    };
  :};




# 69 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_multi.msl" 1
 














 




CLASS MultiSensor (* icon = "sensor_multi"; is_default = "true" *) "Multi-probe sensor" EXTENDS Sensor WITH 
  {:
    comments <- "A model for a multi-probe sensor";
    interface <-
    {
		OBJ y_Q (* terminal = "out_2"; is_favorite = "1" *) "Flow rate" : FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
		
		OBJ y_DO (* terminal = "out_2"; is_favorite = "1" *) "Oxygen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_NH (* terminal = "out_2"; is_favorite = "1" *) "Ammonia concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_NO (* terminal = "out_2"; is_favorite = "1" *) "Nitrate concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TSS (* terminal = "out_2"; is_favorite = "1" *) "Particulates concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_COD (* terminal = "out_2"; is_favorite = "1" *) "COD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_BOD (* terminal = "out_2"; is_favorite = "1" *) "BOD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TN (* terminal = "out_2"; is_favorite = "1" *) "Total Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TKN (* terminal = "out_2"; is_favorite = "1" *) "Total Kjeldahl Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		
		
		OBJ y_TP (* terminal = "out_2"; is_favorite = "1" *) "Total Phosphorous concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_PO (* terminal = "out_2"; is_favorite = "1" *) "Phosphate concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		
    };
    parameters <- 
    {
		OBJ F_TSS_COD "Fraction TSS/COD" : Ratio := {: value <- 0.75 ; group <- "Conversion factors":};

		


		
		OBJ f_X_I "Fraction of inert COD generated in biomass lysis" : Fraction := {: value <- 0.10 ; group <- "Stoichiometry" :};
		
		


		OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};

		



		
		OBJ i_N_S_I "Nitrogen content of inert soluble COD S_I" : NitrogenConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
		OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
		OBJ i_N_X_I "Nitrogen content of inert particulate COD X_I" : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
		OBJ i_N_X_S "Nitrogen content of particulate substrate X_S" : NitrogenConversionFactor := {:value <- 0.04 ; group <- "Composition parameters" :};
		OBJ i_N_BM "Nitrogen content of biomass X_H, X_PAO, X_AUT" : NitrogenConversionFactor := {:value <- 0.07 ; group <- "Composition parameters" :};
		
		






		







		
		OBJ i_P_S_I "Phosphorus content of inert soluble COD S_I" : PhosphorusConversionFactor := {:value <- 0.00 ; group <- "Composition parameters" :};
		OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : PhosphorusConversionFactor := {:value <-0.01 ; group <- "Composition parameters" :};
		OBJ i_P_X_I "Phosphorus content of inert particulate COD X_I" : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
		OBJ i_P_X_S "Phosphorus content of particulate substrate X_S" : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
		OBJ i_P_BM "Phosphorus content of biomass X_H, X_PAO, X_AUT" : PhosphorusConversionFactor := {:value <- 0.02 ; group <- "Composition parameters" :};
		
		






    };
    equations <- 
    {
		interface.y_Q = state.Q_In ;

		
		interface.y_DO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_O] / state.Q_In ;

		interface.y_NH = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_NH] / state.Q_In ;

		interface.y_NO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_NO] / state.Q_In ;
		 
		 
		




		
		interface.y_TSS = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[X_TSS] / state.Q_In ; 
		
		 
		 
		




		
		interface.y_COD = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_A] + interface.Inflow[S_F] + interface.Inflow[X_S] +
			interface.Inflow[S_I] + interface.Inflow[X_I] + interface.Inflow[X_AUT] +
			interface.Inflow[X_H] + interface.Inflow[X_PAO] + interface.Inflow[X_PHA]) / state.Q_In ; 
		
		




		





		 
		 
		




		
		interface.y_BOD = IF (state.Q_In == 0) THEN 0
			ELSE parameters.F_BOD_COD * (interface.Inflow[S_A] + interface.Inflow[S_F] +
			interface.Inflow[X_S] + interface.Inflow[X_PHA] + (1 - parameters.f_X_I) * (interface.Inflow[X_AUT] +
			interface.Inflow[X_H] + interface.Inflow[X_PAO] )) / state.Q_In ; 
		
		




		





		 
		 
		





		
		interface.y_TN = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_NO] + interface.Inflow[S_NH] + parameters.i_N_S_I * interface.Inflow[S_I] +
			parameters.i_N_S_F * interface.Inflow[S_F] + parameters.i_N_X_I * interface.Inflow[X_I] +
			parameters.i_N_X_S * interface.Inflow[X_S] + parameters.i_N_BM * (interface.Inflow[X_H] +
			interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) / state.Q_In ;
		
		





		






		 
		 
		





		
		interface.y_TKN = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_NH] + parameters.i_N_S_I * interface.Inflow[S_I] +
			parameters.i_N_S_F * interface.Inflow[S_F] + parameters.i_N_X_I * interface.Inflow[X_I] +
			parameters.i_N_X_S * interface.Inflow[X_S] + parameters.i_N_BM * (interface.Inflow[X_H] +
			interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) / state.Q_In ;
		
		





		






		 
		 
		
		interface.y_TP = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_PO] + interface.Inflow[X_PP] + 0.205 * interface.Inflow[X_MEP] +
			parameters.i_P_S_I * interface.Inflow[S_I] + parameters.i_P_S_F * interface.Inflow[S_F] +
			parameters.i_P_X_I * interface.Inflow[X_I] + parameters.i_P_X_S * interface.Inflow[X_S] +
			parameters.i_P_BM * (interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) / state.Q_In ;
		
		






		 
		 
		
		interface.y_PO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_PO] / state.Q_In ; 
		

		
    };

  :};




# 72 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.quality_index.msl" 1
 





 



  

 CLASS EffluentQualityIndex 
 
   (* icon = "sensor_multi" *)
   "sensor"
   EXTENDS Sensor WITH 
   {:
     comments <- "A model for a sensor measuring BOD, COD, TN, TP, NH4 and NO3, PUBOD, PUCOD, PUTP, PUNH4 and PUNO3";
 
 	interface <-
     {
 	 OBJ y_M (* terminal = "out_2" *)"measurement" :Real:= {: causality <- "COUT" ; group <- "Measurement data" :};
     };
     	
 
# 120 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.quality_index.msl"

  
  
 
 parameters <-
   {
    OBJ F_BOD5_BOD20 "Conversion factor BOD5/BOD20": Fraction := {: value <- 0.25 ; group <- "Conversion factors" :};
    OBJ i_N_S_I "Nitrogen content of inert soluble COD S_I" : NitrogenConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
    OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
    OBJ i_N_X_I "Nitrogen content of inert particulate COD X_I" : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
    OBJ i_N_X_S "Nitrogen content of particulate substrate X_S" : NitrogenConversionFactor := {:value <- 0.04 ; group <- "Composition parameters" :};
    OBJ i_N_BM "Nitrogen content of biomass X_H, X_PAO, X_AUT" : NitrogenConversionFactor := {:value <- 0.07 ; group <- "Composition parameters" :};
    OBJ i_P_S_I "Phosphorus content of inert soluble COD S_I" : PhosphorusConversionFactor := {:value <- 0.00 ; group <- "Composition parameters" :};
    OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
    OBJ i_P_X_I "Phosphorus content of inert particulate COD X_I" : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
    OBJ i_P_X_S "Phosphorus content of particulate substrate X_S" : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
    OBJ i_P_BM "Phosphorus content of biomass X_H, X_PAO, X_AUT" : PhosphorusConversionFactor := {:value <- 0.02 ; group <- "Composition parameters" :};
    OBJ i_TSS_X_I "TSS to X_I ratio" : ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
    OBJ i_TSS_X_S "TSS to X_S ratio" : ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
    OBJ i_TSS_BM "TSS to biomass ratio for X_H, X_PAO, X_AUT" : ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
    OBJ i_TSS_X_PP "TSS to X_PP ratio" : Real	:= {: value <- 3.23 ; group <- "Composition parameters" :}; 
    OBJ i_TSS_X_PHA "TSS to X_PHA ratio" : ConversionFactor	:= {: value <- 0.6 ; group <- "Composition parameters" :};
	OBJ beta_TSS "weight TSS" : Real	:= {: value <- 2 ; group <- "weight number" :};
	OBJ beta_COD "weight COD" : Real := {: value <- 1 ; group <- "weight number" :};
	OBJ beta_BOD5 "weight BOD" : Real	:= {: value <- 2 ; group <- "weight number" :};
	OBJ beta_NH_4 "weight NH4" : Real	:= {: value <- 20 ; group <- "weight number" :};
	OBJ beta_NO_3 "weight NO" : Real	:= {: value <- 20 ; group <- "weight number" :};
	OBJ beta_TP "weight TP" : Real	:= {: value <- 0 ; group <- "weight number" :};
	OBJ f_S_F "Fraction of fermentable readily biodegradable products (S_F) in the soluble COD": Fraction := {: value <- 0.375 ; group <- "Conversion factors" :};
   OBJ f_S_A "Fraction of fermentation procucts (S_A) in the soluble COD": Fraction := {: value <- 0.25 ; group <- "Conversion factors" :};
   OBJ f_X_S "Fraction slowly biodegradable substrate (X_S) in the particulate COD" : Fraction := {: value <- 0.69 ; group <- "Conversion factors" :};

 };
 
 state <-
   {
    OBJ S_COD "Soluble COD" : ChemOxDemand := {: group <- "Influent characterization" :};
    OBJ X_COD "Particulate COD" : ChemOxDemand := {: group <- "Influent characterization" :};
    OBJ BOD20 "BOD20" : BiolOxDemand := {: group <- "Influent characterization" :};
    OBJ COD "COD" : ChemOxDemand := {: group <- "Influent characterization" :};
    OBJ BOD5 "BOD5" : BiolOxDemand := {: group <- "Influent characterization" :};
    OBJ TSS "TSS" : Concentration := {: group <- "Influent characterization" :};
    OBJ TN "Total Nitrogen" : Concentration := {: group <- "Influent characterization" :};
    OBJ TKN "Total Nitrogen" : Concentration := {: group <- "Influent characterization" :};
    OBJ TP "Total Phosphorus" : Concentration := {: group <- "Influent characterization" :};
    OBJ NH_4 "Ammonia" : Concentration := {: group <- "Influent characterization" :};
    OBJ NO_3 "Nitrates" : Concentration := {: group <- "Influent characterization" :};
    OBJ PO_4 "Phosphates" : Concentration := {: group <- "Influent characterization" :};
	OBJ PU_COD "COD Pollution" : ChemOxDemand := {: group <- "Influent characterization" :};
    OBJ PU_BOD5 "BOD5 Pollution" : BiolOxDemand := {: group <- "Influent characterization" :};
    OBJ PU_TSS "TSS Pollution" : Concentration := {: group <- "Influent characterization" :};
    OBJ PU_TP "Total Phosphorus Pollution" : Concentration := {: group <- "Influent characterization" :};
    OBJ PU_NH_4 "Ammonia Pollution" : Concentration := {: group <- "Influent characterization" :};
    OBJ PU_NO_3 "Nitrates Pollution" : Concentration := {: group <- "Influent characterization" :};
	OBJ Total_PU "Total Pollution" : Concentration := {: group <- "Influent characterization" :};
	OBJ Integ_NH4 "Integral NH4" : Real ;
	OBJ Integ_NO3 "Integral NO3" : Real ;
	OBJ Integ_BOD5 "Integral BOD5" : Real ;
	OBJ Integ_COD "Integral COD" : Real ;
	OBJ Integ_TSS "Integral TSS" : Real ;
	OBJ Integ_TKN "Integral TKN" : Real ;
   OBJ fX_I  "fraction of Xi" : Real := {: group <- "Influent characterization" :};
   OBJ fX_s  "fraction of Xs" : Real := {: group <- "Influent characterization" :};
   OBJ fS_s  "fraction of Ss" : Real := {: group <- "Influent characterization" :};
   OBJ fS_i  "fraction of Si" : Real := {: group <- "Influent characterization" :};
   };
   
     equations <-
   {
   interface.y_M = state.Q_In * state.TSS/1000;
   
    state.S_COD = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE (interface.Inflow[S_I] + interface.Inflow[S_F] + interface.Inflow[S_A]) / state.Q_In; 
    state.X_COD = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE (interface.Inflow[X_I] + interface.Inflow[X_S] 
 				  	    + interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO] + interface.Inflow[X_PHA])
					   / state.Q_In;
    state.BOD20 = IF (state.Q_In == 0)
    			  THEN 0
 			   	  ELSE (interface.Inflow[S_F] + interface.Inflow[S_A] + interface.Inflow[X_S] 
 				  	    + interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO] + interface.Inflow[X_PHA])
					   / state.Q_In;
 
    state.COD = state.S_COD + state.X_COD;
    state.BOD5 = parameters.F_BOD5_BOD20 * state.BOD20;
    state.TSS = IF (state.Q_In == 0)
			  	THEN 0
				ELSE interface.Inflow[X_TSS] / state.Q_In;
 







    state.TKN = IF (state.Q_In == 0)
    			THEN 0
 				ELSE (interface.Inflow[S_NH]
 		 + parameters.i_N_S_I * interface.Inflow[S_I] 
 		 + parameters.i_N_S_F * interface.Inflow[S_F] 
 		 + parameters.i_N_X_I * interface.Inflow[X_I] 
 		 + parameters.i_N_X_S * interface.Inflow[X_S] 
 		 + parameters.i_N_BM * (interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO])) / state.Q_In; 
 		 
    state.TN = state.TKN + state.NO_3;
 
    state.TP = IF (state.Q_In == 0)
    		   THEN 0
 			   ELSE
 			   (interface.Inflow[S_PO] + interface.Inflow[X_PP] + interface.Inflow[X_MEP]
    		 + parameters.i_P_S_I * interface.Inflow[S_I] 
 		 + parameters.i_P_S_F * interface.Inflow[S_F] 
 		 + parameters.i_P_X_I * interface.Inflow[X_I] 
 		 + parameters.i_P_X_S * interface.Inflow[X_S] 
 		 + parameters.i_P_BM * (interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO])) / state.Q_In;
 	
    state.NH_4 = IF (state.Q_In == 0)
    			 THEN 0
 			   	 ELSE interface.Inflow[S_NH] / state.Q_In;
    state.NO_3 = IF (state.Q_In == 0)
    			 THEN 0
 			   	 ELSE interface.Inflow[S_NO] / state.Q_In;
    state.PO_4 = IF (state.Q_In == 0)
        		 THEN 0
     			 ELSE interface.Inflow[S_PO] / state.Q_In;
    DERIV(state.Integ_NH4, [independent.t]) = state.NH_4 ;
	DERIV(state.Integ_NO3, [independent.t]) = state.NO_3 ;
	DERIV(state.Integ_BOD5, [independent.t]) = state.BOD5 ;
	DERIV(state.Integ_COD, [independent.t]) = state.COD ;
	DERIV(state.Integ_TSS, [independent.t]) = state.TSS ;
	DERIV(state.Integ_TKN, [independent.t]) = state.TKN ;
	state.PU_COD = (parameters.beta_COD * state.COD * state.Q_In)/1000;
	state.PU_BOD5 = (parameters.beta_BOD5 * state.BOD5 * state.Q_In)/1000;
	state.PU_TSS = (parameters.beta_TSS * state.TSS * state.Q_In)/1000;
	state.PU_NH_4 = (parameters.beta_NH_4 * state.NH_4 * state.Q_In)/1000;
	state.PU_NO_3 = (parameters.beta_NO_3 * state.NO_3 * state.Q_In)/1000;
	state.PU_TP = (parameters.beta_TP * state.TP * state.Q_In)/1000;
	state.Total_PU = (state.PU_COD + state.PU_BOD5 + state.PU_TSS + state.PU_NH_4 + state.PU_NO_3 + state.PU_TP); 
  
 
 
 
 
 
 
 
 
 
 
 
   
  };
  :};
 
 
 




# 74 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_od.msl" 1
 










CLASS OD
  (* icon = "sensor_od" *)
  "sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring Oxygen Demand - only implemented for ASM2dTemp";

    interface <-
    {
      OBJ y_M (* terminal = "out_2" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
	  state <-
    {
      OBJ OD_C  "Oxygen demand for carbon" : ChemOxDemand := {: group <- "Influent characterization" :};
	    OBJ OD_NH  "oxygen demand for ammonia" : ChemOxDemand := {: group <- "Influent characterization" :};	 
	};
	
    parameters <-
    {





     OBJ f_X_I "Fraction of inert COD generated in biomass lysis"
      : Fraction := {:value <- 0.10 ; group <- "Stoichiometry" :};





     OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};
     };

    equations <-
    {
# 58 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_od.msl"



	  state.OD_C = (interface.Inflow[S_A] + interface.Inflow[S_F] + interface.Inflow[X_S] + interface.Inflow[X_PHA])/ state.Q_In ;
	  state.OD_NH = 4.57*interface.Inflow[S_NH]/ state.Q_In;
	  
	  interface.y_M = IF (state.Q_In == 0)
			      	  THEN 0
			      	  ELSE (state.OD_C + state.OD_NH);
	     
	


# 79 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_od.msl"


# 89 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sensor/wwtp.base.sensors.sensor_od.msl"

	};
    :};




# 75 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sensors.msl" 2




# 44 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.onoffideal.msl" 1
 


















CLASS OnOffIdeal
  (* icon = "controller_on_off" ; is_default = "" *)
  "Ideal On-off controller"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
         Real := {: causality <- "CIN" ; value <- 2  ; group <- "Operational":};
    OBJ u_Off (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when off" : 
    Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_On  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when on"  : 
    Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
     OBJ help_t (* hidden = "1" *) "Previous t help variable" : Real;
    };

    equations <-
    {
    state.e = interface.y_S - interface.y_M;

    state.help_u = interface.u;
    state.help_t = independent.t;
    interface.u = IF (interface.y_M > interface.y_S)
                  THEN interface.u_Off
                  ELSE interface.u_On;
   };

 :};

 


# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.onoffband.msl" 1
 


















CLASS OnOffBand
  (* icon = "controller_on_off" ; is_default = "true" *)
  "On-off controller with a band"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
         Real := {: causality <- "CIN" ; value <- 2  ; group <- "Operational":};
    OBJ y_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum allowed measured value" : 
         Real := {: causality <- "CIN" ; value <- 1.8  ; group <- "Operational":};
    OBJ y_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum allowed measured value" : 
         Real := {: causality <- "CIN" ; value <- 2.2  ; group <- "Operational":};
    OBJ u_Off (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when off" : 
    Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_On  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when on"  : 
    Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
     OBJ help_t (* hidden = "1" *) "Previous t help variable" : Real;
    };

    equations <-
    {
    state.e = interface.y_S - interface.y_M;

    state.help_u = interface.u;
    state.help_t = independent.t;
    interface.u = IF(interface.y_M < interface.y_Min)
                  THEN interface.u_On
                  ELSE
                    IF (interface.y_M > interface.y_Max)
                    THEN interface.u_Off
                    ELSE
            IF (previous(state.help_t) >= independent.t)
              THEN interface.u_On
              ELSE previous(state.help_u) ;
   };

 :};

 


# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.constantratio.msl" 1
 


















CLASS ConstantRatio
  (* icon = "controller_ratio" *)
  "Ratio controller"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a ratio controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" :
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" :
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ ConstantRatio (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Ratio between measured value and controller output" :
        Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    equations <-
    {

    interface.u = interface.ConstantRatio * interface.y_M;

    };
  :};

 


# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.p_saturation.msl" 1
 


















CLASS P_Saturation
  (* icon = "controller_p" *)
  "P controller with saturation"

 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable " : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) " Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

     state.e = interface.y_S - interface.y_M ;
     state.uhelp = interface.u0 + interface.K_P * state.e;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
   };

 :};

 


# 23 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.p_saturation_operator.msl" 1
 








CLASS Operator
    (* icon = "controller" ; is_default = "" *)
    "P controller with saturation"
  
   
   
   
   
   
   
   
  
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
      comments <- "A model for a proportional controller with saturation";
      interface <-
      {
        OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
		     
         
		     
         
        OBJ u (* terminal = "out_1" *) "Controlled variable" : 
                 FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
      };
  
      parameters <-
      {
       OBJ K_P " Factor of proportionality" : Real := {: value <- 1 ; group <- "Operational" :};
       OBJ u0 "No error action" : FlowRate := {: value <- 1 ; group <- "Operational" :};
       OBJ u_Min "Minimum control action" : FlowRate := {: value <- 0 ; group <- "Operational" :};
       OBJ u_Max "Maximum control action" : FlowRate := {: value <- 1000 ; group <- "Operational" :};
        
       OBJ y_S "Setpoint value for controlled variable" : Concentration := {: value <- 3500 ; group <- "Operational" :};
       OBJ t_win "Control window" : Time := {: value <- 0.04166666667 ; group <- "Operational" :};
	     OBJ t_ini "Initial time" : Time := {: value <- 0 ; group <- "Control" :};
	     OBJ gain "Multiplyer of set-points, for GSA" : Real := {: value <- 1 ; group <- "Operational" :};
      };
  
      independent <- 
      { 
      OBJ t "Time" : Time := {: group <- "Time" :}; 
      };
  
      state <-
      {
       OBJ uhelp (* hidden = "0" *) "Help variable to calculate the proportional control action" : Real;
	     OBJ uhelp_h (* hidden = "0" *) "Help variable to calculate the proportional control action" : Real;
       OBJ Prev_t (* hidden = "0" *) "Help variable to calculate the begin of each period" : Time ;
      };
  
      initial <-
      {
      state.Prev_t = parameters.t_ini;
      };
   
      equations <-
      {
  
       state.Prev_t = IF	(independent.t - previous(state.Prev_t) < (parameters.t_win))
  			 	 				 THEN previous(state.Prev_t)
  			 						ELSE previous(state.Prev_t) + parameters.t_win;
  
       state.uhelp_h = IF (previous(state.uhelp) < 0)
  	 			   				 THEN 0
  				   					ELSE IF (independent.t - previous(state.Prev_t) < parameters.t_win)
  	 			   	 					 THEN previous(state.uhelp)
  				   	 						ELSE IF(interface.y_M < parameters.y_S * parameters.gain)
                     	   			 THEN previous(state.uhelp) - parameters.K_P * (parameters.y_S * parameters.gain - interface.y_M)
                     	   			 ELSE IF (interface.y_M > parameters.y_S * parameters.gain)
                         	 				  THEN previous(state.uhelp) + parameters.K_P * (interface.y_M - parameters.y_S * parameters.gain)
                         	 					ELSE previous(state.uhelp);
                         	
                           
                     	   	 
                     	   	 
                         	 
                         	 
  
      state.uhelp = IF(state.uhelp_h < parameters.u_Min)
                    THEN (parameters.u_Min)
                    ELSE IF (state.uhelp_h > parameters.u_Max)
                      	 THEN parameters.u_Max
                        ELSE state.uhelp_h;
					   
	    interface.u = state.uhelp;
     };
  
   :};
   

# 24 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.pi_saturation.msl" 1
 


















CLASS PI_Saturation
  (* icon = "controller_pi"; is_default = "true" *)
  "PI controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1" *) "Setpoint value for controlled variable" : 
     Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};
     OBJ T_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : 
     Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ;value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
     OBJ Prev_t (* hidden = "1" *) : Time;
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

     DERIV(state.Integ_e, [independent.t]) = state.e ;

     state.uhelp = interface.u0 + interface.K_P 
                     * (state.e + (1 / interface.T_I) * state.Integ_e); 

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
    };
  :};
 

 


# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.pid_saturation.msl" 1
 


















CLASS PID_Saturation
  (* icon = "controller_pid" *)
  "PID controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral-derivative controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ K_P (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Factor of proportionality" : 
        Real := {: causality <- "CIN" ; value <- 11.31977725 ; group <- "Operational" :};
      OBJ T_I (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Integral time" : 
        Time := {: causality <- "CIN" ; value <- 0.5062161847 ; group <- "Operational" :};
      OBJ T_D (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Derivative time" : 
        Time := {: causality <- "CIN" ; value <- 0.2531080923 ; group <- "Operational" :};
      OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
        Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
      OBJ u0  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
        Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
      OBJ u_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
        Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
      OBJ u_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
        Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral-derivative control action" : Real;
     OBJ Deriv_e  "Derivative of error" : Real := {: group <- "Operational" :};
     OBJ Prev_t (* hidden = "1" *) : Time;
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

   state.Deriv_e = IF (previous(state.help) != state.help)
             THEN (previous(state.e) - state.e) / (previous(state.help) - state.help)
             ELSE previous(state.Deriv_e);  

     DERIV(state.Integ_e, [independent.t]) = state.e ;

     state.uhelp = interface.u0 
           + interface.K_P * (state.e + interface.T_D * state.Deriv_e 
                       + state.Integ_e / interface.T_I); 
                      
     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
    };
  :};

 


# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.linear_saturation.msl" 1
 








CLASS linear_Saturation
  (* icon = "controller" *)
  "Linear controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a linear controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    };

    parameters <-
    {
     OBJ a "u=a+b*y_M" : Real := {: value <- 0 ; group <- "Operational" :};
     OBJ b "u=a+b*y_M" : Real := {: value <- 1 ; group <- "Operational" :};
     OBJ u_Min "Minimum control action" : Real := {: value <- 0 ; group <- "Operational" :};
     OBJ u_Max "Maximum control action" : Real := {: value <- 1000 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
    };

    equations <-
    {
     state.uhelp = parameters.a + parameters.b * interface.y_M; 

     interface.u = IF(state.uhelp < parameters.u_Min)
                   THEN (parameters.u_Min)
                   ELSE
                     IF (state.uhelp > parameters.u_Max)
                     THEN parameters.u_Max
                     ELSE state.uhelp;
    };
  :};

 


# 27 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.pi_saturation_recB_EHV.msl" 1
 








  CLASS PI_Saturation_recB_EHV
  (* icon = "controller" *)
  "PI controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with saturation";
    interface <-
    {
     OBJ y_MA (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ y_MB (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
     OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_SA (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
				 Real := {: causality <- "CIN" ; value <- 3 ; group <- "Operational" :};
	   OBJ temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature" : 
				 CelsiusTemperature := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :};
	   OBJ switch (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "1=A, 2=B, 0=min(A,B)" : 
				 Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
    };

    parameters <-
    {
     OBJ K_PA "Factor of proportionality" : Real := {: value <- 25 ; group <- "Operational" :};
	   OBJ K_PB "Factor of proportionality" : Real := {: value <- 25 ; group <- "Operational" :};
     OBJ T_I "Integral time" : Time := {: value <- 0.1 ; group <- "Operational" :};
     OBJ u0A "No error action" : Real := {: value <- 50 ; group <- "Operational" :};
	   OBJ u0B "No error action" : Real := {: value <- 50 ; group <- "Operational" :};
     OBJ u_Min "Minimum control action" : Real := {: value <- 0 ; group <- "Operational" :};
     OBJ u_Max "Maximum control action" : Real := {: value <- 1000 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ eA "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_eA "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelpA (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
	   OBJ uA (* hidden = "0" *) "" : Real;
	 
	   OBJ eB "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_eB "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelpB (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
	   OBJ y_SB (* hidden = "0" *) "Setpoint value for controlled variable" : Real;
	   OBJ uB (* hidden = "0" *) "" : Real;
	     };

    equations <-
    {
     state.eA = interface.y_SA - interface.y_MA;

     DERIV(state.Integ_eA, [independent.t]) = state.eA ;

     state.uhelpA = parameters.u0A + parameters.K_PA 
	 			  				   * (state.eA + (1 / parameters.T_I) * state.Integ_eA); 

     state.uA = IF(state.uhelpA < parameters.u_Min)
                   THEN (parameters.u_Min)
                   ELSE
                     IF (state.uhelpA > parameters.u_Max)
                     THEN parameters.u_Max
                     ELSE state.uhelpA;
	
	 state.y_SB = IF(interface.temp < 11)
	 			  		 THEN 11.8
				  			ELSE
				  	  		IF(interface.temp < 12) 
					  			THEN 11.0
				      		ELSE
					  	  		IF(interface.temp < 13) 
					      		THEN 10.8
				          	ELSE
						  	  		IF(interface.temp < 14) 
					          	THEN 10.5
				              ELSE
							  	  		IF(interface.temp < 15) 
					              THEN 10.2
				                ELSE
								  	  		IF(interface.temp < 16) 
					                THEN 3.3
				                  ELSE
									  	  		IF(interface.temp < 17) 
					                  THEN 2.4
				                    ELSE
										  	  		IF(interface.temp < 18) 
					                    THEN 2.2
				                      ELSE 2.1;
					 
	 state.eB = state.y_SB - interface.y_MB;

   DERIV(state.Integ_eB, [independent.t]) = state.eB ;

   state.uhelpB = parameters.u0B + parameters.K_PB 
	 			  				   * (state.eB + (1 / parameters.T_I) * state.Integ_eB); 

   state.uB = IF(state.uhelpB < parameters.u_Min)
              THEN (parameters.u_Min)
              ELSE
                IF (state.uhelpB > parameters.u_Max)
                THEN parameters.u_Max
                ELSE state.uhelpB;				
	 
	 interface.u = IF (interface.switch == 1)
	 			   		 THEN state.uA
				   			ELSE
				   	   	 IF (interface.switch == 2)
					   			THEN state.uB
					   			ELSE
								 		IF (state.uB < state.uA)
	 			   				 THEN state.uB
				   				  ELSE state.uA;
				   
    };
  :};

 


# 28 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.raintank_EHV.msl" 1
 








   CLASS raintank_Eindhoven
   (* icon = "controller" *)
   "Ratio controller"
 
  
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ y_M1 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ y_M2 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ u (* terminal = "out_1" *) "Controlled variable" :
                Real := {: causality <- "COUT" ; group <- "Control action" :};
       OBJ Q_empty (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow when emptying" :
          FlowRate := {: causality <- "CIN" ; value <- 9600 ; group <- "Operational" :};
	  	 OBJ max_bio (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when Q_In = 0" :
          FlowRate := {: causality <- "CIN" ; value <- 9600 ; group <- "Operational" :};
};
 
     parameters <-
     {
      };
 
 
     equations <-
     {
     interface.u = IF (interface.y_M1 > 0)
 				   			 THEN 0
 				   			 ELSE 
		 								IF (interface.y_M2 > interface.max_bio)
				   					THEN 0
										 ELSE interface.Q_empty;
     };
  :};

 


# 29 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.constant_ratio_with_offset_Saturation.msl" 1
 








CLASS ConstantRatioWithOffset_Saturation
  (* icon = "controller" *)
  "Ratio controller with offset"

 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a ratio controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" :
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" :
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    	OBJ ConstantRatio (* terminal = "in_2"; manip = "1" *) "Ratio between measured value and controller output" :
         			Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
			OBJ Offset (* terminal = "in_2"; manip = "1" *) "Offset to be added to the calculated value" :
		 				  Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};	 
			OBJ u_Min (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
							 Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
			OBJ u_Max (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
							 Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
};

    parameters <-
    {

     
        
	 
	 
      
      
      
    };

    state <-  
    {
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

    state.uhelp = interface.ConstantRatio * interface.y_M + interface.Offset;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;

    };
  :};

 


# 30 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.pid_antiwindup_saturation.msl" 1
 








CLASS PID_AntiWindup_Saturation
  (* icon = "controller" *)
  "PID controller with anti-windup and saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with anti-windup and saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ y_S  (* terminal = "in_2"; manip = "1" *) "Setpoint value for controlled variable" : 
     				Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
      OBJ K_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" : 
     				Real := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};
      OBJ T_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : 
      			 Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ T_D (* terminal = "in_2"; manip = "1" *) "Derivative time" : 
						 Time := {: causality <- "CIN" ; value <- 0.2531080923 ; group <- "Operational" :};
      OBJ T_t (* terminal = "in_2"; manip = "1" *) "Tracking time (anti-windup)" : 
						 Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
      OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
     				Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
      OBJ u_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
     				Real := {: causality <- "CIN" ;value <- 0 ; group <- "Operational" :};
      OBJ u_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
     				Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Operational" :};

    };

    parameters <-
    {
 
 
 
 
 
 
 
 
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ u_Unsat (* hidden = "1" *) "Unsaturated output of the proportional-integral control action" : Real;
     OBJ u_Sat (* hidden = "1" *) "Saturated output of the proportional-integral control action" : Real;
     OBJ Deriv_e  "Derivative of error" : Real := {: group <- "Operational" :};
 
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

	 state.Deriv_e = IF (previous(state.help) != state.help)
				   	 THEN (previous(state.e) - state.e) / (previous(state.help) - state.help)
				   	 ELSE previous(state.Deriv_e);	

     DERIV(state.Integ_e, [independent.t]) = (interface.K_P * state.e / interface.T_I) + ((state.u_Sat - state.u_Unsat) / interface.T_t) ;

     state.u_Unsat = interface.u0 + interface.K_P * state.e + state.Integ_e + interface.K_P * interface.T_D * state.Deriv_e; 

	 state.u_Sat = IF(state.u_Unsat < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.u_Unsat > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.u_Unsat;
	 
     interface.u = state.u_Sat;
    };
  :};

 


# 31 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.operator_delayed.msl" 1
 








CLASS OperatorDelayed 
  (* icon = "controller" *)
  "operator control with loop breaker"

 
 
 
 
 
 
 
 


  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
              Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
              FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ y_S_Lower (* terminal = "in_2"; manip = "1" *) "Lower limit setpoint value for controlled variable " : 
							Concentration := {: causality <- "CIN" ; value <- 3.2 ; group <- "Operational" :};
      OBJ y_S_Upper (* terminal = "in_2"; manip = "1" *) "Upper limit setpoint value for controlled variable " : 
							Concentration := {: causality <- "CIN" ; value <- 3.5 ; group <- "Operational" :};
      OBJ K_P (* terminal = "in_2"; manip = "1" *) " Factor of proportionality" : 
							Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
      OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
							FlowRate := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
      OBJ u_Min (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
							FlowRate := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
      OBJ u_Max (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
							FlowRate := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
      OBJ T (* terminal = "in_2"; manip = "1" *) "Control window" : 
							Time := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
      
};

    parameters <-
    {
 
 
 
 
 
 
      
 
      
	 OBJ Tau "Implicit loop breaker time constant, d" : Time := {: value <- 0.0005 ; group <- "Miscellaneous" :};
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ uhelp (* hidden = "0" *) "Help variable to calculate the proportional control action" : Real;
     OBJ uhelp_control (* hidden = "0" *) "Help variable: calculated control action" : Real;
     OBJ uhelp_loopbreaker (* hidden = "0" *) "Help variable: loopbreaker/delay on calculated control action" : Real;
     OBJ Prev_t (* hidden = "0" *) "Help variable to calculate the begin of each period" : Time ;
    };

    initial <-  
    {
    state.Prev_t = 0;
 
    };	
    equations <-
    {

    state.Prev_t = 	IF	(independent.t - previous(state.Prev_t) < (interface.T))
			 	 	THEN	previous(state.Prev_t)
			 		ELSE	previous(state.Prev_t) + interface.T;

	
	
     state.uhelp = IF (independent.t == 0)
	 			   THEN interface.u0
				   ELSE
	 			     IF (independent.t - previous(state.Prev_t) < interface.T)
	 			   	 THEN	previous(state.uhelp)
				   	 ELSE
				       IF(interface.y_M < interface.y_S_Lower)
                   	   THEN previous(state.uhelp) - interface.K_P * (interface.y_S_Lower - interface.y_M)
                   	   ELSE
                         IF (interface.y_M > interface.y_S_Upper)
                       	 THEN previous(state.uhelp) + interface.K_P * (interface.y_M - interface.y_S_Upper)
                       	 ELSE previous(state.uhelp);

	 
     state.uhelp_control = IF(state.uhelp < interface.u_Min)
                   		   THEN (interface.u_Min)
                   		   ELSE
                     	     IF (state.uhelp > interface.u_Max)
                     		 THEN interface.u_Max
                     		 ELSE state.uhelp;


      DERIV(state.uhelp_loopbreaker,[independent.t]) =
       - (1 / parameters.Tau) * (state.uhelp_loopbreaker - state.uhelp_control);

      interface.u = state.uhelp_loopbreaker;


   };

 :};


 


# 32 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.aerationmodel.msl" 1
 








	CLASS Irvine_Aeration_model_Carbon_foot_print
    (* icon = "controller" *)
    "Irvine Carbon foot print"
  
   
   
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
    comments <- "A model that calculates Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
   	OBJ TSS_Anaerobic (* terminal = "in_1" *) "TSS concentration in the aeration tank (g/m3)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ TSS_Aerobic (* terminal = "in_1" *) "TSS concentration in the aeration tank (g/m3)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ TSS_Anoxic (* terminal = "in_1" *) "TSS concentration in the aeration tank (g/m3)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ Q_was   (* terminal = "in_1" *) " Load Sludge Flow  (kg/d)" :
    			 FlowRate := {: causality <- "CIN" ; group <- "Control action" :};
     OBJ Kla   	 (* terminal = "out_1" *) "Calculated Kla (1/d)" :
                 OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
	   OBJ O2_tank  (* terminal = "in_1" *) "Actual oxygen concentration in the aeration tank (g/m)" :
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ Volume   (* terminal = "in_1" *) "Aeration tank volume (m)" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ O2_rsat_average   (* terminal = "out_1" *) "Average oxygen saturation depending on water temperature and tank depth for fine bubble aeration (g/m)" :
    			 Concentration := {: causality <- "COUT" ; group <- "Control action" :};
		 OBJ Q_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Air flow rate of the fine bubble aerators under standard conditions (Nm/d)": 
			     FlowRate := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
	   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature (C)": 
				   CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Local conditions of the situ" :};
	   OBJ P_atm (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Standard atmospheric pressure (Pa)": 
			     Real := {: causality <- "CIN" ; value <- 101325; group <- "Local conditions of the situ" :};
	   OBJ Temp_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature (C)": 
			     CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Local conditions of the situ" :};

	 
    };
  
 parameters <-
    {
	OBJ Depth "Depth of fine bubble aerator below the watersurface (m)": Real := {: value <- 6 ; group <- "Geometry of the tank and aerators" :};
	OBJ H "altitudine": Real := {: value <- 10 ; group <- "Local conditions of the situ" :};
	OBJ p_site "Vapour pressure (Pa)": Real := {: value <- 2334; group <- "Local conditions of the situ" :};
	OBJ P_st_atm "Standard atmospheric pressure (Pa)": Real := {: value <- 101325; group <- "Local conditions of the situ" :};
	OBJ Rho_sludge "Density of sludge (kg/m)": Real := {: value <- 988 ; group <- "Characteristic of the sludge and air" :};
	OBJ Rho_air "Air Density (kg/m)": Real := {: value <- 1.23 ; group <- "Characteristic of the sludge and air" :};
	OBJ Beta "Beta factor (-)": Real := {: value <- 0.98 ; group <- "Characteristic of the sludge and air" :};
	OBJ Phi "Phi factor (-)": Real := {: value <- 1.024 ; group <- "Characteristic of the sludge and air" :};
	OBJ O2_air "Oxygen concentration in the atmosphere (%)": Real := {: value <- 20.85 ; group <- "Characteristic of the sludge and air" :};
	OBJ CO2_in "CO2 concentration in the atmosphere (%)": Real := {: value <- 0.03 ; group <- "Characteristic of the sludge and air" :};
	OBJ O2_sat20 "Oxygen saturation of water under standard conditions (g/m): 1 atm, 20 C, no salts": Real := {: value <- 10.50 ; group <- "Characteristic of the sludge and air" :};
	OBJ g "Strength of the gravitational field (m/s)": Real := {: value <- 9.82 ; group <- "Characteristic of the sludge and air" :};
	OBJ a "diffuser specific aerea (m2)": Real := {: value <- 2 ; group <- "Geometry of the tank and aerators" :};
	OBJ A "dimensionaless Aeration model": Real := {: value <- 5.717 ; group <- "Aeration model" :};
	OBJ B "dimensionaless Aeration model": Real := {: value <- 6.815 ; group <- "Aeration model" :};
	OBJ f "fraction of the tank": Real := {: value <- 0.44 ; group <- "Aeration model" :};
	OBJ Nd "Total diffuser number (-)": Real := {: value <- 504 ; group <- "Geometry of the tank and aerators" :};
	OBJ SOTE "standard oxygen transfer efficiency (%)": Real := {: value <- 42 ; group <- "Operational" :};
	OBJ Anaerobic_Volume_biological "anaerobic volume biological reactor  (mc)": Real := {: value <- 11200 ; group <- "Operational" :};
	OBJ Anoxic_Volume_biological "anoxic volume biological reactor  (mc)": Real := {: value <- 28750 ; group <- "Operational" :};
	OBJ Aerobic_Volume_biological "aerobic volume biological reactor  (mc)": Real := {: value <- 50100 ; group <- "Operational" :};
	 
	OBJ P_out "Outut Pressure from the Blower (Pa)": Real := {: value <- 80000; group <- "Power consumption" :};
	OBJ landa "costant for air (-)": Real := {: value <- 1.395 ; group <- "Power consumption" :};
	OBJ epsilon "efficiency of the motor (-)": Real := {: value <- 0.58 ; group <- "Power consumption" :};
	OBJ fCO2 "factor of CO2 production (-)": Real := {: value <- 0.718 ; group <- "Power consumption" :};
	OBJ Tin "absolute inlet temperature  (K)": Real := {: value <- 293.15 ; group <- "Power consumption" :};
	};	 
		
	independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
     };
		
	state <-
    {
	OBJ p_site_variable "Vapour pressure (Pa)": Real := {: group <- "Local conditions of the situ" :};
	OBJ MCRT "Age slduge(d)": Real := {: group <- "Operational" :};
	OBJ Alpha "alphafactor ": Real := {: group <- "Operational" :};
	OBJ AlphaSOTE "Oxygen transfer efficiency for new fine bubble aeration in wastewater ": Real := {: group <- "Aeration" :};
	OBJ Chi "Characteristic number (-)": Real := {: group <- "Aeration" :};
	OBJ lgChi "Characteristic number (-)": Real := {: group <- "Aeration":};
	OBJ Qn "Normalized air flow (-)": Real := {: group <- "Aeration" :};
    OBJ SOTR "Standard oxygen transfer rate for fine bubble aeration (g/d)": Real := {: group <- "Aeration" :};
	OBJ AOTR "Actual oxygen transfer rate for fine bubble aeration (g/d)": Real := {: group <- "Aeration" :};
	OBJ	AOTRspecific "Oxygen transfer for diffuser (kg/d/m2)": Real := {: group <- "Aeration" :};
	OBJ O2_rsat "Oxygen saturation depending on water temperature (g/m3)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ O2sat_std "Oxygen saturation depending on water depth (g/m3)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ MRi "mole ratio of oxygen to inters in ambient air and off gas (%)": Real := {: group <- "Aeration" :};
	OBJ MRe "mole ratio of oxygen to leave from aeration tank (%)": Real := {: group <- "Aeration" :};
	OBJ P_depth "Pressure at the bottom of the tank (Pa)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ OTEf "Oxygen transfer efficiency under field conditions (%)": Real := {: group <- "Aeration" :};
	 
	OBJ CO2 "CO2 production (kg/d)": Real := {: group <- "Power consumption" :};
	OBJ k "costant power factor (kW/(m3/s))": Real := {: group <- "Power consumption" :};
	OBJ Energy_consume "energy consume (kWh)": Real := {: group <- "Power consumption" :};
	OBJ Integ_energy_consume "Integral energy consume(kWh)" : Real:= {: group <- "Power consumption" :} ;
	OBJ Integ_emissione_CO2 "Integral CO2(kg)" : Real:= {: group <- "Power consumption" :} ;
	OBJ Power_blowers "Power(kW)" : Real:= {: group <- "Power consumption" :};
	};
    
		 
    equations <-
    { 
	 
	state.MCRT = (parameters.Anoxic_Volume_biological * interface.TSS_Anoxic + parameters.Anaerobic_Volume_biological * interface.TSS_Anaerobic + parameters.Aerobic_Volume_biological * interface.TSS_Aerobic) / 1000 /(interface.Q_was + 1);
	state.Qn = interface.Q_air / (24*3600*(parameters.a * parameters.Nd * parameters.Depth));
 
       state.Chi = IF (state.Qn == 0.0)
                   THEN 0.0
                   ELSE state.MCRT/state.Qn;
	
 
       state.lgChi = IF (state.Chi == 0.0)
                     THEN 0.0
                     ELSE log10(state.Chi);
 
       state.AlphaSOTE = IF (state.Chi == 0.0)
                         THEN 0.0
                         ELSE (parameters.A * log10(state.Chi) - parameters.B)/100;

	state.Alpha = state.AlphaSOTE / parameters.SOTE * 100;	
	 
	state.MRi = parameters.O2_air/100/(1 - parameters.O2_air/100 - parameters.CO2_in/100);
	state.MRe =  state.MRi*(1-state.OTEf);
	state.OTEf = state.AlphaSOTE * (parameters.Beta * interface.O2_rsat_average - interface.O2_tank) / ( state.O2sat_std) * pow(parameters.Phi,(interface.Temp-20));
	 
	state.P_depth = parameters.Rho_sludge * parameters.g * parameters.Depth;
	state.p_site_variable = pow(10, 0.6979 + 0.02618* interface.Temp_air)* 133.33;
	state.O2_rsat = 14.65 - 0.41 * (interface.Temp) + 0.00799 * (interface.Temp) * (interface.Temp) - 0.0000778 * (interface.Temp) * (interface.Temp) * (interface.Temp);
	interface.O2_rsat_average = state.O2_rsat * (state.P_depth * parameters.f + interface.P_atm - state.p_site_variable)/ (parameters.P_st_atm - parameters.p_site);
	state.O2sat_std =  parameters.O2_sat20;
	 
	state.SOTR =  interface.Q_air * parameters.Rho_air  * parameters.SOTE * parameters.O2_air / 10000;
	state.AOTR = state.Alpha * state.SOTR * (parameters.Beta * interface.O2_rsat_average - interface.O2_tank) /state.O2sat_std * pow(parameters.Phi,(interface.Temp-20));
	interface.Kla = 1000 * state.AOTR/((parameters.Beta * interface.O2_rsat_average - interface.O2_tank) * interface.Volume);
	state.AOTRspecific = state.AOTR /(interface.Volume);
	 
	state.k = (parameters.P_st_atm * parameters.landa * parameters.Tin) / (2.73 * 100000 * parameters.epsilon * (parameters.landa - 1)) * (pow((parameters.P_out + parameters.P_st_atm)/parameters.P_st_atm,1-1/parameters.landa)-1);
	state.Power_blowers = state.k * interface.Q_air/(24*3600);
	state.CO2 = state.Power_blowers * parameters.fCO2;
	DERIV(state.Integ_energy_consume, [independent.t]) = 24 * state.Power_blowers ;
	DERIV(state.Integ_emissione_CO2, [independent.t]) = state.CO2 ;
	};
    :};

 


# 33 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.sensor_switch.msl" 1
 








   CLASS sensor_switch
   (* icon = "controller" *)
   "Controller for the measurement to use for subsequent control actions"
 
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ In_1 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ In_2 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ In_3 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ In_4 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ In_5 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ In_6 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ In_7 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ In_8 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Out (* terminal = "out_1" *) "Measurement to use" :
                Real := {: causality <- "COUT" ; group <- "Measurement data" :};
       
};
 
     parameters <-
     {
     OBJ switch "Switch value to choose which sensor location to use" : 
          Real := {: value <- 1 ; group <- "Operational" :};;
      };
 
 
     equations <-
     {
     interface.Out = IF (parameters.switch == 1)
 				   			       THEN interface.In_1
 				   			       ELSE 
		 								 IF (parameters.switch == 2)
				   					   THEN interface.In_2
										   ELSE
                     IF (parameters.switch == 3)
				   					   THEN interface.In_3
										   ELSE
										 IF (parameters.switch == 3)
				   					   THEN interface.In_3
										   ELSE
                     IF (parameters.switch == 4)
				   					   THEN interface.In_4
										   ELSE
                     IF (parameters.switch == 5)
				   					   THEN interface.In_5
										   ELSE
										 IF (parameters.switch == 6)
				   					   THEN interface.In_6
										   ELSE
										 IF (parameters.switch == 7)
				   					   THEN interface.In_7
										   ELSE
										 IF (parameters.switch == 8)
				   					   THEN interface.In_8
										   ELSE 0
     };
  :};

 


# 34 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.dynamic_volume.msl" 1
 








   CLASS volume_controller
   (* icon = "controller" *)
   "Controller to adjust tank volumes according to influent flow (Compartmental Model)"
 
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ influent_flow (* terminal = "in_1" *) "Influent flow to tank in m3/d" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ airflow_rate (* terminal = "in_1" *) "Air flow rate" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     
	      
	      
	      
	   OBJ tank1_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" : 
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank1_y (* terminal = "in_2" *) "B-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank1_C (* terminal = "in_2" *) "C-Constant in the equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank2_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank2_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank2_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank3_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank3_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank3_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank4_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank4_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank4_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" : 
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank5_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank5_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank5_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank6_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank6_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank6_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank7_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank7_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank7_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank8_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" : 
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank8_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank8_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" : 
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
	               
     OBJ tank9_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank9_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank9_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank10_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank10_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank10_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
    
     OBJ tank11_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank11_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank11_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank12_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank12_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank12_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" : 
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
    
     OBJ tank13_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank13_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank13_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" : 
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
	               
     OBJ tank14_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" : 
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank14_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank14_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
     OBJ tank15_x (* terminal = "in_2" *) "A-factor in equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank15_y (* terminal = "in_2" *) "Value to multiply airflow rate with" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     OBJ tank15_C (* terminal = "in_2" *) "Constant in the linear equation to calculate relative volume" :  
	               Real := {: causality <- "CIN" ; group <- "Dimension" :};
     
       OBJ Volume_tank1 (* terminal = "out_1" *) "Volume of tank 1" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank2 (* terminal = "out_1" *) "Volume of tank 2" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank3 (* terminal = "out_1" *) "Volume of tank 3" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank4 (* terminal = "out_1" *) "Volume of tank 4" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank5 (* terminal = "out_1" *) "Volume of tank 5" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank6 (* terminal = "out_1" *) "Volume of tank 6" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank7 (* terminal = "out_1" *) "Volume of tank 7" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank8 (* terminal = "out_1" *) "Volume of tank 8" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank9 (* terminal = "out_1" *) "Volume of tank 9" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank10 (* terminal = "out_1" *) "Volume of tank 10" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank11 (* terminal = "out_1" *) "Volume of tank 11" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank12 (* terminal = "out_1" *) "Volume of tank 12" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank13 (* terminal = "out_1" *) "Volume of tank 13" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank14 (* terminal = "out_1" *) "Volume of tank 14" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};
       OBJ Volume_tank15 (* terminal = "out_1" *) "Volume of tank 15" :
                Real := {: causality <- "COUT" ; group <- "Dimension" :};                
};
      state <-
     { 
       OBJ Volume_tank1_help (* hidden = "1" *) "Volume of tank 1" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank2_help (* hidden = "1" *) "Volume of tank 2" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank3_help (* hidden = "1" *) "Volume of tank 3" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank4_help (* hidden = "1" *) "Volume of tank 4" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank5_help (* hidden = "1" *) "Volume of tank 5" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank6_help (* hidden = "1" *) "Volume of tank 6" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank7_help (* hidden = "1" *) "Volume of tank 7" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank8_help (* hidden = "1" *) "Volume of tank 8" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank9_help (* hidden = "1" *) "Volume of tank 9" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank10_help (* hidden = "1" *) "Volume of tank 10" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank11_help (* hidden = "1" *) "Volume of tank 11" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank12_help (* hidden = "1" *) "Volume of tank 12" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank13_help (* hidden = "1" *) "Volume of tank 13" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank14_help (* hidden = "1" *) "Volume of tank 14" : Real := {: group <- "Dimension" :};
       OBJ Volume_tank15_help (* hidden = "1" *) "Volume of tank 15" : Real := {: group <- "Dimension" :};
};
     parameters <-
     {    
      
      
      
      
      
      
     OBJ Total_volume "Total volume of the compartmental model under consideration" : Real := {: value <- 1000 ; group <- "Dimension" :};
     OBJ Relation_tank1 "Function determining the relation between airflow, influent flow and relative volume; " : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank2 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank3 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank4 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank5 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank6 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank7 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank8 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank9 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank10 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank11 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank12 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank13 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank14 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_tank15 "Function determining the relation between airflow, influent flow and relative volume; 0=linear,1=paraboloid with maximum,2=paraboloid with minimum" : Real := {:value <- 0 ; group <- "Relations" :};
};
 
     equations <-
     {
     state.Volume_tank1_help = IF (parameters.Relation_tank1 == 0)
                              THEN parameters.Total_volume*(interface.tank1_x*interface.influent_flow + interface.tank1_y*previous(interface.airflow_rate) + interface.tank1_C)
                              ELSE
                              IF (parameters.Relation_tank1 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank1_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank1_y,2) + 
                                   interface.tank1_C)
                              ELSE
                              IF (parameters.Relation_tank1 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank1_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank1_y,2) + 
                                   interface.tank1_C)
                              ELSE
                              IF (parameters.Relation_tank1 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank1_x + pow(previous(interface.airflow_rate),2)*interface.tank1_y + 
                                   interface.tank1_C)
                              ELSE
                              IF (parameters.Relation_tank1 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank1_x - pow(previous(interface.airflow_rate),2)*interface.tank1_y + 
                                   interface.tank1_C)
                              ELSE 0;
     interface.Volume_tank1 = IF (state.Volume_tank1_help < 0)
                              THEN 1
                              ELSE state.Volume_tank1_help;
                            
     state.Volume_tank2_help = IF (parameters.Relation_tank2 == 0)
                              THEN parameters.Total_volume*(interface.tank2_x*interface.influent_flow + interface.tank2_y*previous(interface.airflow_rate) + interface.tank2_C)
                              ELSE
                              IF (parameters.Relation_tank2 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank2_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank2_y,2) + 
                                   interface.tank2_C)
                              ELSE
                              IF (parameters.Relation_tank2 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank2_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank2_y,2) + 
                                   interface.tank2_C)
                              ELSE
                              IF (parameters.Relation_tank2 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank2_x + pow(previous(interface.airflow_rate),2)*interface.tank2_y + 
                                   interface.tank2_C)
                              ELSE
                              IF (parameters.Relation_tank2 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank2_x - pow(previous(interface.airflow_rate),2)*interface.tank2_y + 
                                   interface.tank2_C)
                              ELSE 0;
     interface.Volume_tank2 = IF (state.Volume_tank2_help < 0)
                              THEN 1
                              ELSE state.Volume_tank2_help;
                              
     state.Volume_tank3_help = IF (parameters.Relation_tank3 == 0)
                              THEN parameters.Total_volume*(interface.tank3_x*interface.influent_flow + interface.tank3_y*previous(interface.airflow_rate) + interface.tank3_C)
                              ELSE
                              IF (parameters.Relation_tank3 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank3_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank3_y,2) + 
                                   interface.tank3_C)
                              ELSE
                              IF (parameters.Relation_tank3 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank3_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank3_y,2) + 
                                   interface.tank3_C)
                              ELSE
                              IF (parameters.Relation_tank3 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank3_x + pow(previous(interface.airflow_rate),2)*interface.tank3_y + 
                                   interface.tank3_C)
                              ELSE
                              IF (parameters.Relation_tank3 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank3_x - pow(previous(interface.airflow_rate),2)*interface.tank3_y + 
                                   interface.tank3_C)
                              ELSE 0;
     interface.Volume_tank3 = IF (state.Volume_tank3_help < 0)
                              THEN 1
                              ELSE state.Volume_tank3_help; 
                              
     state.Volume_tank4_help = IF (parameters.Relation_tank4 == 0)
                              THEN parameters.Total_volume*(interface.tank4_x*interface.influent_flow + interface.tank4_y*previous(interface.airflow_rate) + interface.tank4_C)
                              ELSE
                              IF (parameters.Relation_tank4 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank4_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank4_y,2) + 
                                   interface.tank4_C)
                              ELSE
                              IF (parameters.Relation_tank4 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank4_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank4_y,2) + 
                                   interface.tank4_C)
                              ELSE
                              IF (parameters.Relation_tank4 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank4_x + pow(previous(interface.airflow_rate),2)*interface.tank4_y + 
                                   interface.tank4_C)
                              ELSE
                              IF (parameters.Relation_tank4 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank4_x - pow(previous(interface.airflow_rate),2)*interface.tank4_y + 
                                   interface.tank4_C)
                              ELSE 0;
      interface.Volume_tank4 = IF (state.Volume_tank4_help < 0)
                              THEN 1
                              ELSE state.Volume_tank4_help;
                              
      state.Volume_tank5_help = IF (parameters.Relation_tank5 == 0)
                              THEN parameters.Total_volume*(interface.tank5_x*interface.influent_flow + interface.tank5_y*previous(interface.airflow_rate) + interface.tank5_C)
                              ELSE
                              IF (parameters.Relation_tank5 == 1)
                             THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank5_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank5_y,2) + 
                                   interface.tank5_C)
                              ELSE
                              IF (parameters.Relation_tank5 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank5_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank5_y,2) + 
                                   interface.tank5_C)
                              ELSE
                              IF (parameters.Relation_tank5 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank5_x + pow(previous(interface.airflow_rate),2)*interface.tank5_y + 
                                   interface.tank5_C)
                              ELSE
                              IF (parameters.Relation_tank5 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank5_x - pow(previous(interface.airflow_rate),2)*interface.tank5_y + 
                                   interface.tank5_C)
                              ELSE 0;     
     interface.Volume_tank5 = IF (state.Volume_tank5_help < 0)
                              THEN 1
                              ELSE state.Volume_tank5_help;
                              
     state.Volume_tank6_help = IF (parameters.Relation_tank6 == 0)
                              THEN parameters.Total_volume*(interface.tank6_x*interface.influent_flow + interface.tank6_y*previous(interface.airflow_rate) + interface.tank6_C)
                              ELSE
                              IF (parameters.Relation_tank6 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank6_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank6_y,2) + 
                                   interface.tank6_C)
                              ELSE
                              IF (parameters.Relation_tank6 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank6_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank6_y,2) + 
                                   interface.tank6_C)
                              ELSE
                              IF (parameters.Relation_tank6 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank6_x + pow(previous(interface.airflow_rate),2)*interface.tank6_y + 
                                   interface.tank6_C)
                              ELSE
                              IF (parameters.Relation_tank6 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank6_x - pow(previous(interface.airflow_rate),2)*interface.tank6_y + 
                                   interface.tank6_C)
                              ELSE 0;
     interface.Volume_tank6 = IF (state.Volume_tank6_help < 0)
                              THEN 1
                              ELSE state.Volume_tank6_help;
                              
     state.Volume_tank7_help = IF (parameters.Relation_tank7 == 0)
                              THEN parameters.Total_volume*(interface.tank7_x*interface.influent_flow + interface.tank7_y*previous(interface.airflow_rate) + interface.tank7_C)
                              ELSE
                              IF (parameters.Relation_tank7 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank7_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank7_y,2) + 
                                   interface.tank8_C)
                              ELSE
                              IF (parameters.Relation_tank7 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank7_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank7_y,2) + 
                                   interface.tank7_C)
                              ELSE
                              IF (parameters.Relation_tank7 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank7_x + pow(previous(interface.airflow_rate),2)*interface.tank7_y + 
                                   interface.tank7_C)
                              ELSE
                              IF (parameters.Relation_tank7 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank7_x - pow(previous(interface.airflow_rate),2)*interface.tank7_y + 
                                   interface.tank7_C)
                              ELSE 0;     
     interface.Volume_tank7 = IF (state.Volume_tank7_help < 0)
                              THEN 1
                              ELSE state.Volume_tank7_help;
                              
     state.Volume_tank8_help = IF (parameters.Relation_tank8 == 0)
                              THEN parameters.Total_volume*(interface.tank8_x*interface.influent_flow + interface.tank8_y*previous(interface.airflow_rate) + interface.tank8_C)
                              ELSE
                              IF (parameters.Relation_tank8 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank8_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank8_y,2) + 
                                   interface.tank8_C)
                              ELSE
                              IF (parameters.Relation_tank8 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank8_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank8_y,2) + 
                                   interface.tank8_C)
                              ELSE
                              IF (parameters.Relation_tank8 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank8_x + pow(previous(interface.airflow_rate),2)*interface.tank8_y + 
                                   interface.tank8_C)
                              ELSE
                              IF (parameters.Relation_tank8 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank8_x - pow(previous(interface.airflow_rate),2)*interface.tank8_y + 
                                   interface.tank8_C)
                              ELSE 0;     
     interface.Volume_tank8 = IF (state.Volume_tank8_help < 0)
                              THEN 1
                              ELSE state.Volume_tank8_help;
                              
     state.Volume_tank9_help = IF (parameters.Relation_tank9 == 0)
                              THEN parameters.Total_volume*(interface.tank9_x*interface.influent_flow + interface.tank9_y*previous(interface.airflow_rate) + interface.tank9_C)
                              ELSE
                              IF (parameters.Relation_tank9 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank9_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank9_y,2) + 
                                   interface.tank9_C)
                              ELSE
                              IF (parameters.Relation_tank9 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank9_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank9_y,2) + 
                                   interface.tank9_C)
                              ELSE
                              IF (parameters.Relation_tank9 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank9_x + pow(previous(interface.airflow_rate),2)*interface.tank9_y + 
                                   interface.tank9_C)
                              ELSE
                              IF (parameters.Relation_tank9 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank9_x - pow(previous(interface.airflow_rate),2)*interface.tank9_y + 
                                   interface.tank9_C)
                              ELSE 0;     
     interface.Volume_tank9 = IF (state.Volume_tank9_help < 0)
                              THEN 1
                              ELSE state.Volume_tank9_help;
                              
     state.Volume_tank10_help = IF (parameters.Relation_tank10 == 0)
                              THEN parameters.Total_volume*(interface.tank10_x*interface.influent_flow + interface.tank10_y*previous(interface.airflow_rate) + interface.tank10_C)
                              ELSE
                              IF (parameters.Relation_tank10 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank10_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank10_y,2) + 
                                   interface.tank10_C)
                              ELSE
                              IF (parameters.Relation_tank10 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank10_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank10_y,2) + 
                                   interface.tank10_C)
                              ELSE
                              IF (parameters.Relation_tank10 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank10_x + pow(previous(interface.airflow_rate),2)*interface.tank10_y + 
                                   interface.tank10_C)
                              ELSE
                              IF (parameters.Relation_tank10 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank10_x - pow(previous(interface.airflow_rate),2)*interface.tank10_y + 
                                   interface.tank10_C)
                              ELSE 0;     
     interface.Volume_tank10 = IF (state.Volume_tank10_help < 0)
                              THEN 1
                              ELSE state.Volume_tank10_help;
                              
     state.Volume_tank11_help = IF (parameters.Relation_tank11 == 0)
                              THEN parameters.Total_volume*(interface.tank11_x*interface.influent_flow + interface.tank11_y*previous(interface.airflow_rate) + interface.tank11_C)
                              ELSE
                              IF (parameters.Relation_tank11 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank11_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank11_y,2) + 
                                   interface.tank11_C)
                              ELSE
                              IF (parameters.Relation_tank11 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank11_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank11_y,2) + 
                                   interface.tank11_C)
                              ELSE
                              IF (parameters.Relation_tank11 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank11_x + pow(previous(interface.airflow_rate),2)*interface.tank11_y + 
                                   interface.tank11_C)
                              ELSE
                              IF (parameters.Relation_tank11 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank11_x - pow(previous(interface.airflow_rate),2)*interface.tank11_y + 
                                   interface.tank11_C)
                              ELSE 0;                               
     interface.Volume_tank11 = IF (state.Volume_tank11_help < 0)
                              THEN 1
                              ELSE state.Volume_tank11_help;
                              
     state.Volume_tank12_help = IF (parameters.Relation_tank12 == 0)
                              THEN parameters.Total_volume*(interface.tank12_x*interface.influent_flow + interface.tank12_y*previous(interface.airflow_rate) + interface.tank12_C)
                              ELSE
                              IF (parameters.Relation_tank12 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank12_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank12_y,2) + 
                                   interface.tank12_C)
                              ELSE
                              IF (parameters.Relation_tank12 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank12_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank12_y,2) + 
                                   interface.tank12_C)
                              ELSE
                              IF (parameters.Relation_tank12 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank12_x + pow(previous(interface.airflow_rate),2)*interface.tank12_y + 
                                   interface.tank12_C)
                              ELSE
                              IF (parameters.Relation_tank12 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank12_x - pow(previous(interface.airflow_rate),2)*interface.tank12_y + 
                                   interface.tank12_C)
                              ELSE 0;     
     interface.Volume_tank12 = IF (state.Volume_tank12_help < 0)
                              THEN 1
                              ELSE state.Volume_tank12_help;
                              
     state.Volume_tank13_help = IF (parameters.Relation_tank13 == 0)
                              THEN parameters.Total_volume*(interface.tank13_x*interface.influent_flow + interface.tank13_y*previous(interface.airflow_rate) + interface.tank13_C)
                              ELSE
                              IF (parameters.Relation_tank13 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank13_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank13_y,2) + 
                                   interface.tank13_C)
                              ELSE
                              IF (parameters.Relation_tank13 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank13_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank13_y,2) + 
                                   interface.tank13_C)
                              ELSE
                              IF (parameters.Relation_tank13 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank13_x + pow(previous(interface.airflow_rate),2)*interface.tank13_y + 
                                   interface.tank13_C)
                              ELSE
                              IF (parameters.Relation_tank13 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank13_x - pow(previous(interface.airflow_rate),2)*interface.tank13_y + 
                                   interface.tank13_C) 
                              ELSE 0;     
     interface.Volume_tank13 = IF (state.Volume_tank13_help < 0)
                              THEN 1
                              ELSE state.Volume_tank13_help;
                              
     state.Volume_tank14_help = IF (parameters.Relation_tank14 == 0)
                              THEN parameters.Total_volume*(interface.tank14_x*interface.influent_flow + interface.tank14_y*previous(interface.airflow_rate) + interface.tank14_C)
                              ELSE
                              IF (parameters.Relation_tank14 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank14_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank14_y,2) + 
                                   interface.tank14_C)
                              ELSE
                              IF (parameters.Relation_tank14 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank14_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank14_y,2) + 
                                   interface.tank14_C)
                              ELSE
                              IF (parameters.Relation_tank14 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank14_x + pow(previous(interface.airflow_rate),2)*interface.tank14_y + 
                                   interface.tank14_C)
                              ELSE
                              IF (parameters.Relation_tank14 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank14_x - pow(previous(interface.airflow_rate),2)*interface.tank14_y + 
                                   interface.tank14_C)
                              ELSE 0;    
     interface.Volume_tank14 = IF (state.Volume_tank14_help < 0)
                              THEN 1
                              ELSE state.Volume_tank14_help;
                              
     state.Volume_tank15_help = IF (parameters.Relation_tank15 == 0)
                              THEN parameters.Total_volume*(interface.tank15_x*interface.influent_flow + interface.tank15_y*previous(interface.airflow_rate) + interface.tank15_C)
                              ELSE
                              IF (parameters.Relation_tank15 == 1)
                              THEN parameters.Total_volume*(pow(interface.influent_flow,2)/pow(interface.tank15_x,2) + pow(previous(interface.airflow_rate),2)/pow(interface.tank15_y,2) + 
                                   interface.tank15_C)
                              ELSE
                              IF (parameters.Relation_tank15 == 2)
                              THEN parameters.Total_volume*(-pow(interface.influent_flow,2)/pow(interface.tank15_x,2) - pow(previous(interface.airflow_rate),2)/pow(interface.tank15_y,2) + 
                                   interface.tank15_C)
                              ELSE
                              IF (parameters.Relation_tank15 == 3)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank15_x + pow(previous(interface.airflow_rate),2)*interface.tank15_y + 
                                   interface.tank15_C)
                              ELSE
                              IF (parameters.Relation_tank15 == 4)
                              THEN parameters.Total_volume*(interface.influent_flow*previous(interface.airflow_rate)*interface.tank15_x - pow(previous(interface.airflow_rate),2)*interface.tank15_y + 
                                   interface.tank15_C)                                   
                              ELSE 0;
     interface.Volume_tank15 = IF (state.Volume_tank15_help < 0)
                              THEN 1
                              ELSE state.Volume_tank15_help;                         
   };
  :};

 


# 35 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.dynamic_exchangeflows.msl" 1
 








   CLASS exchangeflow_controller
   (* icon = "controller" *)
   "Controller to adjust exchange flows according to influent flow (Compartmental Model)"
 
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ influent_flow (* terminal = "in_1" *) "Influent flow to tank in m3/d" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ airflow_rate (* terminal = "in_1" *) "Air flow rate" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     
	      
        
  	   OBJ flow1_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
  	             Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow1_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow1_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow2_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow2_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow2_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow3_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow3_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow3_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow4_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow4_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow4_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow5_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow5_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow5_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow6_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow6_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow6_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow7_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow7_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow7_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow8_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow8_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow8_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow9_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow9_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow9_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       
       OBJ flow10_x (* terminal = "in_2" *) "Value to multiply influent flow with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow10_y (* terminal = "in_2" *) "Value to multiply airflow rate with" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
       OBJ flow10_C (* terminal = "in_2" *) "Constant in the linear equation to calculate exchange flow" : 
                 Real := {: causality <- "CIN" ; group <- "Operational" :};
	     
	     
       OBJ Exchange_flow1 (* terminal = "out_1" *) "Exchange flow 1" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow2 (* terminal = "out_1" *) "Exchange flow 2" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow3 (* terminal = "out_1" *) "Exchange flow 3" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow4 (* terminal = "out_1" *) "Exchange flow 4" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow5 (* terminal = "out_1" *) "Exchange flow 5" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow6 (* terminal = "out_1" *) "Exchange flow 6" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow7 (* terminal = "out_1" *) "Exchange flow 7" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow8 (* terminal = "out_1" *) "Exchange flow 8" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow9 (* terminal = "out_1" *) "Exchange flow 9" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};
       OBJ Exchange_flow10 (* terminal = "out_1" *) "Exchange flow 10" :
                Real := {: causality <- "COUT" ; group <- "Operational" :};                
};

      parameters <-
     {    
      
      
      
      
      
      
     OBJ Relation_flow1 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow2 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow3 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow4 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow5 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow6 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow7 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow8 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow9 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
     OBJ Relation_flow10 "Function determining the relation between airflow, influent flow and exchange flow" : Real := {:value <- 0 ; group <- "Relations" :};
};
 
     equations <-
     {
     interface.Exchange_flow1 = IF (parameters.Relation_flow1 == 0) 
                                THEN IF (interface.flow1_x*interface.influent_flow + interface.flow1_y*interface.airflow_rate + interface.flow1_C < 0)
                                     THEN 0
                                     ELSE interface.flow1_x*interface.influent_flow + interface.flow1_y*interface.airflow_rate + interface.flow1_C
                                ELSE IF (parameters.Relation_flow1 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow1_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow1_y,2) + interface.flow1_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow1_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow1_y,2) + interface.flow1_C
                                ELSE IF (parameters.Relation_flow1 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow1_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow1_y,2) + interface.flow1_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow1_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow1_y,2) + interface.flow1_C
                                ELSE IF (parameters.Relation_flow1 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow1_x + pow(interface.influent_flow,2)*interface.flow1_y + interface.flow1_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow1_x + pow(interface.influent_flow,2)*interface.flow1_y + interface.flow1_C
                                ELSE IF (parameters.Relation_flow1 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow1_x - pow(interface.influent_flow,2)*interface.flow1_y + interface.flow1_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow1_x - pow(interface.influent_flow,2)*interface.flow1_y + interface.flow1_C
                                ELSE 0; 
     
     interface.Exchange_flow2 = IF (parameters.Relation_flow2 == 0) 
                                THEN IF (interface.flow2_x*interface.influent_flow + interface.flow2_y*interface.airflow_rate + interface.flow2_C < 0)
                                     THEN 0
                                     ELSE interface.flow2_x*interface.influent_flow + interface.flow2_y*interface.airflow_rate + interface.flow2_C
                                ELSE IF (parameters.Relation_flow2 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow2_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow2_y,2) + interface.flow2_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow2_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow2_y,2) + interface.flow2_C
                                ELSE IF (parameters.Relation_flow2 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow2_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow2_y,2) + interface.flow2_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow2_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow2_y,2) + interface.flow2_C
                                ELSE IF (parameters.Relation_flow2 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow2_x + pow(interface.influent_flow,2)*interface.flow2_y + interface.flow2_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow2_x + pow(interface.influent_flow,2)*interface.flow2_y + interface.flow2_C
                                ELSE IF (parameters.Relation_flow2 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow2_x - pow(interface.influent_flow,2)*interface.flow2_y + interface.flow2_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow2_x - pow(interface.influent_flow,2)*interface.flow2_y + interface.flow2_C
                                ELSE 0;
                                                     
     interface.Exchange_flow3 = IF (parameters.Relation_flow3 == 0) 
                                THEN IF (interface.flow3_x*interface.influent_flow + interface.flow3_y*interface.airflow_rate + interface.flow3_C < 0)
                                     THEN 0
                                     ELSE interface.flow3_x*interface.influent_flow + interface.flow3_y*interface.airflow_rate + interface.flow3_C
                                ELSE IF (parameters.Relation_flow3 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow3_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow3_y,2) + interface.flow3_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow3_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow3_y,2) + interface.flow3_C
                                ELSE IF (parameters.Relation_flow3 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow3_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow3_y,2) + interface.flow3_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow3_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow3_y,2) + interface.flow3_C
                                ELSE IF (parameters.Relation_flow3 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow3_x + pow(interface.influent_flow,2)*interface.flow3_y + interface.flow3_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow3_x + pow(interface.influent_flow,2)*interface.flow3_y + interface.flow3_C
                                ELSE IF (parameters.Relation_flow3 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow3_x - pow(interface.influent_flow,2)*interface.flow3_y + interface.flow3_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow3_x - pow(interface.influent_flow,2)*interface.flow3_y + interface.flow3_C
                                ELSE 0;
                                
     interface.Exchange_flow4 = IF (parameters.Relation_flow4 == 0) 
                                THEN IF (interface.flow4_x*interface.influent_flow + interface.flow4_y*interface.airflow_rate + interface.flow4_C < 0)
                                     THEN 0
                                     ELSE interface.flow4_x*interface.influent_flow + interface.flow4_y*interface.airflow_rate + interface.flow4_C
                                ELSE IF (parameters.Relation_flow4 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow4_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow4_y,2) + interface.flow4_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow4_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow4_y,2) + interface.flow4_C
                                ELSE IF (parameters.Relation_flow4 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow4_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow4_y,2) + interface.flow4_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow4_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow4_y,2) + interface.flow4_C
                                ELSE IF (parameters.Relation_flow4 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow4_x + pow(interface.influent_flow,2)*interface.flow4_y + interface.flow4_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow4_x + pow(interface.influent_flow,2)*interface.flow4_y + interface.flow4_C
                                ELSE IF (parameters.Relation_flow4 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow4_x - pow(interface.influent_flow,2)*interface.flow4_y + interface.flow4_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow4_x - pow(interface.influent_flow,2)*interface.flow4_y + interface.flow4_C
                                ELSE 0;
                                
     interface.Exchange_flow5 = IF (parameters.Relation_flow5 == 0) 
                                THEN IF (interface.flow5_x*interface.influent_flow + interface.flow5_y*interface.airflow_rate + interface.flow5_C < 0)
                                     THEN 0
                                     ELSE interface.flow5_x*interface.influent_flow + interface.flow5_y*interface.airflow_rate + interface.flow5_C
                                ELSE IF (parameters.Relation_flow5 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow5_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow5_y,2) + interface.flow5_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow5_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow5_y,2) + interface.flow5_C
                                ELSE IF (parameters.Relation_flow5 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow5_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow5_y,2) + interface.flow5_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow5_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow5_y,2) + interface.flow5_C
                                ELSE IF (parameters.Relation_flow5 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow5_x + pow(interface.influent_flow,2)*interface.flow5_y + interface.flow5_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow5_x + pow(interface.influent_flow,2)*interface.flow5_y + interface.flow5_C
                                ELSE IF (parameters.Relation_flow5 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow5_x - pow(interface.influent_flow,2)*interface.flow5_y + interface.flow5_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow5_x - pow(interface.influent_flow,2)*interface.flow5_y + interface.flow5_C
                                ELSE 0;
                                
     interface.Exchange_flow6 = IF (parameters.Relation_flow6 == 0) 
                                THEN IF (interface.flow6_x*interface.influent_flow + interface.flow6_y*interface.airflow_rate + interface.flow6_C < 0)
                                     THEN 0
                                     ELSE interface.flow6_x*interface.influent_flow + interface.flow6_y*interface.airflow_rate + interface.flow6_C
                                ELSE IF (parameters.Relation_flow6 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow6_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow6_y,2) + interface.flow6_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow6_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow6_y,2) + interface.flow6_C
                                ELSE IF (parameters.Relation_flow6 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow6_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow6_y,2) + interface.flow6_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow6_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow6_y,2) + interface.flow6_C
                                ELSE IF (parameters.Relation_flow6 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow6_x + pow(interface.influent_flow,2)*interface.flow6_y + interface.flow6_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow6_x + pow(interface.influent_flow,2)*interface.flow6_y + interface.flow6_C
                                ELSE IF (parameters.Relation_flow6 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow6_x - pow(interface.influent_flow,2)*interface.flow6_y + interface.flow6_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow6_x - pow(interface.influent_flow,2)*interface.flow6_y + interface.flow6_C
                                ELSE 0;
                                
     interface.Exchange_flow7 = IF (parameters.Relation_flow7 == 0) 
                                THEN IF (interface.flow7_x*interface.influent_flow + interface.flow7_y*interface.airflow_rate + interface.flow7_C < 0)
                                     THEN 0
                                     ELSE interface.flow7_x*interface.influent_flow + interface.flow7_y*interface.airflow_rate + interface.flow7_C
                                ELSE IF (parameters.Relation_flow7 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow7_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow7_y,2) + interface.flow7_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow7_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow7_y,2) + interface.flow7_C
                                ELSE IF (parameters.Relation_flow7 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow7_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow7_y,2) + interface.flow7_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow7_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow7_y,2) + interface.flow7_C
                                ELSE IF (parameters.Relation_flow7 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow7_x + pow(interface.influent_flow,2)*interface.flow7_y + interface.flow7_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow7_x + pow(interface.influent_flow,2)*interface.flow7_y + interface.flow7_C
                                ELSE IF (parameters.Relation_flow7 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow7_x - pow(interface.influent_flow,2)*interface.flow7_y + interface.flow7_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow7_x - pow(interface.influent_flow,2)*interface.flow7_y + interface.flow7_C
                                ELSE 0;
                                
     interface.Exchange_flow8 = IF (parameters.Relation_flow8 == 0) 
                                THEN IF (interface.flow8_x*interface.influent_flow + interface.flow8_y*interface.airflow_rate + interface.flow8_C < 0)
                                     THEN 0
                                     ELSE interface.flow8_x*interface.influent_flow + interface.flow8_y*interface.airflow_rate + interface.flow8_C
                                ELSE IF (parameters.Relation_flow8 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow8_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow8_y,2) + interface.flow8_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow8_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow8_y,2) + interface.flow8_C
                                ELSE IF (parameters.Relation_flow8 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow8_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow8_y,2) + interface.flow8_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow8_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow8_y,2) + interface.flow8_C
                                ELSE IF (parameters.Relation_flow8 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow8_x + pow(interface.influent_flow,2)*interface.flow8_y + interface.flow8_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow8_x + pow(interface.influent_flow,2)*interface.flow8_y + interface.flow8_C
                                ELSE IF (parameters.Relation_flow8 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow8_x - pow(interface.influent_flow,2)*interface.flow8_y + interface.flow8_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow8_x - pow(interface.influent_flow,2)*interface.flow8_y + interface.flow8_C
                                ELSE 0;
                                
     interface.Exchange_flow9 = IF (parameters.Relation_flow9 == 0) 
                                THEN IF (interface.flow9_x*interface.influent_flow + interface.flow9_y*interface.airflow_rate + interface.flow9_C < 0)
                                     THEN 0
                                     ELSE interface.flow9_x*interface.influent_flow + interface.flow9_y*interface.airflow_rate + interface.flow9_C
                                ELSE IF (parameters.Relation_flow9 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow9_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow9_y,2) + interface.flow9_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow9_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow9_y,2) + interface.flow9_C
                                ELSE IF (parameters.Relation_flow9 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow9_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow9_y,2) + interface.flow9_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow9_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow9_y,2) + interface.flow9_C
                                ELSE IF (parameters.Relation_flow9 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow9_x + pow(interface.influent_flow,2)*interface.flow9_y + interface.flow9_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow9_x + pow(interface.influent_flow,2)*interface.flow9_y + interface.flow9_C
                                ELSE IF (parameters.Relation_flow9 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow9_x - pow(interface.influent_flow,2)*interface.flow9_y + interface.flow9_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow9_x - pow(interface.influent_flow,2)*interface.flow9_y + interface.flow9_C
                                ELSE 0;
                                
     interface.Exchange_flow10 = IF (parameters.Relation_flow10 == 0) 
                                THEN IF (interface.flow10_x*interface.influent_flow + interface.flow10_y*interface.airflow_rate + interface.flow10_C < 0)
                                     THEN 0
                                     ELSE interface.flow10_x*interface.influent_flow + interface.flow10_y*interface.airflow_rate + interface.flow10_C
                                ELSE IF (parameters.Relation_flow10 == 1)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow10_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow10_y,2) + interface.flow10_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow10_x,2) + pow(interface.airflow_rate,2)/pow(interface.flow10_y,2) + interface.flow10_C
                                ELSE IF (parameters.Relation_flow10 == 2)
                                THEN IF (pow(interface.influent_flow,2)/pow(interface.flow10_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow10_y,2) + interface.flow10_C < 0)
                                     THEN 0
                                     ELSE pow(interface.influent_flow,2)/pow(interface.flow10_x,2) - pow(interface.airflow_rate,2)/pow(interface.flow10_y,2) + interface.flow10_C
                                ELSE IF (parameters.Relation_flow10 == 3)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow10_x + pow(interface.influent_flow,2)*interface.flow10_y + interface.flow10_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow10_x + pow(interface.influent_flow,2)*interface.flow10_y + interface.flow10_C
                                ELSE IF (parameters.Relation_flow10 == 4)
                                THEN IF (interface.influent_flow*interface.airflow_rate*interface.flow10_x - pow(interface.influent_flow,2)*interface.flow10_y + interface.flow10_C < 0)
                                     THEN 0
                                     ELSE interface.influent_flow*interface.airflow_rate*interface.flow10_x - pow(interface.influent_flow,2)*interface.flow10_y + interface.flow10_C
                                ELSE 0;
     };
  :};

 


# 36 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.aeration_FF.msl" 1
 










 CLASS OnOff_FF_aer
  (* icon = "controller" *)
  "On-off controller for feed-forward aeration control"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off feed-forward controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
	    OBJ ON (* terminal = "in_2"; manip = "1" *) "Additional criterion for on/off" :
	 					  Real := {: causality <- "CIN"  ; group <- "Operational":};
    };

    parameters <-
    {
    OBJ y_S "Threshold for on/off" : Real := {: value <- 7000000  ; group <- "Operational":};
    OBJ u_max	"Max out"	: Real := {: value <- 10000 ; group <- "Operational" :};
    OBJ u_min	"Min out"	: Real := {: value <- 0 ; group <- "Operational" :};
	  OBJ change_rate "Rate of change" : Real := {: value <- 1000000 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ TS (* hidden = "1" *) "Time step" : Time := {: group <- "Operational" :};  
	   OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
	   OBJ help_u_h (* hidden = "1" *) "Previous u help variable" : Real;
    };

    equations <-
    {
    state.TS = independent.t - previous(independent.t); 
	  state.help_u = interface.u;
    state.help_u_h = IF ((interface.y_M > parameters.y_S) && (interface.ON == 1))
                     THEN previous(state.help_u) + parameters.change_rate * state.TS
                     ELSE previous(state.help_u) - parameters.change_rate * state.TS;
	  interface.u = IF (state.help_u_h > parameters.u_max)
				  			  THEN parameters.u_max
				  			  ELSE IF (state.help_u_h < parameters.u_min)
				  	   				THEN parameters.u_min
					   				  ELSE state.help_u_h;
    };
 :};
 
 
# 37 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.controllers.msl" 2




# 45 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer21.msl" 1
 














 



CLASS Timer21
  (* icon = "timer" ; is_default = "true" *)
  "Timer with 2 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
     OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
     OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
      THEN  interface.u11
      ELSE  interface.u12;

    };
  :};

  

# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer22.msl" 1
 


















CLASS Timer22
  (* icon = "timer" *)
  "Timer with 2 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE  interface.u12;

    interface.u2 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE  interface.u22;
    };
  :};

  

# 21 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer31.msl" 1
 


















CLASS Timer31
  (* icon = "timer" *)
  "Timer with 3 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};     
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
       THEN interface.u11
       ELSE
         IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
         THEN interface.u12
         ELSE interface.u13;
    };
  :};

  


# 22 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer32.msl" 1
 


















CLASS Timer32
  (* icon = "timer" *)
  "Timer with 3 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u12
          ELSE  interface.u13;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u22
          ELSE  interface.u23;

    };
  :};

  


# 23 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer41.msl" 1
 


















CLASS Timer41
  (* icon = "timer" *)
  "Timer with 4 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};      
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;
    };
  :};

  


# 24 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer42.msl" 1
 


















CLASS Timer42
  (* icon = "timer" *)
  "Timer with 4 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE  interface.u24;
    };
  :};

  


# 25 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer51.msl" 1
 


















CLASS Timer51
  (* icon = "timer" *)
  "Timer with 5 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;
    };
  :};

  


# 26 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer52.msl" 1
 


















CLASS Timer52
  (* icon = "timer" *)
  "Timer with 5 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u24
              ELSE  interface.u25;

    };
  :};

  


# 27 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer61.msl" 1
 


















CLASS Timer61
  (* icon = "timer" *)
  "Timer with 6 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;
    };
  :};

  


# 28 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer62.msl" 1
 


















CLASS Timer62
  (* icon = "timer" *)
  "Timer with 6 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE  interface.u26;

    };
  :};

  


# 29 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer71.msl" 1
 


















CLASS Timer71
  (* icon = "timer" *)
  "Timer with 7 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;
    };
  :};

  


# 30 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer72.msl" 1
 


















CLASS Timer72
  (* icon = "timer" *)
  "Timer with 7 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE  interface.u27;

    };
  :};

  

# 31 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer81.msl" 1
 














 



CLASS Timer81
  (* icon = "timer" *)
  "Timer with 8 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eight period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eight period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;
    };
  :};

  

# 32 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\timer/wwtp.base.timers.timer82.msl" 1
 


















CLASS Timer82
  (* icon = "timer" *)
  "Timer with 8 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u28 (* terminal = "in_2"; manip = "1" *) "Output 2 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eigth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u27
                       ELSE  interface.u28;

    };
  :};

  

# 33 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.timers.msl" 2

  

# 46 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.loopbreaker.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\loopbreaker/wwtp.base.loopbreaker.differentialloopbreaker.msl" 1
 


















CLASS DifferentialLoopBreaker
(* icon = "loop_breaker" ; is_default = "true" *)
"An Explicit Implicit Algebraic Loop Breaker using differential equations "

SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for a loopbreaker without differential equations";
  interface <-
  {
   OBJ Inflow (* terminal = "in_1" *) "inflow" :
        InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "outflow" :
        OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
   OBJ Tau "Implicit loop breaker time constant, d" : Time := {: value <- 0.0005 ; group <- "Miscellaneous" :};
  };

  independent <- 
  { 
   OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
   OBJ FluxPerComponent (* hidden = "0" *) : MassFluxVector;
  };

  equations <-
  {

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.FluxPerComponent[Comp_Index],[independent.t]) =
       - (1 / parameters.Tau) *
       (state.FluxPerComponent[Comp_Index] - interface.Inflow[Comp_Index]);
   };

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.FluxPerComponent[Comp_Index];
   };

  };

:};




# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.loopbreaker.msl" 2





# 47 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.process_calculator.msl" 1
 


















CLASS BaseParameters
  "Base class for all process calculators, ie cost and process parameters"

  SPECIALISES
  PhysicalDAEModelType :=
  {:

    interface <-
    {
   
  OBJ V1 (* terminal = "in_1" *)"Volume of unit 1" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V2 (* terminal = "in_1" *)"Volume of unit 2" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V3 (* terminal = "in_1" *)"Volume of unit 3" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V4 (* terminal = "in_1" *)"Volume of unit 4" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V5 (* terminal = "in_1" *)"Volume of unit 5" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V6 (* terminal = "in_1" *)"Volume of unit 6" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V7 (* terminal = "in_1" *)"Volume of unit 7" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V8 (* terminal = "in_1" *)"Volume of unit 8" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V9 (* terminal = "in_1" *)"Volume of unit 9" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V10 (* terminal = "in_1" *)"Volume of unit 10" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V11 (* terminal = "in_1" *)"Volume of unit 11" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V12 (* terminal = "in_1" *)"Volume of unit 12" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V13 (* terminal = "in_1" *)"Volume of unit 13" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V14 (* terminal = "in_1" *)"Volume of unit 14" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V15 (* terminal = "in_1" *)"Volume of unit 15" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V16 (* terminal = "in_1" *)"Volume of unit 16" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    
    OBJ V1_aer (* terminal = "in_1" *)"Volume of aerated unit 1" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V2_aer (* terminal = "in_1" *)"Volume of aerated unit 2" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V3_aer (* terminal = "in_1" *)"Volume of aerated unit 3" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V4_aer (* terminal = "in_1" *)"Volume of aerated unit 4" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V5_aer (* terminal = "in_1" *)"Volume of aerated unit 5" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V6_aer (* terminal = "in_1" *)"Volume of aerated unit 6" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
 
  OBJ TSS1 (* terminal = "in_1" *) "Tot.susp.solids (unit 1)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS2 (* terminal = "in_1" *) "Tot.susp.solids (unit 2)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS3 (* terminal = "in_1" *) "Tot.susp.solids (unit 3)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS4 (* terminal = "in_1" *) "Tot.susp.solids (unit 4)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS5 (* terminal = "in_1" *) "Tot.susp.solids (unit 5)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS6 (* terminal = "in_1" *) "Tot.susp.solids (unit 6)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS7 (* terminal = "in_1" *) "Tot.susp.solids (unit 7)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS8 (* terminal = "in_1" *) "Tot.susp.solids (unit 8)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS9 (* terminal = "in_1" *) "Tot.susp.solids (unit 9)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS10 (* terminal = "in_1" *) "Tot.susp.solids (unit 10)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS11 (* terminal = "in_1" *) "Tot.susp.solids (unit 11)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS12 (* terminal = "in_1" *) "Tot.susp.solids (unit 12)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS13 (* terminal = "in_1" *) "Tot.susp.solids (unit 13)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS14 (* terminal = "in_1" *) "Tot.susp.solids (unit 14)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS15 (* terminal = "in_1" *) "Tot.susp.solids (unit 15)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS16 (* terminal = "in_1" *) "Tot.susp.solids (unit 16)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    
    OBJ TSS1_aer (* terminal = "in_1" *) "Tot.susp.solids (aerated unit 1)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS2_aer (* terminal = "in_1" *) "Tot.susp.solids (aerated unit 2)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS3_aer (* terminal = "in_1" *) "Tot.susp.solids (aerated unit 3)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS4_aer (* terminal = "in_1" *) "Tot.susp.solids (aerated unit 4)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS5_aer (* terminal = "in_1" *) "Tot.susp.solids (aerated unit 5)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS6_aer (* terminal = "in_1" *) "Tot.susp.solids (aerated unit 6)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :}; 
   
  OBJ Q_Waste (*terminal = "in_1" *) "Flow rate of waste sludge": FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
  OBJ TSS_waste (* terminal = "in_1" *) "Suspended solids in the waste sludge" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    };
  
  independent <-
    {
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

  parameters <-
    {
    };

  state <-
    {
  OBJ m_TSS (* hidden = "1" *) "Amount of sludge accumulated in the system" : Mass :={:group <- "Measurement data":};
  OBJ V (* hidden = "1" *) "Total volume of the tanks" : Volume := {: group <- "Dimension" :};
  OBJ m_aer_TSS (* hidden="1" *) "Amount of aerobic sludge accumulated in the system" : Mass :={:group <- "Measurement data":};
    };

  equations <-
    {
  state.m_TSS = interface.V1 * interface.TSS1 + interface.V2 * interface.TSS2 + interface.V3 * interface.TSS3
         + interface.V4 * interface.TSS4 + interface.V5 * interface.TSS5 + interface.V6 * interface.TSS6
         + interface.V7 * interface.TSS7 + interface.V8 * interface.TSS8 + interface.V9 * interface.TSS9
         + interface.V10 * interface.TSS10 + interface.V11 * interface.TSS11 + interface.V12 * interface.TSS12
         + interface.V13 * interface.TSS13 + interface.V14 * interface.TSS14 + interface.V15 * interface.TSS15
         + interface.V16 * interface.TSS16 + interface.V1_aer * interface.TSS1_aer + interface.V2_aer * interface.TSS2_aer 
        + interface.V3_aer * interface.TSS3_aer + interface.V4_aer * interface.TSS4_aer + interface.V5_aer * interface.TSS5_aer 
        + interface.V6_aer * interface.TSS6_aer;
         
  state.V = interface.V1 + interface.V2 + interface.V3 + interface.V4 + interface.V5
        + interface.V6 + interface.V7 + interface.V8 + interface.V9 + interface.V10 + interface.V11 + interface.V12
        + interface.V13 + interface.V14 + interface.V15 + interface.V16;
        
  state.m_aer_TSS = interface.V1_aer * interface.TSS1_aer + interface.V2_aer * interface.TSS2_aer 
        + interface.V3_aer * interface.TSS3_aer + interface.V4_aer * interface.TSS4_aer + interface.V5_aer * interface.TSS5_aer 
        + interface.V6_aer * interface.TSS6_aer;
    };

  :};

  
CLASS OperationalParameters
  (* icon = "process_calculator" ; is_default = "true" *)
  "Calculation of the basic operational parameters of the plant: eg SRT, HRT"
 
 
 
 

  EXTENDS BaseParameters WITH
  {:
    comments <- "A model for the calculation of basic operational parameters";
    interface <-
    {
   
    OBJ TSS_out (* terminal = "in_1" *) "Sludge concentration in the effluent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
   
  OBJ Q_In (* terminal = "in_1" *) "Influent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational":};
  OBJ Q_Out (* terminal = "in_1" *) "Effluent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational" :};
   
    OBJ BOD_In (* terminal = "in_1" *) "BOD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ COD_In (* terminal = "in_1" *) "COD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    };

    state <-
    {
    OBJ SRT "Instantenous Sludge retention time" : Time := {: group <- "Operational" :};
    OBJ SRT_aer "Instantaneous aerobic sludge retention time" : Time := {: group <- "Operational" :};
    OBJ HRT "Hydraulic retention time" : Time := {: group <- "Operational" :};
    OBJ F_M_BOD "Food to microorganism ratio on BOD basis" : Rate := {: group <- "Operational" :};
    OBJ F_M_COD "Food to microorganism ratio on COD basis" : Rate := {: group <- "Operational" :};
    };

    equations <-
    {
   
    state.SRT =  IF ((interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste) <= 0)
                 THEN 0
                 ELSE state.m_TSS / (interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste);
    state.SRT_aer =  IF ((interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste) <= 0)
                 THEN 0
                 ELSE state.m_aer_TSS / (interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste);
   
    state.HRT = IF (interface.Q_In == 0)
        THEN 0
        ELSE state.V / interface.Q_In;
    state.F_M_BOD = IF (interface.Q_In == 0)
        THEN 0
        ELSE interface.BOD_In / (state.m_TSS / interface.Q_In);
    state.F_M_COD = IF (interface.Q_In == 0)
        THEN 0
        ELSE interface.COD_In / (state.m_TSS / interface.Q_In);
     };
  :};


# 48 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.evaluator.msl" 1
 


















CLASS OperationalCost
  (* icon = "cost" ; is_default = "true" *)
  "Calculation of the operational cost of the plant"

 
 
 
 
 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
   
    OBJ AerationEnergy1 (* terminal = "in_1" *) "AerationEnergy unit 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy2 (* terminal = "in_1" *) "AerationEnergy unit 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy3 (* terminal = "in_1" *) "AerationEnergy unit 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy4 (* terminal = "in_1" *) "AerationEnergy unit 4" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy5 (* terminal = "in_1" *) "AerationEnergy unit 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy6 (* terminal = "in_1" *) "AerationEnergy unit 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy7 (* terminal = "in_1" *) "AerationEnergy unit 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy8 (* terminal = "in_1" *) "AerationEnergy unit 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy9 (* terminal = "in_1" *) "AerationEnergy unit 9" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy10 (* terminal = "in_1" *) "AerationEnergy unit 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
   
   
    OBJ PumpingEnergy1 (* terminal = "in_1" *) "PumpingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy2 (* terminal = "in_1" *) "PumpingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy3 (* terminal = "in_1" *) "PumpingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy4 (* terminal = "in_1" *) "PumpingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy5 (* terminal = "in_1" *) "PumpingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy6 (* terminal = "in_1" *) "PumpingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy7 (* terminal = "in_1" *) "PumpingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy8 (* terminal = "in_1" *) "PumpingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy9 (* terminal = "in_1" *) "PumpingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy10 (* terminal = "in_1" *) "PumpingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy11 (* terminal = "in_1" *) "PumpingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy12 (* terminal = "in_1" *) "PumpingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy13 (* terminal = "in_1" *) "PumpingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy14 (* terminal = "in_1" *) "PumpingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy15 (* terminal = "in_1" *) "PumpingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy16 (* terminal = "in_1" *) "PumpingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy17 (* terminal = "in_1" *) "PumpingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy18 (* terminal = "in_1" *) "PumpingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy19 (* terminal = "in_1" *) "PumpingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy20 (* terminal = "in_1" *) "PumpingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
   
   
    OBJ MixingEnergy1 (* terminal = "in_1" *) "MixingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy2 (* terminal = "in_1" *) "MixingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy3 (* terminal = "in_1" *) "MixingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy4 (* terminal = "in_1" *) "MixingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy5 (* terminal = "in_1" *) "MixingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy6 (* terminal = "in_1" *) "MixingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy7 (* terminal = "in_1" *) "MixingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy8 (* terminal = "in_1" *) "MixingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy9 (* terminal = "in_1" *) "MixingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy10 (* terminal = "in_1" *) "MixingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy11 (* terminal = "in_1" *) "MixingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy12 (* terminal = "in_1" *) "MixingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy13 (* terminal = "in_1" *) "MixingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy14 (* terminal = "in_1" *) "MixingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy15 (* terminal = "in_1" *) "MixingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy16 (* terminal = "in_1" *) "MixingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy17 (* terminal = "in_1" *) "MixingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy18 (* terminal = "in_1" *) "MixingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy19 (* terminal = "in_1" *) "MixingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy20 (* terminal = "in_1" *) "MixingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
   
   
    OBJ TSS1 (* terminal = "in_1" *) "TSS1" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 1" :};
    OBJ TSS2 (* terminal = "in_1" *) "TSS2" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 2" :};
    OBJ Q_Pump_Waste1 (* terminal = "in_1" *) "Q_Pump sludge wastage 1" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ Q_Pump_Waste2 (* terminal = "in_1" *) "Q_Pump sludge wastage 2" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
   
   
    OBJ Q1_COD (* terminal = "in_1" *) "External COD dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q1_MeOH (* terminal = "in_1" *) "Metal dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_COD (* terminal = "in_1" *) "External COD dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_MeOH (* terminal = "in_1" *) "Metal dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_COD (* terminal = "in_1" *) "External COD dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_MeOH (* terminal = "in_1" *) "Metal dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    };

    parameters <-
    {
    OBJ F_AC "Aeration cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_PC "Pumping cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_MC "Mixing cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_SC "Sludge cost factor (Euro/kg)" : Ratio := {: value <- 0.58 ; group <- "Cost" :};
  OBJ C1_COD "COD cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C1_MeOH "Metal hydroxide cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_COD "COD cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_MeOH "Metal hydroxide cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_COD "COD cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_MeOH "Metal hydroxide cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
   
    OBJ TotalAerationEnergy "Aeration energy" : ElectricalEnergy := {: group <- "Energy" :};
   
    OBJ TotalPumpingEnergy "Pumping energy" : ElectricalEnergy := {: group <- "Energy" :};
   
    OBJ TotalMixingEnergy "Mixing energy" : ElectricalEnergy := {: group <- "Energy" :};
   
 
    OBJ SludgeProduction "Sludge production" : Mass := {: group <- "Sludge" :};
    OBJ Integ_SP (* hidden = "1" *)"Integral sludge production" : Mass ;
   
  OBJ CODdosed "External COD dosed" : Volume := {: group <- "Chemicals" :};
  OBJ MeOHdosed "Metal hydroxide dosed" : Volume := {: group <- "Chemicals" :};
    OBJ Integ_COD (* hidden = "1" *) "Integral ext.COD addition" : Volume ;
    OBJ Integ_MeOH (* hidden = "1" *) "Integral MeOH addition" : Volume ;
    OBJ Integ_ChemicalCost (* hidden = "1" *) "Integral cost of chemicals" : Euro ;
   
    OBJ AerationCost "Aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PumpingCost "Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MixingCost "Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SludgeCost "Sludge cost" : Euro := {: group <- "Cost" :};
    OBJ ChemicalCost "Cost of chemicals" : Euro := {: group <- "Chemicals" :};
    OBJ TotalCost "Total cost" : Euro := {: group <- "Cost" :};
    OBJ Prev_t (* hidden = "1" *) "Help variable for time" : Time ;
    OBJ Prev_TotalAerationEnergy (* hidden = "1" *) "Help variable to calculate the Periodical aeration cost" : ElectricalEnergy ;
    OBJ Prev_TotalPumpingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical pumping cost" : ElectricalEnergy ;
    OBJ Prev_TotalMixingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical mixing cost" : ElectricalEnergy ;
    OBJ Prev_Integ_SP (* hidden = "1" *) "Help variable to calculate the Periodical sludge cost" : Mass ;
    OBJ Prev_Integ_ChemicalCost (* hidden = "1" *) "Help variable to calculate the Periodical chemical cost (carbon addition)" : Euro ;
    OBJ AC_Period "Periodical aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PC_Period "Periodical Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MC_Period "Periodical Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SC_Period "Periodical sludge cost" : Euro := {: group <- "Cost" :};
    OBJ CC_Period "Periodical cost of COD addition" : Euro := {: group <- "Cost" :};
    OBJ TC_Period "Periodical total cost" : Euro := {: group <- "Cost" :};
    };

    equations <-
    {
   
   
  state.TotalAerationEnergy = interface.AerationEnergy1 + interface.AerationEnergy2 + interface.AerationEnergy3
                    + interface.AerationEnergy4 + interface.AerationEnergy5+ interface.AerationEnergy6 
                + interface.AerationEnergy7 + interface.AerationEnergy8 + interface.AerationEnergy9 
                + interface.AerationEnergy10;
   
   
   
   
   
  state.TotalPumpingEnergy = interface.PumpingEnergy1 + interface.PumpingEnergy2 + interface.PumpingEnergy3 + interface.PumpingEnergy4 
                 + interface.PumpingEnergy5 + interface.PumpingEnergy6  + interface.PumpingEnergy7 + interface.PumpingEnergy8 
                 + interface.PumpingEnergy9 + interface.PumpingEnergy10 + interface.PumpingEnergy11 + interface.PumpingEnergy12 
                 + interface.PumpingEnergy13 + interface.PumpingEnergy14 + interface.PumpingEnergy15+ interface.PumpingEnergy16 
                 + interface.PumpingEnergy17 + interface.PumpingEnergy18 + interface.PumpingEnergy19 + interface.PumpingEnergy20;
   
   
  state.TotalMixingEnergy = interface.MixingEnergy1 + interface.MixingEnergy2 + interface.MixingEnergy3 + interface.MixingEnergy4 
                + interface.MixingEnergy5 + interface.MixingEnergy6 + interface.MixingEnergy7 + interface.MixingEnergy8 
                + interface.MixingEnergy9 + interface.MixingEnergy10 + interface.MixingEnergy11 + interface.MixingEnergy12 
                + interface.MixingEnergy13 + interface.MixingEnergy14 + interface.MixingEnergy15+ interface.MixingEnergy16 
                + interface.MixingEnergy17 + interface.MixingEnergy18 + interface.MixingEnergy19 + interface.MixingEnergy20;
   
   
  DERIV(state.Integ_SP,[independent.t])= interface.TSS1 * interface.Q_Pump_Waste1 + interface.TSS2 * interface.Q_Pump_Waste2;
  state.SludgeProduction = state.Integ_SP ;
   
   
  DERIV(state.Integ_COD,[independent.t]) = interface.Q1_COD + interface.Q2_COD + interface.Q3_COD;
  DERIV(state.Integ_MeOH,[independent.t]) = interface.Q1_MeOH + interface.Q2_MeOH + interface.Q3_MeOH;
  state.CODdosed = state.Integ_COD;
  state.MeOHdosed = state.Integ_MeOH;
   
   
   
  state.AerationCost = state.TotalAerationEnergy * parameters.F_AC;
  state.PumpingCost = state.TotalPumpingEnergy * parameters.F_PC;
  state.SludgeCost = state.SludgeProduction * parameters.F_SC / 1000.0;
  state.MixingCost = state.TotalMixingEnergy * parameters.F_MC;
  DERIV(state.Integ_ChemicalCost,[independent.t]) =
      interface.Q1_COD * parameters.C1_COD + interface.Q2_COD  * parameters.C2_COD
      + interface.Q3_COD * parameters.C3_COD + interface.Q1_MeOH * parameters.C1_MeOH
      + interface.Q2_MeOH * parameters.C2_MeOH + interface.Q3_MeOH * parameters.C3_MeOH ;
  state.ChemicalCost = state.Integ_ChemicalCost;
  state.TotalCost = state.AerationCost + state.PumpingCost + state.SludgeCost + state.MixingCost + state.ChemicalCost;
   
    state.Prev_t =  IF (independent.t < previous(state.Prev_t))
          THEN 0
          ELSE
            IF  (independent.t - previous(state.Prev_t) < parameters.Period)
            THEN  previous(state.Prev_t)
            ELSE  independent.t;
  state.Prev_TotalAerationEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
              THEN previous(state.Prev_TotalAerationEnergy)
              ELSE state.TotalAerationEnergy;
  state.Prev_TotalPumpingEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_TotalPumpingEnergy)
                ELSE state.TotalPumpingEnergy;
  state.Prev_TotalMixingEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_TotalMixingEnergy)
                ELSE state.TotalMixingEnergy;
  state.Prev_Integ_SP = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_Integ_SP)
                ELSE state.Integ_SP;
  state.Prev_Integ_ChemicalCost = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Integ_ChemicalCost)
                ELSE state.Integ_ChemicalCost;
     
  state.AC_Period = parameters.F_AC * (state.TotalAerationEnergy - state.Prev_TotalAerationEnergy);
  state.PC_Period = parameters.F_PC * (state.TotalPumpingEnergy - state.Prev_TotalPumpingEnergy);
  state.MC_Period = parameters.F_MC * (state.TotalMixingEnergy - state.Prev_TotalMixingEnergy);
  state.SC_Period = parameters.F_SC * (state.Integ_SP - state.Prev_Integ_SP) / 1000.0 ;
  state.CC_Period = state.Integ_ChemicalCost - state.Prev_Integ_ChemicalCost;
  state.TC_Period = state.AC_Period + state.PC_Period + state.SC_Period + state.CC_Period + state.MC_Period;
    };
  :};

  
  

# 49 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.dosing_units.msl" 1
 


















 CLASS DosingUnit
 "A dosing unit model"
 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-
  {
   
   
   
  OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ Q_Dose (* terminal = "in_1"; manip = "1" *) "Flowrate of the solution" : 
      FlowRate := {: causality <- "CIN"; value <- 10 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };

  parameters <-
  {
  OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components"
        : SpecificVolumeVector;
  OBJ C_Dose "Concentration of the solution" : 
       Concentration := {: value <- 1 ; group <- "Concentration" :};
  OBJ MW (* hidden = "1" *) "Molecular weight of the chemical species dosed"
        : Real := {: group <- "System" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
  };

  independent <-
  {
  OBJ t "Time": Time := {: group <- "Time" :};
  };

  state <-
  {
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };
  initial <-
  {
  parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  };

  equations <-
  {
  interface.Outflow[IndexOfSolvent] = - interface.Q_Dose
      / parameters.WWTPSpecificVolume[IndexOfSolvent];

 
  DERIV(state.Integ_PE,[independent.t])=  interface.Q_Dose;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };

 :};


 CLASS AdditionOfFermentationProducts
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {




    




  };

:};



 CLASS AdditionOfFermentableCOD
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {




    




  };

:};



 CLASS P_Precipitation
 "A dosing unit model for the chemical precipitation of P"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ MW_FeOH (* hidden = "1" *) "Molecular weight of Ferric Hydroxyde"
        : Real := {: value <- 106.85 ; group <- "System" :};
   OBJ Equiv_P "Molar equivalence to phosphorous"
        : Fraction := {: group <- "Operational" :};
  };

  equations <-
  {
   interface.Outflow[X_MEOH] = - interface.Q_Dose * parameters.C_Dose *
      parameters.Equiv_P * (parameters.MW/parameters.MW_FeOH) ;
  };

:};


# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\dosing_unit/wwtp.base.dosing_units.acetate.msl" 1
 














 




 CLASS Acetate
 (* icon = "dosing_unit_acetate"; is_default = "true" *)
 "A simple model for dosage of acetate"
 EXTENDS AdditionOfFermentationProducts WITH
 {:
  comments <- "A model for the addition of acetate as external carbon source";
  
  interface <-
  {
  OBJ M_Acetate (* terminal = "out_2" *) "Amount of acetate dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Acetate (* terminal = "out_2" *) "Flow rate of acetate dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  



  };
  
  initial <-
  {
  parameters.COD = 64;
  parameters.MW = 60;
  };

  equations <-
  {
  


   
  interface.M_Acetate = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Acetate = interface.Q_Dose ;
  };

:};


 


# 155 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\dosing_unit/wwtp.base.dosing_units.methanol.msl" 1
 



















 CLASS Methanol
 (* icon = "dosing_unit_methanol" *)
 "A simple model for dosage of methanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of methanol as external carbon source";

  interface <-
  {
  OBJ M_Methanol (* terminal = "out_2" *) "Amount of methanol dosed" : MassFlux
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Methanol (* terminal = "out_2" *) "Flow rate of methanol dosed" : FlowRate
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  initial <-
  {
  parameters.COD = 48;
  parameters.MW = 32;
  };

  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  equations <-
  {





   
  interface.M_Methanol = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Methanol = interface.Q_Dose ;
  };

:};



# 156 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\dosing_unit/wwtp.base.dosing_units.ethanol.msl" 1
 



















 CLASS Ethanol
 (* icon = "dosing_unit_ethanol" *)
 "A simple model for dosage of ethanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of ethanol as external carbon source";

  interface <-
  {
  OBJ M_Ethanol (* terminal = "out_2" *) "Amount of ethanol dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Ethanol (* terminal = "out_2" *) "Flow rate of ethanol dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  initial <-
  {
  parameters.COD = 96;
  parameters.MW = 46;
  };

  equations <-
  {





   
  interface.M_Ethanol = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Ethanol = interface.Q_Dose ;
  };

:};




# 157 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\dosing_unit/wwtp.base.dosing_units.alum.msl" 1
 


















# 49 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\dosing_unit/wwtp.base.dosing_units.alum.msl"



 CLASS Alum
 (* icon = "dosing_unit_alum" *)
 "A simple model for dosage of a Al2(SO4)3 solution"
 EXTENDS DosingUnit WITH
 {:
  comments <- "A model for the addition of alum for chemical precipitation";

  interface <-
  {
  OBJ M_Alum (* terminal = "out_2" *) "Amount of alum dosed" : MassFlux
  	  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Alum (* terminal = "out_2" *) "Flow rate of alum dosed" : FlowRate
  	  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  initial <-
  {
  };

  equations <-
  {
  interface.M_Alum = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Alum = interface.Q_Dose ;
  interface.Outflow[S_Al] = - interface.Q_Dose * parameters.C_Dose ; 
  };

:};



# 158 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\dosing_unit/wwtp.base.dosing_units.ironhydroxide.msl" 1
 



















 CLASS IronHydroxide
 (* icon = "dosing_unit_iron" *)
 "A simple model for dosage of a Fe(OH)3 solution"
 EXTENDS P_Precipitation WITH
 {:
  comments <- "A model for the addition of iron hydroxide for chemical precipitation";

  interface <-
  {
  OBJ M_FeOH (* terminal = "out_2" *) "Amount of iron hydroxyde dosed" : MassFlux
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_FeOH (* terminal = "out_2" *) "Flow rate of iron hydroxyde dosed" : FlowRate
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  initial <-
  {
   parameters.MW = 106.85;
   parameters.Equiv_P = 1.0;
  };

  equations <-
  {
  interface.M_FeOH = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_FeOH = interface.Q_Dose ;
  };

:};



# 159 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.dosing_units.msl" 2



# 52 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sludge_dewatering.msl" 1
 


















CLASS SolidSeparationModel EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ OutflowPermeate (* terminal = "out_1" *) "Permeate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   OBJ OutflowConcentrate (* terminal = "out_3" *) "Concentrate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    
   };

   parameters <-
   { 
   OBJ rho_sludge "Specific gravity of dewatered sludge" : Concentration := {: value <- 1.07e6 ; group <- "Operational" :};
    
   OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    
   };

   state <-
   {
   OBJ Q_Permeate "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   OBJ Q_Concentrate_Actual "Concentrate flow rate" : FlowRate := {: group <- "Operational" :};
    
   OBJ Help_X_Sludge (* hidden = "1" *) "Working variable to calculate TSS in the concentrate" : MassFlux;
   OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the outflow" : Fraction ;
   };

   equations <-
   {
    
   



    
    
   
   state.Help_X_Sludge = (- interface.OutflowConcentrate[IndexOfTSSComponent]) ;
   
   };

 :};

 
 
 
CLASS EfficiencyDewateringModel
 "efficiency-based dewatering"
 EXTENDS SolidSeparationModel WITH
 {:

  interface <-
  {
  OBJ DS (* terminal = "out_2" *) "Dry solids" : Real := {: causality <- "COUT" ; group <- "Measurement" :};
  OBJ e_X (* terminal = "in_2"; manip = "1" *) "Separation efficiency (fraction of solids going to sludge flow)" :
    Fraction := {: causality <- "CIN" ; value <- 0.96; group <- "Operational" :}; 
  OBJ Q_Concentrate (* terminal = "in_2"; manip = "1" *) "Desired flow rate of the concentrated sludge" :
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
  };

  parameters <-
  { 
  };
 
  state <-
  {
  OBJ DrySolids "Dry solid content (of the cake)" : Real := {: group <- "Operational" :};
  };
  
  equations <-
  {
   
   
   
   
   
   
   
   
   
  state.DrySolids = IF (state.Q_Concentrate_Actual == 0.0)
              THEN 0.0
            ELSE 100.0 * (state.Help_X_Sludge / (state.Q_Concentrate_Actual * parameters.rho_sludge));
   
   
  state.Q_Concentrate_Actual = IF (state.Q_In <= interface.Q_Concentrate)
                     THEN state.Q_In
                     ELSE interface.Q_Concentrate;
   
  state.Q_Permeate = state.Q_In - state.Q_Concentrate_Actual;
   
   
   
  state.f_Out = IF (state.Q_In <= interface.Q_Concentrate)
            THEN 0
            ELSE (state.Q_In - interface.Q_Concentrate) / state.Q_In ;
   
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowPermeate[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out;
  };
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowConcentrate[Comp_Index] =
         - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out);
  };
   
   
   
   
   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowPermeate[Comp_Index] = IF (state.Q_Concentrate_Actual == 0.0)
                         THEN - state.InFluxPerComponent[Comp_Index]
                       ELSE - state.InFluxPerComponent[Comp_Index] * (1-interface.e_X);
  };   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowConcentrate[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * interface.e_X;
  };
   
  interface.DS = state.DrySolids ;
  }; 
 
 :};

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencythickener.msl" 1
 


















CLASS EfficiencyThickener
  (* icon = "dewatering_unit"; is_default = "true" *)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge thickener based on dewatering efficiency";
  :};


# 149 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencycentrifuge.msl" 1
 


















CLASS EfficiencyCentrifuge
  (* icon = "centrifuge"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 150 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencybeltpress.msl" 1
 


















CLASS EfficiencyBeltPress
  (* icon = "beltpress"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 151 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.sludge_dewatering.msl" 2





# 53 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2





# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.ADM1.msl" 1
 















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.definitionsADM1.msl" 1
 


















 
 

 


 CLASS CarbonContentOfAminoAcids
   "carbon content of amino acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfAcetate
   "carbon content of acetate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfBiomass
   "carbon content of biomass"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfButyrate
   "carbon content of butyrate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfMethane
   "carbon content of methane"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfLCFattyAcids
   "carbon content of long chain fatty acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfPropionate
   "carbon content of propionate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfSolubleInertCOD
   "carbon content of soluble inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfValerate
   "carbon content of valerate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfComplexParticulateCOD
   "carbon content of complex particulate COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};

CLASS CarbonContentOfParticulateInertCOD
   "carbon content of particulate inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole.g COD-1";
    :};
CLASS CarbonContentOfLipids
   "carbon content of particulate inert COD"
    SPECIALISES PhysicalQuantityType :=
       {:
        unit     <- "mole.g COD-1";
        :};

CLASS CarbonContentOfSugars
   "carbon content of particulate inert COD"
    SPECIALISES PhysicalQuantityType :=
       {:
        unit     <- "mole.g COD-1";
        :};

 

CLASS NitrogenContentOfAminoAcids
   "Nitrogen content of amino acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

CLASS NitrogenContentOfBiomass
   "Nitrogen content of  biomass"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

CLASS NitrogenContentOfSolubleInertCOD
   "nitrogen content of Soluble inert"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};
CLASS NitrogenContentOfParticulateDegradableCOD
   "nitrogen content of particulate degradable COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

CLASS NitrogenContentOfParticulateInertCOD
   "nitrogen content of particulate inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mole-N.g COD-1";
    :};

 

CLASS pKa
   "A class for pKa"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "pKa";
    interval  <- {: lowerBound <- 0; upperBound <- 14 :};
   :};

CLASS Acidity
   "A class for Acidity"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Acidity";
    unit     <- "M";
   :};

 

CLASS HydrogenInhibitoryConcentrationForFADegradingOrganisms
   "hydrogen inhibitory concentration for FA degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
   
CLASS HydrogenInhibitoryConcentrationForC4DegradingOrganisms
   "hydrogen inhibitory concentration for C4 degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS InhibitoryHydrogenConcentrationForPropionateDegradingOrganisms
   "inhibitory hydrogen concentration for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS InhibitoryFreeAmmoniaConcentrationForAcetateDegradingOrganisms
   "inhibitory free ammonia concentration for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "M";
   :};

 

CLASS KineticConstantForCO2andHCO3AcidBaseReaction
   "kinetic constant for CO2-HCO3 acid-base reaction"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS DecayRateForAminoAcidDegradingOrganisms
   "decay rate for amino acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForAcetateDegradingOrganisms
   "decay rate for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForButyrateAndValerateDegradingOrganisms
   "decay rate for butyrate and valerate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForLongChainFattyAcidDegradingOrganisms
   "decay rate for long chain fatty acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS DecayRateForHydrogenDegradingOrganisms
   "decay rate for hydrogen degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS DecayRateForPropionateDegradingOrganisms
   "decay rate for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForMonosaccharideDegradingOrganisms
   "decay rate for monosaccharide degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS ComplexParticulateDisintegrationFirstOrderConstant
   "complex particulate disintegration first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS CarbohydrateHydrolysisFirstOrderConstant
   "carbohydrate hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS LipidHydrolysisFirstOrderConstant
   "lipid hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS ProteinHydrolysisFirstOrderConstant
   "protein hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS GasLiquidTransferCoefficientForReactor
   "gas liquid transfer coefficient for reactor"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
 

CLASS PhysChemRate 
   "Phiscal or chemical reaction rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "KMole.d-1";
   :};
 

CLASS MaximumUptakeRateAminoAcidDegradingOrganisms
   "maximum uptake rate amino acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForAcetateDegradingOrganisms
   "maximum uptake rate for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForC4DegradingOrganisms
   "maximum uptake rate for c4 degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS MaximumUptakeRateForLongChainFattyAcidDegradingOrganisms
   "maximum uptake rate for long chain fatty acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateFForHydrogenDegradingOrganisms
   "maximum uptake rate for hydrogen degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForPropionateDegradingOrganisms
   "maximum uptake rate for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForMonosaccharideDegradingOrganisms
   "maximum uptake rate for monosaccharide degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS HalfSaturationConstantForAminoAcidDegradation
   "half saturation constant for amino acid degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS HalfSaturationConstantForAcetateDegradation
   "half saturation constant for acetate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForButyrateAndValerateDegradation
   "half saturation constant for butyrate and valerate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForLongChainFattyAcidsDegradation
   "half saturation constant for long chain fatty acids degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS HalfSaturationConstantForUptakeOfHydrogen
   "half saturation constant for uptake of hydrogen"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS InorganicNitrogenConcentrationAtWhichGrowthCeases
   "inorganic nitrogen concentration at which growth ceases"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "M";
   :};
CLASS HalfSaturationConstantForPropionateDegradation
   "half saturation constant for propionate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForMonosaccharideDegradation
   "half saturation constant for monosaccharide degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

 

CLASS BarPressure
   "pressure "
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "bar";
   :};

CLASS GasLawConstant
   "Gas law constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "bar.M-1.K-1";
   :};

CLASS SolidsRetentionTimeInAdditionToHydraulicRetentionTime
   "solids retention time in addition to hydraulic retention time"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "K";
   :};

  

CLASS KgDensity
   "Water Density"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kg/m3";
   :};

CLASS KgCODConcentration
   "Concentration of COD components"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m";
   :};

CLASS InhibitionFactor
   "Inhibition Factor"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "_";
   :};

   CLASS ADMMass "A class for (kg, kmol) mass in the scope of ADM1"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "kg";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS ADMConcentration "A class for (kg, kmol) concentration in the scope of ADM1"
   SPECIALISES PhysicalQuantityType :=
   {:
    nature <- "ACROSS";
    quantity <- "Concentration";
    unit <- "kg/m3";
    interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};
   
  
 
 

 
TYPE ADM1Components
  "The biological components considered in the ADM1 model"
  = ENUM { H2O_An, S_INN, S_IC, S_ch4, S_h2, S_aa, S_ac, S_bu, S_fa, S_Inert, S_pro, S_su, S_va, X_aa, X_ac, X_c, X_c4, X_ch, X_fa, X_h2, X_Inert, X_li, X_pr, X_pro, X_su, S_an, S_cat};

TYPE ADM1IonComponents
  "The ion components considered in the ADM1 model"
  = ENUM { S_ac_ion, S_bu_ion, S_pro_ion, S_va_ion, S_hco3_ion, S_nh3};

TYPE ADM1GasVesselComponents
  "The gaseous components considered in the ADM1 model in the gas phase"
  = ENUM { S_ch4_gas, S_co2_gas, S_h2_gas};
  
TYPE ADM1GasComponentsInliquid
    "The gaseous components considered in the ADM1 model dissolved in the liquid phase"
  = ENUM { S_ch4_liq, S_IC_liq, S_h2_liq};

  
  
  
  
  
  
 
 TYPE ADM1Reactions
  "The anaerobic reactions between biological components considered in the ADM1 model"
  = ENUM {decay_aa, decay_ac, decay_c4, decay_fa, decay_h2, decay_pro, decay_su,
  	dis, hyd_ch, hyd_li, hyd_pr,
	uptake_aa, uptake_ac, uptake_bu, uptake_fa, uptake_h2, uptake_pro, uptake_su, uptake_va, };

TYPE ADM1IonReactions
  "The equilibrium reactions between biological components considered in the ADM1 model"
  = ENUM {dissociation_va, dissociation_bu, dissociation_pro, dissociation_ac, hco3_co2, ammonia_production, };

TYPE ADM1GasTransfer
  "The anaerobic gas transfer considered in the ADM1 model"
  = ENUM {transfer_ch4, transfer_co2, transfer_h2, };

 
 
 

 
 
 
 

 

 OBJ NrOfADM1GasComponents "The number of anaerobic components considered in the gas"
  : Integer := Cardinality(ADM1GasVesselComponents);

OBJ NrOfADM1GasComponentsInliquid "The number of gaseous anaerobic components dissolved in the liquid"
  : Integer := Cardinality(ADM1GasComponentsInliquid);

 OBJ NrOfADM1Components "The number of anaerobic components considered in the ADM1 model"
  : Integer := Cardinality(ADM1Components);

OBJ NrOfADM1IonComponents "The number of anaerobic ion components considered in the ADM1 model"
  : Integer := Cardinality(ADM1IonComponents);
  
 
 OBJ NrOfADM1Reactions "The number of anaerobic reactions considered in the ADM1 model"
  : Integer := Cardinality(ADM1Reactions);

OBJ NrOfADM1IonReactions "The number of anaerobic ion reactions considered in the ADM1 model"
  : Integer := Cardinality(ADM1IonReactions);

OBJ NrOfADM1GasTransfer "The number of anaerobic gas transfers considered in the ADM1 model"
  : Integer := Cardinality(ADM1GasTransfer);

CLASS ADM1GasOutFromTheADVessel "The variables which are passed between WWTP model building blocks here in concentrations"
  = PhysicalQuantityType[NrOfADM1GasComponents;];

CLASS ADM1MassVector "The mass of components in the reactor"
  = ADMMass[NrOfADM1Components;];		  

CLASS ADM1GasMassVector "The mass of gasses in the reactor"
  = ADMMass[NrOfADM1GasComponents;];		  
  
CLASS ADM1ConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1Components;];		  

CLASS ADM1IonConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1IonComponents;];		  

CLASS ADM1GasConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1GasComponents;];		  

CLASS ADM1ConcTerminal "The variables which are passed between WWTP model building blocks here in General concentrations"
  = Concentration[NrOfADM1Components;];		  


CLASS InADM1ConcTerminal SPECIALISES ADM1ConcTerminal;  
CLASS OutADM1ConcTerminal SPECIALISES ADM1ConcTerminal;  
CLASS ADM1MassFluxVector = PhysicalQuantityType[NrOfADM1Components;];
CLASS ADM1GasMassFluxVector = PhysicalQuantityType[NrOfADM1GasComponents;];
CLASS ADM1IonConcentrationVector = PhysicalQuantityType[NrOfADM1IonComponents;];

 


# 17 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.ADM1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.ADM1.msl" 1
 


















# 749 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.ADM1.msl"



# 18 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.ADM1.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.transformers.ADM1.msl" 1
 


















# 795 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.transformers.ADM1.msl"


# 19 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.ADM1.msl" 2

# 58 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion_units.msl" 1
 


















# 276 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion_units.msl"




 
# 59 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.data_treatment.msl" 1
 















 
 
 
 




CLASS DataTreatment "Data Treatment" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A general model for signal treatment";
    interface <-
    {
	 	OBJ u (* terminal = "in_1" *) "Signal input" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ y_M (* terminal = "out_1" *) "Output signal" : Real := {: causality <- "COUT" ; group <- "Measurement data" :};    
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
	state <-
    {
		OBJ signal (* hidden = "1" *) "Dummy variable to store the signal": Real ;
    };
	equations <-
    {
		 
		state.signal = interface.u ;  
    };
  :};

  
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\data_treatment/wwtp.base.datatreatment.response_time.msl" 1
 














 
 
 
 
 




CLASS Response_Time
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding response time to a signal";
    parameters <-
    {
		OBJ T90 "Response time" : Time := {: value <- 0.00694444444444444 ; group <- "System" :};
		OBJ n "Order for the response time (2-8)" : Integer := {: value <- 2 ; group <- "System" :};
    };
    state <-
    {
		OBJ signal_response1 (* hidden = "1" *) "variable for 1st order response time output": Real ;
		OBJ signal_response2 (* hidden = "1" *) "variable for 2nd order response time output": Real ;
		OBJ signal_response3 (* hidden = "1" *) "variable for 3rd order response time output": Real ;
		OBJ signal_response4 (* hidden = "1" *) "variable for 4th order response time output": Real ;
		OBJ signal_response5 (* hidden = "1" *) "variable for 5th order response time output": Real ;
		OBJ signal_response6 (* hidden = "1" *) "variable for 6th order response time output": Real ;
		OBJ signal_response7 (* hidden = "1" *) "variable for 7th order response time output": Real ;
		OBJ signal_response8 (* hidden = "1" *) "variable for 8th order response time output": Real ;
		 
 		OBJ Tau "Time constant" : Time := {: value <- 0.00006944444444 ; group <- "System" :};  
    };
    initial <-
    {
		 
		 
		 
		state.Tau = IF (parameters.n==1) THEN parameters.T90/2.3247
			ELSE IF (parameters.n==2) THEN parameters.T90/3.89
				 ELSE IF (parameters.n==3) THEN parameters.T90/5.3336
				 	  ELSE IF (parameters.n==4) THEN parameters.T90/6.6902
					  	   ELSE IF (parameters.n==5) THEN parameters.T90/8.0031
						   		ELSE IF (parameters.n==6) THEN parameters.T90/9.2680
									 ELSE IF (parameters.n==7) THEN parameters.T90/10.5357
									 	  ELSE parameters.T90/11.7724;
		 
		 
		 
    };
    equations <-
    {
		 
		DERIV(state.signal_response1,[independent.t]) = -(1/state.Tau)*(state.signal_response1 - state.signal);
		DERIV(state.signal_response2,[independent.t]) = -(1/state.Tau)*(state.signal_response2 - state.signal_response1);
		DERIV(state.signal_response3,[independent.t]) = -(1/state.Tau)*(state.signal_response3 - state.signal_response2);
		DERIV(state.signal_response4,[independent.t]) = -(1/state.Tau)*(state.signal_response4 - state.signal_response3);
		DERIV(state.signal_response5,[independent.t]) = -(1/state.Tau)*(state.signal_response5 - state.signal_response4);
		DERIV(state.signal_response6,[independent.t]) = -(1/state.Tau)*(state.signal_response6 - state.signal_response5);
		DERIV(state.signal_response7,[independent.t]) = -(1/state.Tau)*(state.signal_response7 - state.signal_response6);
		DERIV(state.signal_response8,[independent.t]) = -(1/state.Tau)*(state.signal_response8 - state.signal_response7);
		
		interface.y_M = IF (parameters.n==1) THEN state.signal_response1
			ELSE IF (parameters.n==2) THEN state.signal_response2
				 ELSE IF (parameters.n==3) THEN state.signal_response3
				 	  ELSE IF (parameters.n==4)	THEN state.signal_response4
					  	   ELSE IF (parameters.n==5) THEN state.signal_response5
						   		ELSE IF (parameters.n==6) THEN state.signal_response6
									 ELSE IF (parameters.n==7) THEN state.signal_response7
									 	  ELSE state.signal_response8;
    };
  :};
  

# 49 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\data_treatment/wwtp.base.datatreatment.delay.msl" 1
 














 
 
 
 
 




CLASS Delay
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding delay to a signal";
    parameters <-
    {
		OBJ t_Delay "Delay time" : Time := {: value <- 0 ; group <- "System" :};
    };
    state <-
    {
		OBJ temp (* hidden = "1" *) "dummy variable for initialisation" : Real ;
		OBJ ID (* hidden = "1" *) "dummy variable for buffer ID" : Integer ;
		OBJ Signal_Delay (* hidden = "1" *) "dummy variable for signal that is retrieved from buffer": Real ;
		OBJ Delta_t  "Time to get a value from the buffer" : Time:= {: group <- "System" :};
    };
    initial <-
    {
		 
		state.ID = MSLUBufferCreate(state.Signal_Delay, 0);
    };
    equations <-
    {
		 
		 
		 
		state.temp = MSLUBufferPut(state.ID, independent.t, state.signal);
		state.Delta_t = independent.t - parameters.t_Delay;
		state.Signal_Delay = MSLUBufferGet(state.ID,state.Delta_t);
		interface.y_M = state.Signal_Delay ;   
    };
  :};
  

# 50 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\data_treatment/wwtp.base.datatreatment.noise.msl" 1
 















 
 
 
 




CLASS Noise
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal, using random values sampled from a normal distribution";
    parameters <-
    {
		OBJ Percent_YMax "Percentage of the measuring range to define the standard deviation of the noise (%)" : Real := {: value <- 2.5 ; group <- "System" :};
		OBJ Noise_Sample_Time "Noise sampling interval": Time := {: value <- 0.000694444444444 ; group <- "System" :};
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
    };
    state <-
    {
		OBJ signal_noise (* hidden = "1" *) "Dummy variable to store the noisy signal": Real:= {: group <- "System" :};
		OBJ Noise "Random number sampled from Normal Distribution N(0,1)" : Real:= {: group <- "System" :};
		OBJ rand "Random number in the range [0,1[ sampled from Uniform distribution" : Real:= {: group <- "System" :};
		OBJ prev_nst (* hidden = "1" *) "Previous noise sampling time" : Real ;
		OBJ flag_noise (* hidden = "1" *)"Boolean variable related to a timer": Boolean ;
		OBJ Noise_Level "Noise level (Std Dev of the noise signal)" : Real := {: group <- "System" :};
    };
    initial <-
    {
		state.prev_nst = 0;
		 
		state.Noise_Level = parameters.Percent_YMax/100 * parameters.YMax;
    };
    equations <-
    {
		 
		 
		state.flag_noise = IF (independent.t > (previous(state.prev_nst) + parameters.Noise_Sample_Time)) THEN 1
			ELSE 0 ;

		state.rand = IF (state.flag_noise) THEN MSLUGetRandom()
			ELSE IF (independent.t == 0) THEN MSLUGetRandom()
				 ELSE previous(state.rand) ;

		state.prev_nst = IF (state.flag_noise) THEN previous(state.prev_nst) + parameters.Noise_Sample_Time
			ELSE previous(state.prev_nst) ;

		 
		 
		state.Noise = MSLU_normal_cdf_inv(state.rand,0,1);
		
		 
		interface.y_M = state.Noise*state.Noise_Level+state.signal ;
    };
    
  :};
  

# 51 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\data_treatment/wwtp.base.datatreatment.noise_file.msl" 1
 














 
 
 
 
 




CLASS Noise_File
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal using an input file";
    interface <-
    {
		OBJ u_file (* terminal = "in_2" *) "Signal input for noise file" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};  
    };
    parameters <-
    {
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
		OBJ Noise_Percent "Noise level (%)" : Real := {: value <- 2.5 ; group <- "System" :};  
    };
    state <-
    {
		OBJ Noise_Level "Noise level" : Real:= {: group <- "System" :};
    };
    initial <-
    {
		state.Noise_Level = parameters.Noise_Percent/100 * parameters.YMax ;
    };
    equations <-
    {
		interface.y_M = interface.u_file*state.Noise_Level + state.signal ; 
    };
  :};
  

# 52 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\data_treatment/wwtp.base.datatreatment.sample_and_hold.msl" 1
 














 
 
 
 
 




CLASS Sample_and_Hold
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for obtaining discrete signal: Zero Order Hold. Sample and Hold (SAH)";
    parameters <-
    {
		OBJ T_interval "Sampling interval": Time := {: value <- 0.00347222222222 ; group <- "System" :};  
    };
    state <-
    {
		OBJ signal_SAH (* hidden = "1" *) "dummy variable for concentration of sample and hold": Real ;
		OBJ prev_SAHst (* hidden = "1" *) "previous SAH sampling time" : Real ;
		OBJ flag_SAH (* hidden = "1" *) "flag for the sampling time": Boolean ;
    };
    initial <-
    {
		state.prev_SAHst = 0;
		state.flag_SAH = 0;
		state.signal_SAH= 0;  
    };
    equations <-
    {
		 
		state.prev_SAHst = IF (independent.t - previous(state.prev_SAHst) <= (parameters.T_interval)) THEN  previous(state.prev_SAHst)
			ELSE  previous(state.prev_SAHst) + parameters.T_interval;   

		state.flag_SAH = IF  (state.prev_SAHst != previous(state.prev_SAHst)) THEN  1
			ELSE  0;    
  
		 
		state.signal_SAH = IF (state.flag_SAH) THEN previous(state.signal)
			ELSE IF (independent.t == 0) THEN previous(state.signal)
				 ELSE previous(state.signal_SAH) ;
      
		 
		interface.y_M = state.signal_SAH ;
    };
  :};
  

# 53 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\data_treatment/wwtp.base.datatreatment.saturation_range.msl" 1
 














 
 
 
 
 




CLASS Saturation_Range
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding saturation to the signal";
    parameters <-
    {
		OBJ uMin "Minimum level for the signal" : Real := {: value <- 0 ; group <- "System" :};
		OBJ uMax "Minimum level for the signal" : Real := {: value <- 10 ; group <- "System" :};
    };
    equations <-
    {
		interface.u = IF (state.signal < parameters.uMin) THEN parameters.uMin
			ELSE IF (state.signal > parameters.uMax) THEN parameters.uMax
				 ELSE state.signal ;
    };
  :};
  

# 54 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.data_treatment.msl" 2

  
  


# 62 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.aeration.msl" 1
 


















# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\aeration/wwtp.irvine_carbon_footprint.msl" 1
 














 
 
 




   
   
CLASS Irvine_wCarbon_Footprint
  (* icon = "aerator" ; is_default = "true" *)
  "Irvine aeration model with carbon footprint" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A model that computes the Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
		OBJ O2_tank (* terminal = "in_1" *) "Actual oxygen concentration in the aeration tank" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ Vol_tank (* terminal = "in_1" *) "Volume of the aeration tank" : Volume := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ SRT (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge age" : Time := {: causality <- "CIN" ; value <- 6.5 ; group <- "Operational" :};   
		OBJ Kla (* terminal = "out_1" *) "Oxygen Transfer Coefficient" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
		OBJ O2_rsat_ave (* terminal = "out_1" *) "Average oxygen saturation f(T_water; Depth) for fine bubble aeration" : Concentration := {: causality <- "COUT" ; group <- "Control action" :};
 






    };
    parameters <- 
    {
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/s2)": Real := {: value <- 9.82 :};
		OBJ T_water "Temperature of the water": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ T_air "Temperature of the air": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ H "Altitude": Length := {: value <- 10 ; group <- "Operational" :};
		OBJ Rho_air "Air density": Concentration := {: value <- 1230 ; group <- "Operational" :};
		OBJ Q_air "Air flow rate under Standard Conditions": FlowRate := {: value <- 1000 ; group <- "Operational" :};
		OBJ O2_sat20 "Oxygen saturation of water under Standard Conditions and no salts": Concentration := {: value <- 10.50 ; group <- "Operational" :};
		OBJ SOTE "Standard Oxygen Transfer Efficiency (%)": Real := {: value <- 42 ; group <- "Operational"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};

		OBJ Rho_sludge "Sludge density": Concentration := {: value <- 988000 ; group <- "Sludge" :};
		OBJ Beta "Empirical factor": Real := {: value <- 0.98 ; group <- "Sludge" :};
		OBJ Phi "Empirical factor": Real := {: value <- 1.024 ; group <- "Sludge" :};

		OBJ P_atm "Atmospheric pressure": Pressure := {: value <- 101325; group <- "Local conditions" :};
		OBJ P_st_atm "Standard atmospheric pressure": Pressure := {: value <- 101325; group <- "Local conditions" :};
		OBJ P_water_ref "Vapour pressure": Pressure := {: value <- 2334; group <- "Local conditions" :};
		OBJ O2_air "O2 conc. in the atmosphere (%)": Real := {: value <- 20.85 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		OBJ CO2_air "CO2 conc. in the atmosphere (%)": Real := {: value <- 0.03 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};

		OBJ Depth "Depth of the (fine bubble) aerator": Length := {: value <- 6 ; group <- "Tank geometry" :};
		OBJ A_sp "Specific area of the diffusers": Area := {: value <- 2 ; group <- "Tank geometry" :};
		OBJ Nd "Number of diffusers": Real := {: value <- 504 ; group <- "Tank geometry"; interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :}; :};
		
		OBJ A "Empirical factor": Real := {: value <- 5.717 ; group <- "Aeration model" :};
		OBJ B "Empirical factor": Real := {: value <- 6.815 ; group <- "Aeration model" :};
		OBJ f "Fraction of tank depth (from surface) at which pressure corresponds to the average saturation concentration": Real := {: value <- 0.44 ; group <- "Aeration model" :};
 




		 
		OBJ P_out "Output pressure from the blowers": Pressure := {: value <- 80000; group <- "Power consumption" :};
		OBJ Lambda "Empirical constant for air": Real := {: value <- 1.395 ; group <- "Power consumption" :};
		OBJ Epsilon "Efficiency of the motor": Real := {: value <- 0.58 ; group <- "Power consumption"; interval <- {: lowerBound <- 0; upperBound <- 1; :}; :};
		OBJ fCO2 "CO2 production per unit of energy (kg/kWh)": Real := {: value <- 0.718 ; group <- "Power consumption" :};
		OBJ T_in "Inlet temperature": CelsiusTemperature := {: value <- 20 ; group <- "Power consumption" :};
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    state <- 
    {
		OBJ P_water "Vapour pressure": Pressure := {: group <- "Local conditions" :};
		OBJ O2_rsat "Oxygen saturation at the water temperature": Concentration := {: group <- "Local conditions" :};
 
		
 

		OBJ Alpha "Empirical factor ": Real := {: group <- "Operational" :};
		
		OBJ AlphaSOTE "Oxygen transfer efficiency for new aerators": Real := {: group <- "Aeration" :};
		OBJ SOTR "Standard Oxygen Transfer Rate": MassFlux := {: group <- "Aeration" :};
		OBJ OTR "Oxygen Transfer Rate (under field conditions)": MassFlux := {: group <- "Aeration" :};
		OBJ	OTR_sp "Specific Oxygen Transfer Rate": OxygenUptakeRate := {: group <- "Aeration" :};
		OBJ OTE "Oxygen Transfer Efficiency (under field conditions) (%)": Real := {: group <- "Aeration"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		OBJ MRi "Mole ratio of oxygen that enters air and off gas (%)": Real := {: group <- "Aeration" :};
		OBJ MRe "Mole ratio of oxygen that leaves aeration tank (%)": Real := {: group <- "Aeration" :};
		OBJ Qn "Normalized air flow": Real := {: group <- "Aeration" :};

		OBJ P_bottom "Pressure at the bottom of the tank": Pressure := {: group <- "Site" :};

		 
		OBJ Load_CO2 "CO2 production": MassFlux := {: group <- "Power consumption" :};
		OBJ Power_blowers "Power of the blowers" : Power := {: group <- "Power consumption" :};
		OBJ k "Power usage per cubic meter of air blown (kW/(m3/s))": Real := {: group <- "Power consumption" :};
		OBJ Emission_CO2 "Overall CO2 emission" : Mass := {: group <- "Power consumption" :} ;
		OBJ Consumption "Overall electrical energy (kWh)" : ElectricalEnergy := {: group <- "Power consumption" :} ;
		OBJ Chi (* hidden = "1" *) "Characteristic number": Real ;
		OBJ lgChi (* hidden = "1" *) "Characteristic number": Real ;
    };
    equations <- 
    {
		 
 
		state.Qn = parameters.Q_air / (24*3600*(parameters.A_sp * parameters.Nd * parameters.Depth)) ;
		state.Chi = IF (state.Qn == 0.0) THEN 0.0 ELSE interface.SRT/state.Qn ;
		state.lgChi = IF (state.Chi == 0.0) THEN 0.0 ELSE log10(state.Chi) ;
	
		state.AlphaSOTE = IF (state.Chi == 0.0) THEN 0.0 ELSE (parameters.A * log10(state.Chi) - parameters.B)/100 ;
		state.Alpha = state.AlphaSOTE / parameters.SOTE * 100 ;

		 
		state.MRi = parameters.O2_air/(100 - parameters.O2_air - parameters.CO2_air);
		state.MRe =  state.MRi*(1-state.OTE);
 
		state.OTE = state.AlphaSOTE *
			(parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) / parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));

		 
		state.P_bottom = (parameters.Rho_sludge/1000) * parameters.g * parameters.Depth;
		state.P_water = pow(10, 0.6979 + 0.02618 * parameters.T_air)* 133.33;
		state.O2_rsat = 14.65 - 0.41 * (parameters.T_water) + 0.00799 * pow(parameters.T_water,2) - 0.0000778 * pow(parameters.T_water,3);
 
 
		interface.O2_rsat_ave = parameters.O2_sat20 * (state.P_bottom * parameters.f + parameters.P_atm - state.P_water)/ (parameters.P_st_atm - parameters.P_water_ref);

		 
		state.SOTR =  parameters.Q_air * (parameters.Rho_air/1000)  * parameters.SOTE * (parameters.O2_air/10000);
 
		state.OTR = state.Alpha * state.SOTR * (parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) /parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));
		interface.Kla = 1000 * state.OTR/((parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) * interface.Vol_tank);
		state.OTR_sp = state.OTR /(interface.Vol_tank);
		
		 
		state.k = (parameters.P_st_atm * parameters.Lambda * (parameters.T_in + 273.15)) / (2.73 * 100000 * parameters.Epsilon * (parameters.Lambda - 1)) * (pow((parameters.P_out + parameters.P_st_atm)/parameters.P_st_atm,1-1/parameters.Lambda)-1);
		state.Power_blowers = state.k * parameters.Q_air/(24*3600);
		state.Load_CO2 = state.Power_blowers * parameters.fCO2 ;
		DERIV(state.Consumption, [independent.t]) = 24 * state.Power_blowers ;
		DERIV(state.Emission_CO2, [independent.t]) = state.Load_CO2 ;
    };

  :};


# 20 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.aeration.msl" 2

 


# 63 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2


 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.chemical_processes.msl" 1
 









# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\chemical_processes/wwtp.base.chemical_processes.me_dosing_unit.msl" 1
 










CLASS MEChemical 
(* icon = "me_dosing_unit" ; is_default = "true" *)
"A dosing unit for chemical P removal"

SPECIALISES PhysicalDAEModelType :=

 {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   OBJ pH	(* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "pH wastewater at chemical dosing point"
		: Real	:= {: causality <- "CIN" ; value <- 7 ; group <- "Kinetic" :}; 

   };

   parameters <-
   {
   
  OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing the specific volume (= 1/density) for all the components" : SpecificVolumeVector;
   	
	OBJ pKa1_P	"pKa1 H3PO4/H2PO4"
	: Real	:= {: value <- 2.1 ; group <- "Kinetic" :}; 
	OBJ pKa2_P	"pKa2 H2PO4/HPO4"
	: Real	:= {: value <- 7.2 ; group <- "Kinetic" :}; 
	OBJ pKa3_P	"pKa3 HPO4/PO4"
	: Real	:= {: value <- 12.3 ; group <- "Kinetic" :}; 
	OBJ pKa1_Al	"pKa1  Al/AlOH"
	: Real	:= {: value <- 5 ; group <- "Kinetic" :}; 
	OBJ pKa2_Al	"pKa2 AlOH/Al(OH)2"
	: Real	:= {: value <- 3.7 ; group <- "Kinetic" :}; 
	OBJ pKa3_Al	"pKa3 Al(OH)2/Al(OH)3"
	: Real	:= {: value <- 6.5 ; group <- "Kinetic" :}; 
	OBJ pKa4_Al	"pKa4 Al(OH)3/Al(OH)4"
	: Real	:= {: value <- 8.1 ; group <- "Kinetic" :}; 
	OBJ pKs_AlPO4	"pKs AlPO4"
	: Real	:= {: value <- 22 ; group <- "Kinetic" :}; 
	OBJ pKs_AlOH3	"pKs AlOH3"
	: Real	:= {: value <- 32.3 ; group <- "Kinetic" :}; 
	OBJ pK_AlH2PO4	""
	: Real	:= {: value <- -5.72 ; group <- "Kinetic" :}; 
	OBJ MW_P	"Molecular weight phosphorus"
	: Real	:= {: value <- 31 ; group <- "Kinetic" :}; 
	OBJ MW_Al	"Molecular weight Alum"
	: Real	:= {: value <- 27 ; group <- "Kinetic" :}; 
	OBJ MW_OH "Molecular weight hydroxide"
	: Real	:= {: value <- 17 ; group <- "Kinetic" :};
	OBJ MW_H "Molecular weight hydrogen"
	: Real	:= {: value <- 1 ; group <- "Kinetic" :};  
	OBJ MW_O "Molecular weight oxygen"
	: Real	:= {: value <- 16 ; group <- "Kinetic" :};  
	OBJ a2	"parameter empirical model"
	: Real	:= {: value <- 1.42 ; group <- "Kinetic" :}; 
	OBJ a1	"parameter empirical model"
	: Real	:= {: value <- 1.09 ; group <- "Kinetic" :}; 
	OBJ r "formula precipitate Me(r)H(2)P(1)O(4)OH(3r-1)"
   : Real	:= {: value <- 1.2 ; group <- "Kinetic" :}; 
    
   };

   independent <- 
   { 
   OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };

   initial <- 
   { 
   parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
   state.S_OH := 7;
   };

   state <-
   {
   OBJ Q_In "Influent flow rate" : Real;
   OBJ C_In "Incoming concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
   OBJ S_H	"Molar Concentration H+ ions": Real := {: group <- "Concentration" :};
   OBJ pOH	"pOH"	: Real;
   OBJ S_OH	"Molar Concentration OH- ions"	: Real := {: group <- "Concentration" :};
   OBJ S_PO4	"chemical equilibrium molar concentration PO4"	: Real := {: group <- "Concentration" :};
   OBJ S_HPO4	"chemical equilibrium molar concentration HPO4"	: Real := {: group <- "Concentration" :};
   OBJ S_H2PO4	"chemical equilibrium molar concentration H2PO4"	: Real := {: group <- "Concentration" :};
   OBJ S_H3PO4	"chemical equilibrium molar concentration H3PO4"	: Real := {: group <- "Concentration" :};
   OBJ S_AlChem	"chemical equilibrium molar concentration Al"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH	"chemical equilibrium molar concentration AlOH"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH2	"chemical equilibrium molar concentration AlOH2"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH3	"chemical equilibrium molar concentration AlOH3"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH4	"chemical equilibrium molar concentration AlOH4"	: Real := {: group <- "Concentration" :};
   OBJ X_AlH2PO4	"chemical equilibrium molar concentration AlH2PO4"	: Real := {: group <- "Concentration" :};
   OBJ TP	"chemical equilibrium PO4-P concentration (sum of all species)"	: Real := {: group <- "Concentration" :};
   OBJ TAl	"chemical equilibrium Al concentration(sum of all species)"	: Real := {: group <- "Concentration" :};
   OBJ RatioBis	"Ratio of mass metal dosed over P in influent"	: Real;
   OBJ TP_emp	"empirical equation PO4-P concentration"	: Real := {: group <- "Concentration" :};
   OBJ TP_limit	"limited PO4-P concentration by Al dosing"	: Real := {: group <- "Concentration" :};
   OBJ Presult_help	"PO4-P concentration after chemical dosing (help)"	: Real;
   OBJ Presult_help2	"PO4-P concentration after chemical dosing (help2)"	: Real;
   OBJ Presult	"PO4-P concentration after chemical dosing"	: Real := {: group <- "Concentration" :};
   OBJ MW_prec	"molecular weight precipitate Me(r)H(2)P(1)O(4)OH(3r-1)" : Real;   
   OBJ RatioPrec "gram Al/gram P in precipitaat" : Real;   
   OBJ Ratio_in "" : Real;
   OBJ Al_actual	"Actual Al concentration in effluent"	: Real := {: group <- "Concentration" :}; 
   };

   equations <-
   {
   state.Q_In = parameters.WWTPSpecificVolume[IndexOfSolvent] * interface.Inflow[IndexOfSolvent] ;
   
    interface.Outflow[IndexOfSolvent] =
			- interface.Inflow[IndexOfSolvent];
  
  
   {FOREACH Comp_Index IN {S_I .. S_NO}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
  
  {FOREACH Comp_Index IN {S_NH .. S_ALK}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
			
			
  {FOREACH Comp_Index IN {X_I .. X_AUT}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
  
  {FOREACH Comp_Index IN {X_MEOH .. X_MEP}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
			
			
			
    state.pOH = 14 - interface.pH;
	state.S_H = pow(10, - interface.pH);
	state.S_OH = pow(10, - state.pOH);
	state.S_PO4 = pow(10, - parameters.pKs_AlPO4) / pow(10, - parameters.pKs_AlOH3) * pow(state.S_OH,3);
	state.S_HPO4 = state.S_PO4 * state.S_H / pow(10, - parameters.pKa3_P);
	state.S_H2PO4 = state.S_HPO4 * state.S_H / pow(10, - parameters.pKa2_P);
	state.S_H3PO4 = state.S_H2PO4 * state.S_H / pow(10, - parameters.pKa1_P);
	state.S_AlChem = pow(10, - parameters.pKs_AlOH3) / pow(state.S_OH,3);
	state.S_AlOH = pow(10, - parameters.pKa1_Al) * state.S_AlChem / state.S_H;
	state.S_AlOH2 = pow(10, - parameters.pKa2_Al) * state.S_AlOH / state.S_H;
	state.S_AlOH3 = pow(10, - parameters.pKa3_Al) * state.S_AlOH2 / state.S_H;
	state.S_AlOH4 = pow(10, - parameters.pKa4_Al) * state.S_AlOH3 / state.S_H;
	state.X_AlH2PO4 = pow(10, - parameters.pK_AlH2PO4) * state.S_AlChem * state.S_H2PO4;
	state.TP = (state.S_PO4 + state.S_HPO4 + state.S_H2PO4 + state.S_H3PO4 + state.X_AlH2PO4) * parameters.MW_P * 1000;
	state.TAl = (state.S_AlChem + state.S_AlOH + state.S_AlOH2 + state.S_AlOH3 + state.S_AlOH4) * parameters.MW_Al * 1000;
	
	state.Ratio_in = interface.Inflow[S_Al] / interface.Inflow[S_PO];
	state.TP_emp = parameters.a1 * interface.Inflow[S_PO] / state.Q_In * exp( - parameters.a2 * state.Ratio_in);
	state.TP_limit = (interface.Inflow[S_PO]/state.Q_In)- (interface.Inflow[S_Al]/(state.Q_In*state.RatioPrec));

  {FOREACH Comp_Index IN {1 .. NrOfComponents}:
	state.C_In[Comp_Index] = interface.Inflow[Comp_Index]/state.Q_In;
   };
	
	
 
 
	state.Presult_help = MSLUGetMax2(state.TP_limit,state.TP_emp);
	state.Presult_help2 = MSLUGetMax2(state.TP,state.Presult_help);
	state.Presult = MSLUGetMin2(state.C_In[S_PO],state.Presult_help2);  
	
	interface.Outflow[S_PO]=-state.Presult*state.Q_In;
    
	state.MW_prec = parameters.r * parameters.MW_Al+2*parameters.MW_H+parameters.MW_P+4*parameters.MW_O+(3*parameters.r-1)*parameters.MW_OH;
	state.RatioPrec=parameters.r * parameters.MW_Al/parameters.MW_P;
	
	interface.Outflow[X_I_i]=-interface.Inflow[X_I_i]-state.MW_prec/parameters.MW_P*(interface.Inflow[S_PO]+interface.Outflow[S_PO]);
	
	interface.Outflow[S_Al]=  -interface.Inflow[S_Al]+state.RatioPrec*(interface.Inflow[S_PO]+interface.Outflow[S_PO]) ;
	
	state.Al_actual = - interface.Outflow[S_Al]/state.Q_In ;
	
	 



	interface.Outflow[X_TSS]=-interface.Inflow[X_TSS]-state.MW_prec/parameters.MW_P*(interface.Inflow[S_PO]+interface.Outflow[S_PO]);  
 
	   };

 :};





# 11 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.base.chemical_processes.msl" 2



# 66 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\coupled_models.msl" 1
 



















# 69 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2


 

# 1 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\controller/wwtp.base.controllers.constantratio_double.msl" 1
 








CLASS ConstantRatio_double
    (* icon = "controller_ratio" ; is_default = "" *)
    "Ratio controller with two ratios for two input ranges"
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
      comments <- "A model for a ratio controller";
      interface <-
      {
        OBJ y_M (* terminal = "in_1" *) "Sensor measured output" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
        OBJ u (* terminal = "out_1" *) "Controlled variable" :
                 Real := {: causality <- "COUT" ; group <- "Control action" :};
      };
  
      parameters <-
      {
      OBJ ConstantRatio1 "Ratio between measured value and controller output, first input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
      OBJ ConstantRatio2 "Ratio between measured value and controller output, second input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
  	  OBJ y_M_min "Minimumum measured value for first input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
  	  OBJ y_M_mid "Maximum measured value for first input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
      OBJ u_min "Minimum output, calculated as y_M_min*ConstantRatio1" :
           Real := {: value <- 1 ; group <- "Operational" :};
	    OBJ u_max "Maximum output, calculated as y_M_min*ConstantRatio1" :
           Real := {: value <- 1 ; group <- "Operational" :};
      };
  
      equations <-
      {
  
      interface.u = IF (interface.y_M < parameters.y_M_min)
  				  				THEN parameters.u_min
  				  				ELSE IF (interface.y_M < parameters.y_M_mid)
  				  	   				THEN interface.y_M * parameters.ConstantRatio1
  					   					ELSE IF ((parameters.ConstantRatio2 * interface.y_M) < parameters.u_max)
															THEN parameters.ConstantRatio2 * interface.y_M
															ELSE parameters.u_max;
  
      };
  :};
  
  
# 73 "C:\\Users\\WEST\\Desktop\\github\\EHV_Model\\WEST\\data\\blocks\\WESTforKALLISTO - EHV10\\Models\\wwtp.msl" 2


